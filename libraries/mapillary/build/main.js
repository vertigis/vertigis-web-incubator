/*! For license information please see main.js.LICENSE.txt */
define([
    "react/jsx-runtime",
    "react",
    "@vertigis/web/components",
    "@vertigis/web/ui/IconButton",
    "@vertigis/web/ui/ButtonGroup",
    "@vertigis/web/ui/icons/MapSyncOn",
    "@vertigis/web/ui/icons/MapSyncOff",
    "@vertigis/web/ui/icons/CenterMap",
    "@vertigis/web/ui/hooks",
    "@vertigis/web/models",
    "@vertigis/web/ui",
    "@arcgis/core/geometry/Point",
    "@vertigis/web/designer",
], (e, t, i, n, r, s, a, o, c, l, h, u, d) =>
    (() => {
        "use strict";
        var p = {
                151: (e, t, i) => {
                    i.d(t, { A: () => o });
                    var n = i(6758),
                        r = i.n(n),
                        s = i(935),
                        a = i.n(s)()(r());
                    a.push([
                        e.id,
                        ".third-party-map-controls {\n    position: absolute;\n    top: 1rem;\n    right: 1rem;\n    background-color: var(--buttonBackground);\n    opacity: 0.8;\n}\n\n.third-party-map-controls:hover {\n    opacity: 1;\n}\n\n.third-party-map-controls button {\n    border-radius: inherit;\n}\n\n.third-party-map-controls svg {\n    fill: var(--buttonIcon);\n}\n\n.third-party-map-controls button.selected {\n    background-color: var(--emphasizedButtonBackground);\n}\n\n.third-party-map-controls button.selected svg {\n    fill: var(--emphasizedButtonIcon);\n}\n\n.mapillary-map-container {\n    height: 100%;\n}\n\n.mapillary-js {\n    height: 100%;\n}\n",
                        "",
                    ]);
                    const o = a;
                },
                9824: (e, t, i) => {
                    i.d(t, { A: () => fe });
                    var n = i(6758),
                        r = i.n(n),
                        s = i(935),
                        a = i.n(s),
                        o = i(62),
                        c = i.n(o),
                        l = new URL(i(2574), i.b),
                        h = new URL(i(1939), i.b),
                        u = new URL(i(5044), i.b),
                        d = new URL(i(710), i.b),
                        p = new URL(i(4556), i.b),
                        g = new URL(i(2868), i.b),
                        m = new URL(i(3954), i.b),
                        f = new URL(i(8422), i.b),
                        _ = new URL(i(2505), i.b),
                        M = new URL(i(3827), i.b),
                        v = new URL(i(9830), i.b),
                        y = new URL(i(4422), i.b),
                        x = new URL(i(8393), i.b),
                        b = new URL(i(8932), i.b),
                        w = new URL(i(3014), i.b),
                        T = new URL(i(2366), i.b),
                        S = new URL(i(7678), i.b),
                        N = new URL(i(8227), i.b),
                        D = new URL(i(4737), i.b),
                        I = new URL(i(7326), i.b),
                        C = new URL(i(600), i.b),
                        A = new URL(i(9435), i.b),
                        E = new URL(i(7254), i.b),
                        L = new URL(i(9244), i.b),
                        z = new URL(i(3953), i.b),
                        j = new URL(i(9273), i.b),
                        O = new URL(i(3009), i.b),
                        k = new URL(i(6532), i.b),
                        R = new URL(i(6372), i.b),
                        P = new URL(i(9347), i.b),
                        U = a()(r()),
                        $ = c()(l),
                        B = c()(h),
                        F = c()(u),
                        H = c()(d),
                        G = c()(p),
                        V = c()(g),
                        Y = c()(m),
                        q = c()(f),
                        W = c()(_),
                        Q = c()(M),
                        Z = c()(v),
                        X = c()(y),
                        J = c()(x),
                        K = c()(b),
                        ee = c()(w),
                        te = c()(T),
                        ie = c()(S),
                        ne = c()(N),
                        re = c()(D),
                        se = c()(I),
                        ae = c()(C),
                        oe = c()(A),
                        ce = c()(E),
                        le = c()(L),
                        he = c()(z),
                        ue = c()(j),
                        de = c()(O),
                        pe = c()(k),
                        ge = c()(R),
                        me = c()(P);
                    U.push([
                        e.id,
                        `.mapillary-attribution-container {\n    background-color: rgba(0, 0, 0, 0.5);\n    font-size: 9px;\n    font-weight: 300;\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    height: 16px;\n    line-height: normal;\n    line-height: initial;\n    z-index: 10;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, "Segoe UI",\n        "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans",\n        "Helvetica Neue", sans-serif;\n}\n\n.mapillary-attribution-image-container {\n    display: inline-block;\n    color: white;\n    -webkit-text-decoration: none;\n    text-decoration: none;\n    margin-left: 8px;\n    vertical-align: middle;\n    height: 100%;\n}\n\n.mapillary-attribution-image-container:hover,\n.mapillary-attribution-image-container:active,\n.mapillary-attribution-image-container:visited {\n    color: white;\n}\n\n.mapillary-attribution-compact .mapillary-attribution-image-container {\n    margin-left: 4px;\n}\n\n.mapillary-attribution-username {\n    display: inline-block;\n    vertical-align: middle;\n    line-height: 16px;\n}\n\n.mapillary-attribution-date {\n    display: inline-block;\n    vertical-align: middle;\n    color: white;\n    line-height: 16px;\n    margin-right: 8px;\n    margin-left: 4px;\n}\n\n.mapillary-attribution-compact .mapillary-attribution-date {\n    margin-right: 6px;\n}\n\n.mapillary-attribution-icon-container {\n    display: inline-block;\n    margin-left: 8px;\n    vertical-align: middle;\n    height: 100%;\n}\n\n.mapillary-attribution-compact .mapillary-attribution-icon-container {\n    margin-left: 6px;\n}\n\n.mapillary-attribution-image-container .mapillary-attribution-icon-container {\n    margin-left: 2px;\n    margin-right: 2px;\n}\n\n.mapillary-attribution-logo {\n    margin-top: 3px;\n    width: 44px;\n    height: 10px;\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-image: url(${$});\n}\n\n.mapillary-attribution-compact .mapillary-attribution-logo {\n    width: 11px;\n    background-size: cover;\n}\n.mapillary-bearing-indicator-container {\n    bottom: 34px;\n    height: 40px;\n    pointer-events: none;\n    position: absolute;\n    right: 10px;\n    width: 40px;\n    z-index: 10;\n}\n\n.mapillary-bearing-indicator-container.mapillary-bearing-compact {\n    -webkit-transform: scale(0.6);\n            transform: scale(0.6);\n    bottom: 16px;\n    right: 2px;\n}\n\n.mapillary-bearing-indicator-background {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 40px;\n    height: 40px;\n    opacity: 0.5;\n    -webkit-transform-origin: 50% 50%;\n            transform-origin: 50% 50%;\n}\n\n.mapillary-bearing-indicator-background-circle {\n    pointer-events: auto;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    background-color: #000;\n}\n\n.mapillary-bearing-indicator-background-arrow-container {\n    position: absolute;\n    left: 14px;\n    top: -3.5px;\n    height: 8px;\n    width: 12px;\n    overflow: hidden;\n}\n\n.mapillary-bearing-indicator-background-arrow {\n    position: absolute;\n    width: 12px;\n    height: 12px;\n    left: 0;\n    top: 2px;\n    background-color: #000;\n    -webkit-transform: rotate(45deg);\n            transform: rotate(45deg);\n    border-radius: 2px;\n}\n\n.mapillary-bearing-north-container {\n    position: absolute;\n    left: 16px;\n    top: -1px;\n    width: 8px;\n    height: 21px;\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n}\n\n.mapillary-bearing-north {\n    position: absolute;\n    border-left: 4px solid transparent;\n    border-right: 4px solid transparent;\n    border-bottom: 4px solid white;\n}\n.mapillary-cover-container {\n    background-color: rgba(0, 0, 0, 0.5);\n    bottom: 0;\n    left: 0;\n    overflow: hidden;\n    position: absolute;\n    right: 0;\n    top: 0;\n    z-index: 100;\n}\n\n.mapillary-cover-background {\n    background-position: center;\n    background-size: cover;\n    bottom: 0;\n    left: 0;\n    margin: -3px;\n    position: absolute;\n    right: 0;\n    top: 0;\n    z-index: 0;\n}\n\n.mapillary-cover-indicator {\n    bottom: 0;\n    left: 0;\n    margin: -3px;\n    position: absolute;\n    right: 0;\n    top: 0;\n    z-index: 0;\n    background-color: rgba(0, 0, 0, 0.2);\n    -webkit-transition: opacity 0.1s ease-in-out;\n    transition: opacity 0.1s ease-in-out;\n    cursor: pointer;\n}\n\n.mapillary-cover-indicator:hover {\n    opacity: 0;\n}\n\n.mapillary-cover-button {\n    background-color: rgba(0, 0, 0, 0.5);\n    border-radius: 64px;\n    width: 128px;\n    height: 128px;\n    left: 50%;\n    top: 50%;\n    letter-spacing: 1px;\n    margin-left: -64px;\n    margin-top: -64px;\n    position: absolute;\n    -webkit-transition: opacity 0.2s ease-in-out;\n    transition: opacity 0.2s ease-in-out;\n    z-index: 1;\n    pointer-events: none;\n}\n\n.mapillary-cover-compact .mapillary-cover-button {\n    width: 72px;\n    height: 72px;\n    margin-left: -36px;\n    margin-top: -36px;\n}\n\n.mapillary-cover-button-icon {\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-image: url(${B});\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    pointer-events: none;\n}\n\n.mapillary-cover-compact .mapillary-cover-button-icon {\n    width: 72px;\n    height: 72px;\n}\n\n.mapillary-cover-logo {\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-image: url(${F});\n    bottom: 0px;\n    height: 52px;\n    left: 50%;\n    margin-left: -73px;\n    position: absolute;\n    -webkit-transition: opacity 0.2s ease-in-out;\n    transition: opacity 0.2s ease-in-out;\n    width: 157px;\n    z-index: 1;\n}\n\n.mapillary-cover-compact .mapillary-cover-logo {\n    width: 104px;\n    height: 35px;\n    margin-left: -49px;\n}\n\n.mapillary-cover-done {\n    visibility: hidden;\n    opacity: 0;\n}\n\n.mapillary-cover.mapillary-cover-loading .mapillary-cover-button,\n.mapillary-cover.mapillary-cover-loading .mapillary-cover-logo {\n    opacity: 0;\n}\n\n.mapillary-cover-spinner {\n    -webkit-animation: rotate 1s linear infinite;\n            animation: rotate 1s linear infinite;\n    background-repeat: no-repeat;\n    background-size: 100%;\n    background-image: url(${H});\n    height: 32px;\n    left: 50%;\n    margin-left: -16px;\n    margin-top: -16px;\n    position: absolute;\n    top: 50%;\n    width: 32px;\n    z-index: 1;\n}\n\n@-webkit-keyframes rotate {\n    100% {\n        -webkit-transform: rotate(360deg);\n                transform: rotate(360deg);\n    }\n}\n\n@keyframes rotate {\n    100% {\n        -webkit-transform: rotate(360deg);\n                transform: rotate(360deg);\n    }\n}\n.mapillary-direction-perspective {\n    display: block;\n    position: absolute;\n    pointer-events: none;\n    -webkit-transform-style: preserve-3d;\n            transform-style: preserve-3d;\n    z-index: 10;\n}\n\n.mapillary-direction-circle,\n.mapillary-direction-circle-sequence,\n.mapillary-direction-circle-inactive,\n.mapillary-direction-circle-highlight,\n.mapillary-direction-circle-sequence-highlight {\n    position: absolute;\n    border-radius: 50%;\n}\n\n.mapillary-direction-circle,\n.mapillary-direction-circle-sequence,\n.mapillary-direction-circle-highlight,\n.mapillary-direction-circle-sequence-highlight {\n    pointer-events: auto;\n}\n\n.mapillary-direction-circle:hover,\n.mapillary-direction-circle-sequence:hover,\n.mapillary-direction-circle-highlight:hover,\n.mapillary-direction-circle-sequence-highlight:hover {\n    cursor: pointer;\n}\n\n.mapillary-direction-circle,\n.mapillary-direction-circle-sequence {\n    background: rgba(0, 0, 0, 0);\n}\n\n.mapillary-direction-circle-inactive {\n    background: rgba(0, 0, 0, 0);\n    z-index: -1;\n}\n\n.mapillary-direction-circle-highlight,\n.mapillary-direction-circle-sequence-highlight {\n    background: rgba(0, 0, 0, 0.4);\n}\n\n.mapillary-direction-arrow-step,\n.mapillary-direction-arrow-spherical,\n.mapillary-direction-arrow-inactive {\n    position: absolute;\n    top: 44%;\n    left: 50%;\n    -webkit-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n    width: 75%;\n    height: 44.0775%;\n    pointer-events: none;\n}\n\n.mapillary-direction-arrow-step,\n.mapillary-direction-arrow-inactive {\n    background: url(${G});\n    background-repeat: no-repeat;\n}\n\n.mapillary-direction-arrow-inactive {\n    opacity: 0.2;\n    z-index: -1;\n}\n\n.mapillary-direction-arrow-spherical {\n    background: url(${V});\n    background-repeat: no-repeat;\n}\n\n.mapillary-direction-turn-circle,\n.mapillary-direction-turn-circle-sequence,\n.mapillary-direction-turn-circle-highlight,\n.mapillary-direction-turn-circle-sequence-highlight {\n    position: absolute;\n    border-radius: 50%;\n    pointer-events: auto;\n}\n\n.mapillary-direction-turn-circle,\n.mapillary-direction-turn-circle-sequence {\n    background: rgba(0, 0, 0, 0);\n}\n\n.mapillary-direction-turn-circle-highlight,\n.mapillary-direction-turn-circle-sequence-highlight {\n    background: rgba(0, 0, 0, 0.4);\n}\n\n.mapillary-direction-turn-circle:hover,\n.mapillary-direction-turn-circle-sequence:hover,\n.mapillary-direction-turn-circle-highlight:hover,\n.mapillary-direction-turn-circle-sequence-highlight:hover {\n    cursor: pointer;\n}\n\n.mapillary-direction-turn-left,\n.mapillary-direction-turn-right,\n.mapillary-direction-turn-around {\n    position: absolute;\n    top: 50%;\n    pointer-events: none;\n    -webkit-filter: drop-shadow(0px 2px 1px rgba(0, 0, 0, 0.8));\n            filter: drop-shadow(0px 2px 1px rgba(0, 0, 0, 0.8));\n}\n\n.mapillary-direction-turn-left,\n.mapillary-direction-turn-right {\n    width: 58.794%;\n    height: 70%;\n}\n\n.mapillary-direction-turn-around {\n    left: 50%;\n    width: 75%;\n    height: 63.2475%;\n}\n\n.mapillary-direction-turn-left {\n    left: 45%;\n    background: url(${Y});\n    background-repeat: no-repeat;\n    -webkit-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n}\n\n.mapillary-direction-turn-right {\n    left: 55%;\n    background: url(${Y});\n    background-repeat: no-repeat;\n    -webkit-transform: translate(-50%, -50%) scaleX(-1);\n            transform: translate(-50%, -50%) scaleX(-1);\n}\n\n.mapillary-direction-turn-around {\n    background: url(${q});\n    background-repeat: no-repeat;\n    -webkit-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n}\n\n@media (hover: hover) {\n    .mapillary-direction-circle:hover,\n    .mapillary-direction-circle-sequence:hover {\n        background: rgba(0, 0, 0, 0.4);\n    }\n\n    .mapillary-direction-turn-circle:hover,\n    .mapillary-direction-turn-circle-sequence:hover {\n        background: rgba(0, 0, 0, 0.4);\n    }\n}\n.mapillary-viewer {\n    background-color: #0F0F0F;\n    position: relative;\n    overflow: hidden;\n    -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n.mapillary-interactive {\n    cursor: -webkit-grab;\n    cursor: grab;\n}\n\n.mapillary-interactive:active {\n    cursor: -webkit-grabbing;\n    cursor: grabbing;\n}\n\n.mapillary-viewer .mapillary-dom {\n    bottom: 0;\n    left: 0;\n    overflow: hidden;\n    pointer-events: none;\n    position: absolute;\n    right: 0;\n    top: 0;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n\n.mapillary-dom .mapillary-dom-renderer {\n    pointer-events: auto;\n}\n\n.mapillary-viewer div {\n    -webkit-box-sizing: content-box;\n            box-sizing: content-box;\n}\n\n.mapillary-viewer input:focus {\n    background: none;\n}\n.mapillary-navigation-sequence,\n.mapillary-navigation-spatial {\n    position: absolute;\n    pointer-events: none;\n    z-index: 10;\n}\n\n.mapillary-navigation-sequence {\n    top: 12px;\n    left: 50%;\n    margin-left: -40px;\n}\n\n.mapillary-navigation-spatial {\n    bottom: 18px;\n    left: 50%;\n    margin-left: -100px;\n}\n\n.mapillary-navigation-spatial-bottom {\n    margin-left: 40px;\n}\n\n.mapillary-navigation-button {\n    width: 36px;\n    height: 36px;\n    background-size: contain;\n    background-repeat: no-repeat;\n    pointer-events: auto;\n    margin: 0px 2px;\n    cursor: pointer;\n    display: inline-block;\n    -webkit-filter: drop-shadow(0 2px 0 rgba(0, 0, 0, 1));\n            filter: drop-shadow(0 2px 0 rgba(0, 0, 0, 1));\n}\n\n.mapillary-navigation-prev,\n.mapillary-navigation-left {\n    background-image: url(${W});\n}\n\n.DirectionNext,\n.DirectionRight {\n    background-image: url(${Q});\n}\n\n.mapillary-navigation-forward {\n    background-image: url(${Z});\n}\n\n.mapillary-navigation-backward {\n    background-image: url(${X});\n}\n\n.mapillary-navigation-turn-left {\n    background-image: url(${J});\n}\n\n.mapillary-navigation-turn-right {\n    background-image: url(${K});\n}\n\n.mapillary-navigation-turn-around {\n    background-image: url(${ee});\n}\n.mapillary-popup {\n    position: absolute;\n    left: 0;\n    top: 0;\n    pointer-events: none;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n\n.mapillary-popup-content,\n.mapillary-popup-content-clean {\n    position: relative;\n}\n\n.mapillary-popup-capture-pointer {\n    pointer-events: auto;\n}\n\n.mapillary-popup-content {\n    padding: 5px 10px;\n    background: white;\n    border: 1px solid black;\n    border-radius: 2px;\n}\n\n.mapillary-popup-float-bottom,\n.mapillary-popup-float-bottom-left,\n.mapillary-popup-float-bottom-right {\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n}\n\n.mapillary-popup-float-top,\n.mapillary-popup-float-top-left,\n.mapillary-popup-float-top-right {\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: reverse;\n        -ms-flex-direction: column-reverse;\n            flex-direction: column-reverse;\n}\n\n.mapillary-popup-float-left {\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: reverse;\n        -ms-flex-direction: row-reverse;\n            flex-direction: row-reverse;\n}\n\n.mapillary-popup-float-right {\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: row;\n            flex-direction: row;\n}\n\n.mapillary-popup-tip,\n.mapillary-popup-tip-inner {\n    position: relative;\n    z-index: 1;\n    width: 0;\n    height: 0;\n    border: 7px solid transparent;\n}\n\n.mapillary-popup-float-top .mapillary-popup-tip {\n    -ms-flex-item-align: center;\n        align-self: center;\n    border-top-color:black;\n    border-bottom: none;\n}\n\n.mapillary-popup-float-top .mapillary-popup-tip-inner {\n    position: relative;\n    top: -8px;\n    left: -7px;\n    border-top-color: white;\n    border-bottom: none;\n}\n\n.mapillary-popup-float-top-right .mapillary-popup-tip {\n    -ms-flex-item-align: start;\n        align-self: flex-start;\n    border-top-color:black;\n    border-bottom: none;\n    border-left: none;\n}\n\n.mapillary-popup-float-top-right .mapillary-popup-tip-inner {\n    position: relative;\n    top: -9px;\n    left: 1px;\n    border-top-color: white;\n    border-bottom: none;\n    border-left: none;\n}\n\n.mapillary-popup-float-top-left .mapillary-popup-tip {\n    -ms-flex-item-align: end;\n        align-self: flex-end;\n    border-top-color:black;\n    border-bottom: none;\n    border-right: none;\n}\n\n.mapillary-popup-float-top-left .mapillary-popup-tip-inner {\n    position: relative;\n    top: -9px;\n    left: -8px;\n    border-top-color: white;\n    border-bottom: none;\n    border-right: none;\n}\n\n.mapillary-popup-float-bottom .mapillary-popup-tip {\n    -ms-flex-item-align: center;\n        align-self: center;\n    border-top: none;\n    border-bottom-color: black;\n}\n\n.mapillary-popup-float-bottom .mapillary-popup-tip-inner {\n    position: relative;\n    bottom: -1px;\n    left: -7px;\n    border-top: none;\n    border-bottom-color: white;\n}\n\n.mapillary-popup-float-bottom-right .mapillary-popup-tip {\n    -ms-flex-item-align: start;\n        align-self: flex-start;\n    border-bottom-color:black;\n    border-top: none;\n    border-left: none;\n}\n\n.mapillary-popup-float-bottom-right .mapillary-popup-tip-inner {\n    position: relative;\n    bottom: -2px;\n    left: 1px;\n    border-bottom-color: white;\n    border-top: none;\n    border-left: none;\n}\n\n.mapillary-popup-float-bottom-left .mapillary-popup-tip {\n    -ms-flex-item-align: end;\n        align-self: flex-end;\n    border-bottom-color:black;\n    border-top: none;\n    border-right: none;\n}\n\n.mapillary-popup-float-bottom-left .mapillary-popup-tip-inner {\n    position: relative;\n    bottom: -2px;\n    left: -8px;\n    border-bottom-color: white;\n    border-top: none;\n    border-right: none;\n}\n\n.mapillary-popup-float-left .mapillary-popup-tip {\n    -ms-flex-item-align: center;\n        align-self: center;\n    border-left-color: black;\n    border-right: none;\n}\n\n.mapillary-popup-float-left .mapillary-popup-tip-inner {\n    position: relative;\n    top: -7px;\n    left: -8px;\n    border-left-color: white;\n    border-right: none;\n}\n\n.mapillary-popup-float-right .mapillary-popup-tip {\n    -ms-flex-item-align: center;\n        align-self: center;\n    border-right-color: black;\n    border-left: none;\n}\n\n.mapillary-popup-float-right .mapillary-popup-tip-inner {\n    position: relative;\n    top: -7px;\n    left: 1px;\n    border-right-color: white;\n    border-left: none;\n}\n\n.mapillary-popup-float-top-left .mapillary-popup-content {\n    border-bottom-right-radius: 0;\n}\n\n.mapillary-popup-float-top-right .mapillary-popup-content {\n    border-bottom-left-radius: 0;\n}\n\n.mapillary-popup-float-bottom-left .mapillary-popup-content {\n    border-top-right-radius: 0;\n}\n\n.mapillary-popup-float-bottom-right .mapillary-popup-content {\n    border-top-left-radius: 0;\n}\n.mapillary-sequence-container {\n    position: absolute;\n    top: 14px;\n    pointer-events: none;\n    font-size: 0;\n    z-index: 10;\n    width: 100%;\n}\n\n.mapillary-sequence-stepper,\n.mapillary-sequence-controls {\n    position: absolute;\n    left: 50%;\n    cursor: pointer;\n}\n\n.mapillary-sequence-stepper {\n    -webkit-transform: translate(-50%, 0);\n            transform: translate(-50%, 0);\n}\n\n.mapillary-sequence-expander-button,\n.mapillary-sequence-playback-button,\n.mapillary-sequence-timeline-button {\n    display: inline-block;\n    height: 100%;\n    pointer-events: auto;\n}\n\n.mapillary-sequence-expander-button {\n    width: calc(100% * 16 / 88);\n    background: rgba(0, 0, 0, 0.5);\n}\n\n.mapillary-sequence-expander-bar {\n    background-color: white;\n    width: 12.5%;\n    border-radius: 1px;\n    height: calc(100% * 16 / 30);\n    position: relative;\n    left: 50%;\n    top: 50%;\n    -webkit-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n}\n\n.mapillary-sequence-playback-button,\n.mapillary-sequence-timeline-button {\n    width: 0;\n    background: rgba(0, 0, 0, 0.5);\n    -webkit-transition: width 0.15s ease-out;\n    transition: width 0.15s ease-out;\n}\n\n.mapillary-sequence-speed-container,\n.mapillary-sequence-position-container,\n.mapillary-sequence-position-container-inactive {\n    display: inline-block;\n    height: 100%;\n    vertical-align: top;\n    background: rgba(0, 0, 0, 0.5);\n    pointer-events: auto;\n    padding-right: 3px;\n}\n\n.mapillary-sequence-speed-container {\n    padding-left: 3px;\n}\n\n.mapillary-sequence-position-container,\n.mapillary-sequence-position-container-inactive {\n    padding-left: 16px;\n}\n\n.mapillary-sequence-speed,\n.mapillary-sequence-position {\n    margin: 0;\n    padding: 0;\n    margin-top: 7px;\n    height: 16px;\n    cursor: pointer;\n    outline: none;\n    background: none;\n    -webkit-appearance: none;\n}\n\n.mapillary-sequence-position-container-inactive .mapillary-sequence-position {\n    cursor: default;\n}\n\n.mapillary-sequence-fast-icon,\n.mapillary-sequence-fast-icon-gray,\n.mapillary-sequence-timeline-icon,\n.mapillary-sequence-timeline-icon-gray,\n.mapillary-sequence-slow-icon,\n.mapillary-sequence-switch-icon,\n.mapillary-sequence-close-icon {\n    position: relative;\n    left: 50%;\n    top: 50%;\n    -webkit-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n    background-size: contain;\n    background-repeat: no-repeat;\n    opacity: 0;\n}\n\n.mapillary-sequence-fast-icon,\n.mapillary-sequence-timeline-icon {\n    -webkit-transition-delay: 0s;\n            transition-delay: 0s;\n    -webkit-transition-property: opacity;\n    transition-property: opacity;\n}\n\n.mapillary-sequence-fast-icon,\n.mapillary-sequence-fast-icon-gray,\n.mapillary-sequence-timeline-icon,\n.mapillary-sequence-timeline-icon-gray,\n.mapillary-sequence-slow-icon {\n    width: calc(100% * 24 / 36);\n    height: calc(100% * 24 / 30);\n}\n\n.mapillary-sequence-switch-icon,\n.mapillary-sequence-close-icon {\n    width: calc(100% * 16 / 36);\n    height: calc(100% * 16 / 30);\n}\n\n.mapillary-sequence-fast-icon {\n    background-image: url(${te});\n}\n\n.mapillary-sequence-fast-icon-gray {\n    background-image: url(${ie});\n}\n\n.mapillary-sequence-timeline-icon {\n    background-image: url(${ne});\n}\n\n.mapillary-sequence-timeline-icon-gray {\n    background-image: url(${re});\n}\n\n.mapillary-sequence-slow-icon {\n    background-image: url(${se});\n}\n\n.mapillary-sequence-switch-icon {\n    background-image: url(${ae});\n}\n\n.mapillary-sequence-close-icon {\n    background-image: url(${oe});\n}\n\n.mapillary-sequence-icon-visible {\n    opacity: 1;\n}\n\n.mapillary-sequence-controls-expanded .mapillary-sequence-fast-icon,\n.mapillary-sequence-controls-expanded .mapillary-sequence-timeline-icon {\n    opacity: 1;\n    -webkit-transition-delay: 0.12s;\n            transition-delay: 0.12s;\n    -webkit-transition: 0.2s ease-in;\n    transition: 0.2s ease-in;\n    -webkit-transition-property: opacity;\n    transition-property: opacity;\n}\n\n.mapillary-sequence-controls-expanded .mapillary-sequence-playback-button,\n.mapillary-sequence-controls-expanded .mapillary-sequence-timeline-button {\n    width: calc(100% * 36 / 88);\n}\n\n.mapillary-sequence-playback,\n.mapillary-sequence-timeline {\n    position: absolute;\n    height: 30px;\n    width: 405px;\n    max-width: 80%;\n    min-width: 271px;\n    left: 50%;\n    padding-left: 5px;\n    -webkit-transform: translate(-50%, 0);\n            transform: translate(-50%, 0);\n}\n\n.mapillary-sequence-switch-button,\n.mapillary-sequence-switch-button-inactive,\n.mapillary-sequence-slow-container,\n.mapillary-sequence-fast-container,\n.mapillary-sequence-close-button {\n    width: 36px;\n    height: 100%;\n    display: inline-block;\n    pointer-events: auto;\n    background: rgba(0, 0, 0, 0.5);\n}\n\n.mapillary-sequence-switch-button,\n.mapillary-sequence-switch-button-inactive,\n.mapillary-sequence-close-button {\n    cursor: pointer;\n}\n\n.mapillary-sequence-play,\n.mapillary-sequence-play-inactive,\n.mapillary-sequence-stop,\n.mapillary-sequence-step-next,\n.mapillary-sequence-step-next-inactive,\n.mapillary-sequence-step-next-highlight,\n.mapillary-sequence-step-prev,\n.mapillary-sequence-step-prev-inactive,\n.mapillary-sequence-step-prev-highlight {\n    display: inline-block;\n    width: calc(100% / 3);\n    height: 100%;\n    pointer-events: auto;\n}\n\n.mapillary-sequence-play-inactive,\n.mapillary-sequence-step-next-inactive,\n.mapillary-sequence-step-prev-inactive {\n    cursor: default;\n}\n\n.mapillary-sequence-play,\n.mapillary-sequence-play-inactive,\n.mapillary-sequence-stop,\n.mapillary-sequence-step-next,\n.mapillary-sequence-step-next-inactive,\n.mapillary-sequence-step-prev,\n.mapillary-sequence-step-prev-inactive {\n    background: rgba(0, 0, 0, 0.5);\n}\n\n.mapillary-sequence-step-next-highlight,\n.mapillary-sequence-step-prev-highlight {\n    background: rgba(0, 0, 0, 0.5);\n}\n\n.mapillary-sequence-switch-button,\n.mapillary-sequence-switch-button-inactive,\n.mapillary-sequence-position-container,\n.mapillary-sequence-position-container-inactive {\n    border-bottom-left-radius: 8px;\n    border-top-left-radius: 8px;\n}\n\n.mapillary-sequence-close-button {\n    border-bottom-right-radius: 8px;\n    border-top-right-radius: 8px;\n}\n\n.mapillary-sequence-play .mapillary-sequence-icon,\n.mapillary-sequence-play-inactive .mapillary-sequence-icon {\n    background-image: url(${ce});\n}\n\n.mapillary-sequence-stop .mapillary-sequence-icon,\n.mapillary-sequence-stop-inactive .mapillary-sequence-icon {\n    background-image: url(${le});\n}\n\n.mapillary-sequence-step-prev .mapillary-sequence-icon,\n.mapillary-sequence-step-prev-inactive .mapillary-sequence-icon,\n.mapillary-sequence-step-prev-highlight .mapillary-sequence-icon {\n    background-image: url(${he});\n}\n\n.mapillary-sequence-step-next .mapillary-sequence-icon,\n.mapillary-sequence-step-next-inactive .mapillary-sequence-icon,\n.mapillary-sequence-step-next-highlight .mapillary-sequence-icon {\n    background-image: url(${ue});\n}\n\n.mapillary-sequence-play-inactive .mapillary-sequence-icon,\n.mapillary-sequence-stop-inactive .mapillary-sequence-icon,\n.mapillary-sequence-step-next-inactive .mapillary-sequence-icon,\n.mapillary-sequence-step-prev-inactive .mapillary-sequence-icon,\n.mapillary-sequence-switch-button-inactive .mapillary-sequence-switch-icon {\n    opacity: 0.35;\n}\n\n.mapillary-sequence-icon {\n    position: relative;\n    left: 50%;\n    top: 50%;\n    -webkit-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n    width: calc(100% * 16 / 36);\n    height: calc(100% * 16 / 30);\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.mapillary-sequence-speed::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    width: 16px;\n    height: 16px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: white;\n    cursor: pointer;\n    margin-top: -6px;\n}\n\n.mapillary-sequence-position::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    width: 16px;\n    height: 16px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: white;\n    cursor: pointer;\n    margin-top: -6px;\n}\n\n.mapillary-sequence-position-container-inactive\n    .mapillary-sequence-position::-webkit-slider-thumb {\n    border: none;\n    background: none;\n    -webkit-box-shadow: none;\n            box-shadow: none;\n}\n\n.mapillary-sequence-speed::-webkit-slider-runnable-track,\n.mapillary-sequence-position::-webkit-slider-runnable-track {\n    height: 4px;\n    border-radius: 2px;\n    background-color: white;\n}\n\n.mapillary-sequence-position-container-inactive\n    .mapillary-sequence-position::-webkit-slider-runnable-track {\n    background-color: #d7dadd;\n}\n\n.mapillary-sequence-speed::-moz-focus-outer,\n.mapillary-sequence-position::-moz-focus-outer {\n    border: 0;\n}\n\n.mapillary-sequence-speed::-moz-range-track,\n.mapillary-sequence-position::-moz-range-track {\n    height: 4px;\n    border-radius: 2px;\n    background-color: white;\n}\n\n.mapillary-sequence-position-container-inactive\n    .mapillary-sequence-position::-moz-range-track {\n    background-color: #d7dadd;\n}\n\n.mapillary-sequence-speed::-moz-range-thumb {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: #dee5ed;\n    cursor: pointer;\n    margin-top: -6px;\n    box-shadow: 1px 2px 4px 0 rgba(0, 0, 0, 0.5);\n}\n\n.mapillary-sequence-position::-moz-range-thumb {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: #ff861b;\n    cursor: pointer;\n    margin-top: -6px;\n    box-shadow: 1px 2px 4px 0 rgba(0, 0, 0, 0.5);\n}\n\n.mapillary-sequence-position-container-inactive\n    .mapillary-sequence-position::-moz-range-thumb {\n    border: none;\n    background: none;\n    box-shadow: none;\n}\n\n.mapillary-sequence-speed::-ms-track,\n.mapillary-sequence-position::-ms-track {\n    height: 2px;\n    border-radius: 2px;\n    background-color: white;\n}\n\n.mapillary-sequence-position-container-inactive\n    .mapillary-sequence-position::-ms-track {\n    background-color: #d7dadd;\n}\n\n.mapillary-sequence-speed::-ms-fill-lower,\n.mapillary-sequence-position::-ms-fill-lower {\n    height: 0;\n    background: none;\n}\n\n.mapillary-sequence-speed::-ms-fill-upper,\n.mapillary-sequence-position::-ms-fill-upper {\n    height: 0;\n    background: none;\n}\n\n.mapillary-sequence-speed::-ms-thumb {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: white;\n    cursor: pointer;\n    margin-top: 0;\n}\n\n.mapillary-sequence-position::-ms-thumb {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: white;\n    cursor: pointer;\n    margin-top: 0;\n}\n\n.mapillary-sequence-position-container-inactive\n    .mapillary-sequence-position::-ms-thumb {\n    border: none;\n    background: none;\n    box-shadow: none;\n}\n\n.mapillary-sequence-speed::-ms-tooltip,\n.mapillary-sequence-position::-ms-tooltip {\n    display: none;\n}\n\n@media (hover: hover) {\n    .mapillary-sequence-play:hover,\n    .mapillary-sequence-stop:hover,\n    .mapillary-sequence-step-prev:hover,\n    .mapillary-sequence-step-next:hover {\n        background: rgba(0, 0, 0, 0.5);\n    }\n\n    .mapillary-sequence-play-inactive:hover,\n    .mapillary-sequence-step-prev-inactive:hover,\n    .mapillary-sequence-step-next-inactive:hover {\n        background: rgba(0, 0, 0, 0.5);\n    }\n\n    .mapillary-sequence-switch-button-inactive:hover {\n        background: rgba(0, 0, 0, 0.5);\n    }\n\n    .mapillary-sequence-playback-button:hover,\n    .mapillary-sequence-timeline-button:hover,\n    .mapillary-sequence-switch-button:hover,\n    .mapillary-sequence-close-button:hover {\n        background: rgba(0, 0, 0, 0.5);\n    }\n}\n.mapillary-slider-container {\n    position: absolute;\n    bottom: 40px;\n    height: 30px;\n    left: 50%;\n    padding-left: 5px;\n    pointer-events: none;\n    -webkit-transform: translate(-50%, 0);\n            transform: translate(-50%, 0);\n    z-index: 10;\n}\n\n.mapillary-slider-border {\n    display: inline-block;\n    width: 8px;\n    height: 100%;\n    border-bottom-left-radius: 8px;\n    border-top-left-radius: 8px;\n    pointer-events: auto;\n    cursor: default;\n    background: rgba(0, 0, 0, 0.5);\n}\n\n.mapillary-slider-mode-button,\n.mapillary-slider-mode-button-2d,\n.mapillary-slider-mode-button-inactive,\n.mapillary-slider-mode-button-2d-inactive {\n    width: 26px;\n    height: 100%;\n    display: inline-block;\n    pointer-events: auto;\n    background: rgba(0, 0, 0, 0.5);\n\n}\n\n.mapillary-slider-mode-button,\n.mapillary-slider-mode-button-2d {\n    cursor: default;\n}\n\n.mapillary-slider-mode-button-inactive,\n.mapillary-slider-mode-button-2d-inactive {\n    cursor: pointer;\n}\n\n.mapillary-slider-mode-icon,\n.mapillary-slider-mode-icon-2d {\n    position: relative;\n    top: 50%;\n    -webkit-transform: translate(0, -50%);\n            transform: translate(0, -50%);\n    background-size: contain;\n    background-repeat: no-repeat;\n    opacity: 1;\n    width: 18px;\n    height: 18px;\n    margin-left: 4px;\n}\n\n.mapillary-slider-mode-icon {\n    background-image: url(${de});\n}\n\n.mapillary-slider-mode-icon-2d {\n    background-image: url(${pe});\n}\n\n.mapillary-slider-mode-button-inactive .mapillary-slider-mode-icon {\n    opacity: 0.35;\n}\n\n.mapillary-slider-mode-button-2d-inactive .mapillary-slider-mode-icon-2d {\n    opacity: 0.35;\n}\n\n.mapillary-slider-position-container {\n    display: inline-block;\n    height: 100%;\n    vertical-align: top;\n    background: rgba(0, 0, 0, 0.5);\n    pointer-events: auto;\n    padding-right: 16px;\n    border-bottom-right-radius: 8px;\n    border-top-right-radius: 8px;\n    padding-left: 8px;\n}\n\n.mapillary-slider-position {\n    pointer-events: auto;\n    margin: 0;\n    padding: 0;\n    margin-top: 7px;\n    height: 16px;\n    cursor: pointer;\n    outline: none;\n    background: none;\n    -webkit-appearance: none;\n}\n\n.mapillary-slider-position::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    width: 16px;\n    height: 16px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: white;\n    cursor: pointer;\n    margin-top: -6px;\n}\n\n.mapillary-slider-position::-webkit-slider-runnable-track {\n    height: 4px;\n    border-radius: 2px;\n    background-color: white;\n}\n\n.mapillary-slider-position::-moz-focus-outer {\n    border: 0;\n}\n\n.mapillary-slider-position::-moz-range-track {\n    height: 4px;\n    border-radius: 2px;\n    background-color: white;\n}\n\n.mapillary-slider-position::-moz-range-thumb {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: white;\n    cursor: pointer;\n    margin-top: -6px;\n}\n\n.mapillary-slider-position::-ms-track {\n    height: 2px;\n    border-radius: 2px;\n    background-color: white;\n}\n\n.mapillary-slider-position::-ms-fill-lower {\n    height: 0;\n    background: none;\n}\n\n.mapillary-slider-position::-ms-fill-upper {\n    height: 0;\n    background: none;\n}\n\n.mapillary-slider-position::-ms-thumb {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    border: 2px solid white;\n    background: white;\n    cursor: pointer;\n    margin-top: 0;\n}\n\n.mapillary-slider-position::-ms-tooltip {\n    display: none;\n}\n.mapillary-viewer.component-tag-create .mapillary-interactive,\n.mapillary-viewer.component-tag-edit-crosshair .mapillary-interactive {\n    cursor: crosshair;\n}\n\n.mapillary-viewer.component-tag-edit-move .mapillary-interactive {\n    cursor: move;\n}\n\n.mapillary-viewer.component-tag-edit-nesw-resize .mapillary-interactive {\n    cursor: nesw-resize;\n}\n\n.mapillary-viewer.component-tag-edit-nwse-resize .mapillary-interactive {\n    cursor: nwse-resize;\n}\n\n.mapillary-tag-container {\n    font-size: 12px;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont,\n                "Segoe UI", "Roboto", "Oxygen", "Ubuntu",\n                "Cantarell", "Fira Sans", "Droid Sans",\n                "Helvetica Neue", sans-serif;\n}\n\n.mapillary-tag-completer,\n.mapillary-tag-interactor,\n.mapillary-tag-mover,\n.mapillary-tag-resizer,\n.mapillary-tag-spot-interactor,\n.mapillary-tag-symbol,\n.mapillary-tag-vertex {\n    position: absolute;\n    left: 0;\n    top: 0;\n}\n\n.mapillary-tag-symbol {\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.mapillary-tag-mover,\n.mapillary-tag-resizer {\n    pointer-events: auto;\n}\n\n.mapillary-tag-mover {\n    border-radius: 7px;\n    width: 14px;\n    height: 14px;\n    opacity: 0.2;\n    cursor: move;\n}\n\n.mapillary-tag-mover:hover {\n    opacity: 0.5;\n}\n\n.mapillary-tag-resizer {\n    border-radius: 7px;\n    width: 14px;\n    height: 14px;\n    opacity: 0;\n    cursor: crosshair;\n}\n\n.mapillary-tag-resizer:hover {\n    opacity: 0.3;\n}\n\n.mapillary-tag-vertex {\n    pointer-events: none;\n    border-radius: 3px;\n    width: 6px;\n    height: 6px;\n}\n\n.mapillary-tag-dot {\n    pointer-events: none;\n    border-radius: 1.5px;\n    width: 3px;\n    height: 3px;\n    background-color: green;\n}\n\n.mapillary-tag-vertex.mapillary-tag-larger {\n    border-radius: 4px;\n    width: 8px;\n    height: 8px;\n}\n\n.mapillary-tag-interactor,\n.mapillary-tag-completer,\n.mapillary-tag-spot-interactor {\n    pointer-events: auto;\n    border-radius: 7px;\n    width: 14px;\n    height: 14px;\n    opacity: 0;\n}\n\n.mapillary-tag-completer.mapillary-tag-larger {\n    border-radius: 8px;\n    width: 16px;\n    height: 16px;\n}\n\n.mapillary-tag-interactor,\n.mapillary-tag-completer {\n    cursor: pointer;\n}\n\n.mapillary-tag-spot-interactor {\n    cursor: move;\n}\n\n.mapillary-tag-completer {\n    background: limegreen;\n}\n\n.mapillary-tag-interactor {\n    background: orangered;\n}\n\n.mapillary-tag-completer:hover,\n.mapillary-tag-interactor:hover {\n    opacity: 0.6;\n}\n\n.mapillary-tag-spot-interactor:hover {\n    opacity: 0.3;\n}\n.mapillary-zoom-container {\n    position: absolute;\n    bottom: 90px;\n    right: 14px;\n    height: 66px;\n    width: 32px;\n    pointer-events: none;\n    z-index: 10;\n}\n\n.mapillary-zoom-in-button,\n.mapillary-zoom-in-button-inactive,\n.mapillary-zoom-out-button,\n.mapillary-zoom-out-button-inactive {\n    width: 100%;\n    height: 32px;\n    pointer-events: auto;\n    background: rgba(0, 0, 0, 0.5);\n    cursor: pointer;\n}\n\n.mapillary-zoom-in-button,\n.mapillary-zoom-in-button-inactive {\n    border-top-left-radius: 8px;\n    border-top-right-radius: 8px;\n}\n\n.mapillary-zoom-out-button,\n.mapillary-zoom-out-button-inactive {\n    margin-top: 2px;\n    border-bottom-left-radius: 8px;\n    border-bottom-right-radius: 8px;\n}\n\n.mapillary-zoom-in-button-inactive,\n.mapillary-zoom-out-button-inactive {\n    cursor: default;\n}\n\n.mapillary-zoom-in-icon,\n.mapillary-zoom-out-icon {\n    position: relative;\n    top: 0;\n    left: 0;\n    background-size: contain;\n    background-repeat: no-repeat;\n    opacity: 1;\n    width: 32px;\n    height: 32px;\n}\n\n.mapillary-zoom-compact.mapillary-zoom-container {\n    height: 34px;\n    width: 16px;\n    bottom: 58px;\n}\n\n.mapillary-zoom-compact .mapillary-zoom-in-button,\n.mapillary-zoom-compact .mapillary-zoom-in-button-inactive,\n.mapillary-zoom-compact .mapillary-zoom-out-button,\n.mapillary-zoom-compact .mapillary-zoom-out-button-inactive,\n.mapillary-zoom-compact .mapillary-zoom-in-icon,\n.mapillary-zoom-compact .mapillary-zoom-out-icon {\n    width: 16px;\n    height: 16px;\n}\n\n.mapillary-zoom-compact .mapillary-zoom-in-button,\n.mapillary-zoom-compact .mapillary-zoom-in-button-inactive {\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n}\n\n.mapillary-zoom-compact .mapillary-zoom-out-button,\n.mapillary-zoom-compact .mapillary-zoom-out-button-inactive {\n    border-bottom-left-radius: 4px;\n    border-bottom-right-radius: 4px;\n}\n\n.mapillary-zoom-in-icon {\n    background-image: url(${ge});\n}\n\n.mapillary-zoom-out-icon {\n    background-image: url(${me});\n}\n\n.mapillary-zoom-in-button-inactive .mapillary-zoom-in-icon,\n.mapillary-zoom-out-button-inactive .mapillary-zoom-out-icon {\n    opacity: 0.35;\n}\n`,
                        "",
                    ]);
                    const fe = U;
                },
                935: (e) => {
                    e.exports = function (e) {
                        var t = [];
                        return (
                            (t.toString = function () {
                                return this.map(function (t) {
                                    var i = "",
                                        n = void 0 !== t[5];
                                    return (
                                        t[4] &&
                                            (i += "@supports (".concat(
                                                t[4],
                                                ") {"
                                            )),
                                        t[2] &&
                                            (i += "@media ".concat(t[2], " {")),
                                        n &&
                                            (i += "@layer".concat(
                                                t[5].length > 0
                                                    ? " ".concat(t[5])
                                                    : "",
                                                " {"
                                            )),
                                        (i += e(t)),
                                        n && (i += "}"),
                                        t[2] && (i += "}"),
                                        t[4] && (i += "}"),
                                        i
                                    );
                                }).join("");
                            }),
                            (t.i = function (e, i, n, r, s) {
                                "string" == typeof e &&
                                    (e = [[null, e, void 0]]);
                                var a = {};
                                if (n)
                                    for (var o = 0; o < this.length; o++) {
                                        var c = this[o][0];
                                        null != c && (a[c] = !0);
                                    }
                                for (var l = 0; l < e.length; l++) {
                                    var h = [].concat(e[l]);
                                    (n && a[h[0]]) ||
                                        (void 0 !== s &&
                                            (void 0 === h[5] ||
                                                (h[1] = "@layer"
                                                    .concat(
                                                        h[5].length > 0
                                                            ? " ".concat(h[5])
                                                            : "",
                                                        " {"
                                                    )
                                                    .concat(h[1], "}")),
                                            (h[5] = s)),
                                        i &&
                                            (h[2]
                                                ? ((h[1] = "@media "
                                                      .concat(h[2], " {")
                                                      .concat(h[1], "}")),
                                                  (h[2] = i))
                                                : (h[2] = i)),
                                        r &&
                                            (h[4]
                                                ? ((h[1] = "@supports ("
                                                      .concat(h[4], ") {")
                                                      .concat(h[1], "}")),
                                                  (h[4] = r))
                                                : (h[4] = "".concat(r))),
                                        t.push(h));
                                }
                            }),
                            t
                        );
                    };
                },
                62: (e) => {
                    e.exports = function (e, t) {
                        return (
                            t || (t = {}),
                            e
                                ? ((e = String(e.__esModule ? e.default : e)),
                                  /^['"].*['"]$/.test(e) &&
                                      (e = e.slice(1, -1)),
                                  t.hash && (e += t.hash),
                                  /["'() \t\n]|(%20)/.test(e) || t.needQuotes
                                      ? '"'.concat(
                                            e
                                                .replace(/"/g, '\\"')
                                                .replace(/\n/g, "\\n"),
                                            '"'
                                        )
                                      : e)
                                : e
                        );
                    };
                },
                6758: (e) => {
                    e.exports = function (e) {
                        return e[1];
                    };
                },
                2591: (e) => {
                    var t = [];
                    function i(e) {
                        for (var i = -1, n = 0; n < t.length; n++)
                            if (t[n].identifier === e) {
                                i = n;
                                break;
                            }
                        return i;
                    }
                    function n(e, n) {
                        for (var s = {}, a = [], o = 0; o < e.length; o++) {
                            var c = e[o],
                                l = n.base ? c[0] + n.base : c[0],
                                h = s[l] || 0,
                                u = "".concat(l, " ").concat(h);
                            s[l] = h + 1;
                            var d = i(u),
                                p = {
                                    css: c[1],
                                    media: c[2],
                                    sourceMap: c[3],
                                    supports: c[4],
                                    layer: c[5],
                                };
                            if (-1 !== d) t[d].references++, t[d].updater(p);
                            else {
                                var g = r(p, n);
                                (n.byIndex = o),
                                    t.splice(o, 0, {
                                        identifier: u,
                                        updater: g,
                                        references: 1,
                                    });
                            }
                            a.push(u);
                        }
                        return a;
                    }
                    function r(e, t) {
                        var i = t.domAPI(t);
                        return (
                            i.update(e),
                            function (t) {
                                if (t) {
                                    if (
                                        t.css === e.css &&
                                        t.media === e.media &&
                                        t.sourceMap === e.sourceMap &&
                                        t.supports === e.supports &&
                                        t.layer === e.layer
                                    )
                                        return;
                                    i.update((e = t));
                                } else i.remove();
                            }
                        );
                    }
                    e.exports = function (e, r) {
                        var s = n((e = e || []), (r = r || {}));
                        return function (e) {
                            e = e || [];
                            for (var a = 0; a < s.length; a++) {
                                var o = i(s[a]);
                                t[o].references--;
                            }
                            for (var c = n(e, r), l = 0; l < s.length; l++) {
                                var h = i(s[l]);
                                0 === t[h].references &&
                                    (t[h].updater(), t.splice(h, 1));
                            }
                            s = c;
                        };
                    };
                },
                8128: (e) => {
                    var t = {};
                    e.exports = function (e, i) {
                        var n = (function (e) {
                            if (void 0 === t[e]) {
                                var i = document.querySelector(e);
                                if (
                                    window.HTMLIFrameElement &&
                                    i instanceof window.HTMLIFrameElement
                                )
                                    try {
                                        i = i.contentDocument.head;
                                    } catch (e) {
                                        i = null;
                                    }
                                t[e] = i;
                            }
                            return t[e];
                        })(e);
                        if (!n)
                            throw new Error(
                                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
                            );
                        n.appendChild(i);
                    };
                },
                3051: (e) => {
                    e.exports = function (e) {
                        var t = document.createElement("style");
                        return (
                            e.setAttributes(t, e.attributes),
                            e.insert(t, e.options),
                            t
                        );
                    };
                },
                855: (e, t, i) => {
                    e.exports = function (e) {
                        var t = i.nc;
                        t && e.setAttribute("nonce", t);
                    };
                },
                1740: (e) => {
                    e.exports = function (e) {
                        if ("undefined" == typeof document)
                            return {
                                update: function () {},
                                remove: function () {},
                            };
                        var t = e.insertStyleElement(e);
                        return {
                            update: function (i) {
                                !(function (e, t, i) {
                                    var n = "";
                                    i.supports &&
                                        (n += "@supports (".concat(
                                            i.supports,
                                            ") {"
                                        )),
                                        i.media &&
                                            (n += "@media ".concat(
                                                i.media,
                                                " {"
                                            ));
                                    var r = void 0 !== i.layer;
                                    r &&
                                        (n += "@layer".concat(
                                            i.layer.length > 0
                                                ? " ".concat(i.layer)
                                                : "",
                                            " {"
                                        )),
                                        (n += i.css),
                                        r && (n += "}"),
                                        i.media && (n += "}"),
                                        i.supports && (n += "}");
                                    var s = i.sourceMap;
                                    s &&
                                        "undefined" != typeof btoa &&
                                        (n +=
                                            "\n/*# sourceMappingURL=data:application/json;base64,".concat(
                                                btoa(
                                                    unescape(
                                                        encodeURIComponent(
                                                            JSON.stringify(s)
                                                        )
                                                    )
                                                ),
                                                " */"
                                            )),
                                        t.styleTagTransform(n, e, t.options);
                                })(t, e, i);
                            },
                            remove: function () {
                                !(function (e) {
                                    if (null === e.parentNode) return !1;
                                    e.parentNode.removeChild(e);
                                })(t);
                            },
                        };
                    };
                },
                3656: (e) => {
                    e.exports = function (e, t) {
                        if (t.styleSheet) t.styleSheet.cssText = e;
                        else {
                            for (; t.firstChild; ) t.removeChild(t.firstChild);
                            t.appendChild(document.createTextNode(e));
                        }
                    };
                },
                3953: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8dGl0bGU+CiAgICBjaGV2cm9ubGVmdAogIDwvdGl0bGU+CiAgPHBhdGggZD0iTTYuMjY4IDguMDAwMmw1LjUyMTUtNS45NDczYy40NzEtLjQ2OTcuNDcxLTEuMjI5NiAwLTEuNzAxLS40NzEtLjQ2OTQtMS4yMzIzLS40Njk0LTEuNzAzNCAwTDMuMzUzNCA3LjE0OGMtLjQ3MS40NzE0LS40NzEgMS4yMzMgMCAxLjcwMjZsNi43MzI4IDYuNzk2Yy40Njk1LjQ3MyAxLjIzMjQuNDY5NSAxLjcwMzUgMCAuNDcxLS40Njc4LjQ3MS0xLjIyOTUgMC0xLjcwMDhMNi4yNjggOC4wMDAyeiIgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJldmVub2RkIi8+Cjwvc3ZnPgo=";
                },
                9273: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8dGl0bGU+CiAgICBjaGV2cm9ucmlnaHQKICA8L3RpdGxlPgogIDxwYXRoIGQ9Ik05Ljg3NSA4LjAwMDJMNC4zNTMyIDIuMDUzYy0uNDcxLS40Njk3LS40NzEtMS4yMjk2IDAtMS43MDEuNDcxMi0uNDY5NCAxLjIzMjMtLjQ2OTQgMS43MDM0IDBsNi43MzI4IDYuNzk2Yy40NzEuNDcxNC40NzEgMS4yMzMgMCAxLjcwMjZsLTYuNzMyOCA2Ljc5NmMtLjQ2OTMuNDczLTEuMjMyMi40Njk1LTEuNzAzNCAwLS40NzEtLjQ2NzgtLjQ3MS0xLjIyOTUgMC0xLjcwMDhMOS44NzUgOC4wMDAyeiIgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJldmVub2RkIi8+Cjwvc3ZnPgo=";
                },
                7254: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8dGl0bGU+CiAgICBwbGF5CiAgPC90aXRsZT4KICA8cGF0aCBkPSJNMTQuODk1MiA4LjY4NjVMMy41MDgyIDE1Ljc1N0MyLjY3ODMgMTYuMzAyIDIgMTUuODk4IDIgMTQuODY1VjEuMTM2QzIgLjEgMi42NzgzLS4zMDEgMy41MDk2LjI0M2wxMS4zODcgNy4wNzNjLS4wMDE0IDAgLjQwNDMuMjg2Ny40MDQzLjY4NTMgMCAuMzk4OC0uNDA1OC42ODU1LS40MDU4LjY4NTV6IiBmaWxsPSIjRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz4KPC9zdmc+Cg==";
                },
                9244: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8dGl0bGU+CiAgICBzdG9wCiAgPC90aXRsZT4KICA8cGF0aCBkPSJNMCAxLjk5NEMwIC44OTMuODk0NSAwIDEuOTk0IDBoMTIuMDEyQzE1LjEwNyAwIDE2IC44OTQ1IDE2IDEuOTk0djEyLjAxMkMxNiAxNS4xMDcgMTUuMTA1NSAxNiAxNC4wMDYgMTZIMS45OTRDLjg5MyAxNiAwIDE1LjEwNTUgMCAxNC4wMDZWMS45OTR6IiBmaWxsPSIjRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz4KPC9zdmc+Cg==";
                },
                9435: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDx0aXRsZT4KICAgICAgY2xvc2UKICAgIDwvdGl0bGU+CiAgICA8cGF0aCBkPSJNOS4yNzM0IDguMDA0N2wzLjQ0MTMgMy40NDE0Yy4yMzE1LjIyOS4zMjI3LjU2NDYuMjM5Ljg3OTMtLjA4MzguMzE0Ny0uMzI5Ni41NjA0LS42NDQzLjY0NC0uMzE0Ny4wODQtLjY1LS4wMDczLS44NzktLjIzODhMNy45ODg4IDkuMjg5bC0zLjQzNjUgMy40MzY1Yy0uMzU2LjM0Ni0uOTI0LjM0MTctMS4yNzUtLjAwOTMtLjM1MS0uMzUxLS4zNTUtLjkxOS0uMDA5LTEuMjc1bDMuNDM2Mi0zLjQzNjQtMy40NDk1LTMuNDQ5NmMtLjM0NDQtLjM1NjMtLjMzOTYtLjkyMy4wMTA4LTEuMjczNC4zNTA0LS4zNTA0LjkxNy0uMzU1MiAxLjI3MzMtLjAxMDhMNy45ODkgNi43MjA1bDMuNDU0NC0zLjQ1NDVjLjIyOTQtLjIyOTQuNTYzOC0uMzE5Ljg3NzItLjIzNS4zMTM1LjA4NC41NTgzLjMyODcuNjQyMy42NDIyLjA4MzguMzEzNC0uMDA1OC42NDc4LS4yMzUyLjg3NzJMOS4yNzM0IDguMDA0N3oiIGZpbGw9IiNGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPgogIDwvc3ZnPg==";
                },
                600: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDx0aXRsZT4KICAgICAgcGxheV9kaXJlY3Rpb24KICAgIDwvdGl0bGU+CiAgICA8cGF0aCBkPSJNNiA0aDhjLjU1MjMgMCAxIC40NDc3IDEgMXMtLjQ0NzcgMS0xIDFINnYyLjA1ODRjLS4wMDM0LjE2NjgtLjExMTguMzE4Mi0uMjgxNS4zOTM0LS4xNjk4LjA3NS0uMzczLjA2MTctLjUyOC0uMDM1TC4yMTQzIDUuMzU4NEMuMDggNS4yNzcgMCA1LjE0MyAwIDVjMC0uMTQzLjA4LS4yNzcuMjE0My0uMzU4NWw0Ljk3NjItMy4wNTgzYy4xNTUtLjA5NjcuMzU4My0uMTEuNTI4LS4wMzUuMTY5OC4wNzUyLjI3OC4yMjY2LjI4MTUuMzkzNFY0em00IDZWNy45NDE2Yy4wMDM0LS4xNjY4LjExMTctLjMxODIuMjgxNS0uMzkzNC4xNjk3LS4wNzUuMzczLS4wNjE3LjUyOC4wMzVsNC45NzYyIDMuMDU4M0MxNS45MiAxMC43MjMgMTYgMTAuODU3IDE2IDExYzAgLjE0My0uMDguMjc3LS4yMTQzLjM1ODRsLTQuOTc2MiAzLjA1ODRjLS4xNTUuMDk2Ny0uMzU4Mi4xMS0uNTI4LjAzNS0uMTY5Ny0uMDc1Mi0uMjc4LS4yMjY2LS4yODE1LS4zOTM0VjEySDJjLS41NTIzIDAtMS0uNDQ3Ny0xLTFzLjQ0NzctMSAxLTFoOHoiIGZpbGw9IiNGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPgogIDwvc3ZnPg==";
                },
                3014: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwcHgiIGhlaWdodD0iMTgwcHgiIHZpZXdCb3g9IjAgMCAxODAgMTgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgaWQ9IlBhZ2UtMSIgZmlsbD0ibm9uZSIgdHJhbnNmb3JtPSJyb3RhdGUoLTEzNSA5MCw5MCkiPjxnIGlkPSJhcnJvdy11cCIgZmlsbD0iI0ZGRkZGRiI+PHBhdGggZD0iTTg4Ljg4NDM4MTcsNDUuNzM3ODgwNiBDODguMjk5ODg1Myw0NS45NDk3OTE2IDg3Ljc1MTU2OTIsNDYuMjg5OTI5OSA4Ny4yODMwODUzLDQ2Ljc1ODQxMzggTDMxLjM2MzM5NDcsMTAyLjY3ODEwNCBDMjkuNjQ2MDYxNCwxMDQuMzk1NDM4IDI5LjY1MTgzNjMsMTA3LjE3MDQ5OCAzMS4zNjcwMDMxLDEwOC44ODU2NjQgTDQwLjY4Njc0NTMsMTE4LjIwNTQwNyBDNDIuNDAwMzk2NywxMTkuOTE5MDU4IDQ1LjE4MTEzMTMsMTE5LjkyMjE4OSA0Ni44OTQzMDUyLDExOC4yMDkwMTUgTDkwLjgwMDkyNzYsNzQuMzAyMzkyNiBMMTM0LjQ1MDU1LDExNy45NTIwMTUgQzEzNi4xNjc4ODMsMTE5LjY2OTM0OSAxMzguOTQyOTQzLDExOS42NjM1NzQgMTQwLjY1ODExLDExNy45NDg0MDcgTDE0OS45Nzc4NTIsMTA4LjYyODY2NSBDMTUxLjY5MTUwNCwxMDYuOTE1MDEzIDE1MS42OTQ2MzUsMTA0LjEzNDI3OSAxNDkuOTgxNDYxLDEwMi40MjExMDUgTDk0LjA2MTc3MDEsNDYuNTAxNDE0MSBDOTIuNjU3MzEwOSw0NS4wOTY5NTQ5IDkwLjU0NTQyMzEsNDQuODQ0OTQ0NSA4OC44ODQzODE3LDQ1LjczNzg4MDYgTDg4Ljg4NDM4MTcsNDUuNzM3ODgwNiBaIiBpZD0iQXJyb3ciID48L3BhdGg+PHBhdGggZD0iTTkwLDE3MC4xMzg4MTIgQzEzNC4yNTk0NDQsMTcwLjEzODgxMiAxNzAuMTM4ODEyLDEzNC4yNTk0NDQgMTcwLjEzODgxMiw5MCBDMTcwLjEzODgxMiw0NS43NDA1NTYyIDEzNC4yNTk0NDQsOS44NjExODc4NSA5MCw5Ljg2MTE4Nzg1IEM0NS43NDA1NTYyLDkuODYxMTg3ODUgOS44NjExODc4NSw0NS43NDA1NTYyIDkuODYxMTg3ODUsOTAgQzkuODYxMTg3ODUsMTM0LjI1OTQ0NCA0NS43NDA1NTYyLDE3MC4xMzg4MTIgOTAsMTcwLjEzODgxMiBMOTAsMTcwLjEzODgxMiBMOTAsMTcwLjEzODgxMiBaIE0wLDkwIEMwLDQwLjI5NDM3MjUgNDAuMjk0MzcyNSwwIDkwLDAgQzEzOS43MDU2MjcsMCAxODAsNDAuMjk0MzcyNSAxODAsOTAgQzE4MCwxMzkuNzA1NjI3IDEzOS43MDU2MjcsMTgwIDkwLDE4MCBDNDAuMjk0MzcyNSwxODAgMCwxMzkuNzA1NjI3IDAsOTAgWiIgaWQ9IkNpcmNsZSI+PC9wYXRoPjwvZz48L2c+PC9zdmc+";
                },
                8393: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwcHgiIGhlaWdodD0iMTgwcHgiIHZpZXdCb3g9IjAgMCAxODAgMTgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgaWQ9IlBhZ2UtMSIgZmlsbD0ibm9uZSIgdHJhbnNmb3JtPSJyb3RhdGUoLTQ1IDkwLDkwKSI+PGcgaWQ9ImFycm93LXVwIiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNODguODg0MzgxNyw0NS43Mzc4ODA2IEM4OC4yOTk4ODUzLDQ1Ljk0OTc5MTYgODcuNzUxNTY5Miw0Ni4yODk5Mjk5IDg3LjI4MzA4NTMsNDYuNzU4NDEzOCBMMzEuMzYzMzk0NywxMDIuNjc4MTA0IEMyOS42NDYwNjE0LDEwNC4zOTU0MzggMjkuNjUxODM2MywxMDcuMTcwNDk4IDMxLjM2NzAwMzEsMTA4Ljg4NTY2NCBMNDAuNjg2NzQ1MywxMTguMjA1NDA3IEM0Mi40MDAzOTY3LDExOS45MTkwNTggNDUuMTgxMTMxMywxMTkuOTIyMTg5IDQ2Ljg5NDMwNTIsMTE4LjIwOTAxNSBMOTAuODAwOTI3Niw3NC4zMDIzOTI2IEwxMzQuNDUwNTUsMTE3Ljk1MjAxNSBDMTM2LjE2Nzg4MywxMTkuNjY5MzQ5IDEzOC45NDI5NDMsMTE5LjY2MzU3NCAxNDAuNjU4MTEsMTE3Ljk0ODQwNyBMMTQ5Ljk3Nzg1MiwxMDguNjI4NjY1IEMxNTEuNjkxNTA0LDEwNi45MTUwMTMgMTUxLjY5NDYzNSwxMDQuMTM0Mjc5IDE0OS45ODE0NjEsMTAyLjQyMTEwNSBMOTQuMDYxNzcwMSw0Ni41MDE0MTQxIEM5Mi42NTczMTA5LDQ1LjA5Njk1NDkgOTAuNTQ1NDIzMSw0NC44NDQ5NDQ1IDg4Ljg4NDM4MTcsNDUuNzM3ODgwNiBMODguODg0MzgxNyw0NS43Mzc4ODA2IFoiIGlkPSJBcnJvdyIgPjwvcGF0aD48cGF0aCBkPSJNOTAsMTcwLjEzODgxMiBDMTM0LjI1OTQ0NCwxNzAuMTM4ODEyIDE3MC4xMzg4MTIsMTM0LjI1OTQ0NCAxNzAuMTM4ODEyLDkwIEMxNzAuMTM4ODEyLDQ1Ljc0MDU1NjIgMTM0LjI1OTQ0NCw5Ljg2MTE4Nzg1IDkwLDkuODYxMTg3ODUgQzQ1Ljc0MDU1NjIsOS44NjExODc4NSA5Ljg2MTE4Nzg1LDQ1Ljc0MDU1NjIgOS44NjExODc4NSw5MCBDOS44NjExODc4NSwxMzQuMjU5NDQ0IDQ1Ljc0MDU1NjIsMTcwLjEzODgxMiA5MCwxNzAuMTM4ODEyIEw5MCwxNzAuMTM4ODEyIEw5MCwxNzAuMTM4ODEyIFogTTAsOTAgQzAsNDAuMjk0MzcyNSA0MC4yOTQzNzI1LDAgOTAsMCBDMTM5LjcwNTYyNywwIDE4MCw0MC4yOTQzNzI1IDE4MCw5MCBDMTgwLDEzOS43MDU2MjcgMTM5LjcwNTYyNywxODAgOTAsMTgwIEM0MC4yOTQzNzI1LDE4MCAwLDEzOS43MDU2MjcgMCw5MCBaIiBpZD0iQ2lyY2xlIj48L3BhdGg+PC9nPjwvZz48L3N2Zz4=";
                },
                2505: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwcHgiIGhlaWdodD0iMTgwcHgiIHZpZXdCb3g9IjAgMCAxODAgMTgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgaWQ9IlBhZ2UtMSIgZmlsbD0ibm9uZSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDkwLDkwKSI+PGcgaWQ9ImFycm93LXVwIiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNODguODg0MzgxNyw0NS43Mzc4ODA2IEM4OC4yOTk4ODUzLDQ1Ljk0OTc5MTYgODcuNzUxNTY5Miw0Ni4yODk5Mjk5IDg3LjI4MzA4NTMsNDYuNzU4NDEzOCBMMzEuMzYzMzk0NywxMDIuNjc4MTA0IEMyOS42NDYwNjE0LDEwNC4zOTU0MzggMjkuNjUxODM2MywxMDcuMTcwNDk4IDMxLjM2NzAwMzEsMTA4Ljg4NTY2NCBMNDAuNjg2NzQ1MywxMTguMjA1NDA3IEM0Mi40MDAzOTY3LDExOS45MTkwNTggNDUuMTgxMTMxMywxMTkuOTIyMTg5IDQ2Ljg5NDMwNTIsMTE4LjIwOTAxNSBMOTAuODAwOTI3Niw3NC4zMDIzOTI2IEwxMzQuNDUwNTUsMTE3Ljk1MjAxNSBDMTM2LjE2Nzg4MywxMTkuNjY5MzQ5IDEzOC45NDI5NDMsMTE5LjY2MzU3NCAxNDAuNjU4MTEsMTE3Ljk0ODQwNyBMMTQ5Ljk3Nzg1MiwxMDguNjI4NjY1IEMxNTEuNjkxNTA0LDEwNi45MTUwMTMgMTUxLjY5NDYzNSwxMDQuMTM0Mjc5IDE0OS45ODE0NjEsMTAyLjQyMTEwNSBMOTQuMDYxNzcwMSw0Ni41MDE0MTQxIEM5Mi42NTczMTA5LDQ1LjA5Njk1NDkgOTAuNTQ1NDIzMSw0NC44NDQ5NDQ1IDg4Ljg4NDM4MTcsNDUuNzM3ODgwNiBMODguODg0MzgxNyw0NS43Mzc4ODA2IFoiIGlkPSJBcnJvdyIgPjwvcGF0aD48cGF0aCBkPSJNOTAsMTcwLjEzODgxMiBDMTM0LjI1OTQ0NCwxNzAuMTM4ODEyIDE3MC4xMzg4MTIsMTM0LjI1OTQ0NCAxNzAuMTM4ODEyLDkwIEMxNzAuMTM4ODEyLDQ1Ljc0MDU1NjIgMTM0LjI1OTQ0NCw5Ljg2MTE4Nzg1IDkwLDkuODYxMTg3ODUgQzQ1Ljc0MDU1NjIsOS44NjExODc4NSA5Ljg2MTE4Nzg1LDQ1Ljc0MDU1NjIgOS44NjExODc4NSw5MCBDOS44NjExODc4NSwxMzQuMjU5NDQ0IDQ1Ljc0MDU1NjIsMTcwLjEzODgxMiA5MCwxNzAuMTM4ODEyIEw5MCwxNzAuMTM4ODEyIEw5MCwxNzAuMTM4ODEyIFogTTAsOTAgQzAsNDAuMjk0MzcyNSA0MC4yOTQzNzI1LDAgOTAsMCBDMTM5LjcwNTYyNywwIDE4MCw0MC4yOTQzNzI1IDE4MCw5MCBDMTgwLDEzOS43MDU2MjcgMTM5LjcwNTYyNywxODAgOTAsMTgwIEM0MC4yOTQzNzI1LDE4MCAwLDEzOS43MDU2MjcgMCw5MCBaIiBpZD0iQ2lyY2xlIj48L3BhdGg+PC9nPjwvZz48L3N2Zz4=";
                },
                9830: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwcHgiIGhlaWdodD0iMTgwcHgiIHZpZXdCb3g9IjAgMCAxODAgMTgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgaWQ9IlBhZ2UtMSIgZmlsbD0ibm9uZSIgdHJhbnNmb3JtPSJyb3RhdGUoMCA5MCw5MCkiPjxnIGlkPSJhcnJvdy11cCIgZmlsbD0iI0ZGRkZGRiI+PHBhdGggZD0iTTg4Ljg4NDM4MTcsNDUuNzM3ODgwNiBDODguMjk5ODg1Myw0NS45NDk3OTE2IDg3Ljc1MTU2OTIsNDYuMjg5OTI5OSA4Ny4yODMwODUzLDQ2Ljc1ODQxMzggTDMxLjM2MzM5NDcsMTAyLjY3ODEwNCBDMjkuNjQ2MDYxNCwxMDQuMzk1NDM4IDI5LjY1MTgzNjMsMTA3LjE3MDQ5OCAzMS4zNjcwMDMxLDEwOC44ODU2NjQgTDQwLjY4Njc0NTMsMTE4LjIwNTQwNyBDNDIuNDAwMzk2NywxMTkuOTE5MDU4IDQ1LjE4MTEzMTMsMTE5LjkyMjE4OSA0Ni44OTQzMDUyLDExOC4yMDkwMTUgTDkwLjgwMDkyNzYsNzQuMzAyMzkyNiBMMTM0LjQ1MDU1LDExNy45NTIwMTUgQzEzNi4xNjc4ODMsMTE5LjY2OTM0OSAxMzguOTQyOTQzLDExOS42NjM1NzQgMTQwLjY1ODExLDExNy45NDg0MDcgTDE0OS45Nzc4NTIsMTA4LjYyODY2NSBDMTUxLjY5MTUwNCwxMDYuOTE1MDEzIDE1MS42OTQ2MzUsMTA0LjEzNDI3OSAxNDkuOTgxNDYxLDEwMi40MjExMDUgTDk0LjA2MTc3MDEsNDYuNTAxNDE0MSBDOTIuNjU3MzEwOSw0NS4wOTY5NTQ5IDkwLjU0NTQyMzEsNDQuODQ0OTQ0NSA4OC44ODQzODE3LDQ1LjczNzg4MDYgTDg4Ljg4NDM4MTcsNDUuNzM3ODgwNiBaIiBpZD0iQXJyb3ciID48L3BhdGg+PHBhdGggZD0iTTkwLDE3MC4xMzg4MTIgQzEzNC4yNTk0NDQsMTcwLjEzODgxMiAxNzAuMTM4ODEyLDEzNC4yNTk0NDQgMTcwLjEzODgxMiw5MCBDMTcwLjEzODgxMiw0NS43NDA1NTYyIDEzNC4yNTk0NDQsOS44NjExODc4NSA5MCw5Ljg2MTE4Nzg1IEM0NS43NDA1NTYyLDkuODYxMTg3ODUgOS44NjExODc4NSw0NS43NDA1NTYyIDkuODYxMTg3ODUsOTAgQzkuODYxMTg3ODUsMTM0LjI1OTQ0NCA0NS43NDA1NTYyLDE3MC4xMzg4MTIgOTAsMTcwLjEzODgxMiBMOTAsMTcwLjEzODgxMiBMOTAsMTcwLjEzODgxMiBaIE0wLDkwIEMwLDQwLjI5NDM3MjUgNDAuMjk0MzcyNSwwIDkwLDAgQzEzOS43MDU2MjcsMCAxODAsNDAuMjk0MzcyNSAxODAsOTAgQzE4MCwxMzkuNzA1NjI3IDEzOS43MDU2MjcsMTgwIDkwLDE4MCBDNDAuMjk0MzcyNSwxODAgMCwxMzkuNzA1NjI3IDAsOTAgWiIgaWQ9IkNpcmNsZSI+PC9wYXRoPjwvZz48L2c+PC9zdmc+";
                },
                4422: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwcHgiIGhlaWdodD0iMTgwcHgiIHZpZXdCb3g9IjAgMCAxODAgMTgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgaWQ9IlBhZ2UtMSIgZmlsbD0ibm9uZSIgdHJhbnNmb3JtPSJyb3RhdGUoMTgwIDkwLDkwKSI+PGcgaWQ9ImFycm93LXVwIiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNODguODg0MzgxNyw0NS43Mzc4ODA2IEM4OC4yOTk4ODUzLDQ1Ljk0OTc5MTYgODcuNzUxNTY5Miw0Ni4yODk5Mjk5IDg3LjI4MzA4NTMsNDYuNzU4NDEzOCBMMzEuMzYzMzk0NywxMDIuNjc4MTA0IEMyOS42NDYwNjE0LDEwNC4zOTU0MzggMjkuNjUxODM2MywxMDcuMTcwNDk4IDMxLjM2NzAwMzEsMTA4Ljg4NTY2NCBMNDAuNjg2NzQ1MywxMTguMjA1NDA3IEM0Mi40MDAzOTY3LDExOS45MTkwNTggNDUuMTgxMTMxMywxMTkuOTIyMTg5IDQ2Ljg5NDMwNTIsMTE4LjIwOTAxNSBMOTAuODAwOTI3Niw3NC4zMDIzOTI2IEwxMzQuNDUwNTUsMTE3Ljk1MjAxNSBDMTM2LjE2Nzg4MywxMTkuNjY5MzQ5IDEzOC45NDI5NDMsMTE5LjY2MzU3NCAxNDAuNjU4MTEsMTE3Ljk0ODQwNyBMMTQ5Ljk3Nzg1MiwxMDguNjI4NjY1IEMxNTEuNjkxNTA0LDEwNi45MTUwMTMgMTUxLjY5NDYzNSwxMDQuMTM0Mjc5IDE0OS45ODE0NjEsMTAyLjQyMTEwNSBMOTQuMDYxNzcwMSw0Ni41MDE0MTQxIEM5Mi42NTczMTA5LDQ1LjA5Njk1NDkgOTAuNTQ1NDIzMSw0NC44NDQ5NDQ1IDg4Ljg4NDM4MTcsNDUuNzM3ODgwNiBMODguODg0MzgxNyw0NS43Mzc4ODA2IFoiIGlkPSJBcnJvdyIgPjwvcGF0aD48cGF0aCBkPSJNOTAsMTcwLjEzODgxMiBDMTM0LjI1OTQ0NCwxNzAuMTM4ODEyIDE3MC4xMzg4MTIsMTM0LjI1OTQ0NCAxNzAuMTM4ODEyLDkwIEMxNzAuMTM4ODEyLDQ1Ljc0MDU1NjIgMTM0LjI1OTQ0NCw5Ljg2MTE4Nzg1IDkwLDkuODYxMTg3ODUgQzQ1Ljc0MDU1NjIsOS44NjExODc4NSA5Ljg2MTE4Nzg1LDQ1Ljc0MDU1NjIgOS44NjExODc4NSw5MCBDOS44NjExODc4NSwxMzQuMjU5NDQ0IDQ1Ljc0MDU1NjIsMTcwLjEzODgxMiA5MCwxNzAuMTM4ODEyIEw5MCwxNzAuMTM4ODEyIEw5MCwxNzAuMTM4ODEyIFogTTAsOTAgQzAsNDAuMjk0MzcyNSA0MC4yOTQzNzI1LDAgOTAsMCBDMTM5LjcwNTYyNywwIDE4MCw0MC4yOTQzNzI1IDE4MCw5MCBDMTgwLDEzOS43MDU2MjcgMTM5LjcwNTYyNywxODAgOTAsMTgwIEM0MC4yOTQzNzI1LDE4MCAwLDEzOS43MDU2MjcgMCw5MCBaIiBpZD0iQ2lyY2xlIj48L3BhdGg+PC9nPjwvZz48L3N2Zz4=";
                },
                8932: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwcHgiIGhlaWdodD0iMTgwcHgiIHZpZXdCb3g9IjAgMCAxODAgMTgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgaWQ9IlBhZ2UtMSIgZmlsbD0ibm9uZSIgdHJhbnNmb3JtPSJyb3RhdGUoNDUgOTAsOTApIj48ZyBpZD0iYXJyb3ctdXAiIGZpbGw9IiNGRkZGRkYiPjxwYXRoIGQ9Ik04OC44ODQzODE3LDQ1LjczNzg4MDYgQzg4LjI5OTg4NTMsNDUuOTQ5NzkxNiA4Ny43NTE1NjkyLDQ2LjI4OTkyOTkgODcuMjgzMDg1Myw0Ni43NTg0MTM4IEwzMS4zNjMzOTQ3LDEwMi42NzgxMDQgQzI5LjY0NjA2MTQsMTA0LjM5NTQzOCAyOS42NTE4MzYzLDEwNy4xNzA0OTggMzEuMzY3MDAzMSwxMDguODg1NjY0IEw0MC42ODY3NDUzLDExOC4yMDU0MDcgQzQyLjQwMDM5NjcsMTE5LjkxOTA1OCA0NS4xODExMzEzLDExOS45MjIxODkgNDYuODk0MzA1MiwxMTguMjA5MDE1IEw5MC44MDA5Mjc2LDc0LjMwMjM5MjYgTDEzNC40NTA1NSwxMTcuOTUyMDE1IEMxMzYuMTY3ODgzLDExOS42NjkzNDkgMTM4Ljk0Mjk0MywxMTkuNjYzNTc0IDE0MC42NTgxMSwxMTcuOTQ4NDA3IEwxNDkuOTc3ODUyLDEwOC42Mjg2NjUgQzE1MS42OTE1MDQsMTA2LjkxNTAxMyAxNTEuNjk0NjM1LDEwNC4xMzQyNzkgMTQ5Ljk4MTQ2MSwxMDIuNDIxMTA1IEw5NC4wNjE3NzAxLDQ2LjUwMTQxNDEgQzkyLjY1NzMxMDksNDUuMDk2OTU0OSA5MC41NDU0MjMxLDQ0Ljg0NDk0NDUgODguODg0MzgxNyw0NS43Mzc4ODA2IEw4OC44ODQzODE3LDQ1LjczNzg4MDYgWiIgaWQ9IkFycm93IiA+PC9wYXRoPjxwYXRoIGQ9Ik05MCwxNzAuMTM4ODEyIEMxMzQuMjU5NDQ0LDE3MC4xMzg4MTIgMTcwLjEzODgxMiwxMzQuMjU5NDQ0IDE3MC4xMzg4MTIsOTAgQzE3MC4xMzg4MTIsNDUuNzQwNTU2MiAxMzQuMjU5NDQ0LDkuODYxMTg3ODUgOTAsOS44NjExODc4NSBDNDUuNzQwNTU2Miw5Ljg2MTE4Nzg1IDkuODYxMTg3ODUsNDUuNzQwNTU2MiA5Ljg2MTE4Nzg1LDkwIEM5Ljg2MTE4Nzg1LDEzNC4yNTk0NDQgNDUuNzQwNTU2MiwxNzAuMTM4ODEyIDkwLDE3MC4xMzg4MTIgTDkwLDE3MC4xMzg4MTIgTDkwLDE3MC4xMzg4MTIgWiBNMCw5MCBDMCw0MC4yOTQzNzI1IDQwLjI5NDM3MjUsMCA5MCwwIEMxMzkuNzA1NjI3LDAgMTgwLDQwLjI5NDM3MjUgMTgwLDkwIEMxODAsMTM5LjcwNTYyNyAxMzkuNzA1NjI3LDE4MCA5MCwxODAgQzQwLjI5NDM3MjUsMTgwIDAsMTM5LjcwNTYyNyAwLDkwIFoiIGlkPSJDaXJjbGUiPjwvcGF0aD48L2c+PC9nPjwvc3ZnPg==";
                },
                3827: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwcHgiIGhlaWdodD0iMTgwcHgiIHZpZXdCb3g9IjAgMCAxODAgMTgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgaWQ9IlBhZ2UtMSIgZmlsbD0ibm9uZSIgdHJhbnNmb3JtPSJyb3RhdGUoOTAgOTAsOTApIj48ZyBpZD0iYXJyb3ctdXAiIGZpbGw9IiNGRkZGRkYiPjxwYXRoIGQ9Ik04OC44ODQzODE3LDQ1LjczNzg4MDYgQzg4LjI5OTg4NTMsNDUuOTQ5NzkxNiA4Ny43NTE1NjkyLDQ2LjI4OTkyOTkgODcuMjgzMDg1Myw0Ni43NTg0MTM4IEwzMS4zNjMzOTQ3LDEwMi42NzgxMDQgQzI5LjY0NjA2MTQsMTA0LjM5NTQzOCAyOS42NTE4MzYzLDEwNy4xNzA0OTggMzEuMzY3MDAzMSwxMDguODg1NjY0IEw0MC42ODY3NDUzLDExOC4yMDU0MDcgQzQyLjQwMDM5NjcsMTE5LjkxOTA1OCA0NS4xODExMzEzLDExOS45MjIxODkgNDYuODk0MzA1MiwxMTguMjA5MDE1IEw5MC44MDA5Mjc2LDc0LjMwMjM5MjYgTDEzNC40NTA1NSwxMTcuOTUyMDE1IEMxMzYuMTY3ODgzLDExOS42NjkzNDkgMTM4Ljk0Mjk0MywxMTkuNjYzNTc0IDE0MC42NTgxMSwxMTcuOTQ4NDA3IEwxNDkuOTc3ODUyLDEwOC42Mjg2NjUgQzE1MS42OTE1MDQsMTA2LjkxNTAxMyAxNTEuNjk0NjM1LDEwNC4xMzQyNzkgMTQ5Ljk4MTQ2MSwxMDIuNDIxMTA1IEw5NC4wNjE3NzAxLDQ2LjUwMTQxNDEgQzkyLjY1NzMxMDksNDUuMDk2OTU0OSA5MC41NDU0MjMxLDQ0Ljg0NDk0NDUgODguODg0MzgxNyw0NS43Mzc4ODA2IEw4OC44ODQzODE3LDQ1LjczNzg4MDYgWiIgaWQ9IkFycm93IiA+PC9wYXRoPjxwYXRoIGQ9Ik05MCwxNzAuMTM4ODEyIEMxMzQuMjU5NDQ0LDE3MC4xMzg4MTIgMTcwLjEzODgxMiwxMzQuMjU5NDQ0IDE3MC4xMzg4MTIsOTAgQzE3MC4xMzg4MTIsNDUuNzQwNTU2MiAxMzQuMjU5NDQ0LDkuODYxMTg3ODUgOTAsOS44NjExODc4NSBDNDUuNzQwNTU2Miw5Ljg2MTE4Nzg1IDkuODYxMTg3ODUsNDUuNzQwNTU2MiA5Ljg2MTE4Nzg1LDkwIEM5Ljg2MTE4Nzg1LDEzNC4yNTk0NDQgNDUuNzQwNTU2MiwxNzAuMTM4ODEyIDkwLDE3MC4xMzg4MTIgTDkwLDE3MC4xMzg4MTIgTDkwLDE3MC4xMzg4MTIgWiBNMCw5MCBDMCw0MC4yOTQzNzI1IDQwLjI5NDM3MjUsMCA5MCwwIEMxMzkuNzA1NjI3LDAgMTgwLDQwLjI5NDM3MjUgMTgwLDkwIEMxODAsMTM5LjcwNTYyNyAxMzkuNzA1NjI3LDE4MCA5MCwxODAgQzQwLjI5NDM3MjUsMTgwIDAsMTM5LjcwNTYyNyAwLDkwIFoiIGlkPSJDaXJjbGUiPjwvcGF0aD48L2c+PC9nPjwvc3ZnPg==";
                },
                3009: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE4IDE3di44NjRjMCAuNTA1IDAgLjk5Ni0uMDM0IDEuNDEyLS4wMzcuNDU4LS4xMjUuOTk3LS40MDIgMS41NGE0IDQgMCAwIDEtMS43NDggMS43NDhjLS41NDMuMjc3LTEuMDgyLjM2NS0xLjU0LjQwMi0uNDE2LjAzNC0uOTA3LjAzNC0xLjQxMi4wMzRINi4xMzZjLS41MDUgMC0uOTk2IDAtMS40MTItLjAzNC0uNDU4LS4wMzctLjk5Ny0uMTI1LTEuNTQtLjQwMmE0IDQgMCAwIDEtMS43NDgtMS43NDhjLS4yNzctLjU0My0uMzY1LTEuMDgyLS40MDItMS41NEExOC4zNiAxOC4zNiAwIDAgMSAxIDE3Ljg2NHYtNi43MjhjMC0uNTA1IDAtLjk5Ni4wMzQtMS40MTIuMDM3LS40NTguMTI1LS45OTcuNDAyLTEuNTRhNCA0IDAgMCAxIDEuNzQ4LTEuNzQ4Yy41NDMtLjI3NyAxLjA4Mi0uMzY1IDEuNTQtLjQwMkM1LjE0IDYgNS42MyA2IDYuMTM2IDZIN3YyaC0uOGMtMS4xMiAwLTEuNjggMC0yLjEwOC4yMThhMiAyIDAgMCAwLS44NzQuODc0QzMgOS41MiAzIDEwLjA4IDMgMTEuMnY2LjZjMCAxLjEyIDAgMS42OC4yMTggMi4xMDhhMiAyIDAgMCAwIC44NzQuODc0QzQuNTIgMjEgNS4wOCAyMSA2LjIgMjFoNi42YzEuMTIgMCAxLjY4IDAgMi4xMDgtLjIxOGEyIDIgMCAwIDAgLjg3NC0uODc0QzE2IDE5LjQ4IDE2IDE4LjEyIDE2IDE3aDJ6TTE2LjUxIDcuMjM2djMuNzFoLjc4YzEuMDk0IDAgMS42Ny0uNTYzIDEuNjctMS44NiAwLTEuMjkzLS41NzYtMS44NS0xLjY2Ny0xLjg1aC0uNzg0eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNy4zMjcgMi42MzhDNyAzLjI4IDcgNC4xMiA3IDUuOHY2LjRjMCAxLjY4IDAgMi41Mi4zMjcgMy4xNjJhMyAzIDAgMCAwIDEuMzExIDEuMzExQzkuMjggMTcgMTAuMTIgMTcgMTEuOCAxN2g2LjRjMS42OCAwIDIuNTIgMCAzLjE2Mi0uMzI3YTMgMyAwIDAgMCAxLjMxMS0xLjMxMUMyMyAxNC43MiAyMyAxMy44OCAyMyAxMi4yVjUuOGMwLTEuNjggMC0yLjUyLS4zMjctMy4xNjJhMyAzIDAgMCAwLTEuMzExLTEuMzExQzIwLjcyIDEgMTkuODggMSAxOC4yIDFoLTYuNGMtMS42OCAwLTIuNTIgMC0zLjE2Mi4zMjdhMyAzIDAgMCAwLTEuMzExIDEuMzExem03LjAzNCA3LjcyOWMuMDAzLjk5NC0uOTMyIDEuNzEyLTIuMjM5IDEuNzEyLTEuMjc4IDAtMi4xODctLjcwNy0yLjIwNy0xLjcyNGgxLjIzOGMuMDIzLjQyNi40My43MS45NzIuNzEuNTYzIDAgLjk2LS4zMTguOTU3LS43OC4wMDMtLjQ3LS40MDktLjgtMS4wNjgtLjhoLS41NDJ2LS45MDNoLjU0MmMuNTYgMCAuOTUtLjMxLjk0Ni0uNzY3LjAwMy0uNDM3LS4zMy0uNzM4LS44MjctLjczOC0uNTAyIDAtLjkwOS4yODctLjkyMy43M2gtMS4xNzljLjAxNy0xLjAwNi45MTUtMS43MDUgMi4xMDgtMS43MDUgMS4yMDUgMCAyLjAwOS43MjIgMi4wMDYgMS42NC4wMDMuNjUzLS40NDYgMS4xMTMtMS4wOTcgMS4yM3YuMDQ1Yy44NTUuMTA4IDEuMzE2LjYyNSAxLjMxMyAxLjM1em01LjgyNy0xLjI4MmMwIDEuODE4LTEuMDc0IDIuOTE1LTIuODQ2IDIuOTE1aC0yLjA2M1Y2LjE4MmgyLjA4YzEuNzU1IDAgMi44MyAxLjA5IDIuODMgMi45MDN6IiBmaWxsPSIjZmZmIi8+PC9zdmc+";
                },
                6532: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEzLjM0NSAxMC4yMzZ2My43MWguNzgxYzEuMDk0IDAgMS42Ny0uNTYzIDEuNjctMS44NiAwLTEuMjkzLS41NzYtMS44NS0xLjY2Ny0xLjg1aC0uNzg0eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNC4zMjcgNS42MzhDNCA2LjI4IDQgNy4xMiA0IDguOHY2LjRjMCAxLjY4IDAgMi41Mi4zMjcgMy4xNjJhMyAzIDAgMCAwIDEuMzExIDEuMzExQzYuMjggMjAgNy4xMiAyMCA4LjggMjBoNi40YzEuNjggMCAyLjUyIDAgMy4xNjItLjMyN2EzIDMgMCAwIDAgMS4zMTEtMS4zMTFDMjAgMTcuNzIgMjAgMTYuODggMjAgMTUuMlY4LjhjMC0xLjY4IDAtMi41Mi0uMzI3LTMuMTYyYTMgMyAwIDAgMC0xLjMxMS0xLjMxMUMxNy43MiA0IDE2Ljg4IDQgMTUuMiA0SDguOGMtMS42OCAwLTIuNTIgMC0zLjE2Mi4zMjdhMyAzIDAgMCAwLTEuMzExIDEuMzExek0xMS4xODcgMTVINy4wNHYtLjg4NmwyLjA3LTEuOTE4Yy41MTgtLjUuODEtLjgyNy44MTMtMS4yOS0uMDAzLS41MTEtLjM4OS0uODMtLjkwMy0uODMtLjUzNCAwLS44OTguMzM5LS44OTguODk4SDYuOTU1Yy0uMDAzLTEuMTQyLjg1NS0xLjg3MiAyLjA3My0xLjg3MiAxLjI1NiAwIDIuMDQ2Ljc4MiAyLjA1MSAxLjc5LjAwMy43NDQtLjM4NiAxLjI5My0xLjQxMSAyLjIzbC0uODU1LjgzMnYuMDRoMi4zNzRWMTV6bTUuODM3LTIuOTE1YzAgMS44MTgtMS4wNzQgMi45MTUtMi44NDYgMi45MTVoLTIuMDYzVjkuMTgyaDIuMDhjMS43NTUgMCAyLjgzIDEuMDkgMi44MyAyLjkwM3oiIGZpbGw9IiNmZmYiLz48L3N2Zz4gIA==";
                },
                2366: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8dGl0bGU+CiAgICAgIGZhc3QKICAgIDwvdGl0bGU+CiAgICA8ZGVmcz4KICAgICAgPHBhdGggZD0iTTIwLjE0ODQgMTMuNWMtMi4xNTE3IDAtMi41NDc4Ljg2Mi0zLjU2NzYgMS4zNjA1LTEuODUzMy45MDYtMy4wOTkzIDIuMDcyNi0zLjA5OTMgNC4yNjQ1IDAgMS4xNjE0LS4wMTAzIDEuODc1LS4zNzAzIDEuODc1LS42NTc1IDAtLjk5MzgtLjY5MS0xLjI5ODgtMS4yMi0uMjA4Mi4wNjktLjQyNjcuMTAxMi0uNjQ1Ny4wOTUtLjg0MzcgMC01LjQ2My0xLjY4NjctNS40NjMtMi42MjUgMC0uNTUxLjM3MDMtLjg0Ny4zNzAzLTEuNXYtLjAxYy0uMDE2NS0uNTUzNC0uMjg2Ny0xLjA2NzMtLjczMDgtMS4zOS0uNTk0My0uNDMwNS0xLjA0NC0xLjAzNS0xLjI4ODItMS43MzIzLS4xNzkyLjA4NjMtLjM3NS4xMzE1LS41NzM1LjEzMjNDMi43NzA1IDEyLjc1IDIgMTEuODczIDIgMTAuNWMwLTEuMzY5NC4yNjYtMS44NzUuNTU1Ni0xLjg3NS4zNzU0IDAgLjQ2My4xODc1LjQ2My4xODc1cy4yNTY4LS45NDEuNzc5OC0uOTQxYy4yNzEyLjAwMzcuNTE3Ny4xNjAyLjYzOS40MDU3Ljg4MDItMS4wMDk3IDIuMTU5LTEuNTY5NiAzLjQ4ODQtMS41MjcyIDUuMzcyIDAgNS43Mjk3IDMuMzc1IDcuNDA3NSAzLjM3NS42MjE0IDAgMS4xMTEtLjg5MjcgMS4xMTEtMS4xMjUgMC0uNzIwNi0zLjMzMzMtMi4wNzU3LTMuMzMzMy01LjI1IDAtLjQ5Ni4zOTM1LS43NS45MjYtLjc1LjQ2MyAwIDEuNDUxMy42MTA0IDIuMDM3IDEuNS44OTUgMS4zNTk0Ljc1OSAzIDEuODUyIDMuNzUuNDA5LjI4MDggMS40NTE4LjI2MDMgMi4yMjIuNzUuNzcwNS40ODk3IDEuMjQ2NCAxLjMwMjcgMS40ODE2IDEuNS4yMTcuMTkwMy4zNTAyLjQ2LjM3MDQuNzUgMCAuMzYxMy0uODA1MyAyLjI1LTEuODUxNiAyLjI1em0tOC44ODkgM2MtLjk5MDctLjAxODgtMS45NjY1LS4yNDg0LTIuODY0LS42NzM4LS4wNTkyLjIxOTgtLjA5MjUuNDQ2LS4wOTkuNjczOCAwIC42MjczLjQ3OTcuODY4IDIuMjIyIDEuNS4zOTE2LjEzNC43Njk3LjMwNTIgMS4xMjkzLjUxMTMuMDQwNC0uNjgzLjExNTQtMS4zNjMyLjIyNS0yLjAzODMtLjIwMDQuMDE0My0uNDAyMi4wMjctLjYxMzMuMDI3eiIgaWQ9ImEiLz4KICAgIDwvZGVmcz4KICAgIDx1c2UgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJub256ZXJvIiB4bGluazpocmVmPSIjYSIvPgogIDwvc3ZnPg==";
                },
                7678: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgPHRpdGxlPgogICAgZmFzdAogIDwvdGl0bGU+CiAgPGRlZnM+CiAgICA8cGF0aCBkPSJNMjAuMTQ4NCAxMy41Yy0yLjE1MTcgMC0yLjU0NzguODYyLTMuNTY3NiAxLjM2MDUtMS44NTMzLjkwNi0zLjA5OTMgMi4wNzI2LTMuMDk5MyA0LjI2NDUgMCAxLjE2MTQtLjAxMDMgMS44NzUtLjM3MDMgMS44NzUtLjY1NzUgMC0uOTkzOC0uNjkxLTEuMjk4OC0xLjIyLS4yMDgyLjA2OS0uNDI2Ny4xMDEyLS42NDU3LjA5NS0uODQzNyAwLTUuNDYzLTEuNjg2Ny01LjQ2My0yLjYyNSAwLS41NTEuMzcwMy0uODQ3LjM3MDMtMS41di0uMDFjLS4wMTY1LS41NTM0LS4yODY3LTEuMDY3My0uNzMwOC0xLjM5LS41OTQzLS40MzA1LTEuMDQ0LTEuMDM1LTEuMjg4Mi0xLjczMjMtLjE3OTIuMDg2My0uMzc1LjEzMTUtLjU3MzUuMTMyM0MyLjc3MDUgMTIuNzUgMiAxMS44NzMgMiAxMC41YzAtMS4zNjk0LjI2Ni0xLjg3NS41NTU2LTEuODc1LjM3NTQgMCAuNDYzLjE4NzUuNDYzLjE4NzVzLjI1NjgtLjk0MS43Nzk4LS45NDFjLjI3MTIuMDAzNy41MTc3LjE2MDIuNjM5LjQwNTcuODgwMi0xLjAwOTcgMi4xNTktMS41Njk2IDMuNDg4NC0xLjUyNzIgNS4zNzIgMCA1LjcyOTcgMy4zNzUgNy40MDc1IDMuMzc1LjYyMTQgMCAxLjExMS0uODkyNyAxLjExMS0xLjEyNSAwLS43MjA2LTMuMzMzMy0yLjA3NTctMy4zMzMzLTUuMjUgMC0uNDk2LjM5MzUtLjc1LjkyNi0uNzUuNDYzIDAgMS40NTEzLjYxMDQgMi4wMzcgMS41Ljg5NSAxLjM1OTQuNzU5IDMgMS44NTIgMy43NS40MDkuMjgwOCAxLjQ1MTguMjYwMyAyLjIyMi43NS43NzA1LjQ4OTcgMS4yNDY0IDEuMzAyNyAxLjQ4MTYgMS41LjIxNy4xOTAzLjM1MDIuNDYuMzcwNC43NSAwIC4zNjEzLS44MDUzIDIuMjUtMS44NTE2IDIuMjV6bS04Ljg4OSAzYy0uOTkwNy0uMDE4OC0xLjk2NjUtLjI0ODQtMi44NjQtLjY3MzgtLjA1OTIuMjE5OC0uMDkyNS40NDYtLjA5OS42NzM4IDAgLjYyNzMuNDc5Ny44NjggMi4yMjIgMS41LjM5MTYuMTM0Ljc2OTcuMzA1MiAxLjEyOTMuNTExMy4wNDA0LS42ODMuMTE1NC0xLjM2MzIuMjI1LTIuMDM4My0uMjAwNC4wMTQzLS40MDIyLjAyNy0uNjEzMy4wMjd6IiBpZD0iYSIvPgogIDwvZGVmcz4KICA8dXNlIGZpbGw9IiNEN0RBREQiIGZpbGwtcnVsZT0ibm9uemVybyIgeGxpbms6aHJlZj0iI2EiLz4KPC9zdmc+";
                },
                7326: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlPiAgc2xvdzwvdGl0bGU+PGRlZnM+ICA8cGF0aCBkPSJNMTguOTMzNyAxMy4yMjIybC0uNzgxNiAxLjg5NjNjLjMzMTcuMjUwMyAxLjMzNSAxLjEwMDIgMS4zMzUgMi4yNTE2LS4wMjIzLjMxMy0uMTU4LjYwNy0uMzgxNi44MjctLjA3NjguMDgwMy0uMTgzNC4xMjU0LS4yOTQ2LjEyNDNoLTIuNjU4Yy0uMTQ1MiAwLS4yNzk2LS4wNzY3LS4zNTM0LS4yMDE3bC0uNzEzNi0xLjIwNzRjLS4xMjAyLS4yMDM3LS4xNDY4LS40NDkyLS4wNzMtLjY3NGwuMTI0OC0uMzgwNUg3LjRjLjM2MS40MjM0LjU2ODguOTU2My41ODk4IDEuNTEyNS0uMDIyLjMxMy0uMTU3Ny42MDctLjM4MTMuODI2Ny0uMDc2Ny4wODA0LS4xODM0LjEyNTUtLjI5NDYuMTI0NEg0LjY1NmMtLjE0NTIgMC0uMjc5Ni0uMDc2Ny0uMzUzNS0uMjAxN2wtLjcxMzYtMS4yMDc1Yy0uMTIwNC0uMjAzNi0uMTQ3LS40NDkyLS4wNzMyLS42NzRsLjAwODItLjAyNDZjLS42MjkuNDgzMi0xLjM4NC43NzQ3LTIuMTc0My44Mzk2LS4xMTk3LjAxNzYtLjIzODUtLjAzNzItLjMwMy0uMTM5Ny0uMDY0My0uMTAyNS0uMDYyLS4yMzM0LjAwNTctLjMzMzdDMy40MjQ2IDEzLjQwMTUgMi43MDggNi4wMDIyIDExLjMxMyA2LjAwMjJjMi42OTQ1LS4wNTkgNS4yNzU1IDEuMDg1IDcuMDQxNyAzLjEyMTcuNzg2LS4yNDIyIDEuNDY1LS43NDY3IDEuOTI0Mi0xLjQyOTIuMzUzLS40NTM0Ljk3MjQtLjYwMyAxLjQ5MzUtLjM2MDdsMS45ODg3LjkyNWMuMTY0NS4wNzYzLjI1OTguMjUxLjIzNS40MzA4LS4yMDI1IDEuNDU1NC0xLjc4ODYgMy43NjYyLTUuMDYyNSA0LjUzMjR6IiBpZD0iYSIvPjwvZGVmcz48dXNlIGZpbGw9IiNGRkYiIGZpbGwtcnVsZT0ibm9uemVybyIgeGxpbms6aHJlZj0iI2EiLz4gIDwvc3ZnPiAg";
                },
                2574: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI2MSIgaGVpZ2h0PSIxNCIgdmlld0JveD0iMCAwIDYxIDE0Ij48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgPHBhdGggZmlsbD0iI0ZGRiIgZD0iTTIzLjk5NDgzMDMgMi44MTQ1MjI4NUwyMy45OTQ4MzAzIDExLjMxMzg1MyAyMi4zNzA4NjM3IDExLjMxMzg1MyAyMi4zNzA4NjM3IDYuODkyMjM2MTQgMjAuNTQzOTAxMiAxMS4zMTM4NTMgMTkuNjYwMjcyNCAxMS4zMTM4NTMgMTcuODMzMzA5OSA2Ljg5MjIzNjE0IDE3LjgzMzMwOTkgMTEuMzEzODUzIDE2LjIwOTM0MzMgMTEuMzEzODUzIDE2LjIwOTM0MzMgMi44MTQ1MjI4NSAxNy44ODEwNzM3IDIuODE0NTIyODUgMjAuMTAyMDg2OCA4LjE2OTU5MjExIDIyLjMyMzEgMi44MTQ1MjI4NSAyMy45OTQ4MzAzIDIuODE0NTIyODUgMjMuOTk0ODMwMyAyLjgxNDUyMjg1ek0zMS4wODE5NTg0IDQuNjY5MTQ1NDZMMzIuNTAyOTI5MiA0LjY2OTE0NTQ2IDMyLjUwMjkyOTIgNS4yMjE4NDc1NkMzMi41OTg0NTcyIDUuMDI1MzMwMjggMzIuNzg5NTEwMSA0Ljg1NzQ3NDI4IDMzLjA3NjA5MzkgNC43MTgyNzQ1MyAzMy4zNjI2Nzc3IDQuNTc5MDc0NzkgMzMuNjc3MTE5MSA0LjUwOTQ3NTk2IDM0LjAxOTQyNzUgNC41MDk0NzU5NiAzNC4zNDU4MTQ1IDQuNTA5NDc1OTYgMzQuNjUyMjk1NCA0LjU4NTIxNTg2IDM0LjkzODg3OTEgNC43MzY2OTc5NCAzNS4yMjU0NjI5IDQuODg4MTgwMDEgMzUuNDc0MjI5OCA1LjExMTMwNTY3IDM1LjY4NTE4NzMgNS40MDYwODE2IDM1Ljg5NjE0NDggNS43MDA4NTc1MiAzNi4wNjMzMTYyIDYuMDY1MjI3ODYgMzYuMTg2NzA2NCA2LjQ5OTIwMzUzIDM2LjMxMDA5NjYgNi45MzMxNzkyIDM2LjM3MTc5MDggNy40Mjg1NTkxIDM2LjM3MTc5MDggNy45ODUzNTgwNyAzNi4zNzE3OTA4IDguNTU4NTMzNDkgMzYuMzEyMDg2OCA5LjA2MjEwMTQ4IDM2LjE5MjY3NjkgOS40OTYwNzcxNSAzNi4wNzMyNjcgOS45MzAwNTI4MiAzNS45MTAwNzU5IDEwLjI5NDQyMzIgMzUuNzAzMDk4NyAxMC41ODkxOTkxIDM1LjQ5NjEyMTUgMTAuODgzOTc1IDM1LjI1MTMzNDkgMTEuMTA1MDUzNiAzNC45Njg3MzE1IDExLjI1MjQ0MTYgMzQuNjg2MTI4IDExLjM5OTgyOTYgMzQuMzc3NjU3MSAxMS40NzM1MjI1IDM0LjA0MzMwOTMgMTEuNDczNTIyNSAzMy42ODUwNzk2IDExLjQ3MzUyMjUgMzMuMzk2NTEgMTEuNDE2MjA1OCAzMy4xNzc1OTE4IDExLjMwMTU3MDcgMzIuOTU4NjczNyAxMS4xODY5MzU2IDMyLjgwMTQ1MyAxMS4wNDM2NDM5IDMyLjcwNTkyNTEgMTAuODcxNjkxM0wzMi43MDU5MjUxIDEzLjUyMDU0MjMgMzEuMDgxOTU4NCAxMy44Nzg3ODc2IDMxLjA4MTk1ODQgNC42NjkxNDU0NiAzMS4wODE5NTg0IDQuNjY5MTQ1NDZ6TTMzLjYzNzMxNzcgOS44ODkxMDk3NkMzNC40MjU0MjMgOS44ODkxMDk3NiAzNC44MTk0Njk4IDkuMjU4NjI2MjYgMzQuODE5NDY5OCA3Ljk5NzY0MDM0IDM0LjgxOTQ2OTggNy4zODM1MjM4MiAzNC43MjE5NTMyIDYuOTE2ODAyMjcgMzQuNTI2OTE3IDYuNTk3NDYxNjggMzQuMzMxODgwOCA2LjI3ODEyMTA5IDM0LjA1MTI3MTggNi4xMTg0NTMxOSAzMy42ODUwODE0IDYuMTE4NDUzMTkgMzMuNDE0NDE4OSA2LjExODQ1MzE5IDMzLjE4OTUzMzYgNi4yMTQ2NjMzNCAzMy4wMTA0MTg4IDYuNDA3MDg2NTEgMzIuODMxMzAzOSA2LjU5OTUwOTY5IDMyLjY5Mzk4NDYgNi44MjY3MjkzOSAzMi41OTg0NTY3IDcuMDg4NzUyNDRMMzIuNTk4NDU2NyA4Ljk4MDIyMTg2QzMyLjcwOTkwNTkgOS4yODMxODYgMzIuODU5MTY2MSA5LjUxMDQwNTcxIDMzLjA0NjI0MTYgOS42NjE4ODc3OCAzMy4yMzMzMTcxIDkuODEzMzY5ODYgMzMuNDMwMzQwNSA5Ljg4OTEwOTc2IDMzLjYzNzMxNzcgOS44ODkxMDk3NkwzMy42MzczMTc3IDkuODg5MTA5NzYgMzMuNjM3MzE3NyA5Ljg4OTEwOTc2ek0zOC43MTIyMTMzIDQuNjY5MTQ1NDZMMzguNzEyMjEzMyAxMS4zMTM4NTMgMzcuMDc2MzA1OCAxMS4zMTM4NTMgMzcuMDc2MzA1OCA0LjY2OTE0NTQ2IDM4LjcxMjIxMzMgNC42NjkxNDU0NiAzOC43MTIyMTMzIDQuNjY5MTQ1NDZ6TTM3LjA3NjMwNTggMy4xOTUyNzMxOUMzNy4wNzYzMDU4IDIuOTU3ODE0OCAzNy4xNTE5MzA5IDIuNzUzMTEyMzYgMzcuMzAzMTgzNSAyLjU4MTE1OTc0IDM3LjQ1NDQzNiAyLjQwOTIwNzExIDM3LjY0OTQ2OTMgMi4zMjMyMzIwOSAzNy44ODgyODkxIDIuMzIzMjMyMDkgMzguMTExMTg3NiAyLjMyMzIzMjA5IDM4LjMwNDIzMDcgMi40MDkyMDcxMSAzOC40Njc0MjQyIDIuNTgxMTU5NzQgMzguNjMwNjE3OCAyLjc1MzExMjM2IDM4LjcxMjIxMzMgMi45NTc4MTQ4IDM4LjcxMjIxMzMgMy4xOTUyNzMxOSAzOC43MTIyMTMzIDMuNDI0NTQzMzUgMzguNjMwNjE3OCAzLjYxOTAxMDY3IDM4LjQ2NzQyNDIgMy43Nzg2ODA5NiAzOC4zMDQyMzA3IDMuOTM4MzUxMjYgMzguMTExMTg3NiA0LjAxODE4NTIxIDM3Ljg4ODI4OTEgNC4wMTgxODUyMSAzNy42NDk0NjkzIDQuMDE4MTg1MjEgMzcuNDU0NDM2IDMuOTM4MzUxMjYgMzcuMzAzMTgzNSAzLjc3ODY4MDk2IDM3LjE1MTkzMDkgMy42MTkwMTA2NyAzNy4wNzYzMDU4IDMuNDI0NTQzMzUgMzcuMDc2MzA1OCAzLjE5NTI3MzE5TDM3LjA3NjMwNTggMy4xOTUyNzMxOSAzNy4wNzYzMDU4IDMuMTk1MjczMTl6TTM5LjU2MDAxOTQgMi45MjUwNjMyN0w0MS4xODM5ODYgMi4zNjAwNzg5IDQxLjE4Mzk4NiAxMS4zMTM4NTMgMzkuNTYwMDE5NCAxMS4zMTM4NTMgMzkuNTYwMDE5NCAyLjkyNTA2MzI3IDM5LjU2MDAxOTQgMi45MjUwNjMyN3pNNDIuMDMxNzkyMSAyLjkyNTA2MzI3TDQzLjY1NTc1ODcgMi4zNjAwNzg5IDQzLjY1NTc1ODcgMTEuMzEzODUzIDQyLjAzMTc5MjEgMTEuMzEzODUzIDQyLjAzMTc5MjEgMi45MjUwNjMyNyA0Mi4wMzE3OTIxIDIuOTI1MDYzMjd6TTUyLjQ2Nzg0OTEgNC42NjkxNDU0Nkw1Mi40Njc4NDkxIDUuMTIzNTg5NDFDNTIuNTc5Mjk4MyA0LjkzNTI2MDM0IDUyLjc2MjM5MDggNC43ODU4Mjc1NyA1My4wMTcxMzE5IDQuNjc1Mjg2NTkgNTMuMjcxODczMSA0LjU2NDc0NTYyIDUzLjUzODU1MTIgNC41MDk0NzU5NiA1My44MTcxNzQzIDQuNTA5NDc1OTYgNTQuMDAwMjY5NSA0LjUwOTQ3NTk2IDU0LjE3NzM5MTUgNC41MzgxMzQzIDU0LjM0ODU0NTcgNC41OTU0NTE4NSA1NC41MTk2OTk5IDQuNjUyNzY5MzkgNTQuNjUzMDM5IDQuNzQ2OTMyNTEgNTQuNzQ4NTY2OSA0Ljg3Nzk0NDAzTDU0LjE2MzQ2MTMgNi4zNjQwOTg1N0M1My45NjQ0NDQ4IDYuMTgzOTU3NzMgNTMuNzQ1NTI5OSA2LjA5Mzg4ODY2IDUzLjUwNjcxMDEgNi4wOTM4ODg2NiA1My4zMDc2OTM2IDYuMDkzODg4NjYgNTMuMTI2NTkxMyA2LjE2OTYyODU2IDUyLjk2MzM5NzcgNi4zMjExMTA2MyA1Mi44MDAyMDQyIDYuNDcyNTkyNzEgNTIuNjY2ODY1MSA2LjcwODAwMDUxIDUyLjU2MzM3NjUgNy4wMjczNDExTDUyLjU2MzM3NjUgMTEuMzEzODUzIDUwLjkzOTQwOTkgMTEuMzEzODUzIDUwLjkzOTQwOTkgNC42NjkxNDU0NiA1Mi40Njc4NDkxIDQuNjY5MTQ1NDYgNTIuNDY3ODQ5MSA0LjY2OTE0NTQ2ek00OC40NjE2MDg4IDEwLjgyOTMxOTJDNDguMDI4ODg4MiAxMS4yMTU4NzI0IDQ3LjUyNDc0MDUgMTEuNDg0MTExIDQ2Ljk4NjY2NzQgMTEuNDg0MTExIDQ1LjEyMzA5NDEgMTEuNDg0MTExIDQ0LjM0MTk0NzMgOS45MjgwNTIxIDQ0LjM0MTk0NzMgOC4wMDg1NTYxNiA0NC4zNDE5NDczIDYuMDg5MDYwMjMgNDUuMTIzMDk0MSA0LjUzMzAwMTMzIDQ2Ljk4NjY2NzQgNC41MzMwMDEzMyA0Ny41NjU5MDA3IDQuNTMzMDAxMzMgNDguMDU4MTgzNSA0Ljc4MzA1OTI5IDQ4LjQ2MTYwODggNS4xNTg1MTc4Mkw0OC40NjE2MDg4IDQuNjIzMDg3MTcgNTAuMTE2NTEzOSA0LjYyMzA4NzE3IDUwLjExNjUxMzkgMTEuMzk0MDI1MiA0OC40NjE2MDg4IDExLjM5NDAyNTIgNDguNDYxNjA4OCAxMC44MjkzMTkyIDQ4LjQ2MTYwODggMTAuODI5MzE5MnpNNDguNDYxNjA4OCA5LjE1MTIyMDIxQzQ4LjI1NDM5MjQgOS42MTI3NDY0MyA0Ny44ODgwNjAxIDkuOTAwOTc4NTIgNDcuMzU4NTk4MyA5LjkxMDM5ODE0IDQ2LjM1NzM2OTUgOS45MjgyMTA5MyA0NS45NzMyNTE2IDkuMDgwNTg1NDcgNDUuOTU1MjA2MSA4LjAyNjg3Nzc4IDQ1LjkzNzE2MDcgNi45NzMxNzAwOSA0Ni4yOTIwMjEyIDYuMTEyMzk3NzMgNDcuMjkzMjUgNi4wOTQ1ODUwNiA0Ny44MDk0MTU2IDYuMDg1NDAyMDUgNDguMjI3OTIyMiA2LjQyMTYyMDk0IDQ4LjQ2MTYwODggNi45NjI1MjM2TDQ4LjQ2MTYwODggOS4xNTEyMjAyMSA0OC40NjE2MDg4IDkuMTUxMjIwMjF6TTI4Ljc4NjM2ODkgMTAuODI5MzE5MkMyOC4zNTM2NDg0IDExLjIxNTg3MjQgMjcuODQ5NTAwNyAxMS40ODQxMTEgMjcuMzExNDI3NiAxMS40ODQxMTEgMjUuNDQ3ODU0MiAxMS40ODQxMTEgMjQuNjY2NzA3NSA5LjkyODA1MjEgMjQuNjY2NzA3NSA4LjAwODU1NjE2IDI0LjY2NjcwNzUgNi4wODkwNjAyMyAyNS40NDc4NTQyIDQuNTMzMDAxMzMgMjcuMzExNDI3NiA0LjUzMzAwMTMzIDI3Ljg5MDY2MDkgNC41MzMwMDEzMyAyOC4zODI5NDM2IDQuNzgzMDU5MjkgMjguNzg2MzY4OSA1LjE1ODUxNzgyTDI4Ljc4NjM2ODkgNC42MjMwODcxNyAzMC40NDEyNzQgNC42MjMwODcxNyAzMC40NDEyNzQgMTEuMzk0MDI1MiAyOC43ODYzNjg5IDExLjM5NDAyNTIgMjguNzg2MzY4OSAxMC44MjkzMTkyIDI4Ljc4NjM2ODkgMTAuODI5MzE5MiAyOC43ODYzNjg5IDEwLjgyOTMxOTJ6TTI4Ljc4NjM2ODkgOS4xNTEyMjAyMUMyOC41NzkxNTI2IDkuNjEyNzQ2NDMgMjguMjEyODIwMiA5LjkwMDk3ODUyIDI3LjY4MzM1ODQgOS45MTAzOTgxNCAyNi42ODIxMjk2IDkuOTI4MjEwOTMgMjYuMjk4MDExNyA5LjA4MDU4NTQ3IDI2LjI3OTk2NjMgOC4wMjY4Nzc3OCAyNi4yNjE5MjA4IDYuOTczMTcwMDkgMjYuNjE2NzgxMyA2LjExMjM5NzczIDI3LjYxODAxMDEgNi4wOTQ1ODUwNiAyOC4xMzQxNzU3IDYuMDg1NDAyMDUgMjguNTUyNjgyNCA2LjQyMTYyMDk0IDI4Ljc4NjM2ODkgNi45NjI1MjM2TDI4Ljc4NjM2ODkgOS4xNTEyMjAyMSAyOC43ODYzNjg5IDkuMTUxMjIwMjEgMjguNzg2MzY4OSA5LjE1MTIyMDIxek01Ny43NDU1ODIzIDEzLjY3MjA0ODZMNTYuMDQ5OTcwMSAxMy42NzIwNDg2IDU3LjA2NDk0OTIgMTAuNzM2NTg2MyA1NC45Mzk0NjM1IDQuNjY5MTQ1NDYgNTYuNzMwNjAzMSA0LjY2OTE0NTQ2IDU3LjkzNjYzNzIgOC41MjU3Nzc5MSA1OS4xNDI2NzEyIDQuNjY5MTQ1NDYgNjAuODk3OTg4IDQuNjY5MTQ1NDYgNTcuNzQ1NTgyMyAxMy42NzIwNDg2IDU3Ljc0NTU4MjMgMTMuNjcyMDQ4NnpNNi4zODE1NDI3NCA5LjY1MDUwNjdDNi4xNDAwNzQxMiA5LjUyNzg2NDA0IDYuMDgxMjQwMDYgOS4zMTcwOTQ1MyA2LjIxMDQ0MDM3IDkuMDg4NjU1NjUgNi4yNzYxNDk0MSA4Ljk3MjQ3NTYxIDYuNDE4NTkyMzQgOC43NDA3NDQyMiA2LjUzNDY4MTY4IDguNTUzOTgyMiA2LjY5NDMyNzI0IDguMjk3MTQ3ODYgNi45MjcwMTQzNCA4LjI5NjM3NTg4IDcuMDU4MzU4NjYgOC4zNzI1MzM2MiA3LjE4OTcwMjk4IDguNDQ4NjkxMzUgOS4wNDg1MzYwNCA5LjQyMDg3MDYzIDkuMTY4NzQ4NzEgOS40ODY3MDY1NiA5LjQ1MjU5MjYgOS42NDIxNTcxMSA5Ljg3MTE4NjI5IDkuMjg2MjM3NDEgOS42ODM0MjI1MSA4Ljk3NDQxMzI2IDkuNTkzNzUzMzIgOC44MjU0OTczMSA4LjgxMDM5MzggNy40MDQ0NzgzIDguNTYxNDk3OCA2LjkzNjEwNDM4IDguNDQ4MjUxNTYgNi43MjI5OTY5NiA4LjQ3OTIxMDA1IDYuNTMxMzIyNTEgOC43MzE2NDcgNi40MDM3NzQ2MyA4Ljg1NjU2NDM2IDYuMzQwNjU4MSA5LjA4MDA0MjM5IDYuMjA4OTA3OTggOS4yNzM5NDc2MiA2LjA5MTkwNTg2IDkuNDcxODkyMTkgNS45NzI0NjY0IDkuNzM1MzQ4OCA2LjA2MjIzODg1IDkuODQyNDU1NTUgNi4yNDAyMjYyMSA5Ljk0OTU2MjI5IDYuNDE4MjEzNTcgMTMuMTIwOTE4MiAxMi4yMjk0MDE5IDEzLjIyMjE1MTcgMTIuNDA5ODE2OSAxMy40MjMxMjk0IDEyLjc2Nzk5MjggMTMuMDMyMjg1MyAxMy4xNTExMTM3IDEyLjY2Mjk0OSAxMi45NTMwOTQgMTIuNDc4MTQzNiAxMi44NTQwMTA1IDYuNjIzMDExMzYgOS43NzMxNDkzNiA2LjM4MTU0Mjc0IDkuNjUwNTA2N3pNLjIwMDE0NjA2MiA2LjQwMDgxMjA1Qy0uMTExNTU0MjgyIDYuMjMyNzQxMDYtLjA1NDU0NDIzMjggNS43OTYwNDA1Mi4zMzg3ODI2NDggNS42ODQ2NjAzNi42NzIwMzAwODMgNS41OTAyOTMxNyAzLjM3ODIwNjQ3IDQuNjg4MjYzNCA0LjE5NzE1MTE1IDQuNDE0OTAwNyA0LjM0NDc5NDQzIDQuMzY1NjE3NTcgNC40NjAwNTgwOSA0LjI1MjI4MjMyIDQuNTA5NjU3NTcgNC4xMDc1ODY3IDQuNzg4NTg4NTMgMy4yOTM4NjY3MSA1LjcyMDI0NTU2LjU3NTk2MTMzNCA1LjgyNDY4OTExLjI3MTI2OTc5IDUuOTQ3NzA0OC0uMDg3NjAxOTc5IDYuMzkzMDQwNzctLjA4ODkxODQ4NjcgNi41NzQ1NDY3MS4yNTg1MDIyNTEgNi42MzkwMTU2Ni4zODE5MDIzNDYgOS4wODk0MDQ4NCA0Ljc5ODEzNTQzIDkuMTc0NjU5NDYgNC45ODU0NzA1MSA5LjI1OTkxNDA4IDUuMTcyODA1NTkgOS4yMDQ5ODczMSA1LjM4MDMxNDM0IDkuMDExNzY0MDYgNS41MDAwMDUxNSA4LjgxODU0MDggNS42MTk2OTU5NiA4LjUwMzQzNTIyIDUuNzk4NzIwNjUgOC4zOTM2NTA3IDUuODY2NTQzMjMgOC4xOTQ4OTQ2MyA1Ljk4OTMzMDU3IDguMDA0MzkxMzUgNS45MDM4NDMyNCA3LjkxMzY1NTAxIDUuNzEzNjQ4MTYgNy44MjI5MTg2NiA1LjUyMzQ1MzA3IDcuMTIzODc4MjggNC4yOTYyNjg4NiA2LjgzODgyOTUyIDMuNzc1Mjc3OTUgNi42OTYzNDk0MSAzLjUxNDg2MzQxIDYuMjY3MTEzMiAzLjQxNDkyNzk2IDYuMTIyODM3MjEgMy44MzU4MjE1OSA2LjAxODQ4NDg4IDQuMTQwMjQ2NjkgNS43NzUyNjI2NCA0Ljg0OTc5NDM5IDUuNjQ4NjQ1NTcgNS4yMTkxNzIgNS42MDAyMDM3NSA1LjM2MDQ5MDQgNS40Nzc0MTk0NCA1LjQ4MjEyNTU0IDUuMzMzOTgxMjQgNS41MjkzNzAwMSA0Ljk3ODAxNjMgNS42NDY2MTQ3OCA0LjMwMTYyOTQ0IDUuODY5Mzk3NDQgMy45MDY3MjM3NSA1Ljk5OTQ2ODE4IDMuNjI0OTE0NjkgNi4wOTIyODgxIDMuNDg3OTM1MjMgNi41MjE1MDI1NyAzLjg2ODQxNzc2IDYuNzAyMjQ2NzQgMy45NDc4OTUyNSA2Ljc0MDAwMTY3IDUuNjYwOTcxNTMgNy42NTQwNDM5MSA1LjgzNzcyMDU0IDcuNzM3NjQ1NTggNi4wMTQ0Njk1NCA3LjgyMTI0NzI0IDYuMTEyNzUyODEgOC4wNjI1Nzk0NSA2LjAwOTI1MzE2IDguMjMzNTUwMDQgNS44NjgwODA0IDguNDY2NzUyNjggNS42ODczNDc5NiA4Ljc2MjcyMDUyIDUuNjIxNzg2MiA4Ljg1ODgwODE1IDUuNTA4MTU4MzggOS4wMjUzNDE2MyA1LjI4NDk1MDc3IDkuMDgwODAyODYgNS4wOTc0ODk5NiA4Ljk4MjUxMDc2IDQuOTEwMDI5MTUgOC44ODQyMTg2Ni4zMTE1MjIyODkgNi40NjA4NjY4OS4yMDAxNDYwNjIgNi40MDA4MTIwNXoiLz48L2c+ICA8L3N2Zz4gIA==";
                },
                710: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4NCIgaGVpZ2h0PSI4NCIgdmlld0JveD0iMCAwIDg0IDg0Ij48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgPHBhdGggZD0iTTQyLDg0IEM2NS4xOTYsODQgODQsNjUuMTk2IDg0LDQyIEM4NCwxOC44MDQgNjUuMTk2LDAgNDIsMCBDMTguODA0LDAgMCwxOC44MDQgMCw0MiBDMCw2NS4xOTYgMTguODA0LDg0IDQyLDg0Ii8+ICA8cGF0aCBmaWxsPSIjRkZGIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik00Miw4My45OTg1MTA0IEM0MC4zNDMxNDU4LDgzLjk5ODUxMDQgMzksODIuNjU1MzY0NiAzOSw4MC45OTg1MTA0IEMzOSw3OS4zNDE2NTYxIDQwLjM0MzE0NTgsNzcuOTk4NTEwNCA0Miw3Ny45OTg1MTA0IEM2MS44ODIyODg2LDc3Ljk5ODUxMDQgNzgsNjEuODgwNzk5IDc4LDQxLjk5ODUxMDQgQzc4LDIyLjIzNDkyOTQgNjIuMDY2MzMxNiw2LjE3MDg3ODA2IDQyLjMxODc2ODIsNS45OTk4ODk5NCBDNDAuNjYxOTc2LDUuOTg1NTQ0MjggMzkuMzMwNTEwMSw0LjYzMDgxOTQyIDM5LjM0NDg1NTgsMi45NzQwMjcyOCBDMzkuMzU5MjAxNCwxLjMxNzIzNTE0IDQwLjcxMzkyNjMsLTAuMDE0MjMwODE0NiA0Mi4zNzA3MTg0LDAuMDAwMTE0ODQyOTUyIEM2NS40MTA5MTU3LDAuMTk5NjEyODggODQsMTguOTQwODA5MSA4NCw0MS45OTg1MTA0IEM4NCw2NS4xOTQ1MDc1IDY1LjE5NTk5NzEsODMuOTk4NTEwNCA0Miw4My45OTg1MTA0IFoiLz48L2c+ICA8L3N2Zz4gIA==";
                },
                1939: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiB2aWV3Qm94PSIwIDAgMTI4IDEyOCI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gIDxwYXRoIGZpbGw9IiNGRkYiIGQ9Ik01Ny43NDc4MjExLDU2LjkzMTc4NDUgTDQwLjkxNDUzODEsNjQuNjM0MjkyIEMzOC40NjQ1MzU5LDY1Ljc1NDY0MzIgMzQuNzg1NzMyMiw2NS43NTMzNDM1IDMyLjc2MzkxMDMsNjQuNjMyOTkyMyBDMzAuNzczNzU4Niw2My41Mjk1MzczIDMxLjE4ODAwNCw2MS43Nzg4MjYxIDMzLjYyNTMzODIsNjAuNzE5NTYxMyBMNjAuMjgzOTk3MSw0OS4xNTIxMzAyIEM2Mi4yODU1NTAxLDQ4LjI4MjYyMzMgNjUuNTAwNzAzLDQ4LjI4MjYyMzMgNjcuNTE2MTkwOCw0OS4xNTIxMzAyIEw5NC4zNDIwNjgyLDYwLjcyNjA1OTkgQzk2Ljc5NDYwNCw2MS43ODQwMjUgOTcuMjM0MTg1Niw2My41MzYwMzU5IDk1LjI2MDUwMjMsNjQuNjM5NDkwOCBDOTMuMjU1MTQ4OSw2NS43NTk4NDIgODkuNTczODExNSw2NS43NTk4NDIgODcuMTA4NjA3Nyw2NC42MzgxOTExIEw3MC42MjEzMjk1LDU3LjE0MDMxMjIgTDcxLjc5NzkzNTgsNzcuMzkyODQ3MiBDNzEuODk1MjAzMSw3OS4wODYzOTEyIDY4LjU0MjcyMzIsODAuNSA2NC4zNDU5NjMsODAuNSBDNjAuMTQ5MjAyOSw4MC41IDU2Ljc3NzI2OTUsNzkuMDg2MzkxMiA1Ni44NTExOTI2LDc3LjM5Mjg0NzIgTDU3Ljc0NzgyMTEsNTYuOTMxNzg0NSBaIi8+PC9nPiAgPC9zdmc+ICA=";
                },
                5044: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNTciIGhlaWdodD0iNTIiIHZpZXdCb3g9IjAgMCAxNTcgNTIiPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+ICA8cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41IiBkPSJNODMuMjMwNCAxOS4wNjg2TDgzLjIzMDQgMjAuMjk1NkM4Mi44NDQ0IDE5LjkxNDYgODIuNDIzNCAxOS41ODI2IDgxLjk2MTQgMTkuMzQwNiA4MS4xMTI0IDE4Ljg5NTYgODAuMTkyNCAxOC42NzE2IDc5LjIyODQgMTguNjcxNiA3OC41MzQ0IDE4LjY3MTYgNzcuODY4NCAxOC43NzM2IDc3LjIzNjQgMTguOTgwNkw3NC4yMDI0IDE4Ljk4MDYgNjcuNDg3NCAxOC45Nzg2QzY3LjAyNzQgMTguODYzNiA2Ni41NDk0IDE4LjgwMzYgNjYuMDU2NCAxOC44MDM2IDY0LjIwMzQgMTguODAzNiA2Mi42OTU0IDE5LjM4MjYgNjEuNTQ0NCAyMC4zOTA2TDYxLjU0NDQgMTUuNDU3NiA1NC45MzA0IDE1LjQ1NzYgNTEuOTAwNCAyMi43MDE2IDQ4Ljg3MDQgMTUuNDU3NiA0Mi4yNTY0IDE1LjQ1NzYgNDIuMjU2NCAzNi4wMDY2IDYxLjU0NDQgMzYuMDA2NiA2MS41NDQ0IDM0Ljc1MTZDNjIuNjk1NCAzNS43NTg2IDY0LjIwMzQgMzYuMzM4NiA2Ni4wNTY0IDM2LjMzODYgNjYuNTIwNCAzNi4zMzg2IDY2Ljk3NDQgMzYuMjc3NiA2Ny40MTc0IDM2LjE2MjZMNzEuNDYwNCAzNi4xNjI2IDcxLjQ2MDQgNDEuNDg1NiA3OC42NDk0IDM5LjkxMzYgNzguNjQ5NCAzNi4yOTM2Qzc4Ljg1MjQgMzYuMzA5NiA3OS4wNjA0IDM2LjMxNzYgNzkuMjc1NCAzNi4zMTc2IDgwLjI0NzQgMzYuMzE3NiA4MS4xNjg0IDM2LjA5OTYgODIuMDEwNCAzNS42NjM2IDgyLjQ1MzQgMzUuNDM0NiA4Mi44NTk0IDM1LjE0NzYgODMuMjMwNCAzNC44MDk2TDgzLjIzMDQgMzYuMDA2NiA4OC4xMDg0IDM2LjAwNjYgOTAuNDQzNCAzNi4wMDY2IDkyLjk2MTQgMzYuMDA2NiA5NS4yOTY0IDM2LjAwNjYgMTAwLjE1MDQgMzYuMDA2NiAxMDAuMTUwNCAzNC43MjU2QzEwMS4zMDU0IDM1Ljc0OTYgMTAyLjgyMTQgMzYuMzM4NiAxMDQuNjkwNCAzNi4zMzg2IDEwNS4xNTQ0IDM2LjMzODYgMTA1LjYwODQgMzYuMjc3NiAxMDYuMDUxNCAzNi4xNjI2TDExMi44MzY0IDM2LjE2MjYgMTE3LjY0MTQgMzYuMTYxNiAxMTcuNjQxNCAyNi4wMzE2IDExOS41ODM0IDI3Ljc3NDYgMTIwLjA5NjQgMjYuNDc4NiAxMjIuMzYwNCAzMi44ODY2IDExOS42NzE0IDQwLjU5NzYgMTI3LjIzMTQgNDAuNTk3NiAxMzQuODM0NCAxOS4wNjg2IDEyNy4wOTM0IDE5LjA2ODYgMTI2LjE5MjQgMjEuOTI3NiAxMjUuMjkwNCAxOS4wNjg2IDExOS45NTk0IDE5LjA2ODZDMTE5Ljg5ODQgMTkuMDQ0NiAxMTkuODQwNCAxOS4wMTE2IDExOS43NzY0IDE4Ljk5MDYgMTE5LjIzNjQgMTguODExNiAxMTguNjc1NCAxOC42NzE2IDExOC4xMDI0IDE4LjY3MTYgMTE3LjQ0ODQgMTguNjcxNiAxMTYuODEwNCAxOC43NzM2IDExNi4xOTc0IDE4Ljk4MDZMMTEyLjgzNjQgMTguOTgwNiAxMDYuMTIxNCAxOC45Nzg2QzEwNS42NjE0IDE4Ljg2MzYgMTA1LjE4MzQgMTguODAzNiAxMDQuNjkwNCAxOC44MDM2IDEwMi44MjE0IDE4LjgwMzYgMTAxLjMwNTQgMTkuMzkyNiAxMDAuMTUwNCAyMC40MTY2TDEwMC4xNTA0IDEzLjc2NjYgOTUuMjk2NCAxNS40NDE2IDk1LjI5NjQgMTMuNzY2NiA4OS41MTg0IDE1Ljc1OTZDODkuNDc4NCAxNS43MTQ2IDg5LjQ0OTQgMTUuNjY0NiA4OS40MDc0IDE1LjYyMDYgODguNzE1NCAxNC44OTc2IDg3LjgxNzQgMTQuNTAxNiA4Ni44MjU0IDE0LjUwMTYgODUuNzkyNCAxNC41MDE2IDg0Ljg2MjQgMTQuOTA3NiA4NC4xODA0IDE1LjY3NTYgODMuNTU1NCAxNi4zODA2IDgzLjIzMDQgMTcuMjUyNiA4My4yMzA0IDE4LjE5ODZMODMuMjMwNCAxOS4wNjg2ek0zOS44ODkxIDM1LjM0NUMzOS44NTAxIDM1LjI3NiAzOS41MDExIDM0LjY0NCAzOC44MDIxIDMzLjM3NSAzOC44NTMxIDMzLjQ2OCAzNy4xMTExIDMwLjMwNyAzNi41NTgxIDI5LjMwNiAzNC4zNDkxIDI1LjMwMSAzMy4yOTIxIDIzLjM4OCAzMy4xNzYxIDIzLjE5NyAzMi45MzUxIDIyLjc5OSAzMi41OTUxIDIyLjQ4OSAzMi4yMDkxIDIyLjI1OCAzMi4yMzMxIDIxLjgyIDMyLjE2MTEgMjEuMzcgMzEuOTY0MSAyMC45NDEgMzEuODU1MSAyMC43MDIgMzEuMDg0MSAxOS4zMSAyOS4zMjQxIDE2LjE1MSAyOS4yNDIxIDE2LjAwMyAyNi44MDUxIDExLjYzMiAyNi43NzUxIDExLjU3NSAyNS42MzMxIDkuNDA4IDIyLjQ3NDEgOS40NDYgMjEuNjMzMSAxMS44NzlMMjEuMjE3MSAxMy4wODIgMjAuNDYyMSAxNS4yNjYgMTkuMjAxMSAxOC45MTVDMTUuNjQ5MSAyMC4wODkgMTIuNTg3MSAyMS4wOTMgMTIuMTM2MSAyMS4yMiA5LjcxMzEgMjEuOTAxIDkuMTY3MSAyNS4wODcgMTEuNDU5MSAyNi4zMTMgMTEuNjU1MSAyNi40MTggMjAuNjMzMSAzMS4xMSAyMS4xNjIxIDMxLjM4NSAyMS42MTgxIDMxLjYyMiAyMi4xMTIxIDMxLjcyMSAyMi41OTUxIDMxLjY5OSAyMi44NjAxIDMyLjEwNiAyMy4yMzIxIDMyLjQ1OSAyMy43MjQxIDMyLjcwNiAyNC4xMTgxIDMyLjkwNSAzNS42MzAxIDM4LjkwOCAzNi4xMDQxIDM5LjE2IDM4LjU2MjEgNDAuNDY4IDQxLjI5NDEgMzcuODI3IDM5Ljg4OTEgMzUuMzQ1Ii8+ICA8cGF0aCBmaWxsPSIjRkZGIiBkPSJNNTkuNTQ0NCAxNy40NTczTDU5LjU0NDQgMzQuMDA3MyA1Ni4zNTU0IDM0LjAwNzMgNTYuMzU1NCAyNS4zOTczIDUyLjc2ODQgMzQuMDA3MyA1MS4wMzM0IDM0LjAwNzMgNDcuNDQ1NCAyNS4zOTczIDQ3LjQ0NTQgMzQuMDA3MyA0NC4yNTY0IDM0LjAwNzMgNDQuMjU2NCAxNy40NTczIDQ3LjUzOTQgMTcuNDU3MyA1MS45MDA0IDI3Ljg4NDMgNTYuMjYxNCAxNy40NTczIDU5LjU0NDQgMTcuNDU3M3pNNzMuNDYxNCAyMS4wNjgzTDc2LjI1MTQgMjEuMDY4MyA3Ni4yNTE0IDIyLjE0NDNDNzYuNDM4NCAyMS43NjIzIDc2LjgxMzQgMjEuNDM2MyA3Ny4zNzY0IDIxLjE2NDMgNzcuOTM4NCAyMC44OTQzIDc4LjU1NjQgMjAuNzU4MyA3OS4yMjg0IDIwLjc1ODMgNzkuODY5NCAyMC43NTgzIDgwLjQ3MDQgMjAuOTA1MyA4MS4wMzQ0IDIxLjIwMDMgODEuNTk2NCAyMS40OTUzIDgyLjA4NTQgMjEuOTMwMyA4Mi40OTk0IDIyLjUwMzMgODIuOTEzNCAyMy4wNzczIDgzLjI0MjQgMjMuNzg3MyA4My40ODQ0IDI0LjYzMjMgODMuNzI2NCAyNS40NzczIDgzLjg0NzQgMjYuNDQxMyA4My44NDc0IDI3LjUyNTMgODMuODQ3NCAyOC42NDIzIDgzLjczMDQgMjkuNjIyMyA4My40OTY0IDMwLjQ2NzMgODMuMjYxNCAzMS4zMTIzIDgyLjk0MDQgMzIuMDIxMyA4Mi41MzQ0IDMyLjU5NjMgODIuMTI4NCAzMy4xNzAzIDgxLjY0NzQgMzMuNjAwMyA4MS4wOTI0IDMzLjg4NzMgODAuNTM4NCAzNC4xNzQzIDc5LjkzMTQgMzQuMzE3MyA3OS4yNzU0IDM0LjMxNzMgNzguNTcyNCAzNC4zMTczIDc4LjAwNDQgMzQuMjA2MyA3Ny41NzU0IDMzLjk4MjMgNzcuMTQ1NCAzMy43NjAzIDc2LjgzNjQgMzMuNDgwMyA3Ni42NDk0IDMzLjE0NTNMNzYuNjQ5NCAzOC4zMDMzIDczLjQ2MTQgMzkuMDAxMyA3My40NjE0IDIxLjA2ODN6TTc4LjQ3ODQgMzEuMjMyM0M4MC4wMjU0IDMxLjIzMjMgODAuNzk5NCAzMC4wMDUzIDgwLjc5OTQgMjcuNTUwMyA4MC43OTk0IDI2LjM1MzMgODAuNjA4NCAyNS40NDUzIDgwLjIyNDQgMjQuODIzMyA3OS44NDE0IDI0LjIwMTMgNzkuMjkxNCAyMy44OTEzIDc4LjU3MjQgMjMuODkxMyA3OC4wNDA0IDIzLjg5MTMgNzcuNTk4NCAyNC4wNzgzIDc3LjI0NzQgMjQuNDUyMyA3Ni44OTU0IDI0LjgyNzMgNzYuNjI2NCAyNS4yNjkzIDc2LjQzODQgMjUuNzc5M0w3Ni40Mzg0IDI5LjQ2MzNDNzYuNjU3NCAzMC4wNTMzIDc2Ljk1MDQgMzAuNDk1MyA3Ny4zMTc0IDMwLjc5MDMgNzcuNjg0NCAzMS4wODUzIDc4LjA3MTQgMzEuMjMyMyA3OC40Nzg0IDMxLjIzMjN6TTg1LjIzMDQgMzQuMDA3M0w4OC40NDM0IDM0LjAwNzMgODguNDQzNCAyMS4wNjkzIDg1LjIzMDQgMjEuMDY5MyA4NS4yMzA0IDM0LjAwNzN6TTg1LjIzMDQgMTguMTk4M0M4NS4yMzA0IDE3LjczNjMgODUuMzc5NCAxNy4zMzgzIDg1LjY3NjQgMTcuMDAzMyA4NS45NzM0IDE2LjY2ODMgODYuMzU2NCAxNi41MDEzIDg2LjgyNTQgMTYuNTAxMyA4Ny4yNjI0IDE2LjUwMTMgODcuNjQxNCAxNi42NjgzIDg3Ljk2MjQgMTcuMDAzMyA4OC4yODM0IDE3LjMzODMgODguNDQzNCAxNy43MzYzIDg4LjQ0MzQgMTguMTk4MyA4OC40NDM0IDE4LjY0NTMgODguMjgzNCAxOS4wMjMzIDg3Ljk2MjQgMTkuMzM1MyA4Ny42NDE0IDE5LjY0NTMgODcuMjYyNCAxOS44MDEzIDg2LjgyNTQgMTkuODAxMyA4Ni4zNTY0IDE5LjgwMTMgODUuOTczNCAxOS42NDUzIDg1LjY3NjQgMTkuMzM1MyA4NS4zNzk0IDE5LjAyMzMgODUuMjMwNCAxOC42NDUzIDg1LjIzMDQgMTguMTk4M3pNOTAuMTA3NCAxNy42NzMzTDkzLjI5NjQgMTYuNTcyMyA5My4yOTY0IDM0LjAwNzMgOTAuMTA3NCAzNC4wMDczIDkwLjEwNzQgMTcuNjczM3pNOTQuOTYxNCAxNy42NzMzTDk4LjE1MDQgMTYuNTcyMyA5OC4xNTA0IDM0LjAwNzMgOTQuOTYxNCAzNC4wMDczIDk0Ljk2MTQgMTcuNjczM3pNMTE1LjQ1MzQgMjEuMDY4M0wxMTUuNDUzNCAyMS45NTMzQzExNS42NzE0IDIxLjU4NzMgMTE2LjAzMjQgMjEuMjk2MyAxMTYuNTMyNCAyMS4wODAzIDExNy4wMzI0IDIwLjg2NTMgMTE3LjU1NTQgMjAuNzU4MyAxMTguMTAzNCAyMC43NTgzIDExOC40NjI0IDIwLjc1ODMgMTE4LjgxMDQgMjAuODEzMyAxMTkuMTQ2NCAyMC45MjUzIDExOS40ODI0IDIxLjAzNjMgMTE5Ljc0NDQgMjEuMjIwMyAxMTkuOTMxNCAyMS40NzUzTDExOC43ODM0IDI0LjM2OTNDMTE4LjM5MjQgMjQuMDE4MyAxMTcuOTYxNCAyMy44NDMzIDExNy40OTM0IDIzLjg0MzMgMTE3LjEwMjQgMjMuODQzMyAxMTYuNzQ3NCAyMy45OTAzIDExNi40MjY0IDI0LjI4NTMgMTE2LjEwNjQgMjQuNTgwMyAxMTUuODQ0NCAyNS4wMzgzIDExNS42NDE0IDI1LjY2MDNMMTE1LjY0MTQgMzQuMDA3MyAxMTIuNDUyNCAzNC4wMDczIDExMi40NTI0IDIxLjA2ODMgMTE1LjQ1MzQgMjEuMDY4M3pNMTA3LjU4NjQgMzMuMDYzM0MxMDYuNzM3NCAzMy44MTUzIDEwNS43NDc0IDM0LjMzODMgMTA0LjY5MDQgMzQuMzM4MyAxMDEuMDMxNCAzNC4zMzgzIDk5LjQ5ODQgMzEuMzA5MyA5OS40OTg0IDI3LjU3MDMgOTkuNDk4NCAyMy44MzMzIDEwMS4wMzE0IDIwLjgwNDMgMTA0LjY5MDQgMjAuODA0MyAxMDUuODI4NCAyMC44MDQzIDEwNi43OTU0IDIxLjI5MDMgMTA3LjU4NjQgMjIuMDIxM0wxMDcuNTg2NCAyMC45NzgzIDExMC44MzY0IDIwLjk3ODMgMTEwLjgzNjQgMzQuMTYyMyAxMDcuNTg2NCAzNC4xNjIzIDEwNy41ODY0IDMzLjA2MzN6TTEwNy41ODY0IDI5Ljc5NjNDMTA3LjE3OTQgMzAuNjk0MyAxMDYuNDYxNCAzMS4yNTYzIDEwNS40MjA0IDMxLjI3MzMgMTAzLjQ1NTQgMzEuMzA5MyAxMDIuNzAxNCAyOS42NTgzIDEwMi42NjU0IDI3LjYwNjMgMTAyLjYyOTQgMjUuNTU1MyAxMDMuMzI3NCAyMy44NzkzIDEwNS4yOTM0IDIzLjg0NDMgMTA2LjMwNjQgMjMuODI2MyAxMDcuMTI4NCAyNC40ODAzIDEwNy41ODY0IDI1LjUzNDNMMTA3LjU4NjQgMjkuNzk2M3pNNjguOTUzNCAzMy4wNjMzQzY4LjEwMzQgMzMuODE1MyA2Ny4xMTM0IDM0LjMzODMgNjYuMDU2NCAzNC4zMzgzIDYyLjM5NzQgMzQuMzM4MyA2MC44NjM0IDMxLjMwOTMgNjAuODYzNCAyNy41NzAzIDYwLjg2MzQgMjMuODMzMyA2Mi4zOTc0IDIwLjgwNDMgNjYuMDU2NCAyMC44MDQzIDY3LjE5NDQgMjAuODA0MyA2OC4xNjE0IDIxLjI5MDMgNjguOTUzNCAyMi4wMjEzTDY4Ljk1MzQgMjAuOTc4MyA3Mi4yMDI0IDIwLjk3ODMgNzIuMjAyNCAzNC4xNjIzIDY4Ljk1MzQgMzQuMTYyMyA2OC45NTM0IDMzLjA2MzN6TTY4Ljk1MzQgMjkuNzk2M0M2OC41NDU0IDMwLjY5NDMgNjcuODI2NCAzMS4yNTYzIDY2Ljc4NzQgMzEuMjczMyA2NC44MjE0IDMxLjMwOTMgNjQuMDY2NCAyOS42NTgzIDY0LjAzMTQgMjcuNjA2MyA2My45OTY0IDI1LjU1NTMgNjQuNjkyNCAyMy44NzkzIDY2LjY1ODQgMjMuODQ0MyA2Ny42NzI0IDIzLjgyNjMgNjguNDk0NCAyNC40ODAzIDY4Ljk1MzQgMjUuNTM0M0w2OC45NTM0IDI5Ljc5NjN6TTEyNS44MTY0IDM4LjU5OTNMMTIyLjQ4NzQgMzguNTk5MyAxMjQuNDgwNCAzMi44ODMzIDEyMC4zMDY0IDIxLjA2ODMgMTIzLjgyNDQgMjEuMDY4MyAxMjYuMTkyNCAyOC41NzgzIDEyOC41NjA0IDIxLjA2ODMgMTMyLjAwNjQgMjEuMDY4MyAxMjUuODE2NCAzOC41OTkzek0yNC42MjQgMzAuOTIwMUMyNC4xNDYgMzAuNjgwMSAyNC4wMyAzMC4yNjcxIDI0LjI4NiAyOS44MTgxIDI0LjQxNiAyOS41OTExIDI0LjY5NyAyOS4xMzcxIDI0LjkyNyAyOC43NzExIDI1LjI0MiAyOC4yNjcxIDI1LjcwMyAyOC4yNjYxIDI1Ljk2MiAyOC40MTUxIDI2LjIyMiAyOC41NjUxIDI5Ljg5NyAzMC40NzAxIDMwLjEzNSAzMC41OTkxIDMwLjY5NiAzMC45MDMxIDMxLjUyMyAzMC4yMDYxIDMxLjE1MiAyOS41OTUxIDMwLjk3NSAyOS4zMDMxIDI5LjQyNiAyNi41MTcxIDI4LjkzNCAyNS41OTkxIDI4LjcxIDI1LjE4MTEgMjguNzcxIDI0LjgwNTEgMjkuMjcgMjQuNTU1MSAyOS41MTggMjQuNDMyMSAyOS45NTkgMjQuMTczMSAzMC4zNDMgMjMuOTQzMSAzMC43MzQgMjMuNzA5MSAzMS4yNTUgMjMuODg2MSAzMS40NjcgMjQuMjM0MSAzMS42NzggMjQuNTgzMSAzNy45NDkgMzUuOTc2MSAzOC4xNDkgMzYuMzI5MSAzOC41NDYgMzcuMDMyMSAzNy43NzMgMzcuNzgzMSAzNy4wNDMgMzcuMzk1MSAzNi42NzggMzcuMjAwMSAyNS4xMDIgMzEuMTYwMSAyNC42MjQgMzAuOTIwMU0xMi40MDIgMjQuNTQ5MUMxMS43ODYgMjQuMjIwMSAxMS44OTkgMjMuMzYzMSAxMi42NzcgMjMuMTQ2MSAxMy4zMzUgMjIuOTYwMSAxOC42ODYgMjEuMTkxMSAyMC4zMDUgMjAuNjU2MSAyMC41OTcgMjAuNTYwMSAyMC44MjUgMjAuMzM3MSAyMC45MjMgMjAuMDU0MSAyMS40NzUgMTguNDU4MSAyMy4zMTYgMTMuMTMwMSAyMy41MjMgMTIuNTMyMSAyMy43NjYgMTEuODI5MSAyNC42NDYgMTEuODI2MSAyNS4wMDUgMTIuNTA4MSAyNS4xMzMgMTIuNzQ5MSAyOS45NzggMjEuNDA3MSAzMC4xNDYgMjEuNzc0MSAzMC4zMTUgMjIuMTQyMSAzMC4yMDYgMjIuNTQ5MSAyOS44MjQgMjIuNzgzMSAyOS40NDIgMjMuMDE4MSAyOC44MTkgMjMuMzY5MSAyOC42MDIgMjMuNTAyMSAyOC4yMDkgMjMuNzQyMSAyNy44MzIgMjMuNTc1MSAyNy42NTMgMjMuMjAyMSAyNy40NzQgMjIuODI5MSAyNi4wOTIgMjAuNDI0MSAyNS41MjggMTkuNDAyMSAyNS4yNDcgMTguODkyMSAyNC4zOTggMTguNjk1MSAyNC4xMTIgMTkuNTIxMSAyMy45MDYgMjAuMTE3MSAyMy40MjUgMjEuNTA5MSAyMy4xNzUgMjIuMjMyMSAyMy4wNzkgMjIuNTEwMSAyMi44MzYgMjIuNzQ4MSAyMi41NTMgMjIuODQxMSAyMS44NDkgMjMuMDcwMSAyMC41MTIgMjMuNTA4MSAxOS43MzEgMjMuNzYzMSAxOS4xNzQgMjMuOTQ0MSAxOC45MDMgMjQuNzg2MSAxOS42NTUgMjUuMTQxMSAxOS44MTIgMjUuMjE0MSAyMy4xOTkgMjcuMDA2MSAyMy41NDkgMjcuMTcwMSAyMy44OTggMjcuMzM0MSAyNC4wOTMgMjcuODA3MSAyMy44ODggMjguMTQzMSAyMy42MDkgMjguNjAwMSAyMy4yNTEgMjkuMTgwMSAyMy4xMjIgMjkuMzY4MSAyMi44OTcgMjkuNjk0MSAyMi40NTYgMjkuODAzMSAyMi4wODUgMjkuNjEwMSAyMS43MTQgMjkuNDE4MSAxMi42MjMgMjQuNjY3MSAxMi40MDIgMjQuNTQ5MSIvPjwvZz4gIDwvc3ZnPiAg";
                },
                6372: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMCIgaGVpZ2h0PSIzMCIgdmlld0JveD0iMCAwIDMwIDMwIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgPHBhdGggZmlsbD0iI0ZGRiIgZD0iTTE2LDE0IEwyMSwxNCBDMjEuNTUyMjg0NywxNCAyMiwxNC40NDc3MTUzIDIyLDE1IEMyMiwxNS41NTIyODQ3IDIxLjU1MjI4NDcsMTYgMjEsMTYgTDE2LDE2IEwxNiwyMSBDMTYsMjEuNTUyMjg0NyAxNS41NTIyODQ3LDIyIDE1LDIyIEMxNC40NDc3MTUzLDIyIDE0LDIxLjU1MjI4NDcgMTQsMjEgTDE0LDE2IEw5LDE2IEM4LjQ0NzcxNTI1LDE2IDgsMTUuNTUyMjg0NyA4LDE1IEM4LDE0LjQ0NzcxNTMgOC40NDc3MTUyNSwxNCA5LDE0IEwxNCwxNCBMMTQsOSBDMTQsOC40NDc3MTUyNSAxNC40NDc3MTUzLDggMTUsOCBDMTUuNTUyMjg0Nyw4IDE2LDguNDQ3NzE1MjUgMTYsOSBMMTYsMTQgWiIvPjwvZz4gIDwvc3ZnPiAg";
                },
                9347: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMCIgaGVpZ2h0PSIzMCIgdmlld0JveD0iMCAwIDMwIDMwIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgPHBhdGggZmlsbD0iI0ZGRiIgZD0iTTIyLDE1IEMyMiwxNS41NTIyODQ3IDIxLjU1MjI4NDcsMTYgMjEsMTYgTDksMTYgQzguNDQ3NzE1MjUsMTYgOCwxNS41NTIyODQ3IDgsMTUgQzgsMTQuNDQ3NzE1MyA4LjQ0NzcxNTI1LDE0IDksMTQgTDIxLDE0IEMyMS41NTIyODQ3LDE0IDIyLDE0LjQ0NzcxNTMgMjIsMTUgWiIvPjwvZz4gIDwvc3ZnPiAg";
                },
                4737: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+ICA8cGF0aCBpZD0ic2NydWJiZXItYSIgZD0iTTksNiBMMTUsNiBDMTYuMTA0NTY5NSw2IDE3LDYuODk1NDMwNSAxNyw4IEwxNywxNiBDMTcsMTcuMTA0NTY5NSAxNi4xMDQ1Njk1LDE4IDE1LDE4IEw5LDE4IEM3Ljg5NTQzMDUsMTggNywxNy4xMDQ1Njk1IDcsMTYgTDcsOCBDNyw2Ljg5NTQzMDUgNy44OTU0MzA1LDYgOSw2IFogTTIwLjYzMzY4ODEsMTMgTDE5LDEzIEMxOC40NDc3MTUzLDEzIDE4LDEyLjU1MjI4NDcgMTgsMTIgQzE4LDExLjQ0NzcxNTMgMTguNDQ3NzE1MywxMSAxOSwxMSBMMjAuNjMzNjg4MSwxMSBDMjAuNDEyNjQzLDEwLjYxNzU2OTMgMjAuNDY1NzExMywxMC4xMjAwNzUxIDIwLjc5Mjg5MzIsOS43OTI4OTMyMiBDMjEuMTgzNDE3NSw5LjQwMjM2ODkzIDIxLjgxNjU4MjUsOS40MDIzNjg5MyAyMi4yMDcxMDY4LDkuNzkyODkzMjIgTDIzLjcwNzEwNjgsMTEuMjkyODkzMiBDMjMuODg4MDcxMiwxMS40NzM4NTc2IDI0LDExLjcyMzg1NzYgMjQsMTIgQzI0LDEyLjI3NjE0MjQgMjMuODg4MDcxMiwxMi41MjYxNDI0IDIzLjcwNzEwNjgsMTIuNzA3MTA2OCBMMjIuMjA3MTA2OCwxNC4yMDcxMDY4IEMyMS44MTY1ODI1LDE0LjU5NzYzMTEgMjEuMTgzNDE3NSwxNC41OTc2MzExIDIwLjc5Mjg5MzIsMTQuMjA3MTA2OCBDMjAuNDY1NzExMywxMy44Nzk5MjQ5IDIwLjQxMjY0MywxMy4zODI0MzA3IDIwLjYzMzY4ODEsMTMgWiBNMy4zNjYzMTE4NiwxMyBDMy41ODczNTcwNCwxMy4zODI0MzA3IDMuNTM0Mjg4NjgsMTMuODc5OTI0OSAzLjIwNzEwNjc4LDE0LjIwNzEwNjggQzIuODE2NTgyNDksMTQuNTk3NjMxMSAyLjE4MzQxNzUxLDE0LjU5NzYzMTEgMS43OTI4OTMyMiwxNC4yMDcxMDY4IEwwLjI5Mjg5MzIxOSwxMi43MDcxMDY4IEMwLjExMTkyODgxMywxMi41MjYxNDI0IDAsMTIuMjc2MTQyNCAwLDEyIEMwLDExLjcyMzg1NzYgMC4xMTE5Mjg4MTMsMTEuNDczODU3NiAwLjI5Mjg5MzIxOSwxMS4yOTI4OTMyIEwxLjc5Mjg5MzIyLDkuNzkyODkzMjIgQzIuMTgzNDE3NTEsOS40MDIzNjg5MyAyLjgxNjU4MjQ5LDkuNDAyMzY4OTMgMy4yMDcxMDY3OCw5Ljc5Mjg5MzIyIEMzLjUzNDI4ODY4LDEwLjEyMDA3NTEgMy41ODczNTcwNCwxMC42MTc1NjkzIDMuMzY2MzExODYsMTEgTDUsMTEgQzUuNTUyMjg0NzUsMTEgNiwxMS40NDc3MTUzIDYsMTIgQzYsMTIuNTUyMjg0NyA1LjU1MjI4NDc1LDEzIDUsMTMgTDMuMzY2MzExODYsMTMgWiIvPjwvZGVmcz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgPHVzZSBmaWxsPSIjRDdEQUREIiB4bGluazpocmVmPSIjc2NydWJiZXItYSIvPjwvZz4gIDwvc3ZnPiAg";
                },
                8227: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGRlZnM+ICA8cGF0aCBpZD0ic2NydWJiZXItYSIgZD0iTTksNiBMMTUsNiBDMTYuMTA0NTY5NSw2IDE3LDYuODk1NDMwNSAxNyw4IEwxNywxNiBDMTcsMTcuMTA0NTY5NSAxNi4xMDQ1Njk1LDE4IDE1LDE4IEw5LDE4IEM3Ljg5NTQzMDUsMTggNywxNy4xMDQ1Njk1IDcsMTYgTDcsOCBDNyw2Ljg5NTQzMDUgNy44OTU0MzA1LDYgOSw2IFogTTIwLjYzMzY4ODEsMTMgTDE5LDEzIEMxOC40NDc3MTUzLDEzIDE4LDEyLjU1MjI4NDcgMTgsMTIgQzE4LDExLjQ0NzcxNTMgMTguNDQ3NzE1MywxMSAxOSwxMSBMMjAuNjMzNjg4MSwxMSBDMjAuNDEyNjQzLDEwLjYxNzU2OTMgMjAuNDY1NzExMywxMC4xMjAwNzUxIDIwLjc5Mjg5MzIsOS43OTI4OTMyMiBDMjEuMTgzNDE3NSw5LjQwMjM2ODkzIDIxLjgxNjU4MjUsOS40MDIzNjg5MyAyMi4yMDcxMDY4LDkuNzkyODkzMjIgTDIzLjcwNzEwNjgsMTEuMjkyODkzMiBDMjMuODg4MDcxMiwxMS40NzM4NTc2IDI0LDExLjcyMzg1NzYgMjQsMTIgQzI0LDEyLjI3NjE0MjQgMjMuODg4MDcxMiwxMi41MjYxNDI0IDIzLjcwNzEwNjgsMTIuNzA3MTA2OCBMMjIuMjA3MTA2OCwxNC4yMDcxMDY4IEMyMS44MTY1ODI1LDE0LjU5NzYzMTEgMjEuMTgzNDE3NSwxNC41OTc2MzExIDIwLjc5Mjg5MzIsMTQuMjA3MTA2OCBDMjAuNDY1NzExMywxMy44Nzk5MjQ5IDIwLjQxMjY0MywxMy4zODI0MzA3IDIwLjYzMzY4ODEsMTMgWiBNMy4zNjYzMTE4NiwxMyBDMy41ODczNTcwNCwxMy4zODI0MzA3IDMuNTM0Mjg4NjgsMTMuODc5OTI0OSAzLjIwNzEwNjc4LDE0LjIwNzEwNjggQzIuODE2NTgyNDksMTQuNTk3NjMxMSAyLjE4MzQxNzUxLDE0LjU5NzYzMTEgMS43OTI4OTMyMiwxNC4yMDcxMDY4IEwwLjI5Mjg5MzIxOSwxMi43MDcxMDY4IEMwLjExMTkyODgxMywxMi41MjYxNDI0IDAsMTIuMjc2MTQyNCAwLDEyIEMwLDExLjcyMzg1NzYgMC4xMTE5Mjg4MTMsMTEuNDczODU3NiAwLjI5Mjg5MzIxOSwxMS4yOTI4OTMyIEwxLjc5Mjg5MzIyLDkuNzkyODkzMjIgQzIuMTgzNDE3NTEsOS40MDIzNjg5MyAyLjgxNjU4MjQ5LDkuNDAyMzY4OTMgMy4yMDcxMDY3OCw5Ljc5Mjg5MzIyIEMzLjUzNDI4ODY4LDEwLjEyMDA3NTEgMy41ODczNTcwNCwxMC42MTc1NjkzIDMuMzY2MzExODYsMTEgTDUsMTEgQzUuNTUyMjg0NzUsMTEgNiwxMS40NDc3MTUzIDYsMTIgQzYsMTIuNTUyMjg0NyA1LjU1MjI4NDc1LDEzIDUsMTMgTDMuMzY2MzExODYsMTMgWiIvPjwvZGVmcz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgPHVzZSBmaWxsPSIjRkZGIiB4bGluazpocmVmPSIjc2NydWJiZXItYSIvPjwvZz4gIDwvc3ZnPiAg";
                },
                3954: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTE5LjA2Ij4KICAgIDxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik05OS4yLDc2Qzk4LDY0LjkxLDk1LjA2LDU2LjYsODkuNTcsNTAsNzksMzcuMzgsNjAuMywzMi43MiwyNC40MiwzMi4zOUw0NC44OSwxMS45M0E3LDcsMCwwLDAsMzUsMmgwbC0zMywzM2E3LDcsMCwwLDAsMCw5Ljg4TDM1LDc3Ljg1YTcsNywwLDEsMCw5LjktOS45TDI0Ljc5LDQ3Ljg5QzU2LDQ4LjE4LDcxLDUxLjkzLDc3LjcyLDYwYzMuMjEsMy44OCw1LjE4LDkuNDIsNi4xMSwxNy43NywwLjg1LDcuNTkuODcsMTYuMjIsMC4zNCwzMy4zNmE3Ljc0LDcuNzQsMCwxLDAsMTUuNDYuNDhDMTAwLjE5LDkzLjcyLDEwMC4xNiw4NC42LDk5LjIsNzZaIi8+Cjwvc3ZnPg==";
                },
                2868: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgNTguNzciPgogICAgPHBhdGggZmlsbD0iI0Y1REVCMyIgZD0iTTk3LjQ0LDQzLjgyTDU2LjE4LDIuNTZhOC43NSw4Ljc1LDAsMCwwLTEyLjM3LDBoMEwyLjU2LDQzLjhBOC43NSw4Ljc1LDAsMCwwLDE0Ljk0LDU2LjE4bDM1LTM1TDg1LjA1LDU2LjJBOC43NSw4Ljc1LDAsMSwwLDk3LjQ0LDQzLjgyaDBaIi8+Cjwvc3ZnPg==";
                },
                4556: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgNTguNzciPgogICAgPHBhdGggZmlsbD0iI0ZGRkZGRiIgZD0iTTk3LjQ0LDQzLjgyTDU2LjE4LDIuNTZhOC43NSw4Ljc1LDAsMCwwLTEyLjM3LDBoMEwyLjU2LDQzLjhBOC43NSw4Ljc1LDAsMCwwLDE0Ljk0LDU2LjE4bDM1LTM1TDg1LjA1LDU2LjJBOC43NSw4Ljc1LDAsMSwwLDk3LjQ0LDQzLjgyaDBaIi8+Cjwvc3ZnPg==";
                },
                8422: (e) => {
                    e.exports =
                        "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgODQuMzMiPgogICAgPHBhdGggZmlsbD0iI0ZGRkZGRiIgZD0iTTY1LjQ3LDBDNTYsMCw0Ni44Niw1LjM5LDQwLjIxLDE2LjA3LDMzLjQ3LDI3LDI5LjM2LDQzLjE4LDI4LjQzLDY1TDEwLDQ2LjU5YTUuODcsNS44NywwLDAsMC04LjMsOC4zTDI5LjQ0LDgyLjYxYTUuODgsNS44OCwwLDAsMCw4LjMsMEw2NS40Nyw1NWE1Ljg4LDUuODgsMCwxLDAtOC4zMi04LjMyTDM5LjMyLDY0LjQ3YzAuOTItMTkuNTYsNC41LTMzLjcsMTAuMTEtNDIuNzIsNC43Mi03LjYyLDEwLjQ1LTExLDE2LjEtMTFhMTYuNjQsMTYuNjQsMCwwLDEsMTQuNzgsOEM4NiwyNyw4OS4yMSw0MS44NSw4OS4yMSw2NC40N2E1LjM5LDUuMzksMCwxLDAsMTAuNzksMEMxMDAuMDUsMTguNzgsODcuMjIsMCw2NS40NywwWiIvPgo8L3N2Zz4=";
                },
                8055: (e) => {
                    e.exports = u;
                },
                5635: (e) => {
                    e.exports = i;
                },
                3622: (e) => {
                    e.exports = d;
                },
                65: (e) => {
                    e.exports = l;
                },
                6817: (e) => {
                    e.exports = h;
                },
                6401: (e) => {
                    e.exports = r;
                },
                5219: (e) => {
                    e.exports = n;
                },
                138: (e) => {
                    e.exports = c;
                },
                8302: (e) => {
                    e.exports = o;
                },
                663: (e) => {
                    e.exports = a;
                },
                5659: (e) => {
                    e.exports = s;
                },
                5959: (e) => {
                    e.exports = t;
                },
                6308: (t) => {
                    t.exports = e;
                },
            },
            g = {};
        function m(e) {
            var t = g[e];
            if (void 0 !== t) return t.exports;
            var i = (g[e] = { id: e, exports: {} });
            return p[e](i, i.exports, m), i.exports;
        }
        (m.m = p),
            (m.n = (e) => {
                var t = e && e.__esModule ? () => e.default : () => e;
                return m.d(t, { a: t }), t;
            }),
            (m.d = (e, t) => {
                for (var i in t)
                    m.o(t, i) &&
                        !m.o(e, i) &&
                        Object.defineProperty(e, i, {
                            enumerable: !0,
                            get: t[i],
                        });
            }),
            (m.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
            (m.r = (e) => {
                "undefined" != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(e, Symbol.toStringTag, {
                        value: "Module",
                    }),
                    Object.defineProperty(e, "__esModule", { value: !0 });
            }),
            (m.b = document.baseURI || self.location.href),
            (m.nc = void 0);
        var f = {};
        return (
            (() => {
                m.r(f), m.d(f, { default: () => cN });
                var e = m(6308),
                    t = m(5959);
                function i(e) {
                    var t,
                        n,
                        r = "";
                    if ("string" == typeof e || "number" == typeof e) r += e;
                    else if ("object" == typeof e)
                        if (Array.isArray(e))
                            for (t = 0; t < e.length; t++)
                                e[t] &&
                                    (n = i(e[t])) &&
                                    (r && (r += " "), (r += n));
                        else for (t in e) e[t] && (r && (r += " "), (r += t));
                    return r;
                }
                const n = function () {
                    for (var e, t, n = 0, r = ""; n < arguments.length; )
                        (e = arguments[n++]) &&
                            (t = i(e)) &&
                            (r && (r += " "), (r += t));
                    return r;
                };
                var r = function (e, t) {
                    return (
                        (r =
                            Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array &&
                                function (e, t) {
                                    e.__proto__ = t;
                                }) ||
                            function (e, t) {
                                for (var i in t)
                                    Object.prototype.hasOwnProperty.call(
                                        t,
                                        i
                                    ) && (e[i] = t[i]);
                            }),
                        r(e, t)
                    );
                };
                function s(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError(
                            "Class extends value " +
                                String(t) +
                                " is not a constructor or null"
                        );
                    function i() {
                        this.constructor = e;
                    }
                    r(e, t),
                        (e.prototype =
                            null === t
                                ? Object.create(t)
                                : ((i.prototype = t.prototype), new i()));
                }
                function a(e, t) {
                    var i,
                        n,
                        r,
                        s,
                        a = {
                            label: 0,
                            sent: function () {
                                if (1 & r[0]) throw r[1];
                                return r[1];
                            },
                            trys: [],
                            ops: [],
                        };
                    return (
                        (s = { next: o(0), throw: o(1), return: o(2) }),
                        "function" == typeof Symbol &&
                            (s[Symbol.iterator] = function () {
                                return this;
                            }),
                        s
                    );
                    function o(s) {
                        return function (o) {
                            return (function (s) {
                                if (i)
                                    throw new TypeError(
                                        "Generator is already executing."
                                    );
                                for (; a; )
                                    try {
                                        if (
                                            ((i = 1),
                                            n &&
                                                (r =
                                                    2 & s[0]
                                                        ? n.return
                                                        : s[0]
                                                        ? n.throw ||
                                                          ((r = n.return) &&
                                                              r.call(n),
                                                          0)
                                                        : n.next) &&
                                                !(r = r.call(n, s[1])).done)
                                        )
                                            return r;
                                        switch (
                                            ((n = 0),
                                            r && (s = [2 & s[0], r.value]),
                                            s[0])
                                        ) {
                                            case 0:
                                            case 1:
                                                r = s;
                                                break;
                                            case 4:
                                                return (
                                                    a.label++,
                                                    { value: s[1], done: !1 }
                                                );
                                            case 5:
                                                a.label++,
                                                    (n = s[1]),
                                                    (s = [0]);
                                                continue;
                                            case 7:
                                                (s = a.ops.pop()), a.trys.pop();
                                                continue;
                                            default:
                                                if (
                                                    !(
                                                        (r =
                                                            (r = a.trys)
                                                                .length > 0 &&
                                                            r[r.length - 1]) ||
                                                        (6 !== s[0] &&
                                                            2 !== s[0])
                                                    )
                                                ) {
                                                    a = 0;
                                                    continue;
                                                }
                                                if (
                                                    3 === s[0] &&
                                                    (!r ||
                                                        (s[1] > r[0] &&
                                                            s[1] < r[3]))
                                                ) {
                                                    a.label = s[1];
                                                    break;
                                                }
                                                if (
                                                    6 === s[0] &&
                                                    a.label < r[1]
                                                ) {
                                                    (a.label = r[1]), (r = s);
                                                    break;
                                                }
                                                if (r && a.label < r[2]) {
                                                    (a.label = r[2]),
                                                        a.ops.push(s);
                                                    break;
                                                }
                                                r[2] && a.ops.pop(),
                                                    a.trys.pop();
                                                continue;
                                        }
                                        s = t.call(e, a);
                                    } catch (e) {
                                        (s = [6, e]), (n = 0);
                                    } finally {
                                        i = r = 0;
                                    }
                                if (5 & s[0]) throw s[1];
                                return {
                                    value: s[0] ? s[1] : void 0,
                                    done: !0,
                                };
                            })([s, o]);
                        };
                    }
                }
                function o(e) {
                    var t = "function" == typeof Symbol && Symbol.iterator,
                        i = t && e[t],
                        n = 0;
                    if (i) return i.call(e);
                    if (e && "number" == typeof e.length)
                        return {
                            next: function () {
                                return (
                                    e && n >= e.length && (e = void 0),
                                    { value: e && e[n++], done: !e }
                                );
                            },
                        };
                    throw new TypeError(
                        t
                            ? "Object is not iterable."
                            : "Symbol.iterator is not defined."
                    );
                }
                function c(e, t) {
                    var i = "function" == typeof Symbol && e[Symbol.iterator];
                    if (!i) return e;
                    var n,
                        r,
                        s = i.call(e),
                        a = [];
                    try {
                        for (
                            ;
                            (void 0 === t || t-- > 0) && !(n = s.next()).done;

                        )
                            a.push(n.value);
                    } catch (e) {
                        r = { error: e };
                    } finally {
                        try {
                            n && !n.done && (i = s.return) && i.call(s);
                        } finally {
                            if (r) throw r.error;
                        }
                    }
                    return a;
                }
                function l(e, t) {
                    for (var i = 0, n = t.length, r = e.length; i < n; i++, r++)
                        e[r] = t[i];
                    return e;
                }
                function h(e) {
                    return this instanceof h ? ((this.v = e), this) : new h(e);
                }
                function u(e) {
                    return "function" == typeof e;
                }
                function d(e) {
                    var t = e(function (e) {
                        Error.call(e), (e.stack = new Error().stack);
                    });
                    return (
                        (t.prototype = Object.create(Error.prototype)),
                        (t.prototype.constructor = t),
                        t
                    );
                }
                var p = d(function (e) {
                    return function (t) {
                        e(this),
                            (this.message = t
                                ? t.length +
                                  " errors occurred during unsubscription:\n" +
                                  t
                                      .map(function (e, t) {
                                          return t + 1 + ") " + e.toString();
                                      })
                                      .join("\n  ")
                                : ""),
                            (this.name = "UnsubscriptionError"),
                            (this.errors = t);
                    };
                });
                function g(e, t) {
                    if (e) {
                        var i = e.indexOf(t);
                        0 <= i && e.splice(i, 1);
                    }
                }
                var _ = (function () {
                        function e(e) {
                            (this.initialTeardown = e),
                                (this.closed = !1),
                                (this._parentage = null),
                                (this._teardowns = null);
                        }
                        return (
                            (e.prototype.unsubscribe = function () {
                                var e, t, i, n, r;
                                if (!this.closed) {
                                    this.closed = !0;
                                    var s = this._parentage;
                                    if (s)
                                        if (
                                            ((this._parentage = null),
                                            Array.isArray(s))
                                        )
                                            try {
                                                for (
                                                    var a = o(s), h = a.next();
                                                    !h.done;
                                                    h = a.next()
                                                )
                                                    h.value.remove(this);
                                            } catch (t) {
                                                e = { error: t };
                                            } finally {
                                                try {
                                                    h &&
                                                        !h.done &&
                                                        (t = a.return) &&
                                                        t.call(a);
                                                } finally {
                                                    if (e) throw e.error;
                                                }
                                            }
                                        else s.remove(this);
                                    var d = this.initialTeardown;
                                    if (u(d))
                                        try {
                                            d();
                                        } catch (e) {
                                            r = e instanceof p ? e.errors : [e];
                                        }
                                    var g = this._teardowns;
                                    if (g) {
                                        this._teardowns = null;
                                        try {
                                            for (
                                                var m = o(g), f = m.next();
                                                !f.done;
                                                f = m.next()
                                            ) {
                                                var _ = f.value;
                                                try {
                                                    y(_);
                                                } catch (e) {
                                                    (r = null != r ? r : []),
                                                        e instanceof p
                                                            ? (r = l(
                                                                  l([], c(r)),
                                                                  c(e.errors)
                                                              ))
                                                            : r.push(e);
                                                }
                                            }
                                        } catch (e) {
                                            i = { error: e };
                                        } finally {
                                            try {
                                                f &&
                                                    !f.done &&
                                                    (n = m.return) &&
                                                    n.call(m);
                                            } finally {
                                                if (i) throw i.error;
                                            }
                                        }
                                    }
                                    if (r) throw new p(r);
                                }
                            }),
                            (e.prototype.add = function (t) {
                                var i;
                                if (t && t !== this)
                                    if (this.closed) y(t);
                                    else {
                                        if (t instanceof e) {
                                            if (t.closed || t._hasParent(this))
                                                return;
                                            t._addParent(this);
                                        }
                                        (this._teardowns =
                                            null !== (i = this._teardowns) &&
                                            void 0 !== i
                                                ? i
                                                : []).push(t);
                                    }
                            }),
                            (e.prototype._hasParent = function (e) {
                                var t = this._parentage;
                                return (
                                    t === e ||
                                    (Array.isArray(t) && t.includes(e))
                                );
                            }),
                            (e.prototype._addParent = function (e) {
                                var t = this._parentage;
                                this._parentage = Array.isArray(t)
                                    ? (t.push(e), t)
                                    : t
                                    ? [t, e]
                                    : e;
                            }),
                            (e.prototype._removeParent = function (e) {
                                var t = this._parentage;
                                t === e
                                    ? (this._parentage = null)
                                    : Array.isArray(t) && g(t, e);
                            }),
                            (e.prototype.remove = function (t) {
                                var i = this._teardowns;
                                i && g(i, t),
                                    t instanceof e && t._removeParent(this);
                            }),
                            (e.EMPTY = (function () {
                                var t = new e();
                                return (t.closed = !0), t;
                            })()),
                            e
                        );
                    })(),
                    M = _.EMPTY;
                function v(e) {
                    return (
                        e instanceof _ ||
                        (e &&
                            "closed" in e &&
                            u(e.remove) &&
                            u(e.add) &&
                            u(e.unsubscribe))
                    );
                }
                function y(e) {
                    u(e) ? e() : e.unsubscribe();
                }
                var x = null,
                    b = void 0,
                    w = !1,
                    T = !1,
                    S = {
                        setTimeout: function () {
                            for (var e = [], t = 0; t < arguments.length; t++)
                                e[t] = arguments[t];
                            var i = S.delegate;
                            return (
                                (null == i ? void 0 : i.setTimeout) ||
                                setTimeout
                            ).apply(void 0, l([], c(e)));
                        },
                        clearTimeout: function (e) {
                            var t = S.delegate;
                            return (
                                (null == t ? void 0 : t.clearTimeout) ||
                                clearTimeout
                            )(e);
                        },
                        delegate: void 0,
                    };
                function N(e) {
                    S.setTimeout(function () {
                        throw e;
                    });
                }
                function D() {}
                var I = C("C", void 0, void 0);
                function C(e, t, i) {
                    return { kind: e, value: t, error: i };
                }
                var A = null;
                function E(e) {
                    if (w) {
                        var t = !A;
                        if (
                            (t && (A = { errorThrown: !1, error: null }),
                            e(),
                            t)
                        ) {
                            var i = A,
                                n = i.errorThrown,
                                r = i.error;
                            if (((A = null), n)) throw r;
                        }
                    } else e();
                }
                var L = (function (e) {
                        function t(t) {
                            var i = e.call(this) || this;
                            return (
                                (i.isStopped = !1),
                                t
                                    ? ((i.destination = t), v(t) && t.add(i))
                                    : (i.destination = R),
                                i
                            );
                        }
                        return (
                            s(t, e),
                            (t.create = function (e, t, i) {
                                return new z(e, t, i);
                            }),
                            (t.prototype.next = function (e) {
                                this.isStopped
                                    ? k(
                                          (function (e) {
                                              return C("N", e, void 0);
                                          })(e),
                                          this
                                      )
                                    : this._next(e);
                            }),
                            (t.prototype.error = function (e) {
                                this.isStopped
                                    ? k(C("E", void 0, e), this)
                                    : ((this.isStopped = !0), this._error(e));
                            }),
                            (t.prototype.complete = function () {
                                this.isStopped
                                    ? k(I, this)
                                    : ((this.isStopped = !0), this._complete());
                            }),
                            (t.prototype.unsubscribe = function () {
                                this.closed ||
                                    ((this.isStopped = !0),
                                    e.prototype.unsubscribe.call(this),
                                    (this.destination = null));
                            }),
                            (t.prototype._next = function (e) {
                                this.destination.next(e);
                            }),
                            (t.prototype._error = function (e) {
                                try {
                                    this.destination.error(e);
                                } finally {
                                    this.unsubscribe();
                                }
                            }),
                            (t.prototype._complete = function () {
                                try {
                                    this.destination.complete();
                                } finally {
                                    this.unsubscribe();
                                }
                            }),
                            t
                        );
                    })(_),
                    z = (function (e) {
                        function t(t, i, n) {
                            var r,
                                s = e.call(this) || this;
                            if (u(t)) r = t;
                            else if (t) {
                                var a;
                                (r = t.next),
                                    (i = t.error),
                                    (n = t.complete),
                                    s && T
                                        ? ((a = Object.create(t)).unsubscribe =
                                              function () {
                                                  return s.unsubscribe();
                                              })
                                        : (a = t),
                                    (r = null == r ? void 0 : r.bind(a)),
                                    (i = null == i ? void 0 : i.bind(a)),
                                    (n = null == n ? void 0 : n.bind(a));
                            }
                            return (
                                (s.destination = {
                                    next: r ? j(r) : D,
                                    error: j(null != i ? i : O),
                                    complete: n ? j(n) : D,
                                }),
                                s
                            );
                        }
                        return s(t, e), t;
                    })(L);
                function j(e, t) {
                    return function () {
                        for (var t = [], i = 0; i < arguments.length; i++)
                            t[i] = arguments[i];
                        try {
                            e.apply(void 0, l([], c(t)));
                        } catch (e) {
                            N(e);
                        }
                    };
                }
                function O(e) {
                    throw e;
                }
                function k(e, t) {
                    var i = x;
                    i &&
                        S.setTimeout(function () {
                            return i(e, t);
                        });
                }
                var R = { closed: !0, next: D, error: O, complete: D },
                    P =
                        ("function" == typeof Symbol && Symbol.observable) ||
                        "@@observable";
                function U(e) {
                    return e;
                }
                var $ = (function () {
                    function e(e) {
                        e && (this._subscribe = e);
                    }
                    return (
                        (e.prototype.lift = function (t) {
                            var i = new e();
                            return (i.source = this), (i.operator = t), i;
                        }),
                        (e.prototype.subscribe = function (e, t, i) {
                            var n,
                                r = this,
                                s =
                                    ((n = e) && n instanceof L) ||
                                    ((function (e) {
                                        return (
                                            e &&
                                            u(e.next) &&
                                            u(e.error) &&
                                            u(e.complete)
                                        );
                                    })(n) &&
                                        v(n))
                                        ? e
                                        : new z(e, t, i);
                            return (
                                E(function () {
                                    var e = r,
                                        t = e.operator,
                                        i = e.source;
                                    s.add(
                                        t
                                            ? t.call(s, i)
                                            : i
                                            ? r._subscribe(s)
                                            : r._trySubscribe(s)
                                    );
                                }),
                                s
                            );
                        }),
                        (e.prototype._trySubscribe = function (e) {
                            try {
                                return this._subscribe(e);
                            } catch (t) {
                                e.error(t);
                            }
                        }),
                        (e.prototype.forEach = function (e, t) {
                            var i = this;
                            return new (t = B(t))(function (t, n) {
                                var r;
                                r = i.subscribe(
                                    function (t) {
                                        try {
                                            e(t);
                                        } catch (e) {
                                            n(e), null == r || r.unsubscribe();
                                        }
                                    },
                                    n,
                                    t
                                );
                            });
                        }),
                        (e.prototype._subscribe = function (e) {
                            var t;
                            return null === (t = this.source) || void 0 === t
                                ? void 0
                                : t.subscribe(e);
                        }),
                        (e.prototype[P] = function () {
                            return this;
                        }),
                        (e.prototype.pipe = function () {
                            for (
                                var e, t = [], i = 0;
                                i < arguments.length;
                                i++
                            )
                                t[i] = arguments[i];
                            return (
                                0 === (e = t).length
                                    ? U
                                    : 1 === e.length
                                    ? e[0]
                                    : function (t) {
                                          return e.reduce(function (e, t) {
                                              return t(e);
                                          }, t);
                                      }
                            )(this);
                        }),
                        (e.prototype.toPromise = function (e) {
                            var t = this;
                            return new (e = B(e))(function (e, i) {
                                var n;
                                t.subscribe(
                                    function (e) {
                                        return (n = e);
                                    },
                                    function (e) {
                                        return i(e);
                                    },
                                    function () {
                                        return e(n);
                                    }
                                );
                            });
                        }),
                        (e.create = function (t) {
                            return new e(t);
                        }),
                        e
                    );
                })();
                function B(e) {
                    var t;
                    return null !== (t = null != e ? e : b) && void 0 !== t
                        ? t
                        : Promise;
                }
                function F(e) {
                    return u(null == e ? void 0 : e.lift);
                }
                function H(e) {
                    return function (t) {
                        if (F(t))
                            return t.lift(function (t) {
                                try {
                                    return e(t, this);
                                } catch (e) {
                                    this.error(e);
                                }
                            });
                        throw new TypeError(
                            "Unable to lift unknown Observable type"
                        );
                    };
                }
                var G = (function (e) {
                    function t(t, i, n, r, s) {
                        var a = e.call(this, t) || this;
                        return (
                            (a.onFinalize = s),
                            (a._next = i
                                ? function (e) {
                                      try {
                                          i(e);
                                      } catch (e) {
                                          t.error(e);
                                      }
                                  }
                                : e.prototype._next),
                            (a._error = r
                                ? function (e) {
                                      try {
                                          r(e);
                                      } catch (e) {
                                          t.error(e);
                                      } finally {
                                          this.unsubscribe();
                                      }
                                  }
                                : e.prototype._error),
                            (a._complete = n
                                ? function () {
                                      try {
                                          n();
                                      } catch (e) {
                                          t.error(e);
                                      } finally {
                                          this.unsubscribe();
                                      }
                                  }
                                : e.prototype._complete),
                            a
                        );
                    }
                    return (
                        s(t, e),
                        (t.prototype.unsubscribe = function () {
                            var t,
                                i = this.closed;
                            e.prototype.unsubscribe.call(this),
                                !i &&
                                    (null === (t = this.onFinalize) ||
                                        void 0 === t ||
                                        t.call(this));
                        }),
                        t
                    );
                })(L);
                function V() {
                    return H(function (e, t) {
                        var i = null;
                        e._refCount++;
                        var n = new G(t, void 0, void 0, void 0, function () {
                            if (!e || e._refCount <= 0 || 0 < --e._refCount)
                                i = null;
                            else {
                                var n = e._connection,
                                    r = i;
                                (i = null),
                                    !n || (r && n !== r) || n.unsubscribe(),
                                    t.unsubscribe();
                            }
                        });
                        e.subscribe(n), n.closed || (i = e.connect());
                    });
                }
                var Y = (function (e) {
                        function t(t, i) {
                            var n = e.call(this) || this;
                            return (
                                (n.source = t),
                                (n.subjectFactory = i),
                                (n._subject = null),
                                (n._refCount = 0),
                                (n._connection = null),
                                F(t) && (n.lift = t.lift),
                                n
                            );
                        }
                        return (
                            s(t, e),
                            (t.prototype._subscribe = function (e) {
                                return this.getSubject().subscribe(e);
                            }),
                            (t.prototype.getSubject = function () {
                                var e = this._subject;
                                return (
                                    (e && !e.isStopped) ||
                                        (this._subject = this.subjectFactory()),
                                    this._subject
                                );
                            }),
                            (t.prototype._teardown = function () {
                                this._refCount = 0;
                                var e = this._connection;
                                (this._subject = this._connection = null),
                                    null == e || e.unsubscribe();
                            }),
                            (t.prototype.connect = function () {
                                var e = this,
                                    t = this._connection;
                                if (!t) {
                                    t = this._connection = new _();
                                    var i = this.getSubject();
                                    t.add(
                                        this.source.subscribe(
                                            new G(
                                                i,
                                                void 0,
                                                function () {
                                                    e._teardown(), i.complete();
                                                },
                                                function (t) {
                                                    e._teardown(), i.error(t);
                                                },
                                                function () {
                                                    return e._teardown();
                                                }
                                            )
                                        )
                                    ),
                                        t.closed &&
                                            ((this._connection = null),
                                            (t = _.EMPTY));
                                }
                                return t;
                            }),
                            (t.prototype.refCount = function () {
                                return V()(this);
                            }),
                            t
                        );
                    })($),
                    q = d(function (e) {
                        return function () {
                            e(this),
                                (this.name = "ObjectUnsubscribedError"),
                                (this.message = "object unsubscribed");
                        };
                    }),
                    W = (function (e) {
                        function t() {
                            var t = e.call(this) || this;
                            return (
                                (t.closed = !1),
                                (t.observers = []),
                                (t.isStopped = !1),
                                (t.hasError = !1),
                                (t.thrownError = null),
                                t
                            );
                        }
                        return (
                            s(t, e),
                            (t.prototype.lift = function (e) {
                                var t = new Q(this, this);
                                return (t.operator = e), t;
                            }),
                            (t.prototype._throwIfClosed = function () {
                                if (this.closed) throw new q();
                            }),
                            (t.prototype.next = function (e) {
                                var t = this;
                                E(function () {
                                    var i, n;
                                    if ((t._throwIfClosed(), !t.isStopped)) {
                                        var r = t.observers.slice();
                                        try {
                                            for (
                                                var s = o(r), a = s.next();
                                                !a.done;
                                                a = s.next()
                                            )
                                                a.value.next(e);
                                        } catch (e) {
                                            i = { error: e };
                                        } finally {
                                            try {
                                                a &&
                                                    !a.done &&
                                                    (n = s.return) &&
                                                    n.call(s);
                                            } finally {
                                                if (i) throw i.error;
                                            }
                                        }
                                    }
                                });
                            }),
                            (t.prototype.error = function (e) {
                                var t = this;
                                E(function () {
                                    if ((t._throwIfClosed(), !t.isStopped)) {
                                        (t.hasError = t.isStopped = !0),
                                            (t.thrownError = e);
                                        for (var i = t.observers; i.length; )
                                            i.shift().error(e);
                                    }
                                });
                            }),
                            (t.prototype.complete = function () {
                                var e = this;
                                E(function () {
                                    if ((e._throwIfClosed(), !e.isStopped)) {
                                        e.isStopped = !0;
                                        for (var t = e.observers; t.length; )
                                            t.shift().complete();
                                    }
                                });
                            }),
                            (t.prototype.unsubscribe = function () {
                                (this.isStopped = this.closed = !0),
                                    (this.observers = null);
                            }),
                            Object.defineProperty(t.prototype, "observed", {
                                get: function () {
                                    var e;
                                    return (
                                        (null === (e = this.observers) ||
                                        void 0 === e
                                            ? void 0
                                            : e.length) > 0
                                    );
                                },
                                enumerable: !1,
                                configurable: !0,
                            }),
                            (t.prototype._trySubscribe = function (t) {
                                return (
                                    this._throwIfClosed(),
                                    e.prototype._trySubscribe.call(this, t)
                                );
                            }),
                            (t.prototype._subscribe = function (e) {
                                return (
                                    this._throwIfClosed(),
                                    this._checkFinalizedStatuses(e),
                                    this._innerSubscribe(e)
                                );
                            }),
                            (t.prototype._innerSubscribe = function (e) {
                                var t = this,
                                    i = t.hasError,
                                    n = t.isStopped,
                                    r = t.observers;
                                return i || n
                                    ? M
                                    : (r.push(e),
                                      new _(function () {
                                          return g(r, e);
                                      }));
                            }),
                            (t.prototype._checkFinalizedStatuses = function (
                                e
                            ) {
                                var t = this,
                                    i = t.hasError,
                                    n = t.thrownError,
                                    r = t.isStopped;
                                i ? e.error(n) : r && e.complete();
                            }),
                            (t.prototype.asObservable = function () {
                                var e = new $();
                                return (e.source = this), e;
                            }),
                            (t.create = function (e, t) {
                                return new Q(e, t);
                            }),
                            t
                        );
                    })($),
                    Q = (function (e) {
                        function t(t, i) {
                            var n = e.call(this) || this;
                            return (n.destination = t), (n.source = i), n;
                        }
                        return (
                            s(t, e),
                            (t.prototype.next = function (e) {
                                var t, i;
                                null ===
                                    (i =
                                        null === (t = this.destination) ||
                                        void 0 === t
                                            ? void 0
                                            : t.next) ||
                                    void 0 === i ||
                                    i.call(t, e);
                            }),
                            (t.prototype.error = function (e) {
                                var t, i;
                                null ===
                                    (i =
                                        null === (t = this.destination) ||
                                        void 0 === t
                                            ? void 0
                                            : t.error) ||
                                    void 0 === i ||
                                    i.call(t, e);
                            }),
                            (t.prototype.complete = function () {
                                var e, t;
                                null ===
                                    (t =
                                        null === (e = this.destination) ||
                                        void 0 === e
                                            ? void 0
                                            : e.complete) ||
                                    void 0 === t ||
                                    t.call(e);
                            }),
                            (t.prototype._subscribe = function (e) {
                                var t, i;
                                return null !==
                                    (i =
                                        null === (t = this.source) ||
                                        void 0 === t
                                            ? void 0
                                            : t.subscribe(e)) && void 0 !== i
                                    ? i
                                    : M;
                            }),
                            t
                        );
                    })(W),
                    Z = (function (e) {
                        function t(t) {
                            var i = e.call(this) || this;
                            return (i._value = t), i;
                        }
                        return (
                            s(t, e),
                            Object.defineProperty(t.prototype, "value", {
                                get: function () {
                                    return this.getValue();
                                },
                                enumerable: !1,
                                configurable: !0,
                            }),
                            (t.prototype._subscribe = function (t) {
                                var i = e.prototype._subscribe.call(this, t);
                                return !i.closed && t.next(this._value), i;
                            }),
                            (t.prototype.getValue = function () {
                                var e = this,
                                    t = e.hasError,
                                    i = e.thrownError,
                                    n = e._value;
                                if (t) throw i;
                                return this._throwIfClosed(), n;
                            }),
                            (t.prototype.next = function (t) {
                                e.prototype.next.call(this, (this._value = t));
                            }),
                            t
                        );
                    })(W),
                    X = {
                        now: function () {
                            return (X.delegate || Date).now();
                        },
                        delegate: void 0,
                    },
                    J = (function (e) {
                        function t(t, i, n) {
                            void 0 === t && (t = 1 / 0),
                                void 0 === i && (i = 1 / 0),
                                void 0 === n && (n = X);
                            var r = e.call(this) || this;
                            return (
                                (r._bufferSize = t),
                                (r._windowTime = i),
                                (r._timestampProvider = n),
                                (r._buffer = []),
                                (r._infiniteTimeWindow = !0),
                                (r._infiniteTimeWindow = i === 1 / 0),
                                (r._bufferSize = Math.max(1, t)),
                                (r._windowTime = Math.max(1, i)),
                                r
                            );
                        }
                        return (
                            s(t, e),
                            (t.prototype.next = function (t) {
                                var i = this,
                                    n = i.isStopped,
                                    r = i._buffer,
                                    s = i._infiniteTimeWindow,
                                    a = i._timestampProvider,
                                    o = i._windowTime;
                                n || (r.push(t), !s && r.push(a.now() + o)),
                                    this._trimBuffer(),
                                    e.prototype.next.call(this, t);
                            }),
                            (t.prototype._subscribe = function (e) {
                                this._throwIfClosed(), this._trimBuffer();
                                for (
                                    var t = this._innerSubscribe(e),
                                        i = this._infiniteTimeWindow,
                                        n = this._buffer.slice(),
                                        r = 0;
                                    r < n.length && !e.closed;
                                    r += i ? 1 : 2
                                )
                                    e.next(n[r]);
                                return this._checkFinalizedStatuses(e), t;
                            }),
                            (t.prototype._trimBuffer = function () {
                                var e = this,
                                    t = e._bufferSize,
                                    i = e._timestampProvider,
                                    n = e._buffer,
                                    r = e._infiniteTimeWindow,
                                    s = (r ? 1 : 2) * t;
                                if (
                                    (t < 1 / 0 &&
                                        s < n.length &&
                                        n.splice(0, n.length - s),
                                    !r)
                                ) {
                                    for (
                                        var a = i.now(), o = 0, c = 1;
                                        c < n.length && n[c] <= a;
                                        c += 2
                                    )
                                        o = c;
                                    o && n.splice(0, o + 1);
                                }
                            }),
                            t
                        );
                    })(W),
                    K = (function (e) {
                        function t(t, i) {
                            return e.call(this) || this;
                        }
                        return (
                            s(t, e),
                            (t.prototype.schedule = function (e, t) {
                                return this;
                            }),
                            t
                        );
                    })(_),
                    ee = {
                        setInterval: function () {
                            for (var e = [], t = 0; t < arguments.length; t++)
                                e[t] = arguments[t];
                            var i = ee.delegate;
                            return (
                                (null == i ? void 0 : i.setInterval) ||
                                setInterval
                            ).apply(void 0, l([], c(e)));
                        },
                        clearInterval: function (e) {
                            var t = ee.delegate;
                            return (
                                (null == t ? void 0 : t.clearInterval) ||
                                clearInterval
                            )(e);
                        },
                        delegate: void 0,
                    },
                    te = (function (e) {
                        function t(t, i) {
                            var n = e.call(this, t, i) || this;
                            return (
                                (n.scheduler = t),
                                (n.work = i),
                                (n.pending = !1),
                                n
                            );
                        }
                        return (
                            s(t, e),
                            (t.prototype.schedule = function (e, t) {
                                if ((void 0 === t && (t = 0), this.closed))
                                    return this;
                                this.state = e;
                                var i = this.id,
                                    n = this.scheduler;
                                return (
                                    null != i &&
                                        (this.id = this.recycleAsyncId(
                                            n,
                                            i,
                                            t
                                        )),
                                    (this.pending = !0),
                                    (this.delay = t),
                                    (this.id =
                                        this.id ||
                                        this.requestAsyncId(n, this.id, t)),
                                    this
                                );
                            }),
                            (t.prototype.requestAsyncId = function (e, t, i) {
                                return (
                                    void 0 === i && (i = 0),
                                    ee.setInterval(e.flush.bind(e, this), i)
                                );
                            }),
                            (t.prototype.recycleAsyncId = function (e, t, i) {
                                if (
                                    (void 0 === i && (i = 0),
                                    null != i &&
                                        this.delay === i &&
                                        !1 === this.pending)
                                )
                                    return t;
                                ee.clearInterval(t);
                            }),
                            (t.prototype.execute = function (e, t) {
                                if (this.closed)
                                    return new Error(
                                        "executing a cancelled action"
                                    );
                                this.pending = !1;
                                var i = this._execute(e, t);
                                if (i) return i;
                                !1 === this.pending &&
                                    null != this.id &&
                                    (this.id = this.recycleAsyncId(
                                        this.scheduler,
                                        this.id,
                                        null
                                    ));
                            }),
                            (t.prototype._execute = function (e, t) {
                                var i,
                                    n = !1;
                                try {
                                    this.work(e);
                                } catch (e) {
                                    (n = !0), (i = (!!e && e) || new Error(e));
                                }
                                if (n) return this.unsubscribe(), i;
                            }),
                            (t.prototype.unsubscribe = function () {
                                if (!this.closed) {
                                    var t = this.id,
                                        i = this.scheduler,
                                        n = i.actions;
                                    (this.work =
                                        this.state =
                                        this.scheduler =
                                            null),
                                        (this.pending = !1),
                                        g(n, this),
                                        null != t &&
                                            (this.id = this.recycleAsyncId(
                                                i,
                                                t,
                                                null
                                            )),
                                        (this.delay = null),
                                        e.prototype.unsubscribe.call(this);
                                }
                            }),
                            t
                        );
                    })(K),
                    ie = (function () {
                        function e(t, i) {
                            void 0 === i && (i = e.now),
                                (this.schedulerActionCtor = t),
                                (this.now = i);
                        }
                        return (
                            (e.prototype.schedule = function (e, t, i) {
                                return (
                                    void 0 === t && (t = 0),
                                    new this.schedulerActionCtor(
                                        this,
                                        e
                                    ).schedule(i, t)
                                );
                            }),
                            (e.now = X.now),
                            e
                        );
                    })(),
                    ne = (function (e) {
                        function t(t, i) {
                            void 0 === i && (i = ie.now);
                            var n = e.call(this, t, i) || this;
                            return (
                                (n.actions = []),
                                (n._active = !1),
                                (n._scheduled = void 0),
                                n
                            );
                        }
                        return (
                            s(t, e),
                            (t.prototype.flush = function (e) {
                                var t = this.actions;
                                if (this._active) t.push(e);
                                else {
                                    var i;
                                    this._active = !0;
                                    do {
                                        if ((i = e.execute(e.state, e.delay)))
                                            break;
                                    } while ((e = t.shift()));
                                    if (((this._active = !1), i)) {
                                        for (; (e = t.shift()); )
                                            e.unsubscribe();
                                        throw i;
                                    }
                                }
                            }),
                            t
                        );
                    })(ie),
                    re = new ne(te),
                    se = re,
                    ae = new $(function (e) {
                        return e.complete();
                    });
                function oe(e) {
                    return e
                        ? (function (e) {
                              return new $(function (t) {
                                  return e.schedule(function () {
                                      return t.complete();
                                  });
                              });
                          })(e)
                        : ae;
                }
                function ce(e, t) {
                    return new $(function (i) {
                        var n = 0;
                        return t.schedule(function () {
                            n === e.length
                                ? i.complete()
                                : (i.next(e[n++]), i.closed || this.schedule());
                        });
                    });
                }
                var le = function (e) {
                    return (
                        e &&
                        "number" == typeof e.length &&
                        "function" != typeof e
                    );
                };
                function he(e) {
                    return u(null == e ? void 0 : e.then);
                }
                var ue =
                    "function" == typeof Symbol && Symbol.iterator
                        ? Symbol.iterator
                        : "@@iterator";
                function de(e, t, i, n) {
                    void 0 === n && (n = 0);
                    var r = t.schedule(function () {
                        try {
                            i.call(this);
                        } catch (t) {
                            e.error(t);
                        }
                    }, n);
                    return e.add(r), r;
                }
                function pe(e, t) {
                    if (!e) throw new Error("Iterable cannot be null");
                    return new $(function (i) {
                        var n = new _();
                        return (
                            n.add(
                                t.schedule(function () {
                                    var r = e[Symbol.asyncIterator]();
                                    n.add(
                                        t.schedule(function () {
                                            var e = this;
                                            r.next().then(function (t) {
                                                t.done
                                                    ? i.complete()
                                                    : (i.next(t.value),
                                                      e.schedule());
                                            });
                                        })
                                    );
                                })
                            ),
                            n
                        );
                    });
                }
                function ge(e) {
                    return u(e[P]);
                }
                function me(e) {
                    return u(null == e ? void 0 : e[ue]);
                }
                function fe(e) {
                    return (
                        Symbol.asyncIterator &&
                        u(null == e ? void 0 : e[Symbol.asyncIterator])
                    );
                }
                function _e(e) {
                    return new TypeError(
                        "You provided " +
                            (null !== e && "object" == typeof e
                                ? "an invalid object"
                                : "'" + e + "'") +
                            " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable."
                    );
                }
                function Me(e) {
                    return (function (e, t, i) {
                        if (!Symbol.asyncIterator)
                            throw new TypeError(
                                "Symbol.asyncIterator is not defined."
                            );
                        var n,
                            r = i.apply(e, t || []),
                            s = [];
                        return (
                            (n = {}),
                            a("next"),
                            a("throw"),
                            a("return"),
                            (n[Symbol.asyncIterator] = function () {
                                return this;
                            }),
                            n
                        );
                        function a(e) {
                            r[e] &&
                                (n[e] = function (t) {
                                    return new Promise(function (i, n) {
                                        s.push([e, t, i, n]) > 1 || o(e, t);
                                    });
                                });
                        }
                        function o(e, t) {
                            try {
                                !(function (e) {
                                    e.value instanceof h
                                        ? Promise.resolve(e.value.v).then(c, l)
                                        : u(s[0][2], e);
                                })(r[e](t));
                            } catch (e) {
                                u(s[0][3], e);
                            }
                        }
                        function c(e) {
                            o("next", e);
                        }
                        function l(e) {
                            o("throw", e);
                        }
                        function u(e, t) {
                            e(t), s.shift(), s.length && o(s[0][0], s[0][1]);
                        }
                    })(this, arguments, function () {
                        var t, i, n;
                        return a(this, function (r) {
                            switch (r.label) {
                                case 0:
                                    (t = e.getReader()), (r.label = 1);
                                case 1:
                                    r.trys.push([1, , 9, 10]), (r.label = 2);
                                case 2:
                                    return [4, h(t.read())];
                                case 3:
                                    return (
                                        (i = r.sent()),
                                        (n = i.value),
                                        i.done ? [4, h(void 0)] : [3, 5]
                                    );
                                case 4:
                                    return [2, r.sent()];
                                case 5:
                                    return [4, h(n)];
                                case 6:
                                    return [4, r.sent()];
                                case 7:
                                    return r.sent(), [3, 2];
                                case 8:
                                    return [3, 10];
                                case 9:
                                    return t.releaseLock(), [7];
                                case 10:
                                    return [2];
                            }
                        });
                    });
                }
                function ve(e) {
                    return u(null == e ? void 0 : e.getReader);
                }
                function ye(e, t) {
                    return t
                        ? (function (e, t) {
                              if (null != e) {
                                  if (ge(e))
                                      return (function (e, t) {
                                          return new $(function (i) {
                                              var n = new _();
                                              return (
                                                  n.add(
                                                      t.schedule(function () {
                                                          var r = e[P]();
                                                          n.add(
                                                              r.subscribe({
                                                                  next: function (
                                                                      e
                                                                  ) {
                                                                      n.add(
                                                                          t.schedule(
                                                                              function () {
                                                                                  return i.next(
                                                                                      e
                                                                                  );
                                                                              }
                                                                          )
                                                                      );
                                                                  },
                                                                  error: function (
                                                                      e
                                                                  ) {
                                                                      n.add(
                                                                          t.schedule(
                                                                              function () {
                                                                                  return i.error(
                                                                                      e
                                                                                  );
                                                                              }
                                                                          )
                                                                      );
                                                                  },
                                                                  complete:
                                                                      function () {
                                                                          n.add(
                                                                              t.schedule(
                                                                                  function () {
                                                                                      return i.complete();
                                                                                  }
                                                                              )
                                                                          );
                                                                      },
                                                              })
                                                          );
                                                      })
                                                  ),
                                                  n
                                              );
                                          });
                                      })(e, t);
                                  if (le(e)) return ce(e, t);
                                  if (he(e))
                                      return (function (e, t) {
                                          return new $(function (i) {
                                              return t.schedule(function () {
                                                  return e.then(
                                                      function (e) {
                                                          i.add(
                                                              t.schedule(
                                                                  function () {
                                                                      i.next(e),
                                                                          i.add(
                                                                              t.schedule(
                                                                                  function () {
                                                                                      return i.complete();
                                                                                  }
                                                                              )
                                                                          );
                                                                  }
                                                              )
                                                          );
                                                      },
                                                      function (e) {
                                                          i.add(
                                                              t.schedule(
                                                                  function () {
                                                                      return i.error(
                                                                          e
                                                                      );
                                                                  }
                                                              )
                                                          );
                                                      }
                                                  );
                                              });
                                          });
                                      })(e, t);
                                  if (fe(e)) return pe(e, t);
                                  if (me(e))
                                      return (function (e, t) {
                                          return new $(function (i) {
                                              var n;
                                              return (
                                                  i.add(
                                                      t.schedule(function () {
                                                          (n = e[ue]()),
                                                              de(
                                                                  i,
                                                                  t,
                                                                  function () {
                                                                      var e =
                                                                              n.next(),
                                                                          t =
                                                                              e.value;
                                                                      e.done
                                                                          ? i.complete()
                                                                          : (i.next(
                                                                                t
                                                                            ),
                                                                            this.schedule());
                                                                  }
                                                              );
                                                      })
                                                  ),
                                                  function () {
                                                      return (
                                                          u(
                                                              null == n
                                                                  ? void 0
                                                                  : n.return
                                                          ) && n.return()
                                                      );
                                                  }
                                              );
                                          });
                                      })(e, t);
                                  if (ve(e))
                                      return (function (e, t) {
                                          return pe(Me(e), t);
                                      })(e, t);
                              }
                              throw _e(e);
                          })(e, t)
                        : xe(e);
                }
                function xe(e) {
                    if (e instanceof $) return e;
                    if (null != e) {
                        if (ge(e))
                            return (
                                (n = e),
                                new $(function (e) {
                                    var t = n[P]();
                                    if (u(t.subscribe)) return t.subscribe(e);
                                    throw new TypeError(
                                        "Provided object does not correctly implement Symbol.observable"
                                    );
                                })
                            );
                        if (le(e)) return be(e);
                        if (he(e))
                            return (
                                (i = e),
                                new $(function (e) {
                                    i.then(
                                        function (t) {
                                            e.closed ||
                                                (e.next(t), e.complete());
                                        },
                                        function (t) {
                                            return e.error(t);
                                        }
                                    ).then(null, N);
                                })
                            );
                        if (fe(e)) return we(e);
                        if (me(e))
                            return (
                                (t = e),
                                new $(function (e) {
                                    var i, n;
                                    try {
                                        for (
                                            var r = o(t), s = r.next();
                                            !s.done;
                                            s = r.next()
                                        ) {
                                            var a = s.value;
                                            if ((e.next(a), e.closed)) return;
                                        }
                                    } catch (e) {
                                        i = { error: e };
                                    } finally {
                                        try {
                                            s &&
                                                !s.done &&
                                                (n = r.return) &&
                                                n.call(r);
                                        } finally {
                                            if (i) throw i.error;
                                        }
                                    }
                                    e.complete();
                                })
                            );
                        if (ve(e)) return we(Me(e));
                    }
                    var t, i, n;
                    throw _e(e);
                }
                function be(e) {
                    return new $(function (t) {
                        for (var i = 0; i < e.length && !t.closed; i++)
                            t.next(e[i]);
                        t.complete();
                    });
                }
                function we(e) {
                    return new $(function (t) {
                        (function (e, t) {
                            var i, n, r, s, c, l, h, u;
                            return (
                                (c = this),
                                (l = void 0),
                                (u = function () {
                                    var c, l;
                                    return a(this, function (a) {
                                        switch (a.label) {
                                            case 0:
                                                a.trys.push([0, 5, 6, 11]),
                                                    (i = (function (e) {
                                                        if (
                                                            !Symbol.asyncIterator
                                                        )
                                                            throw new TypeError(
                                                                "Symbol.asyncIterator is not defined."
                                                            );
                                                        var t,
                                                            i =
                                                                e[
                                                                    Symbol
                                                                        .asyncIterator
                                                                ];
                                                        return i
                                                            ? i.call(e)
                                                            : ((e = o(e)),
                                                              (t = {}),
                                                              n("next"),
                                                              n("throw"),
                                                              n("return"),
                                                              (t[
                                                                  Symbol.asyncIterator
                                                              ] = function () {
                                                                  return this;
                                                              }),
                                                              t);
                                                        function n(i) {
                                                            t[i] =
                                                                e[i] &&
                                                                function (t) {
                                                                    return new Promise(
                                                                        function (
                                                                            n,
                                                                            r
                                                                        ) {
                                                                            !(function (
                                                                                e,
                                                                                t,
                                                                                i,
                                                                                n
                                                                            ) {
                                                                                Promise.resolve(
                                                                                    n
                                                                                ).then(
                                                                                    function (
                                                                                        t
                                                                                    ) {
                                                                                        e(
                                                                                            {
                                                                                                value: t,
                                                                                                done: i,
                                                                                            }
                                                                                        );
                                                                                    },
                                                                                    t
                                                                                );
                                                                            })(
                                                                                n,
                                                                                r,
                                                                                (t =
                                                                                    e[
                                                                                        i
                                                                                    ](
                                                                                        t
                                                                                    ))
                                                                                    .done,
                                                                                t.value
                                                                            );
                                                                        }
                                                                    );
                                                                };
                                                        }
                                                    })(e)),
                                                    (a.label = 1);
                                            case 1:
                                                return [4, i.next()];
                                            case 2:
                                                if ((n = a.sent()).done)
                                                    return [3, 4];
                                                if (
                                                    ((c = n.value),
                                                    t.next(c),
                                                    t.closed)
                                                )
                                                    return [2];
                                                a.label = 3;
                                            case 3:
                                                return [3, 1];
                                            case 4:
                                                return [3, 11];
                                            case 5:
                                                return (
                                                    (l = a.sent()),
                                                    (r = { error: l }),
                                                    [3, 11]
                                                );
                                            case 6:
                                                return (
                                                    a.trys.push([6, , 9, 10]),
                                                    n &&
                                                    !n.done &&
                                                    (s = i.return)
                                                        ? [4, s.call(i)]
                                                        : [3, 8]
                                                );
                                            case 7:
                                                a.sent(), (a.label = 8);
                                            case 8:
                                                return [3, 10];
                                            case 9:
                                                if (r) throw r.error;
                                                return [7];
                                            case 10:
                                                return [7];
                                            case 11:
                                                return t.complete(), [2];
                                        }
                                    });
                                }),
                                new ((h = void 0) || (h = Promise))(function (
                                    e,
                                    t
                                ) {
                                    function i(e) {
                                        try {
                                            r(u.next(e));
                                        } catch (e) {
                                            t(e);
                                        }
                                    }
                                    function n(e) {
                                        try {
                                            r(u.throw(e));
                                        } catch (e) {
                                            t(e);
                                        }
                                    }
                                    function r(t) {
                                        var r;
                                        t.done
                                            ? e(t.value)
                                            : ((r = t.value),
                                              r instanceof h
                                                  ? r
                                                  : new h(function (e) {
                                                        e(r);
                                                    })).then(i, n);
                                    }
                                    r((u = u.apply(c, l || [])).next());
                                })
                            );
                        })(e, t).catch(function (e) {
                            return t.error(e);
                        });
                    });
                }
                function Te(e, t) {
                    return t ? ce(e, t) : be(e);
                }
                function Se(e) {
                    return e && u(e.schedule);
                }
                function Ne(e) {
                    return e[e.length - 1];
                }
                function De(e) {
                    return u(Ne(e)) ? e.pop() : void 0;
                }
                function Ie(e) {
                    return Se(Ne(e)) ? e.pop() : void 0;
                }
                function Ce() {
                    for (var e = [], t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    var i = Ie(e);
                    return i ? ce(e, i) : Te(e);
                }
                function Ae(e, t) {
                    var i = u(e)
                            ? e
                            : function () {
                                  return e;
                              },
                        n = function (e) {
                            return e.error(i());
                        };
                    return new $(
                        t
                            ? function (e) {
                                  return t.schedule(n, 0, e);
                              }
                            : n
                    );
                }
                var Ee = d(function (e) {
                    return function () {
                        e(this),
                            (this.name = "EmptyError"),
                            (this.message = "no elements in sequence");
                    };
                });
                function Le(e) {
                    return e instanceof Date && !isNaN(e);
                }
                var ze = d(function (e) {
                    return function (t) {
                        void 0 === t && (t = null),
                            e(this),
                            (this.message = "Timeout has occurred"),
                            (this.name = "TimeoutError"),
                            (this.info = t);
                    };
                });
                function je(e, t) {
                    var i = Le(e)
                            ? { first: e }
                            : "number" == typeof e
                            ? { each: e }
                            : e,
                        n = i.first,
                        r = i.each,
                        s = i.with,
                        a = void 0 === s ? Oe : s,
                        o = i.scheduler,
                        c = void 0 === o ? (null != t ? t : re) : o,
                        l = i.meta,
                        h = void 0 === l ? null : l;
                    if (null == n && null == r)
                        throw new TypeError("No timeout provided.");
                    return H(function (e, t) {
                        var i,
                            s,
                            o = null,
                            l = 0,
                            u = function (e) {
                                s = de(
                                    t,
                                    c,
                                    function () {
                                        i.unsubscribe(),
                                            xe(
                                                a({
                                                    meta: h,
                                                    lastValue: o,
                                                    seen: l,
                                                })
                                            ).subscribe(t);
                                    },
                                    e
                                );
                            };
                        (i = e.subscribe(
                            new G(
                                t,
                                function (e) {
                                    null == s || s.unsubscribe(),
                                        l++,
                                        t.next((o = e)),
                                        r > 0 && u(r);
                                },
                                void 0,
                                void 0,
                                function () {
                                    (null == s ? void 0 : s.closed) ||
                                        null == s ||
                                        s.unsubscribe(),
                                        (o = null);
                                }
                            )
                        )),
                            u(
                                null != n
                                    ? "number" == typeof n
                                        ? n
                                        : +n - c.now()
                                    : r
                            );
                    });
                }
                function Oe(e) {
                    throw new ze(e);
                }
                function ke(e, t) {
                    return H(function (i, n) {
                        var r = 0;
                        i.subscribe(
                            new G(n, function (i) {
                                n.next(e.call(t, i, r++));
                            })
                        );
                    });
                }
                var Re = Array.isArray;
                function Pe(e) {
                    return ke(function (t) {
                        return (function (e, t) {
                            return Re(t) ? e.apply(void 0, l([], c(t))) : e(t);
                        })(e, t);
                    });
                }
                var Ue = Array.isArray,
                    $e = Object.getPrototypeOf,
                    Be = Object.prototype,
                    Fe = Object.keys;
                function He() {
                    for (var e = [], t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    var i = Ie(e),
                        n = De(e),
                        r = (function (e) {
                            if (1 === e.length) {
                                var t = e[0];
                                if (Ue(t)) return { args: t, keys: null };
                                if (
                                    (n = t) &&
                                    "object" == typeof n &&
                                    $e(n) === Be
                                ) {
                                    var i = Fe(t);
                                    return {
                                        args: i.map(function (e) {
                                            return t[e];
                                        }),
                                        keys: i,
                                    };
                                }
                            }
                            var n;
                            return { args: e, keys: null };
                        })(e),
                        s = r.args,
                        a = r.keys;
                    if (0 === s.length) return ye([], i);
                    var o = new $(
                        (function (e, t, i) {
                            return (
                                void 0 === i && (i = U),
                                function (n) {
                                    Ge(
                                        t,
                                        function () {
                                            for (
                                                var r = e.length,
                                                    s = new Array(r),
                                                    a = r,
                                                    o = r,
                                                    c = function (r) {
                                                        Ge(
                                                            t,
                                                            function () {
                                                                var c = ye(
                                                                        e[r],
                                                                        t
                                                                    ),
                                                                    l = !1;
                                                                c.subscribe(
                                                                    new G(
                                                                        n,
                                                                        function (
                                                                            e
                                                                        ) {
                                                                            (s[
                                                                                r
                                                                            ] =
                                                                                e),
                                                                                l ||
                                                                                    ((l =
                                                                                        !0),
                                                                                    o--),
                                                                                o ||
                                                                                    n.next(
                                                                                        i(
                                                                                            s.slice()
                                                                                        )
                                                                                    );
                                                                        },
                                                                        function () {
                                                                            --a ||
                                                                                n.complete();
                                                                        }
                                                                    )
                                                                );
                                                            },
                                                            n
                                                        );
                                                    },
                                                    l = 0;
                                                l < r;
                                                l++
                                            )
                                                c(l);
                                        },
                                        n
                                    );
                                }
                            );
                        })(
                            s,
                            i,
                            a
                                ? function (e) {
                                      return (function (e, t) {
                                          return e.reduce(function (e, i, n) {
                                              return (e[i] = t[n]), e;
                                          }, {});
                                      })(a, e);
                                  }
                                : U
                        )
                    );
                    return n ? o.pipe(Pe(n)) : o;
                }
                function Ge(e, t, i) {
                    e ? i.add(e.schedule(t)) : t();
                }
                function Ve(e, t, i, n, r, s, a, o) {
                    var c = [],
                        l = 0,
                        h = 0,
                        u = !1,
                        d = function () {
                            !u || c.length || l || t.complete();
                        },
                        p = function (e) {
                            return l < n ? g(e) : c.push(e);
                        },
                        g = function (e) {
                            s && t.next(e), l++;
                            var o = !1;
                            xe(i(e, h++)).subscribe(
                                new G(
                                    t,
                                    function (e) {
                                        null == r || r(e), s ? p(e) : t.next(e);
                                    },
                                    function () {
                                        o = !0;
                                    },
                                    void 0,
                                    function () {
                                        if (o)
                                            try {
                                                l--;
                                                for (
                                                    var e = function () {
                                                        var e = c.shift();
                                                        a
                                                            ? t.add(
                                                                  a.schedule(
                                                                      function () {
                                                                          return g(
                                                                              e
                                                                          );
                                                                      }
                                                                  )
                                                              )
                                                            : g(e);
                                                    };
                                                    c.length && l < n;

                                                )
                                                    e();
                                                d();
                                            } catch (e) {
                                                t.error(e);
                                            }
                                    }
                                )
                            );
                        };
                    return (
                        e.subscribe(
                            new G(t, p, function () {
                                (u = !0), d();
                            })
                        ),
                        function () {
                            null == o || o();
                        }
                    );
                }
                function Ye(e, t, i) {
                    return (
                        void 0 === i && (i = 1 / 0),
                        u(t)
                            ? Ye(function (i, n) {
                                  return ke(function (e, r) {
                                      return t(i, e, n, r);
                                  })(xe(e(i, n)));
                              }, i)
                            : ("number" == typeof t && (i = t),
                              H(function (t, n) {
                                  return Ve(t, n, e, i);
                              }))
                    );
                }
                function qe(e) {
                    return void 0 === e && (e = 1 / 0), Ye(U, e);
                }
                function We() {
                    for (var e = [], t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    return qe(1)(Te(e, Ie(e)));
                }
                var Qe = ["addListener", "removeListener"],
                    Ze = ["addEventListener", "removeEventListener"],
                    Xe = ["on", "off"];
                function Je(e, t, i, n) {
                    if ((u(i) && ((n = i), (i = void 0)), n))
                        return Je(e, t, i).pipe(Pe(n));
                    var r = c(
                            (function (e) {
                                return (
                                    u(e.addEventListener) &&
                                    u(e.removeEventListener)
                                );
                            })(e)
                                ? Ze.map(function (n) {
                                      return function (r) {
                                          return e[n](t, r, i);
                                      };
                                  })
                                : (function (e) {
                                      return (
                                          u(e.addListener) &&
                                          u(e.removeListener)
                                      );
                                  })(e)
                                ? Qe.map(Ke(e, t))
                                : (function (e) {
                                      return u(e.on) && u(e.off);
                                  })(e)
                                ? Xe.map(Ke(e, t))
                                : [],
                            2
                        ),
                        s = r[0],
                        a = r[1];
                    if (!s && le(e))
                        return Ye(function (e) {
                            return Je(e, t, i);
                        })(Te(e));
                    if (!s) throw new TypeError("Invalid event target");
                    return new $(function (e) {
                        var t = function () {
                            for (var t = [], i = 0; i < arguments.length; i++)
                                t[i] = arguments[i];
                            return e.next(1 < t.length ? t : t[0]);
                        };
                        return (
                            s(t),
                            function () {
                                return a(t);
                            }
                        );
                    });
                }
                function Ke(e, t) {
                    return function (i) {
                        return function (n) {
                            return e[i](t, n);
                        };
                    };
                }
                function et(e, t, i) {
                    void 0 === e && (e = 0), void 0 === i && (i = se);
                    var n = -1;
                    return (
                        null != t && (Se(t) ? (i = t) : (n = t)),
                        new $(function (t) {
                            var r = Le(e) ? +e - i.now() : e;
                            r < 0 && (r = 0);
                            var s = 0;
                            return i.schedule(function () {
                                t.closed ||
                                    (t.next(s++),
                                    0 <= n
                                        ? this.schedule(void 0, n)
                                        : t.complete());
                            }, r);
                        })
                    );
                }
                function tt() {
                    for (var e = [], t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    var i = Ie(e),
                        n = (function (e, t) {
                            return "number" == typeof Ne(e) ? e.pop() : 1 / 0;
                        })(e),
                        r = e;
                    return r.length
                        ? 1 === r.length
                            ? xe(r[0])
                            : qe(n)(Te(r, i))
                        : ae;
                }
                var it = Array.isArray;
                function nt(e, t) {
                    return H(function (i, n) {
                        var r = 0;
                        i.subscribe(
                            new G(n, function (i) {
                                return e.call(t, i, r++) && n.next(i);
                            })
                        );
                    });
                }
                function rt() {
                    for (var e = [], t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    var i = De(e),
                        n = (function (e) {
                            return 1 === e.length && it(e[0]) ? e[0] : e;
                        })(e);
                    return n.length
                        ? new $(function (e) {
                              var t = n.map(function () {
                                      return [];
                                  }),
                                  r = n.map(function () {
                                      return !1;
                                  });
                              e.add(function () {
                                  t = r = null;
                              });
                              for (
                                  var s = function (s) {
                                          xe(n[s]).subscribe(
                                              new G(
                                                  e,
                                                  function (n) {
                                                      if (
                                                          (t[s].push(n),
                                                          t.every(function (e) {
                                                              return e.length;
                                                          }))
                                                      ) {
                                                          var a = t.map(
                                                              function (e) {
                                                                  return e.shift();
                                                              }
                                                          );
                                                          e.next(
                                                              i
                                                                  ? i.apply(
                                                                        void 0,
                                                                        l(
                                                                            [],
                                                                            c(a)
                                                                        )
                                                                    )
                                                                  : a
                                                          ),
                                                              t.some(function (
                                                                  e,
                                                                  t
                                                              ) {
                                                                  return (
                                                                      !e.length &&
                                                                      r[t]
                                                                  );
                                                              }) &&
                                                                  e.complete();
                                                      }
                                                  },
                                                  function () {
                                                      (r[s] = !0),
                                                          !t[s].length &&
                                                              e.complete();
                                                  }
                                              )
                                          );
                                      },
                                      a = 0;
                                  !e.closed && a < n.length;
                                  a++
                              )
                                  s(a);
                              return function () {
                                  t = r = null;
                              };
                          })
                        : ae;
                }
                function st(e, t) {
                    return (
                        void 0 === t && (t = se),
                        (i = function () {
                            return et(e, t);
                        }),
                        H(function (e, t) {
                            var n = !1,
                                r = null,
                                s = null,
                                a = !1,
                                o = function () {
                                    if (
                                        (null == s || s.unsubscribe(),
                                        (s = null),
                                        n)
                                    ) {
                                        n = !1;
                                        var e = r;
                                        (r = null), t.next(e);
                                    }
                                    a && t.complete();
                                },
                                c = function () {
                                    (s = null), a && t.complete();
                                };
                            e.subscribe(
                                new G(
                                    t,
                                    function (e) {
                                        (n = !0),
                                            (r = e),
                                            s ||
                                                xe(i()).subscribe(
                                                    (s = new G(t, o, c))
                                                );
                                    },
                                    function () {
                                        (a = !0),
                                            (!n || !s || s.closed) &&
                                                t.complete();
                                    }
                                )
                            );
                        })
                    );
                    var i;
                }
                function at(e, t) {
                    return (
                        void 0 === t && (t = null),
                        (t = null != t ? t : e),
                        H(function (i, n) {
                            var r = [],
                                s = 0;
                            i.subscribe(
                                new G(
                                    n,
                                    function (i) {
                                        var a,
                                            c,
                                            l,
                                            h,
                                            u = null;
                                        s++ % t == 0 && r.push([]);
                                        try {
                                            for (
                                                var d = o(r), p = d.next();
                                                !p.done;
                                                p = d.next()
                                            )
                                                (_ = p.value).push(i),
                                                    e <= _.length &&
                                                        (u =
                                                            null != u
                                                                ? u
                                                                : []).push(_);
                                        } catch (e) {
                                            a = { error: e };
                                        } finally {
                                            try {
                                                p &&
                                                    !p.done &&
                                                    (c = d.return) &&
                                                    c.call(d);
                                            } finally {
                                                if (a) throw a.error;
                                            }
                                        }
                                        if (u)
                                            try {
                                                for (
                                                    var m = o(u), f = m.next();
                                                    !f.done;
                                                    f = m.next()
                                                ) {
                                                    var _ = f.value;
                                                    g(r, _), n.next(_);
                                                }
                                            } catch (e) {
                                                l = { error: e };
                                            } finally {
                                                try {
                                                    f &&
                                                        !f.done &&
                                                        (h = m.return) &&
                                                        h.call(m);
                                                } finally {
                                                    if (l) throw l.error;
                                                }
                                            }
                                    },
                                    function () {
                                        var e, t;
                                        try {
                                            for (
                                                var i = o(r), s = i.next();
                                                !s.done;
                                                s = i.next()
                                            ) {
                                                var a = s.value;
                                                n.next(a);
                                            }
                                        } catch (t) {
                                            e = { error: t };
                                        } finally {
                                            try {
                                                s &&
                                                    !s.done &&
                                                    (t = i.return) &&
                                                    t.call(i);
                                            } finally {
                                                if (e) throw e.error;
                                            }
                                        }
                                        n.complete();
                                    },
                                    void 0,
                                    function () {
                                        r = null;
                                    }
                                )
                            );
                        })
                    );
                }
                function ot(e) {
                    return H(function (t, i) {
                        var n,
                            r = null,
                            s = !1;
                        (r = t.subscribe(
                            new G(i, void 0, void 0, function (a) {
                                (n = xe(e(a, ot(e)(t)))),
                                    r
                                        ? (r.unsubscribe(),
                                          (r = null),
                                          n.subscribe(i))
                                        : (s = !0);
                            })
                        )),
                            s && (r.unsubscribe(), (r = null), n.subscribe(i));
                    });
                }
                function ct(e, t, i, n, r) {
                    return function (s, a) {
                        var o = i,
                            c = t,
                            l = 0;
                        s.subscribe(
                            new G(
                                a,
                                function (t) {
                                    var i = l++;
                                    (c = o ? e(c, t, i) : ((o = !0), t)),
                                        n && a.next(c);
                                },
                                r &&
                                    function () {
                                        o && a.next(c), a.complete();
                                    }
                            )
                        );
                    };
                }
                function lt(e, t) {
                    return H(ct(e, t, arguments.length >= 2, !1, !0));
                }
                function ht(e, t) {
                    return u(t) ? Ye(e, t, 1) : Ye(e, 1);
                }
                var ut = {
                    connector: function () {
                        return new W();
                    },
                };
                function dt(e, t) {
                    void 0 === t && (t = ut);
                    var i = t.connector;
                    return H(function (t, n) {
                        var r,
                            s = i();
                        ye(
                            e(
                                ((r = s),
                                new $(function (e) {
                                    return r.subscribe(e);
                                }))
                            )
                        ).subscribe(n),
                            n.add(t.subscribe(s));
                    });
                }
                function pt(e, t) {
                    return (
                        void 0 === t && (t = re),
                        H(function (i, n) {
                            var r = null,
                                s = null,
                                a = null,
                                o = function () {
                                    if (r) {
                                        r.unsubscribe(), (r = null);
                                        var e = s;
                                        (s = null), n.next(e);
                                    }
                                };
                            function c() {
                                var i = a + e,
                                    s = t.now();
                                if (s < i)
                                    return (
                                        (r = this.schedule(void 0, i - s)),
                                        void n.add(r)
                                    );
                                o();
                            }
                            i.subscribe(
                                new G(
                                    n,
                                    function (i) {
                                        (s = i),
                                            (a = t.now()),
                                            r ||
                                                ((r = t.schedule(c, e)),
                                                n.add(r));
                                    },
                                    function () {
                                        o(), n.complete();
                                    },
                                    void 0,
                                    function () {
                                        s = r = null;
                                    }
                                )
                            );
                        })
                    );
                }
                function gt(e) {
                    return H(function (t, i) {
                        var n = !1;
                        t.subscribe(
                            new G(
                                i,
                                function (e) {
                                    (n = !0), i.next(e);
                                },
                                function () {
                                    n || i.next(e), i.complete();
                                }
                            )
                        );
                    });
                }
                function mt(e) {
                    return e <= 0
                        ? function () {
                              return ae;
                          }
                        : H(function (t, i) {
                              var n = 0;
                              t.subscribe(
                                  new G(i, function (t) {
                                      ++n <= e &&
                                          (i.next(t), e <= n && i.complete());
                                  })
                              );
                          });
                }
                function ft(e, t) {
                    return (
                        void 0 === t && (t = U),
                        (e = null != e ? e : _t),
                        H(function (i, n) {
                            var r,
                                s = !0;
                            i.subscribe(
                                new G(n, function (i) {
                                    var a = t(i);
                                    (!s && e(r, a)) ||
                                        ((s = !1), (r = a), n.next(i));
                                })
                            );
                        })
                    );
                }
                function _t(e, t) {
                    return e === t;
                }
                function Mt(e) {
                    return (
                        void 0 === e && (e = vt),
                        H(function (t, i) {
                            var n = !1;
                            t.subscribe(
                                new G(
                                    i,
                                    function (e) {
                                        (n = !0), i.next(e);
                                    },
                                    function () {
                                        return n ? i.complete() : i.error(e());
                                    }
                                )
                            );
                        })
                    );
                }
                function vt() {
                    return new Ee();
                }
                function yt(e, t, i) {
                    return (
                        void 0 === t && (t = 1 / 0),
                        (t = (t || 0) < 1 ? 1 / 0 : t),
                        H(function (n, r) {
                            return Ve(n, r, e, t, void 0, !0, i);
                        })
                    );
                }
                function xt(e) {
                    return H(function (t, i) {
                        try {
                            t.subscribe(i);
                        } finally {
                            i.add(e);
                        }
                    });
                }
                function bt(e, t) {
                    var i = arguments.length >= 2;
                    return function (n) {
                        return n.pipe(
                            e
                                ? nt(function (t, i) {
                                      return e(t, i, n);
                                  })
                                : U,
                            mt(1),
                            i
                                ? gt(t)
                                : Mt(function () {
                                      return new Ee();
                                  })
                        );
                    };
                }
                function wt(e) {
                    return e <= 0
                        ? function () {
                              return ae;
                          }
                        : H(function (t, i) {
                              var n = [];
                              t.subscribe(
                                  new G(
                                      i,
                                      function (t) {
                                          n.push(t), e < n.length && n.shift();
                                      },
                                      function () {
                                          var e, t;
                                          try {
                                              for (
                                                  var r = o(n), s = r.next();
                                                  !s.done;
                                                  s = r.next()
                                              ) {
                                                  var a = s.value;
                                                  i.next(a);
                                              }
                                          } catch (t) {
                                              e = { error: t };
                                          } finally {
                                              try {
                                                  s &&
                                                      !s.done &&
                                                      (t = r.return) &&
                                                      t.call(r);
                                              } finally {
                                                  if (e) throw e.error;
                                              }
                                          }
                                          i.complete();
                                      },
                                      void 0,
                                      function () {
                                          n = null;
                                      }
                                  )
                              );
                          });
                }
                function Tt(e, t) {
                    var i = arguments.length >= 2;
                    return function (n) {
                        return n.pipe(
                            e
                                ? nt(function (t, i) {
                                      return e(t, i, n);
                                  })
                                : U,
                            wt(1),
                            i
                                ? gt(t)
                                : Mt(function () {
                                      return new Ee();
                                  })
                        );
                    };
                }
                function St(e, t) {
                    var i = u(e)
                        ? e
                        : function () {
                              return e;
                          };
                    return u(t)
                        ? dt(t, { connector: i })
                        : function (e) {
                              return new Y(e, i);
                          };
                }
                function Nt() {
                    return H(function (e, t) {
                        var i,
                            n = !1;
                        e.subscribe(
                            new G(t, function (e) {
                                var r = i;
                                (i = e), n && t.next([r, e]), (n = !0);
                            })
                        );
                    });
                }
                function Dt(e) {
                    return e
                        ? function (t) {
                              return dt(e)(t);
                          }
                        : function (e) {
                              return St(new W())(e);
                          };
                }
                function It(e, t, i, n) {
                    i && !u(i) && (n = i);
                    var r = u(i) ? i : void 0;
                    return function (i) {
                        return St(new J(e, t, n), r)(i);
                    };
                }
                function Ct(e) {
                    var t;
                    void 0 === e && (e = 1 / 0);
                    var i = (t = e && "object" == typeof e ? e : { count: e })
                            .count,
                        n = void 0 === i ? 1 / 0 : i,
                        r = t.delay,
                        s = t.resetOnSuccess,
                        a = void 0 !== s && s;
                    return n <= 0
                        ? U
                        : H(function (e, t) {
                              var i,
                                  s = 0,
                                  o = function () {
                                      var c = !1;
                                      (i = e.subscribe(
                                          new G(
                                              t,
                                              function (e) {
                                                  a && (s = 0), t.next(e);
                                              },
                                              void 0,
                                              function (e) {
                                                  if (s++ < n) {
                                                      var a = function () {
                                                          i
                                                              ? (i.unsubscribe(),
                                                                (i = null),
                                                                o())
                                                              : (c = !0);
                                                      };
                                                      if (null != r) {
                                                          var l =
                                                                  "number" ==
                                                                  typeof r
                                                                      ? et(r)
                                                                      : xe(
                                                                            r(
                                                                                e,
                                                                                s
                                                                            )
                                                                        ),
                                                              h = new G(
                                                                  t,
                                                                  function () {
                                                                      h.unsubscribe(),
                                                                          a();
                                                                  },
                                                                  function () {
                                                                      t.complete();
                                                                  }
                                                              );
                                                          l.subscribe(h);
                                                      } else a();
                                                  } else t.error(e);
                                              }
                                          )
                                      )),
                                          c &&
                                              (i.unsubscribe(),
                                              (i = null),
                                              o());
                                  };
                              o();
                          });
                }
                function At(e, t) {
                    return H(ct(e, t, arguments.length >= 2, !0));
                }
                function Et(e) {
                    void 0 === e && (e = {});
                    var t = e.connector,
                        i =
                            void 0 === t
                                ? function () {
                                      return new W();
                                  }
                                : t,
                        n = e.resetOnError,
                        r = void 0 === n || n,
                        s = e.resetOnComplete,
                        a = void 0 === s || s,
                        o = e.resetOnRefCountZero,
                        c = void 0 === o || o;
                    return function (e) {
                        var t = null,
                            n = null,
                            s = null,
                            o = 0,
                            l = !1,
                            h = !1,
                            u = function () {
                                null == n || n.unsubscribe(), (n = null);
                            },
                            d = function () {
                                u(), (t = s = null), (l = h = !1);
                            },
                            p = function () {
                                var e = t;
                                d(), null == e || e.unsubscribe();
                            };
                        return H(function (e, g) {
                            o++, h || l || u();
                            var m = (s = null != s ? s : i());
                            g.add(function () {
                                0 != --o || h || l || (n = Lt(p, c));
                            }),
                                m.subscribe(g),
                                t ||
                                    ((t = new z({
                                        next: function (e) {
                                            return m.next(e);
                                        },
                                        error: function (e) {
                                            (h = !0),
                                                u(),
                                                (n = Lt(d, r, e)),
                                                m.error(e);
                                        },
                                        complete: function () {
                                            (l = !0),
                                                u(),
                                                (n = Lt(d, a)),
                                                m.complete();
                                        },
                                    })),
                                    ye(e).subscribe(t));
                        })(e);
                    };
                }
                function Lt(e, t) {
                    for (var i = [], n = 2; n < arguments.length; n++)
                        i[n - 2] = arguments[n];
                    return !0 === t
                        ? (e(), null)
                        : !1 === t
                        ? null
                        : t
                              .apply(void 0, l([], c(i)))
                              .pipe(mt(1))
                              .subscribe(function () {
                                  return e();
                              });
                }
                function zt(e) {
                    return nt(function (t, i) {
                        return e <= i;
                    });
                }
                function jt(e) {
                    return H(function (t, i) {
                        var n = !1,
                            r = 0;
                        t.subscribe(
                            new G(i, function (t) {
                                return (n || (n = !e(t, r++))) && i.next(t);
                            })
                        );
                    });
                }
                function Ot() {
                    for (var e = [], t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    var i = Ie(e);
                    return H(function (t, n) {
                        (i ? We(e, t, i) : We(e, t)).subscribe(n);
                    });
                }
                function kt(e, t) {
                    return H(function (i, n) {
                        var r = null,
                            s = 0,
                            a = !1,
                            o = function () {
                                return a && !r && n.complete();
                            };
                        i.subscribe(
                            new G(
                                n,
                                function (i) {
                                    null == r || r.unsubscribe();
                                    var a = 0,
                                        c = s++;
                                    xe(e(i, c)).subscribe(
                                        (r = new G(
                                            n,
                                            function (e) {
                                                return n.next(
                                                    t ? t(i, e, c, a++) : e
                                                );
                                            },
                                            function () {
                                                (r = null), o();
                                            }
                                        ))
                                    );
                                },
                                function () {
                                    (a = !0), o();
                                }
                            )
                        );
                    });
                }
                function Rt(e) {
                    return H(function (t, i) {
                        xe(e).subscribe(
                            new G(
                                i,
                                function () {
                                    return i.complete();
                                },
                                D
                            )
                        ),
                            !i.closed && t.subscribe(i);
                    });
                }
                function Pt(e, t) {
                    return (
                        void 0 === t && (t = !1),
                        H(function (i, n) {
                            var r = 0;
                            i.subscribe(
                                new G(n, function (i) {
                                    var s = e(i, r++);
                                    (s || t) && n.next(i), !s && n.complete();
                                })
                            );
                        })
                    );
                }
                function Ut(e, t, i) {
                    var n =
                        u(e) || t || i ? { next: e, error: t, complete: i } : e;
                    return n
                        ? H(function (e, t) {
                              var i;
                              null === (i = n.subscribe) ||
                                  void 0 === i ||
                                  i.call(n);
                              var r = !0;
                              e.subscribe(
                                  new G(
                                      t,
                                      function (e) {
                                          var i;
                                          null === (i = n.next) ||
                                              void 0 === i ||
                                              i.call(n, e),
                                              t.next(e);
                                      },
                                      function () {
                                          var e;
                                          (r = !1),
                                              null === (e = n.complete) ||
                                                  void 0 === e ||
                                                  e.call(n),
                                              t.complete();
                                      },
                                      function (e) {
                                          var i;
                                          (r = !1),
                                              null === (i = n.error) ||
                                                  void 0 === i ||
                                                  i.call(n, e),
                                              t.error(e);
                                      },
                                      function () {
                                          var e, t;
                                          r &&
                                              (null === (e = n.unsubscribe) ||
                                                  void 0 === e ||
                                                  e.call(n)),
                                              null === (t = n.finalize) ||
                                                  void 0 === t ||
                                                  t.call(n);
                                      }
                                  )
                              );
                          })
                        : U;
                }
                function $t() {
                    for (var e = [], t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    var i = De(e);
                    return H(function (t, n) {
                        for (
                            var r = e.length,
                                s = new Array(r),
                                a = e.map(function () {
                                    return !1;
                                }),
                                o = !1,
                                h = function (t) {
                                    xe(e[t]).subscribe(
                                        new G(
                                            n,
                                            function (e) {
                                                (s[t] = e),
                                                    o ||
                                                        a[t] ||
                                                        ((a[t] = !0),
                                                        (o = a.every(U)) &&
                                                            (a = null));
                                            },
                                            D
                                        )
                                    );
                                },
                                u = 0;
                            u < r;
                            u++
                        )
                            h(u);
                        t.subscribe(
                            new G(n, function (e) {
                                if (o) {
                                    var t = l([e], c(s));
                                    n.next(
                                        i ? i.apply(void 0, l([], c(t))) : t
                                    );
                                }
                            })
                        );
                    });
                }
                class Bt {
                    createFilter(e) {
                        return new Function(
                            "node",
                            "return " + this._compile(e) + ";"
                        );
                    }
                    _compile(e) {
                        if (null == e || e.length <= 1) return "true";
                        const t = e[0];
                        return (
                            "(" +
                            ("==" === t
                                ? this._compileComparisonOp(
                                      "===",
                                      e[1],
                                      e[2],
                                      !1
                                  )
                                : "!=" === t
                                ? this._compileComparisonOp(
                                      "!==",
                                      e[1],
                                      e[2],
                                      !1
                                  )
                                : ">" === t ||
                                  ">=" === t ||
                                  "<" === t ||
                                  "<=" === t
                                ? this._compileComparisonOp(t, e[1], e[2], !0)
                                : "in" === t
                                ? this._compileInOp(e[1], e.slice(2))
                                : "!in" === t
                                ? this._compileNegation(
                                      this._compileInOp(e[1], e.slice(2))
                                  )
                                : "all" === t
                                ? this._compileLogicalOp(e.slice(1), "&&")
                                : "true") +
                            ")"
                        );
                    }
                    _compare(e, t) {
                        return e < t ? -1 : e > t ? 1 : 0;
                    }
                    _compileComparisonOp(e, t, i, n) {
                        const r = this._compilePropertyReference(t),
                            s = JSON.stringify(i);
                        return (
                            (n ? "typeof " + r + "===typeof " + s + "&&" : "") +
                            r +
                            e +
                            s
                        );
                    }
                    _compileInOp(e, t) {
                        const i = this._compare;
                        return (
                            JSON.stringify(t.sort(i)) +
                            ".indexOf(" +
                            this._compilePropertyReference(e) +
                            ")!==-1"
                        );
                    }
                    _compileLogicalOp(e, t) {
                        const i = this._compile.bind(this);
                        return e.map(i).join(t);
                    }
                    _compileNegation(e) {
                        return "!(" + e + ")";
                    }
                    _compilePropertyReference(e) {
                        return "node[" + JSON.stringify(e) + "]";
                    }
                }
                const Ft = 0,
                    Ht = 1,
                    Gt = 2,
                    Vt = 1,
                    Yt = 2,
                    qt = 3,
                    Wt = 0,
                    Qt = 1,
                    Zt = 2,
                    Xt = 0,
                    Jt = 1,
                    Kt = 2,
                    ei = 3,
                    ti = 4,
                    ii = 5,
                    ni = 100,
                    ri = 101,
                    si = 102,
                    ai = 103,
                    oi = 104,
                    ci = 200,
                    li = 201,
                    hi = 202,
                    ui = 203,
                    di = 204,
                    pi = 205,
                    gi = 206,
                    mi = 207,
                    fi = 208,
                    _i = 209,
                    Mi = 210,
                    vi = 0,
                    yi = 1,
                    xi = 2,
                    bi = 3,
                    wi = 4,
                    Ti = 5,
                    Si = 6,
                    Ni = 7,
                    Di = 0,
                    Ii = 1,
                    Ci = 2,
                    Ai = 0,
                    Ei = 1,
                    Li = 2,
                    zi = 3,
                    ji = 4,
                    Oi = 5,
                    ki = 301,
                    Ri = 302,
                    Pi = 303,
                    Ui = 304,
                    $i = 306,
                    Bi = 307,
                    Fi = 1e3,
                    Hi = 1001,
                    Gi = 1002,
                    Vi = 1003,
                    Yi = 1004,
                    qi = 1005,
                    Wi = 1006,
                    Qi = 1007,
                    Zi = 1008,
                    Xi = 1009,
                    Ji = 1010,
                    Ki = 1011,
                    en = 1012,
                    tn = 1013,
                    nn = 1014,
                    rn = 1015,
                    sn = 1016,
                    an = 1017,
                    on = 1018,
                    cn = 1019,
                    ln = 1020,
                    hn = 1021,
                    un = 1022,
                    dn = 1023,
                    pn = 1024,
                    gn = 1025,
                    mn = dn,
                    fn = 1026,
                    _n = 1027,
                    Mn = 1028,
                    vn = 1029,
                    yn = 1030,
                    xn = 1031,
                    bn = 1032,
                    wn = 1033,
                    Tn = 33776,
                    Sn = 33777,
                    Nn = 33778,
                    Dn = 33779,
                    In = 35840,
                    Cn = 35841,
                    An = 35842,
                    En = 35843,
                    Ln = 36196,
                    zn = 37492,
                    jn = 37496,
                    On = 37808,
                    kn = 37809,
                    Rn = 37810,
                    Pn = 37811,
                    Un = 37812,
                    $n = 37813,
                    Bn = 37814,
                    Fn = 37815,
                    Hn = 37816,
                    Gn = 37817,
                    Vn = 37818,
                    Yn = 37819,
                    qn = 37820,
                    Wn = 37821,
                    Qn = 36492,
                    Zn = 37840,
                    Xn = 37841,
                    Jn = 37842,
                    Kn = 37843,
                    er = 37844,
                    tr = 37845,
                    ir = 37846,
                    nr = 37847,
                    rr = 37848,
                    sr = 37849,
                    ar = 37850,
                    or = 37851,
                    cr = 37852,
                    lr = 37853,
                    hr = 2300,
                    ur = 2301,
                    dr = 2302,
                    pr = 2400,
                    gr = 2401,
                    mr = 2402,
                    fr = 3e3,
                    _r = 3001,
                    Mr = 3007,
                    vr = 3002,
                    yr = 3003,
                    xr = 3004,
                    br = 3005,
                    wr = 3006,
                    Tr = 3201,
                    Sr = 0,
                    Nr = 1,
                    Dr = 7680,
                    Ir = 35044,
                    Cr = 35048,
                    Ar = "300 es";
                class Er {
                    addEventListener(e, t) {
                        void 0 === this._listeners && (this._listeners = {});
                        const i = this._listeners;
                        void 0 === i[e] && (i[e] = []),
                            -1 === i[e].indexOf(t) && i[e].push(t);
                    }
                    hasEventListener(e, t) {
                        if (void 0 === this._listeners) return !1;
                        const i = this._listeners;
                        return void 0 !== i[e] && -1 !== i[e].indexOf(t);
                    }
                    removeEventListener(e, t) {
                        if (void 0 === this._listeners) return;
                        const i = this._listeners[e];
                        if (void 0 !== i) {
                            const e = i.indexOf(t);
                            -1 !== e && i.splice(e, 1);
                        }
                    }
                    dispatchEvent(e) {
                        if (void 0 === this._listeners) return;
                        const t = this._listeners[e.type];
                        if (void 0 !== t) {
                            e.target = this;
                            const i = t.slice(0);
                            for (let t = 0, n = i.length; t < n; t++)
                                i[t].call(this, e);
                            e.target = null;
                        }
                    }
                }
                let Lr = 1234567;
                const zr = Math.PI / 180,
                    jr = 180 / Math.PI,
                    Or = [];
                for (let e = 0; e < 256; e++)
                    Or[e] = (e < 16 ? "0" : "") + e.toString(16);
                const kr =
                    "undefined" != typeof crypto && "randomUUID" in crypto;
                function Rr() {
                    if (kr) return crypto.randomUUID().toUpperCase();
                    const e = (4294967295 * Math.random()) | 0,
                        t = (4294967295 * Math.random()) | 0,
                        i = (4294967295 * Math.random()) | 0,
                        n = (4294967295 * Math.random()) | 0;
                    return (
                        Or[255 & e] +
                        Or[(e >> 8) & 255] +
                        Or[(e >> 16) & 255] +
                        Or[(e >> 24) & 255] +
                        "-" +
                        Or[255 & t] +
                        Or[(t >> 8) & 255] +
                        "-" +
                        Or[((t >> 16) & 15) | 64] +
                        Or[(t >> 24) & 255] +
                        "-" +
                        Or[(63 & i) | 128] +
                        Or[(i >> 8) & 255] +
                        "-" +
                        Or[(i >> 16) & 255] +
                        Or[(i >> 24) & 255] +
                        Or[255 & n] +
                        Or[(n >> 8) & 255] +
                        Or[(n >> 16) & 255] +
                        Or[(n >> 24) & 255]
                    ).toUpperCase();
                }
                function Pr(e, t, i) {
                    return Math.max(t, Math.min(i, e));
                }
                function Ur(e, t) {
                    return ((e % t) + t) % t;
                }
                function $r(e, t, i) {
                    return (1 - i) * e + i * t;
                }
                function Br(e) {
                    return !(e & (e - 1)) && 0 !== e;
                }
                function Fr(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
                }
                var Hr = Object.freeze({
                    __proto__: null,
                    DEG2RAD: zr,
                    RAD2DEG: jr,
                    generateUUID: Rr,
                    clamp: Pr,
                    euclideanModulo: Ur,
                    mapLinear: function (e, t, i, n, r) {
                        return n + ((e - t) * (r - n)) / (i - t);
                    },
                    inverseLerp: function (e, t, i) {
                        return e !== t ? (i - e) / (t - e) : 0;
                    },
                    lerp: $r,
                    damp: function (e, t, i, n) {
                        return $r(e, t, 1 - Math.exp(-i * n));
                    },
                    pingpong: function (e, t = 1) {
                        return t - Math.abs(Ur(e, 2 * t) - t);
                    },
                    smoothstep: function (e, t, i) {
                        return e <= t
                            ? 0
                            : e >= i
                            ? 1
                            : (e = (e - t) / (i - t)) * e * (3 - 2 * e);
                    },
                    smootherstep: function (e, t, i) {
                        return e <= t
                            ? 0
                            : e >= i
                            ? 1
                            : (e = (e - t) / (i - t)) *
                              e *
                              e *
                              (e * (6 * e - 15) + 10);
                    },
                    randInt: function (e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1));
                    },
                    randFloat: function (e, t) {
                        return e + Math.random() * (t - e);
                    },
                    randFloatSpread: function (e) {
                        return e * (0.5 - Math.random());
                    },
                    seededRandom: function (e) {
                        return (
                            void 0 !== e && (Lr = e % 2147483647),
                            (Lr = (16807 * Lr) % 2147483647),
                            (Lr - 1) / 2147483646
                        );
                    },
                    degToRad: function (e) {
                        return e * zr;
                    },
                    radToDeg: function (e) {
                        return e * jr;
                    },
                    isPowerOfTwo: Br,
                    ceilPowerOfTwo: function (e) {
                        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
                    },
                    floorPowerOfTwo: Fr,
                    setQuaternionFromProperEuler: function (e, t, i, n, r) {
                        const s = Math.cos,
                            a = Math.sin,
                            o = s(i / 2),
                            c = a(i / 2),
                            l = s((t + n) / 2),
                            h = a((t + n) / 2),
                            u = s((t - n) / 2),
                            d = a((t - n) / 2),
                            p = s((n - t) / 2),
                            g = a((n - t) / 2);
                        switch (r) {
                            case "XYX":
                                e.set(o * h, c * u, c * d, o * l);
                                break;
                            case "YZY":
                                e.set(c * d, o * h, c * u, o * l);
                                break;
                            case "ZXZ":
                                e.set(c * u, c * d, o * h, o * l);
                                break;
                            case "XZX":
                                e.set(o * h, c * g, c * p, o * l);
                                break;
                            case "YXY":
                                e.set(c * p, o * h, c * g, o * l);
                                break;
                            case "ZYZ":
                                e.set(c * g, c * p, o * h, o * l);
                                break;
                            default:
                                console.warn(
                                    "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                                        r
                                );
                        }
                    },
                });
                class Gr {
                    constructor(e = 0, t = 0) {
                        (this.x = e), (this.y = t);
                    }
                    get width() {
                        return this.x;
                    }
                    set width(e) {
                        this.x = e;
                    }
                    get height() {
                        return this.y;
                    }
                    set height(e) {
                        this.y = e;
                    }
                    set(e, t) {
                        return (this.x = e), (this.y = t), this;
                    }
                    setScalar(e) {
                        return (this.x = e), (this.y = e), this;
                    }
                    setX(e) {
                        return (this.x = e), this;
                    }
                    setY(e) {
                        return (this.y = e), this;
                    }
                    setComponent(e, t) {
                        switch (e) {
                            case 0:
                                this.x = t;
                                break;
                            case 1:
                                this.y = t;
                                break;
                            default:
                                throw new Error("index is out of range: " + e);
                        }
                        return this;
                    }
                    getComponent(e) {
                        switch (e) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error("index is out of range: " + e);
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y);
                    }
                    copy(e) {
                        return (this.x = e.x), (this.y = e.y), this;
                    }
                    add(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                              ),
                              this.addVectors(e, t))
                            : ((this.x += e.x), (this.y += e.y), this);
                    }
                    addScalar(e) {
                        return (this.x += e), (this.y += e), this;
                    }
                    addVectors(e, t) {
                        return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
                    }
                    addScaledVector(e, t) {
                        return (this.x += e.x * t), (this.y += e.y * t), this;
                    }
                    sub(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                              ),
                              this.subVectors(e, t))
                            : ((this.x -= e.x), (this.y -= e.y), this);
                    }
                    subScalar(e) {
                        return (this.x -= e), (this.y -= e), this;
                    }
                    subVectors(e, t) {
                        return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
                    }
                    multiply(e) {
                        return (this.x *= e.x), (this.y *= e.y), this;
                    }
                    multiplyScalar(e) {
                        return (this.x *= e), (this.y *= e), this;
                    }
                    divide(e) {
                        return (this.x /= e.x), (this.y /= e.y), this;
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e);
                    }
                    applyMatrix3(e) {
                        const t = this.x,
                            i = this.y,
                            n = e.elements;
                        return (
                            (this.x = n[0] * t + n[3] * i + n[6]),
                            (this.y = n[1] * t + n[4] * i + n[7]),
                            this
                        );
                    }
                    min(e) {
                        return (
                            (this.x = Math.min(this.x, e.x)),
                            (this.y = Math.min(this.y, e.y)),
                            this
                        );
                    }
                    max(e) {
                        return (
                            (this.x = Math.max(this.x, e.x)),
                            (this.y = Math.max(this.y, e.y)),
                            this
                        );
                    }
                    clamp(e, t) {
                        return (
                            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
                            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
                            this
                        );
                    }
                    clampScalar(e, t) {
                        return (
                            (this.x = Math.max(e, Math.min(t, this.x))),
                            (this.y = Math.max(e, Math.min(t, this.y))),
                            this
                        );
                    }
                    clampLength(e, t) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(
                            Math.max(e, Math.min(t, i))
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            this
                        );
                    }
                    negate() {
                        return (this.x = -this.x), (this.y = -this.y), this;
                    }
                    dot(e) {
                        return this.x * e.x + this.y * e.y;
                    }
                    cross(e) {
                        return this.x * e.y - this.y * e.x;
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y;
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y);
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y);
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI;
                    }
                    distanceTo(e) {
                        return Math.sqrt(this.distanceToSquared(e));
                    }
                    distanceToSquared(e) {
                        const t = this.x - e.x,
                            i = this.y - e.y;
                        return t * t + i * i;
                    }
                    manhattanDistanceTo(e) {
                        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e);
                    }
                    lerp(e, t) {
                        return (
                            (this.x += (e.x - this.x) * t),
                            (this.y += (e.y - this.y) * t),
                            this
                        );
                    }
                    lerpVectors(e, t, i) {
                        return (
                            (this.x = e.x + (t.x - e.x) * i),
                            (this.y = e.y + (t.y - e.y) * i),
                            this
                        );
                    }
                    equals(e) {
                        return e.x === this.x && e.y === this.y;
                    }
                    fromArray(e, t = 0) {
                        return (this.x = e[t]), (this.y = e[t + 1]), this;
                    }
                    toArray(e = [], t = 0) {
                        return (e[t] = this.x), (e[t + 1] = this.y), e;
                    }
                    fromBufferAttribute(e, t, i) {
                        return (
                            void 0 !== i &&
                                console.warn(
                                    "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
                                ),
                            (this.x = e.getX(t)),
                            (this.y = e.getY(t)),
                            this
                        );
                    }
                    rotateAround(e, t) {
                        const i = Math.cos(t),
                            n = Math.sin(t),
                            r = this.x - e.x,
                            s = this.y - e.y;
                        return (
                            (this.x = r * i - s * n + e.x),
                            (this.y = r * n + s * i + e.y),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y;
                    }
                }
                Gr.prototype.isVector2 = !0;
                class Vr {
                    constructor() {
                        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                            arguments.length > 0 &&
                                console.error(
                                    "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
                                );
                    }
                    set(e, t, i, n, r, s, a, o, c) {
                        const l = this.elements;
                        return (
                            (l[0] = e),
                            (l[1] = n),
                            (l[2] = a),
                            (l[3] = t),
                            (l[4] = r),
                            (l[5] = o),
                            (l[6] = i),
                            (l[7] = s),
                            (l[8] = c),
                            this
                        );
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                    }
                    copy(e) {
                        const t = this.elements,
                            i = e.elements;
                        return (
                            (t[0] = i[0]),
                            (t[1] = i[1]),
                            (t[2] = i[2]),
                            (t[3] = i[3]),
                            (t[4] = i[4]),
                            (t[5] = i[5]),
                            (t[6] = i[6]),
                            (t[7] = i[7]),
                            (t[8] = i[8]),
                            this
                        );
                    }
                    extractBasis(e, t, i) {
                        return (
                            e.setFromMatrix3Column(this, 0),
                            t.setFromMatrix3Column(this, 1),
                            i.setFromMatrix3Column(this, 2),
                            this
                        );
                    }
                    setFromMatrix4(e) {
                        const t = e.elements;
                        return (
                            this.set(
                                t[0],
                                t[4],
                                t[8],
                                t[1],
                                t[5],
                                t[9],
                                t[2],
                                t[6],
                                t[10]
                            ),
                            this
                        );
                    }
                    multiply(e) {
                        return this.multiplyMatrices(this, e);
                    }
                    premultiply(e) {
                        return this.multiplyMatrices(e, this);
                    }
                    multiplyMatrices(e, t) {
                        const i = e.elements,
                            n = t.elements,
                            r = this.elements,
                            s = i[0],
                            a = i[3],
                            o = i[6],
                            c = i[1],
                            l = i[4],
                            h = i[7],
                            u = i[2],
                            d = i[5],
                            p = i[8],
                            g = n[0],
                            m = n[3],
                            f = n[6],
                            _ = n[1],
                            M = n[4],
                            v = n[7],
                            y = n[2],
                            x = n[5],
                            b = n[8];
                        return (
                            (r[0] = s * g + a * _ + o * y),
                            (r[3] = s * m + a * M + o * x),
                            (r[6] = s * f + a * v + o * b),
                            (r[1] = c * g + l * _ + h * y),
                            (r[4] = c * m + l * M + h * x),
                            (r[7] = c * f + l * v + h * b),
                            (r[2] = u * g + d * _ + p * y),
                            (r[5] = u * m + d * M + p * x),
                            (r[8] = u * f + d * v + p * b),
                            this
                        );
                    }
                    multiplyScalar(e) {
                        const t = this.elements;
                        return (
                            (t[0] *= e),
                            (t[3] *= e),
                            (t[6] *= e),
                            (t[1] *= e),
                            (t[4] *= e),
                            (t[7] *= e),
                            (t[2] *= e),
                            (t[5] *= e),
                            (t[8] *= e),
                            this
                        );
                    }
                    determinant() {
                        const e = this.elements,
                            t = e[0],
                            i = e[1],
                            n = e[2],
                            r = e[3],
                            s = e[4],
                            a = e[5],
                            o = e[6],
                            c = e[7],
                            l = e[8];
                        return (
                            t * s * l -
                            t * a * c -
                            i * r * l +
                            i * a * o +
                            n * r * c -
                            n * s * o
                        );
                    }
                    invert() {
                        const e = this.elements,
                            t = e[0],
                            i = e[1],
                            n = e[2],
                            r = e[3],
                            s = e[4],
                            a = e[5],
                            o = e[6],
                            c = e[7],
                            l = e[8],
                            h = l * s - a * c,
                            u = a * o - l * r,
                            d = c * r - s * o,
                            p = t * h + i * u + n * d;
                        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const g = 1 / p;
                        return (
                            (e[0] = h * g),
                            (e[1] = (n * c - l * i) * g),
                            (e[2] = (a * i - n * s) * g),
                            (e[3] = u * g),
                            (e[4] = (l * t - n * o) * g),
                            (e[5] = (n * r - a * t) * g),
                            (e[6] = d * g),
                            (e[7] = (i * o - c * t) * g),
                            (e[8] = (s * t - i * r) * g),
                            this
                        );
                    }
                    transpose() {
                        let e;
                        const t = this.elements;
                        return (
                            (e = t[1]),
                            (t[1] = t[3]),
                            (t[3] = e),
                            (e = t[2]),
                            (t[2] = t[6]),
                            (t[6] = e),
                            (e = t[5]),
                            (t[5] = t[7]),
                            (t[7] = e),
                            this
                        );
                    }
                    getNormalMatrix(e) {
                        return this.setFromMatrix4(e).invert().transpose();
                    }
                    transposeIntoArray(e) {
                        const t = this.elements;
                        return (
                            (e[0] = t[0]),
                            (e[1] = t[3]),
                            (e[2] = t[6]),
                            (e[3] = t[1]),
                            (e[4] = t[4]),
                            (e[5] = t[7]),
                            (e[6] = t[2]),
                            (e[7] = t[5]),
                            (e[8] = t[8]),
                            this
                        );
                    }
                    setUvTransform(e, t, i, n, r, s, a) {
                        const o = Math.cos(r),
                            c = Math.sin(r);
                        return (
                            this.set(
                                i * o,
                                i * c,
                                -i * (o * s + c * a) + s + e,
                                -n * c,
                                n * o,
                                -n * (-c * s + o * a) + a + t,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    scale(e, t) {
                        const i = this.elements;
                        return (
                            (i[0] *= e),
                            (i[3] *= e),
                            (i[6] *= e),
                            (i[1] *= t),
                            (i[4] *= t),
                            (i[7] *= t),
                            this
                        );
                    }
                    rotate(e) {
                        const t = Math.cos(e),
                            i = Math.sin(e),
                            n = this.elements,
                            r = n[0],
                            s = n[3],
                            a = n[6],
                            o = n[1],
                            c = n[4],
                            l = n[7];
                        return (
                            (n[0] = t * r + i * o),
                            (n[3] = t * s + i * c),
                            (n[6] = t * a + i * l),
                            (n[1] = -i * r + t * o),
                            (n[4] = -i * s + t * c),
                            (n[7] = -i * a + t * l),
                            this
                        );
                    }
                    translate(e, t) {
                        const i = this.elements;
                        return (
                            (i[0] += e * i[2]),
                            (i[3] += e * i[5]),
                            (i[6] += e * i[8]),
                            (i[1] += t * i[2]),
                            (i[4] += t * i[5]),
                            (i[7] += t * i[8]),
                            this
                        );
                    }
                    equals(e) {
                        const t = this.elements,
                            i = e.elements;
                        for (let e = 0; e < 9; e++)
                            if (t[e] !== i[e]) return !1;
                        return !0;
                    }
                    fromArray(e, t = 0) {
                        for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
                        return this;
                    }
                    toArray(e = [], t = 0) {
                        const i = this.elements;
                        return (
                            (e[t] = i[0]),
                            (e[t + 1] = i[1]),
                            (e[t + 2] = i[2]),
                            (e[t + 3] = i[3]),
                            (e[t + 4] = i[4]),
                            (e[t + 5] = i[5]),
                            (e[t + 6] = i[6]),
                            (e[t + 7] = i[7]),
                            (e[t + 8] = i[8]),
                            e
                        );
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements);
                    }
                }
                function Yr(e) {
                    if (0 === e.length) return -1 / 0;
                    let t = e[0];
                    for (let i = 1, n = e.length; i < n; ++i)
                        e[i] > t && (t = e[i]);
                    return t;
                }
                function qr(e) {
                    return document.createElementNS(
                        "http://www.w3.org/1999/xhtml",
                        e
                    );
                }
                function Wr(e, t = 0) {
                    let i = 3735928559 ^ t,
                        n = 1103547991 ^ t;
                    for (let t, r = 0; r < e.length; r++)
                        (t = e.charCodeAt(r)),
                            (i = Math.imul(i ^ t, 2654435761)),
                            (n = Math.imul(n ^ t, 1597334677));
                    return (
                        (i =
                            Math.imul(i ^ (i >>> 16), 2246822507) ^
                            Math.imul(n ^ (n >>> 13), 3266489909)),
                        (n =
                            Math.imul(n ^ (n >>> 16), 2246822507) ^
                            Math.imul(i ^ (i >>> 13), 3266489909)),
                        4294967296 * (2097151 & n) + (i >>> 0)
                    );
                }
                let Qr;
                Vr.prototype.isMatrix3 = !0;
                class Zr {
                    static getDataURL(e) {
                        if (/^data:/i.test(e.src)) return e.src;
                        if ("undefined" == typeof HTMLCanvasElement)
                            return e.src;
                        let t;
                        if (e instanceof HTMLCanvasElement) t = e;
                        else {
                            void 0 === Qr && (Qr = qr("canvas")),
                                (Qr.width = e.width),
                                (Qr.height = e.height);
                            const i = Qr.getContext("2d");
                            e instanceof ImageData
                                ? i.putImageData(e, 0, 0)
                                : i.drawImage(e, 0, 0, e.width, e.height),
                                (t = Qr);
                        }
                        return t.width > 2048 || t.height > 2048
                            ? (console.warn(
                                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                                  e
                              ),
                              t.toDataURL("image/jpeg", 0.6))
                            : t.toDataURL("image/png");
                    }
                }
                let Xr = 0;
                class Jr extends Er {
                    constructor(
                        e = Jr.DEFAULT_IMAGE,
                        t = Jr.DEFAULT_MAPPING,
                        i = Hi,
                        n = Hi,
                        r = Wi,
                        s = Zi,
                        a = dn,
                        o = Xi,
                        c = 1,
                        l = fr
                    ) {
                        super(),
                            Object.defineProperty(this, "id", { value: Xr++ }),
                            (this.uuid = Rr()),
                            (this.name = ""),
                            (this.image = e),
                            (this.mipmaps = []),
                            (this.mapping = t),
                            (this.wrapS = i),
                            (this.wrapT = n),
                            (this.magFilter = r),
                            (this.minFilter = s),
                            (this.anisotropy = c),
                            (this.format = a),
                            (this.internalFormat = null),
                            (this.type = o),
                            (this.offset = new Gr(0, 0)),
                            (this.repeat = new Gr(1, 1)),
                            (this.center = new Gr(0, 0)),
                            (this.rotation = 0),
                            (this.matrixAutoUpdate = !0),
                            (this.matrix = new Vr()),
                            (this.generateMipmaps = !0),
                            (this.premultiplyAlpha = !1),
                            (this.flipY = !0),
                            (this.unpackAlignment = 4),
                            (this.encoding = l),
                            (this.userData = {}),
                            (this.version = 0),
                            (this.onUpdate = null),
                            (this.isRenderTargetTexture = !1);
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(
                            this.offset.x,
                            this.offset.y,
                            this.repeat.x,
                            this.repeat.y,
                            this.rotation,
                            this.center.x,
                            this.center.y
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(e) {
                        return (
                            (this.name = e.name),
                            (this.image = e.image),
                            (this.mipmaps = e.mipmaps.slice(0)),
                            (this.mapping = e.mapping),
                            (this.wrapS = e.wrapS),
                            (this.wrapT = e.wrapT),
                            (this.magFilter = e.magFilter),
                            (this.minFilter = e.minFilter),
                            (this.anisotropy = e.anisotropy),
                            (this.format = e.format),
                            (this.internalFormat = e.internalFormat),
                            (this.type = e.type),
                            this.offset.copy(e.offset),
                            this.repeat.copy(e.repeat),
                            this.center.copy(e.center),
                            (this.rotation = e.rotation),
                            (this.matrixAutoUpdate = e.matrixAutoUpdate),
                            this.matrix.copy(e.matrix),
                            (this.generateMipmaps = e.generateMipmaps),
                            (this.premultiplyAlpha = e.premultiplyAlpha),
                            (this.flipY = e.flipY),
                            (this.unpackAlignment = e.unpackAlignment),
                            (this.encoding = e.encoding),
                            (this.userData = JSON.parse(
                                JSON.stringify(e.userData)
                            )),
                            this
                        );
                    }
                    toJSON(e) {
                        const t = void 0 === e || "string" == typeof e;
                        if (!t && void 0 !== e.textures[this.uuid])
                            return e.textures[this.uuid];
                        const i = {
                            metadata: {
                                version: 4.5,
                                type: "Texture",
                                generator: "Texture.toJSON",
                            },
                            uuid: this.uuid,
                            name: this.name,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            type: this.type,
                            encoding: this.encoding,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment,
                        };
                        if (void 0 !== this.image) {
                            const n = this.image;
                            if (
                                (void 0 === n.uuid && (n.uuid = Rr()),
                                !t && void 0 === e.images[n.uuid])
                            ) {
                                let t;
                                if (Array.isArray(n)) {
                                    t = [];
                                    for (let e = 0, i = n.length; e < i; e++)
                                        n[e].isDataTexture
                                            ? t.push(Kr(n[e].image))
                                            : t.push(Kr(n[e]));
                                } else t = Kr(n);
                                e.images[n.uuid] = { uuid: n.uuid, url: t };
                            }
                            i.image = n.uuid;
                        }
                        return (
                            "{}" !== JSON.stringify(this.userData) &&
                                (i.userData = this.userData),
                            t || (e.textures[this.uuid] = i),
                            i
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                    transformUv(e) {
                        if (300 !== this.mapping) return e;
                        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
                            switch (this.wrapS) {
                                case Fi:
                                    e.x = e.x - Math.floor(e.x);
                                    break;
                                case Hi:
                                    e.x = e.x < 0 ? 0 : 1;
                                    break;
                                case Gi:
                                    1 === Math.abs(Math.floor(e.x) % 2)
                                        ? (e.x = Math.ceil(e.x) - e.x)
                                        : (e.x = e.x - Math.floor(e.x));
                            }
                        if (e.y < 0 || e.y > 1)
                            switch (this.wrapT) {
                                case Fi:
                                    e.y = e.y - Math.floor(e.y);
                                    break;
                                case Hi:
                                    e.y = e.y < 0 ? 0 : 1;
                                    break;
                                case Gi:
                                    1 === Math.abs(Math.floor(e.y) % 2)
                                        ? (e.y = Math.ceil(e.y) - e.y)
                                        : (e.y = e.y - Math.floor(e.y));
                            }
                        return this.flipY && (e.y = 1 - e.y), e;
                    }
                    set needsUpdate(e) {
                        !0 === e && this.version++;
                    }
                }
                function Kr(e) {
                    return ("undefined" != typeof HTMLImageElement &&
                        e instanceof HTMLImageElement) ||
                        ("undefined" != typeof HTMLCanvasElement &&
                            e instanceof HTMLCanvasElement) ||
                        ("undefined" != typeof ImageBitmap &&
                            e instanceof ImageBitmap)
                        ? Zr.getDataURL(e)
                        : e.data
                        ? {
                              data: Array.prototype.slice.call(e.data),
                              width: e.width,
                              height: e.height,
                              type: e.data.constructor.name,
                          }
                        : (console.warn(
                              "THREE.Texture: Unable to serialize Texture."
                          ),
                          {});
                }
                (Jr.DEFAULT_IMAGE = void 0),
                    (Jr.DEFAULT_MAPPING = 300),
                    (Jr.prototype.isTexture = !0);
                class es {
                    constructor(e = 0, t = 0, i = 0, n = 1) {
                        (this.x = e), (this.y = t), (this.z = i), (this.w = n);
                    }
                    get width() {
                        return this.z;
                    }
                    set width(e) {
                        this.z = e;
                    }
                    get height() {
                        return this.w;
                    }
                    set height(e) {
                        this.w = e;
                    }
                    set(e, t, i, n) {
                        return (
                            (this.x = e),
                            (this.y = t),
                            (this.z = i),
                            (this.w = n),
                            this
                        );
                    }
                    setScalar(e) {
                        return (
                            (this.x = e),
                            (this.y = e),
                            (this.z = e),
                            (this.w = e),
                            this
                        );
                    }
                    setX(e) {
                        return (this.x = e), this;
                    }
                    setY(e) {
                        return (this.y = e), this;
                    }
                    setZ(e) {
                        return (this.z = e), this;
                    }
                    setW(e) {
                        return (this.w = e), this;
                    }
                    setComponent(e, t) {
                        switch (e) {
                            case 0:
                                this.x = t;
                                break;
                            case 1:
                                this.y = t;
                                break;
                            case 2:
                                this.z = t;
                                break;
                            case 3:
                                this.w = t;
                                break;
                            default:
                                throw new Error("index is out of range: " + e);
                        }
                        return this;
                    }
                    getComponent(e) {
                        switch (e) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error("index is out of range: " + e);
                        }
                    }
                    clone() {
                        return new this.constructor(
                            this.x,
                            this.y,
                            this.z,
                            this.w
                        );
                    }
                    copy(e) {
                        return (
                            (this.x = e.x),
                            (this.y = e.y),
                            (this.z = e.z),
                            (this.w = void 0 !== e.w ? e.w : 1),
                            this
                        );
                    }
                    add(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                              ),
                              this.addVectors(e, t))
                            : ((this.x += e.x),
                              (this.y += e.y),
                              (this.z += e.z),
                              (this.w += e.w),
                              this);
                    }
                    addScalar(e) {
                        return (
                            (this.x += e),
                            (this.y += e),
                            (this.z += e),
                            (this.w += e),
                            this
                        );
                    }
                    addVectors(e, t) {
                        return (
                            (this.x = e.x + t.x),
                            (this.y = e.y + t.y),
                            (this.z = e.z + t.z),
                            (this.w = e.w + t.w),
                            this
                        );
                    }
                    addScaledVector(e, t) {
                        return (
                            (this.x += e.x * t),
                            (this.y += e.y * t),
                            (this.z += e.z * t),
                            (this.w += e.w * t),
                            this
                        );
                    }
                    sub(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                              ),
                              this.subVectors(e, t))
                            : ((this.x -= e.x),
                              (this.y -= e.y),
                              (this.z -= e.z),
                              (this.w -= e.w),
                              this);
                    }
                    subScalar(e) {
                        return (
                            (this.x -= e),
                            (this.y -= e),
                            (this.z -= e),
                            (this.w -= e),
                            this
                        );
                    }
                    subVectors(e, t) {
                        return (
                            (this.x = e.x - t.x),
                            (this.y = e.y - t.y),
                            (this.z = e.z - t.z),
                            (this.w = e.w - t.w),
                            this
                        );
                    }
                    multiply(e) {
                        return (
                            (this.x *= e.x),
                            (this.y *= e.y),
                            (this.z *= e.z),
                            (this.w *= e.w),
                            this
                        );
                    }
                    multiplyScalar(e) {
                        return (
                            (this.x *= e),
                            (this.y *= e),
                            (this.z *= e),
                            (this.w *= e),
                            this
                        );
                    }
                    applyMatrix4(e) {
                        const t = this.x,
                            i = this.y,
                            n = this.z,
                            r = this.w,
                            s = e.elements;
                        return (
                            (this.x =
                                s[0] * t + s[4] * i + s[8] * n + s[12] * r),
                            (this.y =
                                s[1] * t + s[5] * i + s[9] * n + s[13] * r),
                            (this.z =
                                s[2] * t + s[6] * i + s[10] * n + s[14] * r),
                            (this.w =
                                s[3] * t + s[7] * i + s[11] * n + s[15] * r),
                            this
                        );
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e);
                    }
                    setAxisAngleFromQuaternion(e) {
                        this.w = 2 * Math.acos(e.w);
                        const t = Math.sqrt(1 - e.w * e.w);
                        return (
                            t < 1e-4
                                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                                : ((this.x = e.x / t),
                                  (this.y = e.y / t),
                                  (this.z = e.z / t)),
                            this
                        );
                    }
                    setAxisAngleFromRotationMatrix(e) {
                        let t, i, n, r;
                        const s = 0.01,
                            a = 0.1,
                            o = e.elements,
                            c = o[0],
                            l = o[4],
                            h = o[8],
                            u = o[1],
                            d = o[5],
                            p = o[9],
                            g = o[2],
                            m = o[6],
                            f = o[10];
                        if (
                            Math.abs(l - u) < s &&
                            Math.abs(h - g) < s &&
                            Math.abs(p - m) < s
                        ) {
                            if (
                                Math.abs(l + u) < a &&
                                Math.abs(h + g) < a &&
                                Math.abs(p + m) < a &&
                                Math.abs(c + d + f - 3) < a
                            )
                                return this.set(1, 0, 0, 0), this;
                            t = Math.PI;
                            const e = (c + 1) / 2,
                                o = (d + 1) / 2,
                                _ = (f + 1) / 2,
                                M = (l + u) / 4,
                                v = (h + g) / 4,
                                y = (p + m) / 4;
                            return (
                                e > o && e > _
                                    ? e < s
                                        ? ((i = 0),
                                          (n = 0.707106781),
                                          (r = 0.707106781))
                                        : ((i = Math.sqrt(e)),
                                          (n = M / i),
                                          (r = v / i))
                                    : o > _
                                    ? o < s
                                        ? ((i = 0.707106781),
                                          (n = 0),
                                          (r = 0.707106781))
                                        : ((n = Math.sqrt(o)),
                                          (i = M / n),
                                          (r = y / n))
                                    : _ < s
                                    ? ((i = 0.707106781),
                                      (n = 0.707106781),
                                      (r = 0))
                                    : ((r = Math.sqrt(_)),
                                      (i = v / r),
                                      (n = y / r)),
                                this.set(i, n, r, t),
                                this
                            );
                        }
                        let _ = Math.sqrt(
                            (m - p) * (m - p) +
                                (h - g) * (h - g) +
                                (u - l) * (u - l)
                        );
                        return (
                            Math.abs(_) < 0.001 && (_ = 1),
                            (this.x = (m - p) / _),
                            (this.y = (h - g) / _),
                            (this.z = (u - l) / _),
                            (this.w = Math.acos((c + d + f - 1) / 2)),
                            this
                        );
                    }
                    min(e) {
                        return (
                            (this.x = Math.min(this.x, e.x)),
                            (this.y = Math.min(this.y, e.y)),
                            (this.z = Math.min(this.z, e.z)),
                            (this.w = Math.min(this.w, e.w)),
                            this
                        );
                    }
                    max(e) {
                        return (
                            (this.x = Math.max(this.x, e.x)),
                            (this.y = Math.max(this.y, e.y)),
                            (this.z = Math.max(this.z, e.z)),
                            (this.w = Math.max(this.w, e.w)),
                            this
                        );
                    }
                    clamp(e, t) {
                        return (
                            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
                            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
                            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
                            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
                            this
                        );
                    }
                    clampScalar(e, t) {
                        return (
                            (this.x = Math.max(e, Math.min(t, this.x))),
                            (this.y = Math.max(e, Math.min(t, this.y))),
                            (this.z = Math.max(e, Math.min(t, this.z))),
                            (this.w = Math.max(e, Math.min(t, this.w))),
                            this
                        );
                    }
                    clampLength(e, t) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(
                            Math.max(e, Math.min(t, i))
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            (this.z = Math.floor(this.z)),
                            (this.w = Math.floor(this.w)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            (this.z = Math.ceil(this.z)),
                            (this.w = Math.ceil(this.w)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            (this.z = Math.round(this.z)),
                            (this.w = Math.round(this.w)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            (this.z =
                                this.z < 0
                                    ? Math.ceil(this.z)
                                    : Math.floor(this.z)),
                            (this.w =
                                this.w < 0
                                    ? Math.ceil(this.w)
                                    : Math.floor(this.w)),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.x = -this.x),
                            (this.y = -this.y),
                            (this.z = -this.z),
                            (this.w = -this.w),
                            this
                        );
                    }
                    dot(e) {
                        return (
                            this.x * e.x +
                            this.y * e.y +
                            this.z * e.z +
                            this.w * e.w
                        );
                    }
                    lengthSq() {
                        return (
                            this.x * this.x +
                            this.y * this.y +
                            this.z * this.z +
                            this.w * this.w
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this.x * this.x +
                                this.y * this.y +
                                this.z * this.z +
                                this.w * this.w
                        );
                    }
                    manhattanLength() {
                        return (
                            Math.abs(this.x) +
                            Math.abs(this.y) +
                            Math.abs(this.z) +
                            Math.abs(this.w)
                        );
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e);
                    }
                    lerp(e, t) {
                        return (
                            (this.x += (e.x - this.x) * t),
                            (this.y += (e.y - this.y) * t),
                            (this.z += (e.z - this.z) * t),
                            (this.w += (e.w - this.w) * t),
                            this
                        );
                    }
                    lerpVectors(e, t, i) {
                        return (
                            (this.x = e.x + (t.x - e.x) * i),
                            (this.y = e.y + (t.y - e.y) * i),
                            (this.z = e.z + (t.z - e.z) * i),
                            (this.w = e.w + (t.w - e.w) * i),
                            this
                        );
                    }
                    equals(e) {
                        return (
                            e.x === this.x &&
                            e.y === this.y &&
                            e.z === this.z &&
                            e.w === this.w
                        );
                    }
                    fromArray(e, t = 0) {
                        return (
                            (this.x = e[t]),
                            (this.y = e[t + 1]),
                            (this.z = e[t + 2]),
                            (this.w = e[t + 3]),
                            this
                        );
                    }
                    toArray(e = [], t = 0) {
                        return (
                            (e[t] = this.x),
                            (e[t + 1] = this.y),
                            (e[t + 2] = this.z),
                            (e[t + 3] = this.w),
                            e
                        );
                    }
                    fromBufferAttribute(e, t, i) {
                        return (
                            void 0 !== i &&
                                console.warn(
                                    "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
                                ),
                            (this.x = e.getX(t)),
                            (this.y = e.getY(t)),
                            (this.z = e.getZ(t)),
                            (this.w = e.getW(t)),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            (this.z = Math.random()),
                            (this.w = Math.random()),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z, yield this.w;
                    }
                }
                es.prototype.isVector4 = !0;
                class ts extends Er {
                    constructor(e, t, i = {}) {
                        super(),
                            (this.width = e),
                            (this.height = t),
                            (this.depth = 1),
                            (this.scissor = new es(0, 0, e, t)),
                            (this.scissorTest = !1),
                            (this.viewport = new es(0, 0, e, t)),
                            (this.texture = new Jr(
                                void 0,
                                i.mapping,
                                i.wrapS,
                                i.wrapT,
                                i.magFilter,
                                i.minFilter,
                                i.format,
                                i.type,
                                i.anisotropy,
                                i.encoding
                            )),
                            (this.texture.isRenderTargetTexture = !0),
                            (this.texture.image = {
                                width: e,
                                height: t,
                                depth: 1,
                            }),
                            (this.texture.generateMipmaps =
                                void 0 !== i.generateMipmaps &&
                                i.generateMipmaps),
                            (this.texture.internalFormat =
                                void 0 !== i.internalFormat
                                    ? i.internalFormat
                                    : null),
                            (this.texture.minFilter =
                                void 0 !== i.minFilter ? i.minFilter : Wi),
                            (this.depthBuffer =
                                void 0 === i.depthBuffer || i.depthBuffer),
                            (this.stencilBuffer =
                                void 0 !== i.stencilBuffer && i.stencilBuffer),
                            (this.depthTexture =
                                void 0 !== i.depthTexture
                                    ? i.depthTexture
                                    : null);
                    }
                    setTexture(e) {
                        (e.image = {
                            width: this.width,
                            height: this.height,
                            depth: this.depth,
                        }),
                            (this.texture = e);
                    }
                    setSize(e, t, i = 1) {
                        (this.width === e &&
                            this.height === t &&
                            this.depth === i) ||
                            ((this.width = e),
                            (this.height = t),
                            (this.depth = i),
                            (this.texture.image.width = e),
                            (this.texture.image.height = t),
                            (this.texture.image.depth = i),
                            this.dispose()),
                            this.viewport.set(0, 0, e, t),
                            this.scissor.set(0, 0, e, t);
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(e) {
                        return (
                            (this.width = e.width),
                            (this.height = e.height),
                            (this.depth = e.depth),
                            this.viewport.copy(e.viewport),
                            (this.texture = e.texture.clone()),
                            (this.texture.image = { ...this.texture.image }),
                            (this.depthBuffer = e.depthBuffer),
                            (this.stencilBuffer = e.stencilBuffer),
                            (this.depthTexture = e.depthTexture),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                }
                (ts.prototype.isWebGLRenderTarget = !0),
                    (class extends ts {
                        constructor(e, t, i) {
                            super(e, t);
                            const n = this.texture;
                            this.texture = [];
                            for (let e = 0; e < i; e++)
                                this.texture[e] = n.clone();
                        }
                        setSize(e, t, i = 1) {
                            if (
                                this.width !== e ||
                                this.height !== t ||
                                this.depth !== i
                            ) {
                                (this.width = e),
                                    (this.height = t),
                                    (this.depth = i);
                                for (
                                    let n = 0, r = this.texture.length;
                                    n < r;
                                    n++
                                )
                                    (this.texture[n].image.width = e),
                                        (this.texture[n].image.height = t),
                                        (this.texture[n].image.depth = i);
                                this.dispose();
                            }
                            return (
                                this.viewport.set(0, 0, e, t),
                                this.scissor.set(0, 0, e, t),
                                this
                            );
                        }
                        copy(e) {
                            this.dispose(),
                                (this.width = e.width),
                                (this.height = e.height),
                                (this.depth = e.depth),
                                this.viewport.set(
                                    0,
                                    0,
                                    this.width,
                                    this.height
                                ),
                                this.scissor.set(0, 0, this.width, this.height),
                                (this.depthBuffer = e.depthBuffer),
                                (this.stencilBuffer = e.stencilBuffer),
                                (this.depthTexture = e.depthTexture),
                                (this.texture.length = 0);
                            for (let t = 0, i = e.texture.length; t < i; t++)
                                this.texture[t] = e.texture[t].clone();
                            return this;
                        }
                    }.prototype.isWebGLMultipleRenderTargets = !0);
                class is extends ts {
                    constructor(e, t, i) {
                        super(e, t, i), (this.samples = 4);
                    }
                    copy(e) {
                        return (
                            super.copy.call(this, e),
                            (this.samples = e.samples),
                            this
                        );
                    }
                }
                is.prototype.isWebGLMultisampleRenderTarget = !0;
                class ns {
                    constructor(e = 0, t = 0, i = 0, n = 1) {
                        (this._x = e),
                            (this._y = t),
                            (this._z = i),
                            (this._w = n);
                    }
                    static slerp(e, t, i, n) {
                        return (
                            console.warn(
                                "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
                            ),
                            i.slerpQuaternions(e, t, n)
                        );
                    }
                    static slerpFlat(e, t, i, n, r, s, a) {
                        let o = i[n + 0],
                            c = i[n + 1],
                            l = i[n + 2],
                            h = i[n + 3];
                        const u = r[s + 0],
                            d = r[s + 1],
                            p = r[s + 2],
                            g = r[s + 3];
                        if (0 === a)
                            return (
                                (e[t + 0] = o),
                                (e[t + 1] = c),
                                (e[t + 2] = l),
                                void (e[t + 3] = h)
                            );
                        if (1 === a)
                            return (
                                (e[t + 0] = u),
                                (e[t + 1] = d),
                                (e[t + 2] = p),
                                void (e[t + 3] = g)
                            );
                        if (h !== g || o !== u || c !== d || l !== p) {
                            let e = 1 - a;
                            const t = o * u + c * d + l * p + h * g,
                                i = t >= 0 ? 1 : -1,
                                n = 1 - t * t;
                            if (n > Number.EPSILON) {
                                const r = Math.sqrt(n),
                                    s = Math.atan2(r, t * i);
                                (e = Math.sin(e * s) / r),
                                    (a = Math.sin(a * s) / r);
                            }
                            const r = a * i;
                            if (
                                ((o = o * e + u * r),
                                (c = c * e + d * r),
                                (l = l * e + p * r),
                                (h = h * e + g * r),
                                e === 1 - a)
                            ) {
                                const e =
                                    1 /
                                    Math.sqrt(o * o + c * c + l * l + h * h);
                                (o *= e), (c *= e), (l *= e), (h *= e);
                            }
                        }
                        (e[t] = o),
                            (e[t + 1] = c),
                            (e[t + 2] = l),
                            (e[t + 3] = h);
                    }
                    static multiplyQuaternionsFlat(e, t, i, n, r, s) {
                        const a = i[n],
                            o = i[n + 1],
                            c = i[n + 2],
                            l = i[n + 3],
                            h = r[s],
                            u = r[s + 1],
                            d = r[s + 2],
                            p = r[s + 3];
                        return (
                            (e[t] = a * p + l * h + o * d - c * u),
                            (e[t + 1] = o * p + l * u + c * h - a * d),
                            (e[t + 2] = c * p + l * d + a * u - o * h),
                            (e[t + 3] = l * p - a * h - o * u - c * d),
                            e
                        );
                    }
                    get x() {
                        return this._x;
                    }
                    set x(e) {
                        (this._x = e), this._onChangeCallback();
                    }
                    get y() {
                        return this._y;
                    }
                    set y(e) {
                        (this._y = e), this._onChangeCallback();
                    }
                    get z() {
                        return this._z;
                    }
                    set z(e) {
                        (this._z = e), this._onChangeCallback();
                    }
                    get w() {
                        return this._w;
                    }
                    set w(e) {
                        (this._w = e), this._onChangeCallback();
                    }
                    set(e, t, i, n) {
                        return (
                            (this._x = e),
                            (this._y = t),
                            (this._z = i),
                            (this._w = n),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(
                            this._x,
                            this._y,
                            this._z,
                            this._w
                        );
                    }
                    copy(e) {
                        return (
                            (this._x = e.x),
                            (this._y = e.y),
                            (this._z = e.z),
                            (this._w = e.w),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromEuler(e, t) {
                        if (!e || !e.isEuler)
                            throw new Error(
                                "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
                            );
                        const i = e._x,
                            n = e._y,
                            r = e._z,
                            s = e._order,
                            a = Math.cos,
                            o = Math.sin,
                            c = a(i / 2),
                            l = a(n / 2),
                            h = a(r / 2),
                            u = o(i / 2),
                            d = o(n / 2),
                            p = o(r / 2);
                        switch (s) {
                            case "XYZ":
                                (this._x = u * l * h + c * d * p),
                                    (this._y = c * d * h - u * l * p),
                                    (this._z = c * l * p + u * d * h),
                                    (this._w = c * l * h - u * d * p);
                                break;
                            case "YXZ":
                                (this._x = u * l * h + c * d * p),
                                    (this._y = c * d * h - u * l * p),
                                    (this._z = c * l * p - u * d * h),
                                    (this._w = c * l * h + u * d * p);
                                break;
                            case "ZXY":
                                (this._x = u * l * h - c * d * p),
                                    (this._y = c * d * h + u * l * p),
                                    (this._z = c * l * p + u * d * h),
                                    (this._w = c * l * h - u * d * p);
                                break;
                            case "ZYX":
                                (this._x = u * l * h - c * d * p),
                                    (this._y = c * d * h + u * l * p),
                                    (this._z = c * l * p - u * d * h),
                                    (this._w = c * l * h + u * d * p);
                                break;
                            case "YZX":
                                (this._x = u * l * h + c * d * p),
                                    (this._y = c * d * h + u * l * p),
                                    (this._z = c * l * p - u * d * h),
                                    (this._w = c * l * h - u * d * p);
                                break;
                            case "XZY":
                                (this._x = u * l * h - c * d * p),
                                    (this._y = c * d * h - u * l * p),
                                    (this._z = c * l * p + u * d * h),
                                    (this._w = c * l * h + u * d * p);
                                break;
                            default:
                                console.warn(
                                    "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                                        s
                                );
                        }
                        return !1 !== t && this._onChangeCallback(), this;
                    }
                    setFromAxisAngle(e, t) {
                        const i = t / 2,
                            n = Math.sin(i);
                        return (
                            (this._x = e.x * n),
                            (this._y = e.y * n),
                            (this._z = e.z * n),
                            (this._w = Math.cos(i)),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromRotationMatrix(e) {
                        const t = e.elements,
                            i = t[0],
                            n = t[4],
                            r = t[8],
                            s = t[1],
                            a = t[5],
                            o = t[9],
                            c = t[2],
                            l = t[6],
                            h = t[10],
                            u = i + a + h;
                        if (u > 0) {
                            const e = 0.5 / Math.sqrt(u + 1);
                            (this._w = 0.25 / e),
                                (this._x = (l - o) * e),
                                (this._y = (r - c) * e),
                                (this._z = (s - n) * e);
                        } else if (i > a && i > h) {
                            const e = 2 * Math.sqrt(1 + i - a - h);
                            (this._w = (l - o) / e),
                                (this._x = 0.25 * e),
                                (this._y = (n + s) / e),
                                (this._z = (r + c) / e);
                        } else if (a > h) {
                            const e = 2 * Math.sqrt(1 + a - i - h);
                            (this._w = (r - c) / e),
                                (this._x = (n + s) / e),
                                (this._y = 0.25 * e),
                                (this._z = (o + l) / e);
                        } else {
                            const e = 2 * Math.sqrt(1 + h - i - a);
                            (this._w = (s - n) / e),
                                (this._x = (r + c) / e),
                                (this._y = (o + l) / e),
                                (this._z = 0.25 * e);
                        }
                        return this._onChangeCallback(), this;
                    }
                    setFromUnitVectors(e, t) {
                        let i = e.dot(t) + 1;
                        return (
                            i < Number.EPSILON
                                ? ((i = 0),
                                  Math.abs(e.x) > Math.abs(e.z)
                                      ? ((this._x = -e.y),
                                        (this._y = e.x),
                                        (this._z = 0),
                                        (this._w = i))
                                      : ((this._x = 0),
                                        (this._y = -e.z),
                                        (this._z = e.y),
                                        (this._w = i)))
                                : ((this._x = e.y * t.z - e.z * t.y),
                                  (this._y = e.z * t.x - e.x * t.z),
                                  (this._z = e.x * t.y - e.y * t.x),
                                  (this._w = i)),
                            this.normalize()
                        );
                    }
                    angleTo(e) {
                        return 2 * Math.acos(Math.abs(Pr(this.dot(e), -1, 1)));
                    }
                    rotateTowards(e, t) {
                        const i = this.angleTo(e);
                        if (0 === i) return this;
                        const n = Math.min(1, t / i);
                        return this.slerp(e, n), this;
                    }
                    identity() {
                        return this.set(0, 0, 0, 1);
                    }
                    invert() {
                        return this.conjugate();
                    }
                    conjugate() {
                        return (
                            (this._x *= -1),
                            (this._y *= -1),
                            (this._z *= -1),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    dot(e) {
                        return (
                            this._x * e._x +
                            this._y * e._y +
                            this._z * e._z +
                            this._w * e._w
                        );
                    }
                    lengthSq() {
                        return (
                            this._x * this._x +
                            this._y * this._y +
                            this._z * this._z +
                            this._w * this._w
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this._x * this._x +
                                this._y * this._y +
                                this._z * this._z +
                                this._w * this._w
                        );
                    }
                    normalize() {
                        let e = this.length();
                        return (
                            0 === e
                                ? ((this._x = 0),
                                  (this._y = 0),
                                  (this._z = 0),
                                  (this._w = 1))
                                : ((e = 1 / e),
                                  (this._x = this._x * e),
                                  (this._y = this._y * e),
                                  (this._z = this._z * e),
                                  (this._w = this._w * e)),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    multiply(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
                              ),
                              this.multiplyQuaternions(e, t))
                            : this.multiplyQuaternions(this, e);
                    }
                    premultiply(e) {
                        return this.multiplyQuaternions(e, this);
                    }
                    multiplyQuaternions(e, t) {
                        const i = e._x,
                            n = e._y,
                            r = e._z,
                            s = e._w,
                            a = t._x,
                            o = t._y,
                            c = t._z,
                            l = t._w;
                        return (
                            (this._x = i * l + s * a + n * c - r * o),
                            (this._y = n * l + s * o + r * a - i * c),
                            (this._z = r * l + s * c + i * o - n * a),
                            (this._w = s * l - i * a - n * o - r * c),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    slerp(e, t) {
                        if (0 === t) return this;
                        if (1 === t) return this.copy(e);
                        const i = this._x,
                            n = this._y,
                            r = this._z,
                            s = this._w;
                        let a = s * e._w + i * e._x + n * e._y + r * e._z;
                        if (
                            (a < 0
                                ? ((this._w = -e._w),
                                  (this._x = -e._x),
                                  (this._y = -e._y),
                                  (this._z = -e._z),
                                  (a = -a))
                                : this.copy(e),
                            a >= 1)
                        )
                            return (
                                (this._w = s),
                                (this._x = i),
                                (this._y = n),
                                (this._z = r),
                                this
                            );
                        const o = 1 - a * a;
                        if (o <= Number.EPSILON) {
                            const e = 1 - t;
                            return (
                                (this._w = e * s + t * this._w),
                                (this._x = e * i + t * this._x),
                                (this._y = e * n + t * this._y),
                                (this._z = e * r + t * this._z),
                                this.normalize(),
                                this._onChangeCallback(),
                                this
                            );
                        }
                        const c = Math.sqrt(o),
                            l = Math.atan2(c, a),
                            h = Math.sin((1 - t) * l) / c,
                            u = Math.sin(t * l) / c;
                        return (
                            (this._w = s * h + this._w * u),
                            (this._x = i * h + this._x * u),
                            (this._y = n * h + this._y * u),
                            (this._z = r * h + this._z * u),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    slerpQuaternions(e, t, i) {
                        this.copy(e).slerp(t, i);
                    }
                    random() {
                        const e = Math.random(),
                            t = Math.sqrt(1 - e),
                            i = Math.sqrt(e),
                            n = 2 * Math.PI * Math.random(),
                            r = 2 * Math.PI * Math.random();
                        return this.set(
                            t * Math.cos(n),
                            i * Math.sin(r),
                            i * Math.cos(r),
                            t * Math.sin(n)
                        );
                    }
                    equals(e) {
                        return (
                            e._x === this._x &&
                            e._y === this._y &&
                            e._z === this._z &&
                            e._w === this._w
                        );
                    }
                    fromArray(e, t = 0) {
                        return (
                            (this._x = e[t]),
                            (this._y = e[t + 1]),
                            (this._z = e[t + 2]),
                            (this._w = e[t + 3]),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    toArray(e = [], t = 0) {
                        return (
                            (e[t] = this._x),
                            (e[t + 1] = this._y),
                            (e[t + 2] = this._z),
                            (e[t + 3] = this._w),
                            e
                        );
                    }
                    fromBufferAttribute(e, t) {
                        return (
                            (this._x = e.getX(t)),
                            (this._y = e.getY(t)),
                            (this._z = e.getZ(t)),
                            (this._w = e.getW(t)),
                            this
                        );
                    }
                    _onChange(e) {
                        return (this._onChangeCallback = e), this;
                    }
                    _onChangeCallback() {}
                }
                ns.prototype.isQuaternion = !0;
                class rs {
                    constructor(e = 0, t = 0, i = 0) {
                        (this.x = e), (this.y = t), (this.z = i);
                    }
                    set(e, t, i) {
                        return (
                            void 0 === i && (i = this.z),
                            (this.x = e),
                            (this.y = t),
                            (this.z = i),
                            this
                        );
                    }
                    setScalar(e) {
                        return (this.x = e), (this.y = e), (this.z = e), this;
                    }
                    setX(e) {
                        return (this.x = e), this;
                    }
                    setY(e) {
                        return (this.y = e), this;
                    }
                    setZ(e) {
                        return (this.z = e), this;
                    }
                    setComponent(e, t) {
                        switch (e) {
                            case 0:
                                this.x = t;
                                break;
                            case 1:
                                this.y = t;
                                break;
                            case 2:
                                this.z = t;
                                break;
                            default:
                                throw new Error("index is out of range: " + e);
                        }
                        return this;
                    }
                    getComponent(e) {
                        switch (e) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + e);
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z);
                    }
                    copy(e) {
                        return (
                            (this.x = e.x), (this.y = e.y), (this.z = e.z), this
                        );
                    }
                    add(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                              ),
                              this.addVectors(e, t))
                            : ((this.x += e.x),
                              (this.y += e.y),
                              (this.z += e.z),
                              this);
                    }
                    addScalar(e) {
                        return (
                            (this.x += e), (this.y += e), (this.z += e), this
                        );
                    }
                    addVectors(e, t) {
                        return (
                            (this.x = e.x + t.x),
                            (this.y = e.y + t.y),
                            (this.z = e.z + t.z),
                            this
                        );
                    }
                    addScaledVector(e, t) {
                        return (
                            (this.x += e.x * t),
                            (this.y += e.y * t),
                            (this.z += e.z * t),
                            this
                        );
                    }
                    sub(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                              ),
                              this.subVectors(e, t))
                            : ((this.x -= e.x),
                              (this.y -= e.y),
                              (this.z -= e.z),
                              this);
                    }
                    subScalar(e) {
                        return (
                            (this.x -= e), (this.y -= e), (this.z -= e), this
                        );
                    }
                    subVectors(e, t) {
                        return (
                            (this.x = e.x - t.x),
                            (this.y = e.y - t.y),
                            (this.z = e.z - t.z),
                            this
                        );
                    }
                    multiply(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
                              ),
                              this.multiplyVectors(e, t))
                            : ((this.x *= e.x),
                              (this.y *= e.y),
                              (this.z *= e.z),
                              this);
                    }
                    multiplyScalar(e) {
                        return (
                            (this.x *= e), (this.y *= e), (this.z *= e), this
                        );
                    }
                    multiplyVectors(e, t) {
                        return (
                            (this.x = e.x * t.x),
                            (this.y = e.y * t.y),
                            (this.z = e.z * t.z),
                            this
                        );
                    }
                    applyEuler(e) {
                        return (
                            (e && e.isEuler) ||
                                console.error(
                                    "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
                                ),
                            this.applyQuaternion(as.setFromEuler(e))
                        );
                    }
                    applyAxisAngle(e, t) {
                        return this.applyQuaternion(as.setFromAxisAngle(e, t));
                    }
                    applyMatrix3(e) {
                        const t = this.x,
                            i = this.y,
                            n = this.z,
                            r = e.elements;
                        return (
                            (this.x = r[0] * t + r[3] * i + r[6] * n),
                            (this.y = r[1] * t + r[4] * i + r[7] * n),
                            (this.z = r[2] * t + r[5] * i + r[8] * n),
                            this
                        );
                    }
                    applyNormalMatrix(e) {
                        return this.applyMatrix3(e).normalize();
                    }
                    applyMatrix4(e) {
                        const t = this.x,
                            i = this.y,
                            n = this.z,
                            r = e.elements,
                            s = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
                        return (
                            (this.x =
                                (r[0] * t + r[4] * i + r[8] * n + r[12]) * s),
                            (this.y =
                                (r[1] * t + r[5] * i + r[9] * n + r[13]) * s),
                            (this.z =
                                (r[2] * t + r[6] * i + r[10] * n + r[14]) * s),
                            this
                        );
                    }
                    applyQuaternion(e) {
                        const t = this.x,
                            i = this.y,
                            n = this.z,
                            r = e.x,
                            s = e.y,
                            a = e.z,
                            o = e.w,
                            c = o * t + s * n - a * i,
                            l = o * i + a * t - r * n,
                            h = o * n + r * i - s * t,
                            u = -r * t - s * i - a * n;
                        return (
                            (this.x = c * o + u * -r + l * -a - h * -s),
                            (this.y = l * o + u * -s + h * -r - c * -a),
                            (this.z = h * o + u * -a + c * -s - l * -r),
                            this
                        );
                    }
                    project(e) {
                        return this.applyMatrix4(
                            e.matrixWorldInverse
                        ).applyMatrix4(e.projectionMatrix);
                    }
                    unproject(e) {
                        return this.applyMatrix4(
                            e.projectionMatrixInverse
                        ).applyMatrix4(e.matrixWorld);
                    }
                    transformDirection(e) {
                        const t = this.x,
                            i = this.y,
                            n = this.z,
                            r = e.elements;
                        return (
                            (this.x = r[0] * t + r[4] * i + r[8] * n),
                            (this.y = r[1] * t + r[5] * i + r[9] * n),
                            (this.z = r[2] * t + r[6] * i + r[10] * n),
                            this.normalize()
                        );
                    }
                    divide(e) {
                        return (
                            (this.x /= e.x),
                            (this.y /= e.y),
                            (this.z /= e.z),
                            this
                        );
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e);
                    }
                    min(e) {
                        return (
                            (this.x = Math.min(this.x, e.x)),
                            (this.y = Math.min(this.y, e.y)),
                            (this.z = Math.min(this.z, e.z)),
                            this
                        );
                    }
                    max(e) {
                        return (
                            (this.x = Math.max(this.x, e.x)),
                            (this.y = Math.max(this.y, e.y)),
                            (this.z = Math.max(this.z, e.z)),
                            this
                        );
                    }
                    clamp(e, t) {
                        return (
                            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
                            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
                            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
                            this
                        );
                    }
                    clampScalar(e, t) {
                        return (
                            (this.x = Math.max(e, Math.min(t, this.x))),
                            (this.y = Math.max(e, Math.min(t, this.y))),
                            (this.z = Math.max(e, Math.min(t, this.z))),
                            this
                        );
                    }
                    clampLength(e, t) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(
                            Math.max(e, Math.min(t, i))
                        );
                    }
                    floor() {
                        return (
                            (this.x = Math.floor(this.x)),
                            (this.y = Math.floor(this.y)),
                            (this.z = Math.floor(this.z)),
                            this
                        );
                    }
                    ceil() {
                        return (
                            (this.x = Math.ceil(this.x)),
                            (this.y = Math.ceil(this.y)),
                            (this.z = Math.ceil(this.z)),
                            this
                        );
                    }
                    round() {
                        return (
                            (this.x = Math.round(this.x)),
                            (this.y = Math.round(this.y)),
                            (this.z = Math.round(this.z)),
                            this
                        );
                    }
                    roundToZero() {
                        return (
                            (this.x =
                                this.x < 0
                                    ? Math.ceil(this.x)
                                    : Math.floor(this.x)),
                            (this.y =
                                this.y < 0
                                    ? Math.ceil(this.y)
                                    : Math.floor(this.y)),
                            (this.z =
                                this.z < 0
                                    ? Math.ceil(this.z)
                                    : Math.floor(this.z)),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.x = -this.x),
                            (this.y = -this.y),
                            (this.z = -this.z),
                            this
                        );
                    }
                    dot(e) {
                        return this.x * e.x + this.y * e.y + this.z * e.z;
                    }
                    lengthSq() {
                        return (
                            this.x * this.x + this.y * this.y + this.z * this.z
                        );
                    }
                    length() {
                        return Math.sqrt(
                            this.x * this.x + this.y * this.y + this.z * this.z
                        );
                    }
                    manhattanLength() {
                        return (
                            Math.abs(this.x) +
                            Math.abs(this.y) +
                            Math.abs(this.z)
                        );
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1);
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e);
                    }
                    lerp(e, t) {
                        return (
                            (this.x += (e.x - this.x) * t),
                            (this.y += (e.y - this.y) * t),
                            (this.z += (e.z - this.z) * t),
                            this
                        );
                    }
                    lerpVectors(e, t, i) {
                        return (
                            (this.x = e.x + (t.x - e.x) * i),
                            (this.y = e.y + (t.y - e.y) * i),
                            (this.z = e.z + (t.z - e.z) * i),
                            this
                        );
                    }
                    cross(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
                              ),
                              this.crossVectors(e, t))
                            : this.crossVectors(this, e);
                    }
                    crossVectors(e, t) {
                        const i = e.x,
                            n = e.y,
                            r = e.z,
                            s = t.x,
                            a = t.y,
                            o = t.z;
                        return (
                            (this.x = n * o - r * a),
                            (this.y = r * s - i * o),
                            (this.z = i * a - n * s),
                            this
                        );
                    }
                    projectOnVector(e) {
                        const t = e.lengthSq();
                        if (0 === t) return this.set(0, 0, 0);
                        const i = e.dot(this) / t;
                        return this.copy(e).multiplyScalar(i);
                    }
                    projectOnPlane(e) {
                        return ss.copy(this).projectOnVector(e), this.sub(ss);
                    }
                    reflect(e) {
                        return this.sub(
                            ss.copy(e).multiplyScalar(2 * this.dot(e))
                        );
                    }
                    angleTo(e) {
                        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                        if (0 === t) return Math.PI / 2;
                        const i = this.dot(e) / t;
                        return Math.acos(Pr(i, -1, 1));
                    }
                    distanceTo(e) {
                        return Math.sqrt(this.distanceToSquared(e));
                    }
                    distanceToSquared(e) {
                        const t = this.x - e.x,
                            i = this.y - e.y,
                            n = this.z - e.z;
                        return t * t + i * i + n * n;
                    }
                    manhattanDistanceTo(e) {
                        return (
                            Math.abs(this.x - e.x) +
                            Math.abs(this.y - e.y) +
                            Math.abs(this.z - e.z)
                        );
                    }
                    setFromSpherical(e) {
                        return this.setFromSphericalCoords(
                            e.radius,
                            e.phi,
                            e.theta
                        );
                    }
                    setFromSphericalCoords(e, t, i) {
                        const n = Math.sin(t) * e;
                        return (
                            (this.x = n * Math.sin(i)),
                            (this.y = Math.cos(t) * e),
                            (this.z = n * Math.cos(i)),
                            this
                        );
                    }
                    setFromCylindrical(e) {
                        return this.setFromCylindricalCoords(
                            e.radius,
                            e.theta,
                            e.y
                        );
                    }
                    setFromCylindricalCoords(e, t, i) {
                        return (
                            (this.x = e * Math.sin(t)),
                            (this.y = i),
                            (this.z = e * Math.cos(t)),
                            this
                        );
                    }
                    setFromMatrixPosition(e) {
                        const t = e.elements;
                        return (
                            (this.x = t[12]),
                            (this.y = t[13]),
                            (this.z = t[14]),
                            this
                        );
                    }
                    setFromMatrixScale(e) {
                        const t = this.setFromMatrixColumn(e, 0).length(),
                            i = this.setFromMatrixColumn(e, 1).length(),
                            n = this.setFromMatrixColumn(e, 2).length();
                        return (this.x = t), (this.y = i), (this.z = n), this;
                    }
                    setFromMatrixColumn(e, t) {
                        return this.fromArray(e.elements, 4 * t);
                    }
                    setFromMatrix3Column(e, t) {
                        return this.fromArray(e.elements, 3 * t);
                    }
                    equals(e) {
                        return (
                            e.x === this.x && e.y === this.y && e.z === this.z
                        );
                    }
                    fromArray(e, t = 0) {
                        return (
                            (this.x = e[t]),
                            (this.y = e[t + 1]),
                            (this.z = e[t + 2]),
                            this
                        );
                    }
                    toArray(e = [], t = 0) {
                        return (
                            (e[t] = this.x),
                            (e[t + 1] = this.y),
                            (e[t + 2] = this.z),
                            e
                        );
                    }
                    fromBufferAttribute(e, t, i) {
                        return (
                            void 0 !== i &&
                                console.warn(
                                    "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
                                ),
                            (this.x = e.getX(t)),
                            (this.y = e.getY(t)),
                            (this.z = e.getZ(t)),
                            this
                        );
                    }
                    random() {
                        return (
                            (this.x = Math.random()),
                            (this.y = Math.random()),
                            (this.z = Math.random()),
                            this
                        );
                    }
                    randomDirection() {
                        const e = 2 * (Math.random() - 0.5),
                            t = Math.random() * Math.PI * 2,
                            i = Math.sqrt(1 - e ** 2);
                        return (
                            (this.x = i * Math.cos(t)),
                            (this.y = i * Math.sin(t)),
                            (this.z = e),
                            this
                        );
                    }
                    *[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z;
                    }
                }
                rs.prototype.isVector3 = !0;
                const ss = new rs(),
                    as = new ns();
                class os {
                    constructor(
                        e = new rs(1 / 0, 1 / 0, 1 / 0),
                        t = new rs(-1 / 0, -1 / 0, -1 / 0)
                    ) {
                        (this.min = e), (this.max = t);
                    }
                    set(e, t) {
                        return this.min.copy(e), this.max.copy(t), this;
                    }
                    setFromArray(e) {
                        let t = 1 / 0,
                            i = 1 / 0,
                            n = 1 / 0,
                            r = -1 / 0,
                            s = -1 / 0,
                            a = -1 / 0;
                        for (let o = 0, c = e.length; o < c; o += 3) {
                            const c = e[o],
                                l = e[o + 1],
                                h = e[o + 2];
                            c < t && (t = c),
                                l < i && (i = l),
                                h < n && (n = h),
                                c > r && (r = c),
                                l > s && (s = l),
                                h > a && (a = h);
                        }
                        return (
                            this.min.set(t, i, n), this.max.set(r, s, a), this
                        );
                    }
                    setFromBufferAttribute(e) {
                        let t = 1 / 0,
                            i = 1 / 0,
                            n = 1 / 0,
                            r = -1 / 0,
                            s = -1 / 0,
                            a = -1 / 0;
                        for (let o = 0, c = e.count; o < c; o++) {
                            const c = e.getX(o),
                                l = e.getY(o),
                                h = e.getZ(o);
                            c < t && (t = c),
                                l < i && (i = l),
                                h < n && (n = h),
                                c > r && (r = c),
                                l > s && (s = l),
                                h > a && (a = h);
                        }
                        return (
                            this.min.set(t, i, n), this.max.set(r, s, a), this
                        );
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, i = e.length; t < i; t++)
                            this.expandByPoint(e[t]);
                        return this;
                    }
                    setFromCenterAndSize(e, t) {
                        const i = ls.copy(t).multiplyScalar(0.5);
                        return (
                            this.min.copy(e).sub(i),
                            this.max.copy(e).add(i),
                            this
                        );
                    }
                    setFromObject(e) {
                        return this.makeEmpty(), this.expandByObject(e);
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(e) {
                        return this.min.copy(e.min), this.max.copy(e.max), this;
                    }
                    makeEmpty() {
                        return (
                            (this.min.x = this.min.y = this.min.z = 1 / 0),
                            (this.max.x = this.max.y = this.max.z = -1 / 0),
                            this
                        );
                    }
                    isEmpty() {
                        return (
                            this.max.x < this.min.x ||
                            this.max.y < this.min.y ||
                            this.max.z < this.min.z
                        );
                    }
                    getCenter(e) {
                        return this.isEmpty()
                            ? e.set(0, 0, 0)
                            : e
                                  .addVectors(this.min, this.max)
                                  .multiplyScalar(0.5);
                    }
                    getSize(e) {
                        return this.isEmpty()
                            ? e.set(0, 0, 0)
                            : e.subVectors(this.max, this.min);
                    }
                    expandByPoint(e) {
                        return this.min.min(e), this.max.max(e), this;
                    }
                    expandByVector(e) {
                        return this.min.sub(e), this.max.add(e), this;
                    }
                    expandByScalar(e) {
                        return (
                            this.min.addScalar(-e), this.max.addScalar(e), this
                        );
                    }
                    expandByObject(e) {
                        e.updateWorldMatrix(!1, !1);
                        const t = e.geometry;
                        void 0 !== t &&
                            (null === t.boundingBox && t.computeBoundingBox(),
                            hs.copy(t.boundingBox),
                            hs.applyMatrix4(e.matrixWorld),
                            this.union(hs));
                        const i = e.children;
                        for (let e = 0, t = i.length; e < t; e++)
                            this.expandByObject(i[e]);
                        return this;
                    }
                    containsPoint(e) {
                        return !(
                            e.x < this.min.x ||
                            e.x > this.max.x ||
                            e.y < this.min.y ||
                            e.y > this.max.y ||
                            e.z < this.min.z ||
                            e.z > this.max.z
                        );
                    }
                    containsBox(e) {
                        return (
                            this.min.x <= e.min.x &&
                            e.max.x <= this.max.x &&
                            this.min.y <= e.min.y &&
                            e.max.y <= this.max.y &&
                            this.min.z <= e.min.z &&
                            e.max.z <= this.max.z
                        );
                    }
                    getParameter(e, t) {
                        return t.set(
                            (e.x - this.min.x) / (this.max.x - this.min.x),
                            (e.y - this.min.y) / (this.max.y - this.min.y),
                            (e.z - this.min.z) / (this.max.z - this.min.z)
                        );
                    }
                    intersectsBox(e) {
                        return !(
                            e.max.x < this.min.x ||
                            e.min.x > this.max.x ||
                            e.max.y < this.min.y ||
                            e.min.y > this.max.y ||
                            e.max.z < this.min.z ||
                            e.min.z > this.max.z
                        );
                    }
                    intersectsSphere(e) {
                        return (
                            this.clampPoint(e.center, ls),
                            ls.distanceToSquared(e.center) <=
                                e.radius * e.radius
                        );
                    }
                    intersectsPlane(e) {
                        let t, i;
                        return (
                            e.normal.x > 0
                                ? ((t = e.normal.x * this.min.x),
                                  (i = e.normal.x * this.max.x))
                                : ((t = e.normal.x * this.max.x),
                                  (i = e.normal.x * this.min.x)),
                            e.normal.y > 0
                                ? ((t += e.normal.y * this.min.y),
                                  (i += e.normal.y * this.max.y))
                                : ((t += e.normal.y * this.max.y),
                                  (i += e.normal.y * this.min.y)),
                            e.normal.z > 0
                                ? ((t += e.normal.z * this.min.z),
                                  (i += e.normal.z * this.max.z))
                                : ((t += e.normal.z * this.max.z),
                                  (i += e.normal.z * this.min.z)),
                            t <= -e.constant && i >= -e.constant
                        );
                    }
                    intersectsTriangle(e) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(_s),
                            Ms.subVectors(this.max, _s),
                            us.subVectors(e.a, _s),
                            ds.subVectors(e.b, _s),
                            ps.subVectors(e.c, _s),
                            gs.subVectors(ds, us),
                            ms.subVectors(ps, ds),
                            fs.subVectors(us, ps);
                        let t = [
                            0,
                            -gs.z,
                            gs.y,
                            0,
                            -ms.z,
                            ms.y,
                            0,
                            -fs.z,
                            fs.y,
                            gs.z,
                            0,
                            -gs.x,
                            ms.z,
                            0,
                            -ms.x,
                            fs.z,
                            0,
                            -fs.x,
                            -gs.y,
                            gs.x,
                            0,
                            -ms.y,
                            ms.x,
                            0,
                            -fs.y,
                            fs.x,
                            0,
                        ];
                        return (
                            !!xs(t, us, ds, ps, Ms) &&
                            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                            !!xs(t, us, ds, ps, Ms) &&
                                (vs.crossVectors(gs, ms),
                                (t = [vs.x, vs.y, vs.z]),
                                xs(t, us, ds, ps, Ms)))
                        );
                    }
                    clampPoint(e, t) {
                        return t.copy(e).clamp(this.min, this.max);
                    }
                    distanceToPoint(e) {
                        return ls
                            .copy(e)
                            .clamp(this.min, this.max)
                            .sub(e)
                            .length();
                    }
                    getBoundingSphere(e) {
                        return (
                            this.getCenter(e.center),
                            (e.radius = 0.5 * this.getSize(ls).length()),
                            e
                        );
                    }
                    intersect(e) {
                        return (
                            this.min.max(e.min),
                            this.max.min(e.max),
                            this.isEmpty() && this.makeEmpty(),
                            this
                        );
                    }
                    union(e) {
                        return this.min.min(e.min), this.max.max(e.max), this;
                    }
                    applyMatrix4(e) {
                        return (
                            this.isEmpty() ||
                                (cs[0]
                                    .set(this.min.x, this.min.y, this.min.z)
                                    .applyMatrix4(e),
                                cs[1]
                                    .set(this.min.x, this.min.y, this.max.z)
                                    .applyMatrix4(e),
                                cs[2]
                                    .set(this.min.x, this.max.y, this.min.z)
                                    .applyMatrix4(e),
                                cs[3]
                                    .set(this.min.x, this.max.y, this.max.z)
                                    .applyMatrix4(e),
                                cs[4]
                                    .set(this.max.x, this.min.y, this.min.z)
                                    .applyMatrix4(e),
                                cs[5]
                                    .set(this.max.x, this.min.y, this.max.z)
                                    .applyMatrix4(e),
                                cs[6]
                                    .set(this.max.x, this.max.y, this.min.z)
                                    .applyMatrix4(e),
                                cs[7]
                                    .set(this.max.x, this.max.y, this.max.z)
                                    .applyMatrix4(e),
                                this.setFromPoints(cs)),
                            this
                        );
                    }
                    translate(e) {
                        return this.min.add(e), this.max.add(e), this;
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max);
                    }
                }
                os.prototype.isBox3 = !0;
                const cs = [
                        new rs(),
                        new rs(),
                        new rs(),
                        new rs(),
                        new rs(),
                        new rs(),
                        new rs(),
                        new rs(),
                    ],
                    ls = new rs(),
                    hs = new os(),
                    us = new rs(),
                    ds = new rs(),
                    ps = new rs(),
                    gs = new rs(),
                    ms = new rs(),
                    fs = new rs(),
                    _s = new rs(),
                    Ms = new rs(),
                    vs = new rs(),
                    ys = new rs();
                function xs(e, t, i, n, r) {
                    for (let s = 0, a = e.length - 3; s <= a; s += 3) {
                        ys.fromArray(e, s);
                        const a =
                                r.x * Math.abs(ys.x) +
                                r.y * Math.abs(ys.y) +
                                r.z * Math.abs(ys.z),
                            o = t.dot(ys),
                            c = i.dot(ys),
                            l = n.dot(ys);
                        if (Math.max(-Math.max(o, c, l), Math.min(o, c, l)) > a)
                            return !1;
                    }
                    return !0;
                }
                const bs = new os(),
                    ws = new rs(),
                    Ts = new rs(),
                    Ss = new rs();
                class Ns {
                    constructor(e = new rs(), t = -1) {
                        (this.center = e), (this.radius = t);
                    }
                    set(e, t) {
                        return this.center.copy(e), (this.radius = t), this;
                    }
                    setFromPoints(e, t) {
                        const i = this.center;
                        void 0 !== t
                            ? i.copy(t)
                            : bs.setFromPoints(e).getCenter(i);
                        let n = 0;
                        for (let t = 0, r = e.length; t < r; t++)
                            n = Math.max(n, i.distanceToSquared(e[t]));
                        return (this.radius = Math.sqrt(n)), this;
                    }
                    copy(e) {
                        return (
                            this.center.copy(e.center),
                            (this.radius = e.radius),
                            this
                        );
                    }
                    isEmpty() {
                        return this.radius < 0;
                    }
                    makeEmpty() {
                        return (
                            this.center.set(0, 0, 0), (this.radius = -1), this
                        );
                    }
                    containsPoint(e) {
                        return (
                            e.distanceToSquared(this.center) <=
                            this.radius * this.radius
                        );
                    }
                    distanceToPoint(e) {
                        return e.distanceTo(this.center) - this.radius;
                    }
                    intersectsSphere(e) {
                        const t = this.radius + e.radius;
                        return e.center.distanceToSquared(this.center) <= t * t;
                    }
                    intersectsBox(e) {
                        return e.intersectsSphere(this);
                    }
                    intersectsPlane(e) {
                        return (
                            Math.abs(e.distanceToPoint(this.center)) <=
                            this.radius
                        );
                    }
                    clampPoint(e, t) {
                        const i = this.center.distanceToSquared(e);
                        return (
                            t.copy(e),
                            i > this.radius * this.radius &&
                                (t.sub(this.center).normalize(),
                                t.multiplyScalar(this.radius).add(this.center)),
                            t
                        );
                    }
                    getBoundingBox(e) {
                        return this.isEmpty()
                            ? (e.makeEmpty(), e)
                            : (e.set(this.center, this.center),
                              e.expandByScalar(this.radius),
                              e);
                    }
                    applyMatrix4(e) {
                        return (
                            this.center.applyMatrix4(e),
                            (this.radius = this.radius * e.getMaxScaleOnAxis()),
                            this
                        );
                    }
                    translate(e) {
                        return this.center.add(e), this;
                    }
                    expandByPoint(e) {
                        Ss.subVectors(e, this.center);
                        const t = Ss.lengthSq();
                        if (t > this.radius * this.radius) {
                            const e = Math.sqrt(t),
                                i = 0.5 * (e - this.radius);
                            this.center.add(Ss.multiplyScalar(i / e)),
                                (this.radius += i);
                        }
                        return this;
                    }
                    union(e) {
                        return (
                            Ts.subVectors(e.center, this.center)
                                .normalize()
                                .multiplyScalar(e.radius),
                            this.expandByPoint(ws.copy(e.center).add(Ts)),
                            this.expandByPoint(ws.copy(e.center).sub(Ts)),
                            this
                        );
                    }
                    equals(e) {
                        return (
                            e.center.equals(this.center) &&
                            e.radius === this.radius
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                const Ds = new rs(),
                    Is = new rs(),
                    Cs = new rs(),
                    As = new rs(),
                    Es = new rs(),
                    Ls = new rs(),
                    zs = new rs();
                class js {
                    constructor(e = new rs(), t = new rs(0, 0, -1)) {
                        (this.origin = e), (this.direction = t);
                    }
                    set(e, t) {
                        return (
                            this.origin.copy(e), this.direction.copy(t), this
                        );
                    }
                    copy(e) {
                        return (
                            this.origin.copy(e.origin),
                            this.direction.copy(e.direction),
                            this
                        );
                    }
                    at(e, t) {
                        return t
                            .copy(this.direction)
                            .multiplyScalar(e)
                            .add(this.origin);
                    }
                    lookAt(e) {
                        return (
                            this.direction.copy(e).sub(this.origin).normalize(),
                            this
                        );
                    }
                    recast(e) {
                        return this.origin.copy(this.at(e, Ds)), this;
                    }
                    closestPointToPoint(e, t) {
                        t.subVectors(e, this.origin);
                        const i = t.dot(this.direction);
                        return i < 0
                            ? t.copy(this.origin)
                            : t
                                  .copy(this.direction)
                                  .multiplyScalar(i)
                                  .add(this.origin);
                    }
                    distanceToPoint(e) {
                        return Math.sqrt(this.distanceSqToPoint(e));
                    }
                    distanceSqToPoint(e) {
                        const t = Ds.subVectors(e, this.origin).dot(
                            this.direction
                        );
                        return t < 0
                            ? this.origin.distanceToSquared(e)
                            : (Ds.copy(this.direction)
                                  .multiplyScalar(t)
                                  .add(this.origin),
                              Ds.distanceToSquared(e));
                    }
                    distanceSqToSegment(e, t, i, n) {
                        Is.copy(e).add(t).multiplyScalar(0.5),
                            Cs.copy(t).sub(e).normalize(),
                            As.copy(this.origin).sub(Is);
                        const r = 0.5 * e.distanceTo(t),
                            s = -this.direction.dot(Cs),
                            a = As.dot(this.direction),
                            o = -As.dot(Cs),
                            c = As.lengthSq(),
                            l = Math.abs(1 - s * s);
                        let h, u, d, p;
                        if (l > 0)
                            if (
                                ((h = s * o - a),
                                (u = s * a - o),
                                (p = r * l),
                                h >= 0)
                            )
                                if (u >= -p)
                                    if (u <= p) {
                                        const e = 1 / l;
                                        (h *= e),
                                            (u *= e),
                                            (d =
                                                h * (h + s * u + 2 * a) +
                                                u * (s * h + u + 2 * o) +
                                                c);
                                    } else
                                        (u = r),
                                            (h = Math.max(0, -(s * u + a))),
                                            (d = -h * h + u * (u + 2 * o) + c);
                                else
                                    (u = -r),
                                        (h = Math.max(0, -(s * u + a))),
                                        (d = -h * h + u * (u + 2 * o) + c);
                            else
                                u <= -p
                                    ? ((h = Math.max(0, -(-s * r + a))),
                                      (u =
                                          h > 0
                                              ? -r
                                              : Math.min(Math.max(-r, -o), r)),
                                      (d = -h * h + u * (u + 2 * o) + c))
                                    : u <= p
                                    ? ((h = 0),
                                      (u = Math.min(Math.max(-r, -o), r)),
                                      (d = u * (u + 2 * o) + c))
                                    : ((h = Math.max(0, -(s * r + a))),
                                      (u =
                                          h > 0
                                              ? r
                                              : Math.min(Math.max(-r, -o), r)),
                                      (d = -h * h + u * (u + 2 * o) + c));
                        else
                            (u = s > 0 ? -r : r),
                                (h = Math.max(0, -(s * u + a))),
                                (d = -h * h + u * (u + 2 * o) + c);
                        return (
                            i &&
                                i
                                    .copy(this.direction)
                                    .multiplyScalar(h)
                                    .add(this.origin),
                            n && n.copy(Cs).multiplyScalar(u).add(Is),
                            d
                        );
                    }
                    intersectSphere(e, t) {
                        Ds.subVectors(e.center, this.origin);
                        const i = Ds.dot(this.direction),
                            n = Ds.dot(Ds) - i * i,
                            r = e.radius * e.radius;
                        if (n > r) return null;
                        const s = Math.sqrt(r - n),
                            a = i - s,
                            o = i + s;
                        return a < 0 && o < 0
                            ? null
                            : a < 0
                            ? this.at(o, t)
                            : this.at(a, t);
                    }
                    intersectsSphere(e) {
                        return (
                            this.distanceSqToPoint(e.center) <=
                            e.radius * e.radius
                        );
                    }
                    distanceToPlane(e) {
                        const t = e.normal.dot(this.direction);
                        if (0 === t)
                            return 0 === e.distanceToPoint(this.origin)
                                ? 0
                                : null;
                        const i = -(this.origin.dot(e.normal) + e.constant) / t;
                        return i >= 0 ? i : null;
                    }
                    intersectPlane(e, t) {
                        const i = this.distanceToPlane(e);
                        return null === i ? null : this.at(i, t);
                    }
                    intersectsPlane(e) {
                        const t = e.distanceToPoint(this.origin);
                        return 0 === t || e.normal.dot(this.direction) * t < 0;
                    }
                    intersectBox(e, t) {
                        let i, n, r, s, a, o;
                        const c = 1 / this.direction.x,
                            l = 1 / this.direction.y,
                            h = 1 / this.direction.z,
                            u = this.origin;
                        return (
                            c >= 0
                                ? ((i = (e.min.x - u.x) * c),
                                  (n = (e.max.x - u.x) * c))
                                : ((i = (e.max.x - u.x) * c),
                                  (n = (e.min.x - u.x) * c)),
                            l >= 0
                                ? ((r = (e.min.y - u.y) * l),
                                  (s = (e.max.y - u.y) * l))
                                : ((r = (e.max.y - u.y) * l),
                                  (s = (e.min.y - u.y) * l)),
                            i > s || r > n
                                ? null
                                : ((r > i || i != i) && (i = r),
                                  (s < n || n != n) && (n = s),
                                  h >= 0
                                      ? ((a = (e.min.z - u.z) * h),
                                        (o = (e.max.z - u.z) * h))
                                      : ((a = (e.max.z - u.z) * h),
                                        (o = (e.min.z - u.z) * h)),
                                  i > o || a > n
                                      ? null
                                      : ((a > i || i != i) && (i = a),
                                        (o < n || n != n) && (n = o),
                                        n < 0
                                            ? null
                                            : this.at(i >= 0 ? i : n, t)))
                        );
                    }
                    intersectsBox(e) {
                        return null !== this.intersectBox(e, Ds);
                    }
                    intersectTriangle(e, t, i, n, r) {
                        Es.subVectors(t, e),
                            Ls.subVectors(i, e),
                            zs.crossVectors(Es, Ls);
                        let s,
                            a = this.direction.dot(zs);
                        if (a > 0) {
                            if (n) return null;
                            s = 1;
                        } else {
                            if (!(a < 0)) return null;
                            (s = -1), (a = -a);
                        }
                        As.subVectors(this.origin, e);
                        const o =
                            s * this.direction.dot(Ls.crossVectors(As, Ls));
                        if (o < 0) return null;
                        const c = s * this.direction.dot(Es.cross(As));
                        if (c < 0) return null;
                        if (o + c > a) return null;
                        const l = -s * As.dot(zs);
                        return l < 0 ? null : this.at(l / a, r);
                    }
                    applyMatrix4(e) {
                        return (
                            this.origin.applyMatrix4(e),
                            this.direction.transformDirection(e),
                            this
                        );
                    }
                    equals(e) {
                        return (
                            e.origin.equals(this.origin) &&
                            e.direction.equals(this.direction)
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                class Os {
                    constructor() {
                        (this.elements = [
                            1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
                        ]),
                            arguments.length > 0 &&
                                console.error(
                                    "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
                                );
                    }
                    set(e, t, i, n, r, s, a, o, c, l, h, u, d, p, g, m) {
                        const f = this.elements;
                        return (
                            (f[0] = e),
                            (f[4] = t),
                            (f[8] = i),
                            (f[12] = n),
                            (f[1] = r),
                            (f[5] = s),
                            (f[9] = a),
                            (f[13] = o),
                            (f[2] = c),
                            (f[6] = l),
                            (f[10] = h),
                            (f[14] = u),
                            (f[3] = d),
                            (f[7] = p),
                            (f[11] = g),
                            (f[15] = m),
                            this
                        );
                    }
                    identity() {
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    clone() {
                        return new Os().fromArray(this.elements);
                    }
                    copy(e) {
                        const t = this.elements,
                            i = e.elements;
                        return (
                            (t[0] = i[0]),
                            (t[1] = i[1]),
                            (t[2] = i[2]),
                            (t[3] = i[3]),
                            (t[4] = i[4]),
                            (t[5] = i[5]),
                            (t[6] = i[6]),
                            (t[7] = i[7]),
                            (t[8] = i[8]),
                            (t[9] = i[9]),
                            (t[10] = i[10]),
                            (t[11] = i[11]),
                            (t[12] = i[12]),
                            (t[13] = i[13]),
                            (t[14] = i[14]),
                            (t[15] = i[15]),
                            this
                        );
                    }
                    copyPosition(e) {
                        const t = this.elements,
                            i = e.elements;
                        return (
                            (t[12] = i[12]),
                            (t[13] = i[13]),
                            (t[14] = i[14]),
                            this
                        );
                    }
                    setFromMatrix3(e) {
                        const t = e.elements;
                        return (
                            this.set(
                                t[0],
                                t[3],
                                t[6],
                                0,
                                t[1],
                                t[4],
                                t[7],
                                0,
                                t[2],
                                t[5],
                                t[8],
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    extractBasis(e, t, i) {
                        return (
                            e.setFromMatrixColumn(this, 0),
                            t.setFromMatrixColumn(this, 1),
                            i.setFromMatrixColumn(this, 2),
                            this
                        );
                    }
                    makeBasis(e, t, i) {
                        return (
                            this.set(
                                e.x,
                                t.x,
                                i.x,
                                0,
                                e.y,
                                t.y,
                                i.y,
                                0,
                                e.z,
                                t.z,
                                i.z,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    extractRotation(e) {
                        const t = this.elements,
                            i = e.elements,
                            n = 1 / ks.setFromMatrixColumn(e, 0).length(),
                            r = 1 / ks.setFromMatrixColumn(e, 1).length(),
                            s = 1 / ks.setFromMatrixColumn(e, 2).length();
                        return (
                            (t[0] = i[0] * n),
                            (t[1] = i[1] * n),
                            (t[2] = i[2] * n),
                            (t[3] = 0),
                            (t[4] = i[4] * r),
                            (t[5] = i[5] * r),
                            (t[6] = i[6] * r),
                            (t[7] = 0),
                            (t[8] = i[8] * s),
                            (t[9] = i[9] * s),
                            (t[10] = i[10] * s),
                            (t[11] = 0),
                            (t[12] = 0),
                            (t[13] = 0),
                            (t[14] = 0),
                            (t[15] = 1),
                            this
                        );
                    }
                    makeRotationFromEuler(e) {
                        (e && e.isEuler) ||
                            console.error(
                                "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
                            );
                        const t = this.elements,
                            i = e.x,
                            n = e.y,
                            r = e.z,
                            s = Math.cos(i),
                            a = Math.sin(i),
                            o = Math.cos(n),
                            c = Math.sin(n),
                            l = Math.cos(r),
                            h = Math.sin(r);
                        if ("XYZ" === e.order) {
                            const e = s * l,
                                i = s * h,
                                n = a * l,
                                r = a * h;
                            (t[0] = o * l),
                                (t[4] = -o * h),
                                (t[8] = c),
                                (t[1] = i + n * c),
                                (t[5] = e - r * c),
                                (t[9] = -a * o),
                                (t[2] = r - e * c),
                                (t[6] = n + i * c),
                                (t[10] = s * o);
                        } else if ("YXZ" === e.order) {
                            const e = o * l,
                                i = o * h,
                                n = c * l,
                                r = c * h;
                            (t[0] = e + r * a),
                                (t[4] = n * a - i),
                                (t[8] = s * c),
                                (t[1] = s * h),
                                (t[5] = s * l),
                                (t[9] = -a),
                                (t[2] = i * a - n),
                                (t[6] = r + e * a),
                                (t[10] = s * o);
                        } else if ("ZXY" === e.order) {
                            const e = o * l,
                                i = o * h,
                                n = c * l,
                                r = c * h;
                            (t[0] = e - r * a),
                                (t[4] = -s * h),
                                (t[8] = n + i * a),
                                (t[1] = i + n * a),
                                (t[5] = s * l),
                                (t[9] = r - e * a),
                                (t[2] = -s * c),
                                (t[6] = a),
                                (t[10] = s * o);
                        } else if ("ZYX" === e.order) {
                            const e = s * l,
                                i = s * h,
                                n = a * l,
                                r = a * h;
                            (t[0] = o * l),
                                (t[4] = n * c - i),
                                (t[8] = e * c + r),
                                (t[1] = o * h),
                                (t[5] = r * c + e),
                                (t[9] = i * c - n),
                                (t[2] = -c),
                                (t[6] = a * o),
                                (t[10] = s * o);
                        } else if ("YZX" === e.order) {
                            const e = s * o,
                                i = s * c,
                                n = a * o,
                                r = a * c;
                            (t[0] = o * l),
                                (t[4] = r - e * h),
                                (t[8] = n * h + i),
                                (t[1] = h),
                                (t[5] = s * l),
                                (t[9] = -a * l),
                                (t[2] = -c * l),
                                (t[6] = i * h + n),
                                (t[10] = e - r * h);
                        } else if ("XZY" === e.order) {
                            const e = s * o,
                                i = s * c,
                                n = a * o,
                                r = a * c;
                            (t[0] = o * l),
                                (t[4] = -h),
                                (t[8] = c * l),
                                (t[1] = e * h + r),
                                (t[5] = s * l),
                                (t[9] = i * h - n),
                                (t[2] = n * h - i),
                                (t[6] = a * l),
                                (t[10] = r * h + e);
                        }
                        return (
                            (t[3] = 0),
                            (t[7] = 0),
                            (t[11] = 0),
                            (t[12] = 0),
                            (t[13] = 0),
                            (t[14] = 0),
                            (t[15] = 1),
                            this
                        );
                    }
                    makeRotationFromQuaternion(e) {
                        return this.compose(Ps, e, Us);
                    }
                    lookAt(e, t, i) {
                        const n = this.elements;
                        return (
                            Fs.subVectors(e, t),
                            0 === Fs.lengthSq() && (Fs.z = 1),
                            Fs.normalize(),
                            $s.crossVectors(i, Fs),
                            0 === $s.lengthSq() &&
                                (1 === Math.abs(i.z)
                                    ? (Fs.x += 1e-4)
                                    : (Fs.z += 1e-4),
                                Fs.normalize(),
                                $s.crossVectors(i, Fs)),
                            $s.normalize(),
                            Bs.crossVectors(Fs, $s),
                            (n[0] = $s.x),
                            (n[4] = Bs.x),
                            (n[8] = Fs.x),
                            (n[1] = $s.y),
                            (n[5] = Bs.y),
                            (n[9] = Fs.y),
                            (n[2] = $s.z),
                            (n[6] = Bs.z),
                            (n[10] = Fs.z),
                            this
                        );
                    }
                    multiply(e, t) {
                        return void 0 !== t
                            ? (console.warn(
                                  "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
                              ),
                              this.multiplyMatrices(e, t))
                            : this.multiplyMatrices(this, e);
                    }
                    premultiply(e) {
                        return this.multiplyMatrices(e, this);
                    }
                    multiplyMatrices(e, t) {
                        const i = e.elements,
                            n = t.elements,
                            r = this.elements,
                            s = i[0],
                            a = i[4],
                            o = i[8],
                            c = i[12],
                            l = i[1],
                            h = i[5],
                            u = i[9],
                            d = i[13],
                            p = i[2],
                            g = i[6],
                            m = i[10],
                            f = i[14],
                            _ = i[3],
                            M = i[7],
                            v = i[11],
                            y = i[15],
                            x = n[0],
                            b = n[4],
                            w = n[8],
                            T = n[12],
                            S = n[1],
                            N = n[5],
                            D = n[9],
                            I = n[13],
                            C = n[2],
                            A = n[6],
                            E = n[10],
                            L = n[14],
                            z = n[3],
                            j = n[7],
                            O = n[11],
                            k = n[15];
                        return (
                            (r[0] = s * x + a * S + o * C + c * z),
                            (r[4] = s * b + a * N + o * A + c * j),
                            (r[8] = s * w + a * D + o * E + c * O),
                            (r[12] = s * T + a * I + o * L + c * k),
                            (r[1] = l * x + h * S + u * C + d * z),
                            (r[5] = l * b + h * N + u * A + d * j),
                            (r[9] = l * w + h * D + u * E + d * O),
                            (r[13] = l * T + h * I + u * L + d * k),
                            (r[2] = p * x + g * S + m * C + f * z),
                            (r[6] = p * b + g * N + m * A + f * j),
                            (r[10] = p * w + g * D + m * E + f * O),
                            (r[14] = p * T + g * I + m * L + f * k),
                            (r[3] = _ * x + M * S + v * C + y * z),
                            (r[7] = _ * b + M * N + v * A + y * j),
                            (r[11] = _ * w + M * D + v * E + y * O),
                            (r[15] = _ * T + M * I + v * L + y * k),
                            this
                        );
                    }
                    multiplyScalar(e) {
                        const t = this.elements;
                        return (
                            (t[0] *= e),
                            (t[4] *= e),
                            (t[8] *= e),
                            (t[12] *= e),
                            (t[1] *= e),
                            (t[5] *= e),
                            (t[9] *= e),
                            (t[13] *= e),
                            (t[2] *= e),
                            (t[6] *= e),
                            (t[10] *= e),
                            (t[14] *= e),
                            (t[3] *= e),
                            (t[7] *= e),
                            (t[11] *= e),
                            (t[15] *= e),
                            this
                        );
                    }
                    determinant() {
                        const e = this.elements,
                            t = e[0],
                            i = e[4],
                            n = e[8],
                            r = e[12],
                            s = e[1],
                            a = e[5],
                            o = e[9],
                            c = e[13],
                            l = e[2],
                            h = e[6],
                            u = e[10],
                            d = e[14];
                        return (
                            e[3] *
                                (+r * o * h -
                                    n * c * h -
                                    r * a * u +
                                    i * c * u +
                                    n * a * d -
                                    i * o * d) +
                            e[7] *
                                (+t * o * d -
                                    t * c * u +
                                    r * s * u -
                                    n * s * d +
                                    n * c * l -
                                    r * o * l) +
                            e[11] *
                                (+t * c * h -
                                    t * a * d -
                                    r * s * h +
                                    i * s * d +
                                    r * a * l -
                                    i * c * l) +
                            e[15] *
                                (-n * a * l -
                                    t * o * h +
                                    t * a * u +
                                    n * s * h -
                                    i * s * u +
                                    i * o * l)
                        );
                    }
                    transpose() {
                        const e = this.elements;
                        let t;
                        return (
                            (t = e[1]),
                            (e[1] = e[4]),
                            (e[4] = t),
                            (t = e[2]),
                            (e[2] = e[8]),
                            (e[8] = t),
                            (t = e[6]),
                            (e[6] = e[9]),
                            (e[9] = t),
                            (t = e[3]),
                            (e[3] = e[12]),
                            (e[12] = t),
                            (t = e[7]),
                            (e[7] = e[13]),
                            (e[13] = t),
                            (t = e[11]),
                            (e[11] = e[14]),
                            (e[14] = t),
                            this
                        );
                    }
                    setPosition(e, t, i) {
                        const n = this.elements;
                        return (
                            e.isVector3
                                ? ((n[12] = e.x), (n[13] = e.y), (n[14] = e.z))
                                : ((n[12] = e), (n[13] = t), (n[14] = i)),
                            this
                        );
                    }
                    invert() {
                        const e = this.elements,
                            t = e[0],
                            i = e[1],
                            n = e[2],
                            r = e[3],
                            s = e[4],
                            a = e[5],
                            o = e[6],
                            c = e[7],
                            l = e[8],
                            h = e[9],
                            u = e[10],
                            d = e[11],
                            p = e[12],
                            g = e[13],
                            m = e[14],
                            f = e[15],
                            _ =
                                h * m * c -
                                g * u * c +
                                g * o * d -
                                a * m * d -
                                h * o * f +
                                a * u * f,
                            M =
                                p * u * c -
                                l * m * c -
                                p * o * d +
                                s * m * d +
                                l * o * f -
                                s * u * f,
                            v =
                                l * g * c -
                                p * h * c +
                                p * a * d -
                                s * g * d -
                                l * a * f +
                                s * h * f,
                            y =
                                p * h * o -
                                l * g * o -
                                p * a * u +
                                s * g * u +
                                l * a * m -
                                s * h * m,
                            x = t * _ + i * M + n * v + r * y;
                        if (0 === x)
                            return this.set(
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
                            );
                        const b = 1 / x;
                        return (
                            (e[0] = _ * b),
                            (e[1] =
                                (g * u * r -
                                    h * m * r -
                                    g * n * d +
                                    i * m * d +
                                    h * n * f -
                                    i * u * f) *
                                b),
                            (e[2] =
                                (a * m * r -
                                    g * o * r +
                                    g * n * c -
                                    i * m * c -
                                    a * n * f +
                                    i * o * f) *
                                b),
                            (e[3] =
                                (h * o * r -
                                    a * u * r -
                                    h * n * c +
                                    i * u * c +
                                    a * n * d -
                                    i * o * d) *
                                b),
                            (e[4] = M * b),
                            (e[5] =
                                (l * m * r -
                                    p * u * r +
                                    p * n * d -
                                    t * m * d -
                                    l * n * f +
                                    t * u * f) *
                                b),
                            (e[6] =
                                (p * o * r -
                                    s * m * r -
                                    p * n * c +
                                    t * m * c +
                                    s * n * f -
                                    t * o * f) *
                                b),
                            (e[7] =
                                (s * u * r -
                                    l * o * r +
                                    l * n * c -
                                    t * u * c -
                                    s * n * d +
                                    t * o * d) *
                                b),
                            (e[8] = v * b),
                            (e[9] =
                                (p * h * r -
                                    l * g * r -
                                    p * i * d +
                                    t * g * d +
                                    l * i * f -
                                    t * h * f) *
                                b),
                            (e[10] =
                                (s * g * r -
                                    p * a * r +
                                    p * i * c -
                                    t * g * c -
                                    s * i * f +
                                    t * a * f) *
                                b),
                            (e[11] =
                                (l * a * r -
                                    s * h * r -
                                    l * i * c +
                                    t * h * c +
                                    s * i * d -
                                    t * a * d) *
                                b),
                            (e[12] = y * b),
                            (e[13] =
                                (l * g * n -
                                    p * h * n +
                                    p * i * u -
                                    t * g * u -
                                    l * i * m +
                                    t * h * m) *
                                b),
                            (e[14] =
                                (p * a * n -
                                    s * g * n -
                                    p * i * o +
                                    t * g * o +
                                    s * i * m -
                                    t * a * m) *
                                b),
                            (e[15] =
                                (s * h * n -
                                    l * a * n +
                                    l * i * o -
                                    t * h * o -
                                    s * i * u +
                                    t * a * u) *
                                b),
                            this
                        );
                    }
                    scale(e) {
                        const t = this.elements,
                            i = e.x,
                            n = e.y,
                            r = e.z;
                        return (
                            (t[0] *= i),
                            (t[4] *= n),
                            (t[8] *= r),
                            (t[1] *= i),
                            (t[5] *= n),
                            (t[9] *= r),
                            (t[2] *= i),
                            (t[6] *= n),
                            (t[10] *= r),
                            (t[3] *= i),
                            (t[7] *= n),
                            (t[11] *= r),
                            this
                        );
                    }
                    getMaxScaleOnAxis() {
                        const e = this.elements,
                            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                            i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                            n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                        return Math.sqrt(Math.max(t, i, n));
                    }
                    makeTranslation(e, t, i) {
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                e,
                                0,
                                1,
                                0,
                                t,
                                0,
                                0,
                                1,
                                i,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeRotationX(e) {
                        const t = Math.cos(e),
                            i = Math.sin(e);
                        return (
                            this.set(
                                1,
                                0,
                                0,
                                0,
                                0,
                                t,
                                -i,
                                0,
                                0,
                                i,
                                t,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeRotationY(e) {
                        const t = Math.cos(e),
                            i = Math.sin(e);
                        return (
                            this.set(
                                t,
                                0,
                                i,
                                0,
                                0,
                                1,
                                0,
                                0,
                                -i,
                                0,
                                t,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeRotationZ(e) {
                        const t = Math.cos(e),
                            i = Math.sin(e);
                        return (
                            this.set(
                                t,
                                -i,
                                0,
                                0,
                                i,
                                t,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeRotationAxis(e, t) {
                        const i = Math.cos(t),
                            n = Math.sin(t),
                            r = 1 - i,
                            s = e.x,
                            a = e.y,
                            o = e.z,
                            c = r * s,
                            l = r * a;
                        return (
                            this.set(
                                c * s + i,
                                c * a - n * o,
                                c * o + n * a,
                                0,
                                c * a + n * o,
                                l * a + i,
                                l * o - n * s,
                                0,
                                c * o - n * a,
                                l * o + n * s,
                                r * o * o + i,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeScale(e, t, i) {
                        return (
                            this.set(
                                e,
                                0,
                                0,
                                0,
                                0,
                                t,
                                0,
                                0,
                                0,
                                0,
                                i,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    makeShear(e, t, i, n, r, s) {
                        return (
                            this.set(
                                1,
                                i,
                                r,
                                0,
                                e,
                                1,
                                s,
                                0,
                                t,
                                n,
                                1,
                                0,
                                0,
                                0,
                                0,
                                1
                            ),
                            this
                        );
                    }
                    compose(e, t, i) {
                        const n = this.elements,
                            r = t._x,
                            s = t._y,
                            a = t._z,
                            o = t._w,
                            c = r + r,
                            l = s + s,
                            h = a + a,
                            u = r * c,
                            d = r * l,
                            p = r * h,
                            g = s * l,
                            m = s * h,
                            f = a * h,
                            _ = o * c,
                            M = o * l,
                            v = o * h,
                            y = i.x,
                            x = i.y,
                            b = i.z;
                        return (
                            (n[0] = (1 - (g + f)) * y),
                            (n[1] = (d + v) * y),
                            (n[2] = (p - M) * y),
                            (n[3] = 0),
                            (n[4] = (d - v) * x),
                            (n[5] = (1 - (u + f)) * x),
                            (n[6] = (m + _) * x),
                            (n[7] = 0),
                            (n[8] = (p + M) * b),
                            (n[9] = (m - _) * b),
                            (n[10] = (1 - (u + g)) * b),
                            (n[11] = 0),
                            (n[12] = e.x),
                            (n[13] = e.y),
                            (n[14] = e.z),
                            (n[15] = 1),
                            this
                        );
                    }
                    decompose(e, t, i) {
                        const n = this.elements;
                        let r = ks.set(n[0], n[1], n[2]).length();
                        const s = ks.set(n[4], n[5], n[6]).length(),
                            a = ks.set(n[8], n[9], n[10]).length();
                        this.determinant() < 0 && (r = -r),
                            (e.x = n[12]),
                            (e.y = n[13]),
                            (e.z = n[14]),
                            Rs.copy(this);
                        const o = 1 / r,
                            c = 1 / s,
                            l = 1 / a;
                        return (
                            (Rs.elements[0] *= o),
                            (Rs.elements[1] *= o),
                            (Rs.elements[2] *= o),
                            (Rs.elements[4] *= c),
                            (Rs.elements[5] *= c),
                            (Rs.elements[6] *= c),
                            (Rs.elements[8] *= l),
                            (Rs.elements[9] *= l),
                            (Rs.elements[10] *= l),
                            t.setFromRotationMatrix(Rs),
                            (i.x = r),
                            (i.y = s),
                            (i.z = a),
                            this
                        );
                    }
                    makePerspective(e, t, i, n, r, s) {
                        void 0 === s &&
                            console.warn(
                                "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
                            );
                        const a = this.elements,
                            o = (2 * r) / (t - e),
                            c = (2 * r) / (i - n),
                            l = (t + e) / (t - e),
                            h = (i + n) / (i - n),
                            u = -(s + r) / (s - r),
                            d = (-2 * s * r) / (s - r);
                        return (
                            (a[0] = o),
                            (a[4] = 0),
                            (a[8] = l),
                            (a[12] = 0),
                            (a[1] = 0),
                            (a[5] = c),
                            (a[9] = h),
                            (a[13] = 0),
                            (a[2] = 0),
                            (a[6] = 0),
                            (a[10] = u),
                            (a[14] = d),
                            (a[3] = 0),
                            (a[7] = 0),
                            (a[11] = -1),
                            (a[15] = 0),
                            this
                        );
                    }
                    makeOrthographic(e, t, i, n, r, s) {
                        const a = this.elements,
                            o = 1 / (t - e),
                            c = 1 / (i - n),
                            l = 1 / (s - r),
                            h = (t + e) * o,
                            u = (i + n) * c,
                            d = (s + r) * l;
                        return (
                            (a[0] = 2 * o),
                            (a[4] = 0),
                            (a[8] = 0),
                            (a[12] = -h),
                            (a[1] = 0),
                            (a[5] = 2 * c),
                            (a[9] = 0),
                            (a[13] = -u),
                            (a[2] = 0),
                            (a[6] = 0),
                            (a[10] = -2 * l),
                            (a[14] = -d),
                            (a[3] = 0),
                            (a[7] = 0),
                            (a[11] = 0),
                            (a[15] = 1),
                            this
                        );
                    }
                    equals(e) {
                        const t = this.elements,
                            i = e.elements;
                        for (let e = 0; e < 16; e++)
                            if (t[e] !== i[e]) return !1;
                        return !0;
                    }
                    fromArray(e, t = 0) {
                        for (let i = 0; i < 16; i++)
                            this.elements[i] = e[i + t];
                        return this;
                    }
                    toArray(e = [], t = 0) {
                        const i = this.elements;
                        return (
                            (e[t] = i[0]),
                            (e[t + 1] = i[1]),
                            (e[t + 2] = i[2]),
                            (e[t + 3] = i[3]),
                            (e[t + 4] = i[4]),
                            (e[t + 5] = i[5]),
                            (e[t + 6] = i[6]),
                            (e[t + 7] = i[7]),
                            (e[t + 8] = i[8]),
                            (e[t + 9] = i[9]),
                            (e[t + 10] = i[10]),
                            (e[t + 11] = i[11]),
                            (e[t + 12] = i[12]),
                            (e[t + 13] = i[13]),
                            (e[t + 14] = i[14]),
                            (e[t + 15] = i[15]),
                            e
                        );
                    }
                }
                Os.prototype.isMatrix4 = !0;
                const ks = new rs(),
                    Rs = new Os(),
                    Ps = new rs(0, 0, 0),
                    Us = new rs(1, 1, 1),
                    $s = new rs(),
                    Bs = new rs(),
                    Fs = new rs(),
                    Hs = new Os(),
                    Gs = new ns();
                class Vs {
                    constructor(e = 0, t = 0, i = 0, n = Vs.DefaultOrder) {
                        (this._x = e),
                            (this._y = t),
                            (this._z = i),
                            (this._order = n);
                    }
                    get x() {
                        return this._x;
                    }
                    set x(e) {
                        (this._x = e), this._onChangeCallback();
                    }
                    get y() {
                        return this._y;
                    }
                    set y(e) {
                        (this._y = e), this._onChangeCallback();
                    }
                    get z() {
                        return this._z;
                    }
                    set z(e) {
                        (this._z = e), this._onChangeCallback();
                    }
                    get order() {
                        return this._order;
                    }
                    set order(e) {
                        (this._order = e), this._onChangeCallback();
                    }
                    set(e, t, i, n = this._order) {
                        return (
                            (this._x = e),
                            (this._y = t),
                            (this._z = i),
                            (this._order = n),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(
                            this._x,
                            this._y,
                            this._z,
                            this._order
                        );
                    }
                    copy(e) {
                        return (
                            (this._x = e._x),
                            (this._y = e._y),
                            (this._z = e._z),
                            (this._order = e._order),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    setFromRotationMatrix(e, t = this._order, i = !0) {
                        const n = e.elements,
                            r = n[0],
                            s = n[4],
                            a = n[8],
                            o = n[1],
                            c = n[5],
                            l = n[9],
                            h = n[2],
                            u = n[6],
                            d = n[10];
                        switch (t) {
                            case "XYZ":
                                (this._y = Math.asin(Pr(a, -1, 1))),
                                    Math.abs(a) < 0.9999999
                                        ? ((this._x = Math.atan2(-l, d)),
                                          (this._z = Math.atan2(-s, r)))
                                        : ((this._x = Math.atan2(u, c)),
                                          (this._z = 0));
                                break;
                            case "YXZ":
                                (this._x = Math.asin(-Pr(l, -1, 1))),
                                    Math.abs(l) < 0.9999999
                                        ? ((this._y = Math.atan2(a, d)),
                                          (this._z = Math.atan2(o, c)))
                                        : ((this._y = Math.atan2(-h, r)),
                                          (this._z = 0));
                                break;
                            case "ZXY":
                                (this._x = Math.asin(Pr(u, -1, 1))),
                                    Math.abs(u) < 0.9999999
                                        ? ((this._y = Math.atan2(-h, d)),
                                          (this._z = Math.atan2(-s, c)))
                                        : ((this._y = 0),
                                          (this._z = Math.atan2(o, r)));
                                break;
                            case "ZYX":
                                (this._y = Math.asin(-Pr(h, -1, 1))),
                                    Math.abs(h) < 0.9999999
                                        ? ((this._x = Math.atan2(u, d)),
                                          (this._z = Math.atan2(o, r)))
                                        : ((this._x = 0),
                                          (this._z = Math.atan2(-s, c)));
                                break;
                            case "YZX":
                                (this._z = Math.asin(Pr(o, -1, 1))),
                                    Math.abs(o) < 0.9999999
                                        ? ((this._x = Math.atan2(-l, c)),
                                          (this._y = Math.atan2(-h, r)))
                                        : ((this._x = 0),
                                          (this._y = Math.atan2(a, d)));
                                break;
                            case "XZY":
                                (this._z = Math.asin(-Pr(s, -1, 1))),
                                    Math.abs(s) < 0.9999999
                                        ? ((this._x = Math.atan2(u, c)),
                                          (this._y = Math.atan2(a, r)))
                                        : ((this._x = Math.atan2(-l, d)),
                                          (this._y = 0));
                                break;
                            default:
                                console.warn(
                                    "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                                        t
                                );
                        }
                        return (
                            (this._order = t),
                            !0 === i && this._onChangeCallback(),
                            this
                        );
                    }
                    setFromQuaternion(e, t, i) {
                        return (
                            Hs.makeRotationFromQuaternion(e),
                            this.setFromRotationMatrix(Hs, t, i)
                        );
                    }
                    setFromVector3(e, t = this._order) {
                        return this.set(e.x, e.y, e.z, t);
                    }
                    reorder(e) {
                        return (
                            Gs.setFromEuler(this), this.setFromQuaternion(Gs, e)
                        );
                    }
                    equals(e) {
                        return (
                            e._x === this._x &&
                            e._y === this._y &&
                            e._z === this._z &&
                            e._order === this._order
                        );
                    }
                    fromArray(e) {
                        return (
                            (this._x = e[0]),
                            (this._y = e[1]),
                            (this._z = e[2]),
                            void 0 !== e[3] && (this._order = e[3]),
                            this._onChangeCallback(),
                            this
                        );
                    }
                    toArray(e = [], t = 0) {
                        return (
                            (e[t] = this._x),
                            (e[t + 1] = this._y),
                            (e[t + 2] = this._z),
                            (e[t + 3] = this._order),
                            e
                        );
                    }
                    toVector3(e) {
                        return e
                            ? e.set(this._x, this._y, this._z)
                            : new rs(this._x, this._y, this._z);
                    }
                    _onChange(e) {
                        return (this._onChangeCallback = e), this;
                    }
                    _onChangeCallback() {}
                }
                (Vs.prototype.isEuler = !0),
                    (Vs.DefaultOrder = "XYZ"),
                    (Vs.RotationOrders = [
                        "XYZ",
                        "YZX",
                        "ZXY",
                        "XZY",
                        "YXZ",
                        "ZYX",
                    ]);
                class Ys {
                    constructor() {
                        this.mask = 1;
                    }
                    set(e) {
                        this.mask = 1 << e;
                    }
                    enable(e) {
                        this.mask |= 1 << e;
                    }
                    enableAll() {
                        this.mask = -1;
                    }
                    toggle(e) {
                        this.mask ^= 1 << e;
                    }
                    disable(e) {
                        this.mask &= ~(1 << e);
                    }
                    disableAll() {
                        this.mask = 0;
                    }
                    test(e) {
                        return !!(this.mask & e.mask);
                    }
                }
                let qs = 0;
                const Ws = new rs(),
                    Qs = new ns(),
                    Zs = new Os(),
                    Xs = new rs(),
                    Js = new rs(),
                    Ks = new rs(),
                    ea = new ns(),
                    ta = new rs(1, 0, 0),
                    ia = new rs(0, 1, 0),
                    na = new rs(0, 0, 1),
                    ra = { type: "added" },
                    sa = { type: "removed" };
                class aa extends Er {
                    constructor() {
                        super(),
                            Object.defineProperty(this, "id", { value: qs++ }),
                            (this.uuid = Rr()),
                            (this.name = ""),
                            (this.type = "Object3D"),
                            (this.parent = null),
                            (this.children = []),
                            (this.up = aa.DefaultUp.clone());
                        const e = new rs(),
                            t = new Vs(),
                            i = new ns(),
                            n = new rs(1, 1, 1);
                        t._onChange(function () {
                            i.setFromEuler(t, !1);
                        }),
                            i._onChange(function () {
                                t.setFromQuaternion(i, void 0, !1);
                            }),
                            Object.defineProperties(this, {
                                position: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: e,
                                },
                                rotation: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: t,
                                },
                                quaternion: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: i,
                                },
                                scale: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: n,
                                },
                                modelViewMatrix: { value: new Os() },
                                normalMatrix: { value: new Vr() },
                            }),
                            (this.matrix = new Os()),
                            (this.matrixWorld = new Os()),
                            (this.matrixAutoUpdate =
                                aa.DefaultMatrixAutoUpdate),
                            (this.matrixWorldNeedsUpdate = !1),
                            (this.layers = new Ys()),
                            (this.visible = !0),
                            (this.castShadow = !1),
                            (this.receiveShadow = !1),
                            (this.frustumCulled = !0),
                            (this.renderOrder = 0),
                            (this.animations = []),
                            (this.userData = {});
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(e) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                            this.matrix.premultiply(e),
                            this.matrix.decompose(
                                this.position,
                                this.quaternion,
                                this.scale
                            );
                    }
                    applyQuaternion(e) {
                        return this.quaternion.premultiply(e), this;
                    }
                    setRotationFromAxisAngle(e, t) {
                        this.quaternion.setFromAxisAngle(e, t);
                    }
                    setRotationFromEuler(e) {
                        this.quaternion.setFromEuler(e, !0);
                    }
                    setRotationFromMatrix(e) {
                        this.quaternion.setFromRotationMatrix(e);
                    }
                    setRotationFromQuaternion(e) {
                        this.quaternion.copy(e);
                    }
                    rotateOnAxis(e, t) {
                        return (
                            Qs.setFromAxisAngle(e, t),
                            this.quaternion.multiply(Qs),
                            this
                        );
                    }
                    rotateOnWorldAxis(e, t) {
                        return (
                            Qs.setFromAxisAngle(e, t),
                            this.quaternion.premultiply(Qs),
                            this
                        );
                    }
                    rotateX(e) {
                        return this.rotateOnAxis(ta, e);
                    }
                    rotateY(e) {
                        return this.rotateOnAxis(ia, e);
                    }
                    rotateZ(e) {
                        return this.rotateOnAxis(na, e);
                    }
                    translateOnAxis(e, t) {
                        return (
                            Ws.copy(e).applyQuaternion(this.quaternion),
                            this.position.add(Ws.multiplyScalar(t)),
                            this
                        );
                    }
                    translateX(e) {
                        return this.translateOnAxis(ta, e);
                    }
                    translateY(e) {
                        return this.translateOnAxis(ia, e);
                    }
                    translateZ(e) {
                        return this.translateOnAxis(na, e);
                    }
                    localToWorld(e) {
                        return e.applyMatrix4(this.matrixWorld);
                    }
                    worldToLocal(e) {
                        return e.applyMatrix4(
                            Zs.copy(this.matrixWorld).invert()
                        );
                    }
                    lookAt(e, t, i) {
                        e.isVector3 ? Xs.copy(e) : Xs.set(e, t, i);
                        const n = this.parent;
                        this.updateWorldMatrix(!0, !1),
                            Js.setFromMatrixPosition(this.matrixWorld),
                            this.isCamera || this.isLight
                                ? Zs.lookAt(Js, Xs, this.up)
                                : Zs.lookAt(Xs, Js, this.up),
                            this.quaternion.setFromRotationMatrix(Zs),
                            n &&
                                (Zs.extractRotation(n.matrixWorld),
                                Qs.setFromRotationMatrix(Zs),
                                this.quaternion.premultiply(Qs.invert()));
                    }
                    add(e) {
                        if (arguments.length > 1) {
                            for (let e = 0; e < arguments.length; e++)
                                this.add(arguments[e]);
                            return this;
                        }
                        return e === this
                            ? (console.error(
                                  "THREE.Object3D.add: object can't be added as a child of itself.",
                                  e
                              ),
                              this)
                            : (e && e.isObject3D
                                  ? (null !== e.parent && e.parent.remove(e),
                                    (e.parent = this),
                                    this.children.push(e),
                                    e.dispatchEvent(ra))
                                  : console.error(
                                        "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                                        e
                                    ),
                              this);
                    }
                    remove(e) {
                        if (arguments.length > 1) {
                            for (let e = 0; e < arguments.length; e++)
                                this.remove(arguments[e]);
                            return this;
                        }
                        const t = this.children.indexOf(e);
                        return (
                            -1 !== t &&
                                ((e.parent = null),
                                this.children.splice(t, 1),
                                e.dispatchEvent(sa)),
                            this
                        );
                    }
                    removeFromParent() {
                        const e = this.parent;
                        return null !== e && e.remove(this), this;
                    }
                    clear() {
                        for (let e = 0; e < this.children.length; e++) {
                            const t = this.children[e];
                            (t.parent = null), t.dispatchEvent(sa);
                        }
                        return (this.children.length = 0), this;
                    }
                    attach(e) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            Zs.copy(this.matrixWorld).invert(),
                            null !== e.parent &&
                                (e.parent.updateWorldMatrix(!0, !1),
                                Zs.multiply(e.parent.matrixWorld)),
                            e.applyMatrix4(Zs),
                            this.add(e),
                            e.updateWorldMatrix(!1, !0),
                            this
                        );
                    }
                    getObjectById(e) {
                        return this.getObjectByProperty("id", e);
                    }
                    getObjectByName(e) {
                        return this.getObjectByProperty("name", e);
                    }
                    getObjectByProperty(e, t) {
                        if (this[e] === t) return this;
                        for (let i = 0, n = this.children.length; i < n; i++) {
                            const n = this.children[i].getObjectByProperty(
                                e,
                                t
                            );
                            if (void 0 !== n) return n;
                        }
                    }
                    getWorldPosition(e) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            e.setFromMatrixPosition(this.matrixWorld)
                        );
                    }
                    getWorldQuaternion(e) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            this.matrixWorld.decompose(Js, e, Ks),
                            e
                        );
                    }
                    getWorldScale(e) {
                        return (
                            this.updateWorldMatrix(!0, !1),
                            this.matrixWorld.decompose(Js, ea, e),
                            e
                        );
                    }
                    getWorldDirection(e) {
                        this.updateWorldMatrix(!0, !1);
                        const t = this.matrixWorld.elements;
                        return e.set(t[8], t[9], t[10]).normalize();
                    }
                    raycast() {}
                    traverse(e) {
                        e(this);
                        const t = this.children;
                        for (let i = 0, n = t.length; i < n; i++)
                            t[i].traverse(e);
                    }
                    traverseVisible(e) {
                        if (!1 === this.visible) return;
                        e(this);
                        const t = this.children;
                        for (let i = 0, n = t.length; i < n; i++)
                            t[i].traverseVisible(e);
                    }
                    traverseAncestors(e) {
                        const t = this.parent;
                        null !== t && (e(t), t.traverseAncestors(e));
                    }
                    updateMatrix() {
                        this.matrix.compose(
                            this.position,
                            this.quaternion,
                            this.scale
                        ),
                            (this.matrixWorldNeedsUpdate = !0);
                    }
                    updateMatrixWorld(e) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                            (this.matrixWorldNeedsUpdate || e) &&
                                (null === this.parent
                                    ? this.matrixWorld.copy(this.matrix)
                                    : this.matrixWorld.multiplyMatrices(
                                          this.parent.matrixWorld,
                                          this.matrix
                                      ),
                                (this.matrixWorldNeedsUpdate = !1),
                                (e = !0));
                        const t = this.children;
                        for (let i = 0, n = t.length; i < n; i++)
                            t[i].updateMatrixWorld(e);
                    }
                    updateWorldMatrix(e, t) {
                        const i = this.parent;
                        if (
                            (!0 === e &&
                                null !== i &&
                                i.updateWorldMatrix(!0, !1),
                            this.matrixAutoUpdate && this.updateMatrix(),
                            null === this.parent
                                ? this.matrixWorld.copy(this.matrix)
                                : this.matrixWorld.multiplyMatrices(
                                      this.parent.matrixWorld,
                                      this.matrix
                                  ),
                            !0 === t)
                        ) {
                            const e = this.children;
                            for (let t = 0, i = e.length; t < i; t++)
                                e[t].updateWorldMatrix(!1, !0);
                        }
                    }
                    toJSON(e) {
                        const t = void 0 === e || "string" == typeof e,
                            i = {};
                        t &&
                            ((e = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                            }),
                            (i.metadata = {
                                version: 4.5,
                                type: "Object",
                                generator: "Object3D.toJSON",
                            }));
                        const n = {};
                        function r(t, i) {
                            return (
                                void 0 === t[i.uuid] &&
                                    (t[i.uuid] = i.toJSON(e)),
                                i.uuid
                            );
                        }
                        if (
                            ((n.uuid = this.uuid),
                            (n.type = this.type),
                            "" !== this.name && (n.name = this.name),
                            !0 === this.castShadow && (n.castShadow = !0),
                            !0 === this.receiveShadow && (n.receiveShadow = !0),
                            !1 === this.visible && (n.visible = !1),
                            !1 === this.frustumCulled && (n.frustumCulled = !1),
                            0 !== this.renderOrder &&
                                (n.renderOrder = this.renderOrder),
                            "{}" !== JSON.stringify(this.userData) &&
                                (n.userData = this.userData),
                            (n.layers = this.layers.mask),
                            (n.matrix = this.matrix.toArray()),
                            !1 === this.matrixAutoUpdate &&
                                (n.matrixAutoUpdate = !1),
                            this.isInstancedMesh &&
                                ((n.type = "InstancedMesh"),
                                (n.count = this.count),
                                (n.instanceMatrix =
                                    this.instanceMatrix.toJSON()),
                                null !== this.instanceColor &&
                                    (n.instanceColor =
                                        this.instanceColor.toJSON())),
                            this.isScene)
                        )
                            this.background &&
                                (this.background.isColor
                                    ? (n.background = this.background.toJSON())
                                    : this.background.isTexture &&
                                      (n.background =
                                          this.background.toJSON(e).uuid)),
                                this.environment &&
                                    this.environment.isTexture &&
                                    (n.environment =
                                        this.environment.toJSON(e).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            n.geometry = r(e.geometries, this.geometry);
                            const t = this.geometry.parameters;
                            if (void 0 !== t && void 0 !== t.shapes) {
                                const i = t.shapes;
                                if (Array.isArray(i))
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = i[t];
                                        r(e.shapes, n);
                                    }
                                else r(e.shapes, i);
                            }
                        }
                        if (
                            (this.isSkinnedMesh &&
                                ((n.bindMode = this.bindMode),
                                (n.bindMatrix = this.bindMatrix.toArray()),
                                void 0 !== this.skeleton &&
                                    (r(e.skeletons, this.skeleton),
                                    (n.skeleton = this.skeleton.uuid))),
                            void 0 !== this.material)
                        )
                            if (Array.isArray(this.material)) {
                                const t = [];
                                for (
                                    let i = 0, n = this.material.length;
                                    i < n;
                                    i++
                                )
                                    t.push(r(e.materials, this.material[i]));
                                n.material = t;
                            } else n.material = r(e.materials, this.material);
                        if (this.children.length > 0) {
                            n.children = [];
                            for (let t = 0; t < this.children.length; t++)
                                n.children.push(
                                    this.children[t].toJSON(e).object
                                );
                        }
                        if (this.animations.length > 0) {
                            n.animations = [];
                            for (let t = 0; t < this.animations.length; t++) {
                                const i = this.animations[t];
                                n.animations.push(r(e.animations, i));
                            }
                        }
                        if (t) {
                            const t = s(e.geometries),
                                n = s(e.materials),
                                r = s(e.textures),
                                a = s(e.images),
                                o = s(e.shapes),
                                c = s(e.skeletons),
                                l = s(e.animations);
                            t.length > 0 && (i.geometries = t),
                                n.length > 0 && (i.materials = n),
                                r.length > 0 && (i.textures = r),
                                a.length > 0 && (i.images = a),
                                o.length > 0 && (i.shapes = o),
                                c.length > 0 && (i.skeletons = c),
                                l.length > 0 && (i.animations = l);
                        }
                        return (i.object = n), i;
                        function s(e) {
                            const t = [];
                            for (const i in e) {
                                const n = e[i];
                                delete n.metadata, t.push(n);
                            }
                            return t;
                        }
                    }
                    clone(e) {
                        return new this.constructor().copy(this, e);
                    }
                    copy(e, t = !0) {
                        if (
                            ((this.name = e.name),
                            this.up.copy(e.up),
                            this.position.copy(e.position),
                            (this.rotation.order = e.rotation.order),
                            this.quaternion.copy(e.quaternion),
                            this.scale.copy(e.scale),
                            this.matrix.copy(e.matrix),
                            this.matrixWorld.copy(e.matrixWorld),
                            (this.matrixAutoUpdate = e.matrixAutoUpdate),
                            (this.matrixWorldNeedsUpdate =
                                e.matrixWorldNeedsUpdate),
                            (this.layers.mask = e.layers.mask),
                            (this.visible = e.visible),
                            (this.castShadow = e.castShadow),
                            (this.receiveShadow = e.receiveShadow),
                            (this.frustumCulled = e.frustumCulled),
                            (this.renderOrder = e.renderOrder),
                            (this.userData = JSON.parse(
                                JSON.stringify(e.userData)
                            )),
                            !0 === t)
                        )
                            for (let t = 0; t < e.children.length; t++) {
                                const i = e.children[t];
                                this.add(i.clone());
                            }
                        return this;
                    }
                }
                (aa.DefaultUp = new rs(0, 1, 0)),
                    (aa.DefaultMatrixAutoUpdate = !0),
                    (aa.prototype.isObject3D = !0);
                const oa = new rs(),
                    ca = new rs(),
                    la = new rs(),
                    ha = new rs(),
                    ua = new rs(),
                    da = new rs(),
                    pa = new rs(),
                    ga = new rs(),
                    ma = new rs(),
                    fa = new rs();
                class _a {
                    constructor(e = new rs(), t = new rs(), i = new rs()) {
                        (this.a = e), (this.b = t), (this.c = i);
                    }
                    static getNormal(e, t, i, n) {
                        n.subVectors(i, t), oa.subVectors(e, t), n.cross(oa);
                        const r = n.lengthSq();
                        return r > 0
                            ? n.multiplyScalar(1 / Math.sqrt(r))
                            : n.set(0, 0, 0);
                    }
                    static getBarycoord(e, t, i, n, r) {
                        oa.subVectors(n, t),
                            ca.subVectors(i, t),
                            la.subVectors(e, t);
                        const s = oa.dot(oa),
                            a = oa.dot(ca),
                            o = oa.dot(la),
                            c = ca.dot(ca),
                            l = ca.dot(la),
                            h = s * c - a * a;
                        if (0 === h) return r.set(-2, -1, -1);
                        const u = 1 / h,
                            d = (c * o - a * l) * u,
                            p = (s * l - a * o) * u;
                        return r.set(1 - d - p, p, d);
                    }
                    static containsPoint(e, t, i, n) {
                        return (
                            this.getBarycoord(e, t, i, n, ha),
                            ha.x >= 0 && ha.y >= 0 && ha.x + ha.y <= 1
                        );
                    }
                    static getUV(e, t, i, n, r, s, a, o) {
                        return (
                            this.getBarycoord(e, t, i, n, ha),
                            o.set(0, 0),
                            o.addScaledVector(r, ha.x),
                            o.addScaledVector(s, ha.y),
                            o.addScaledVector(a, ha.z),
                            o
                        );
                    }
                    static isFrontFacing(e, t, i, n) {
                        return (
                            oa.subVectors(i, t),
                            ca.subVectors(e, t),
                            oa.cross(ca).dot(n) < 0
                        );
                    }
                    set(e, t, i) {
                        return (
                            this.a.copy(e), this.b.copy(t), this.c.copy(i), this
                        );
                    }
                    setFromPointsAndIndices(e, t, i, n) {
                        return (
                            this.a.copy(e[t]),
                            this.b.copy(e[i]),
                            this.c.copy(e[n]),
                            this
                        );
                    }
                    setFromAttributeAndIndices(e, t, i, n) {
                        return (
                            this.a.fromBufferAttribute(e, t),
                            this.b.fromBufferAttribute(e, i),
                            this.c.fromBufferAttribute(e, n),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(e) {
                        return (
                            this.a.copy(e.a),
                            this.b.copy(e.b),
                            this.c.copy(e.c),
                            this
                        );
                    }
                    getArea() {
                        return (
                            oa.subVectors(this.c, this.b),
                            ca.subVectors(this.a, this.b),
                            0.5 * oa.cross(ca).length()
                        );
                    }
                    getMidpoint(e) {
                        return e
                            .addVectors(this.a, this.b)
                            .add(this.c)
                            .multiplyScalar(1 / 3);
                    }
                    getNormal(e) {
                        return _a.getNormal(this.a, this.b, this.c, e);
                    }
                    getPlane(e) {
                        return e.setFromCoplanarPoints(this.a, this.b, this.c);
                    }
                    getBarycoord(e, t) {
                        return _a.getBarycoord(e, this.a, this.b, this.c, t);
                    }
                    getUV(e, t, i, n, r) {
                        return _a.getUV(e, this.a, this.b, this.c, t, i, n, r);
                    }
                    containsPoint(e) {
                        return _a.containsPoint(e, this.a, this.b, this.c);
                    }
                    isFrontFacing(e) {
                        return _a.isFrontFacing(this.a, this.b, this.c, e);
                    }
                    intersectsBox(e) {
                        return e.intersectsTriangle(this);
                    }
                    closestPointToPoint(e, t) {
                        const i = this.a,
                            n = this.b,
                            r = this.c;
                        let s, a;
                        ua.subVectors(n, i),
                            da.subVectors(r, i),
                            ga.subVectors(e, i);
                        const o = ua.dot(ga),
                            c = da.dot(ga);
                        if (o <= 0 && c <= 0) return t.copy(i);
                        ma.subVectors(e, n);
                        const l = ua.dot(ma),
                            h = da.dot(ma);
                        if (l >= 0 && h <= l) return t.copy(n);
                        const u = o * h - l * c;
                        if (u <= 0 && o >= 0 && l <= 0)
                            return (
                                (s = o / (o - l)),
                                t.copy(i).addScaledVector(ua, s)
                            );
                        fa.subVectors(e, r);
                        const d = ua.dot(fa),
                            p = da.dot(fa);
                        if (p >= 0 && d <= p) return t.copy(r);
                        const g = d * c - o * p;
                        if (g <= 0 && c >= 0 && p <= 0)
                            return (
                                (a = c / (c - p)),
                                t.copy(i).addScaledVector(da, a)
                            );
                        const m = l * p - d * h;
                        if (m <= 0 && h - l >= 0 && d - p >= 0)
                            return (
                                pa.subVectors(r, n),
                                (a = (h - l) / (h - l + (d - p))),
                                t.copy(n).addScaledVector(pa, a)
                            );
                        const f = 1 / (m + g + u);
                        return (
                            (s = g * f),
                            (a = u * f),
                            t
                                .copy(i)
                                .addScaledVector(ua, s)
                                .addScaledVector(da, a)
                        );
                    }
                    equals(e) {
                        return (
                            e.a.equals(this.a) &&
                            e.b.equals(this.b) &&
                            e.c.equals(this.c)
                        );
                    }
                }
                let Ma = 0;
                class va extends Er {
                    constructor() {
                        super(),
                            Object.defineProperty(this, "id", { value: Ma++ }),
                            (this.uuid = Rr()),
                            (this.name = ""),
                            (this.type = "Material"),
                            (this.fog = !0),
                            (this.blending = Jt),
                            (this.side = Wt),
                            (this.vertexColors = !1),
                            (this.opacity = 1),
                            (this.format = dn),
                            (this.transparent = !1),
                            (this.blendSrc = di),
                            (this.blendDst = pi),
                            (this.blendEquation = ni),
                            (this.blendSrcAlpha = null),
                            (this.blendDstAlpha = null),
                            (this.blendEquationAlpha = null),
                            (this.depthFunc = bi),
                            (this.depthTest = !0),
                            (this.depthWrite = !0),
                            (this.stencilWriteMask = 255),
                            (this.stencilFunc = 519),
                            (this.stencilRef = 0),
                            (this.stencilFuncMask = 255),
                            (this.stencilFail = Dr),
                            (this.stencilZFail = Dr),
                            (this.stencilZPass = Dr),
                            (this.stencilWrite = !1),
                            (this.clippingPlanes = null),
                            (this.clipIntersection = !1),
                            (this.clipShadows = !1),
                            (this.shadowSide = null),
                            (this.colorWrite = !0),
                            (this.precision = null),
                            (this.polygonOffset = !1),
                            (this.polygonOffsetFactor = 0),
                            (this.polygonOffsetUnits = 0),
                            (this.dithering = !1),
                            (this.alphaToCoverage = !1),
                            (this.premultipliedAlpha = !1),
                            (this.visible = !0),
                            (this.toneMapped = !0),
                            (this.userData = {}),
                            (this.version = 0),
                            (this._alphaTest = 0);
                    }
                    get alphaTest() {
                        return this._alphaTest;
                    }
                    set alphaTest(e) {
                        this._alphaTest > 0 != e > 0 && this.version++,
                            (this._alphaTest = e);
                    }
                    onBuild() {}
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString();
                    }
                    setValues(e) {
                        if (void 0 !== e)
                            for (const t in e) {
                                const i = e[t];
                                if (void 0 === i) {
                                    console.warn(
                                        "THREE.Material: '" +
                                            t +
                                            "' parameter is undefined."
                                    );
                                    continue;
                                }
                                if ("shading" === t) {
                                    console.warn(
                                        "THREE." +
                                            this.type +
                                            ": .shading has been removed. Use the boolean .flatShading instead."
                                    ),
                                        (this.flatShading = 1 === i);
                                    continue;
                                }
                                const n = this[t];
                                void 0 !== n
                                    ? n && n.isColor
                                        ? n.set(i)
                                        : n && n.isVector3 && i && i.isVector3
                                        ? n.copy(i)
                                        : (this[t] = i)
                                    : console.warn(
                                          "THREE." +
                                              this.type +
                                              ": '" +
                                              t +
                                              "' is not a property of this material."
                                      );
                            }
                    }
                    toJSON(e) {
                        const t = void 0 === e || "string" == typeof e;
                        t && (e = { textures: {}, images: {} });
                        const i = {
                            metadata: {
                                version: 4.5,
                                type: "Material",
                                generator: "Material.toJSON",
                            },
                        };
                        function n(e) {
                            const t = [];
                            for (const i in e) {
                                const n = e[i];
                                delete n.metadata, t.push(n);
                            }
                            return t;
                        }
                        if (
                            ((i.uuid = this.uuid),
                            (i.type = this.type),
                            "" !== this.name && (i.name = this.name),
                            this.color &&
                                this.color.isColor &&
                                (i.color = this.color.getHex()),
                            void 0 !== this.roughness &&
                                (i.roughness = this.roughness),
                            void 0 !== this.metalness &&
                                (i.metalness = this.metalness),
                            void 0 !== this.sheen && (i.sheen = this.sheen),
                            this.sheenColor &&
                                this.sheenColor.isColor &&
                                (i.sheenColor = this.sheenColor.getHex()),
                            void 0 !== this.sheenRoughness &&
                                (i.sheenRoughness = this.sheenRoughness),
                            this.emissive &&
                                this.emissive.isColor &&
                                (i.emissive = this.emissive.getHex()),
                            this.emissiveIntensity &&
                                1 !== this.emissiveIntensity &&
                                (i.emissiveIntensity = this.emissiveIntensity),
                            this.specular &&
                                this.specular.isColor &&
                                (i.specular = this.specular.getHex()),
                            void 0 !== this.specularIntensity &&
                                (i.specularIntensity = this.specularIntensity),
                            this.specularColor &&
                                this.specularColor.isColor &&
                                (i.specularColor = this.specularColor.getHex()),
                            void 0 !== this.shininess &&
                                (i.shininess = this.shininess),
                            void 0 !== this.clearcoat &&
                                (i.clearcoat = this.clearcoat),
                            void 0 !== this.clearcoatRoughness &&
                                (i.clearcoatRoughness =
                                    this.clearcoatRoughness),
                            this.clearcoatMap &&
                                this.clearcoatMap.isTexture &&
                                (i.clearcoatMap =
                                    this.clearcoatMap.toJSON(e).uuid),
                            this.clearcoatRoughnessMap &&
                                this.clearcoatRoughnessMap.isTexture &&
                                (i.clearcoatRoughnessMap =
                                    this.clearcoatRoughnessMap.toJSON(e).uuid),
                            this.clearcoatNormalMap &&
                                this.clearcoatNormalMap.isTexture &&
                                ((i.clearcoatNormalMap =
                                    this.clearcoatNormalMap.toJSON(e).uuid),
                                (i.clearcoatNormalScale =
                                    this.clearcoatNormalScale.toArray())),
                            this.map &&
                                this.map.isTexture &&
                                (i.map = this.map.toJSON(e).uuid),
                            this.matcap &&
                                this.matcap.isTexture &&
                                (i.matcap = this.matcap.toJSON(e).uuid),
                            this.alphaMap &&
                                this.alphaMap.isTexture &&
                                (i.alphaMap = this.alphaMap.toJSON(e).uuid),
                            this.lightMap &&
                                this.lightMap.isTexture &&
                                ((i.lightMap = this.lightMap.toJSON(e).uuid),
                                (i.lightMapIntensity = this.lightMapIntensity)),
                            this.aoMap &&
                                this.aoMap.isTexture &&
                                ((i.aoMap = this.aoMap.toJSON(e).uuid),
                                (i.aoMapIntensity = this.aoMapIntensity)),
                            this.bumpMap &&
                                this.bumpMap.isTexture &&
                                ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
                                (i.bumpScale = this.bumpScale)),
                            this.normalMap &&
                                this.normalMap.isTexture &&
                                ((i.normalMap = this.normalMap.toJSON(e).uuid),
                                (i.normalMapType = this.normalMapType),
                                (i.normalScale = this.normalScale.toArray())),
                            this.displacementMap &&
                                this.displacementMap.isTexture &&
                                ((i.displacementMap =
                                    this.displacementMap.toJSON(e).uuid),
                                (i.displacementScale = this.displacementScale),
                                (i.displacementBias = this.displacementBias)),
                            this.roughnessMap &&
                                this.roughnessMap.isTexture &&
                                (i.roughnessMap =
                                    this.roughnessMap.toJSON(e).uuid),
                            this.metalnessMap &&
                                this.metalnessMap.isTexture &&
                                (i.metalnessMap =
                                    this.metalnessMap.toJSON(e).uuid),
                            this.emissiveMap &&
                                this.emissiveMap.isTexture &&
                                (i.emissiveMap =
                                    this.emissiveMap.toJSON(e).uuid),
                            this.specularMap &&
                                this.specularMap.isTexture &&
                                (i.specularMap =
                                    this.specularMap.toJSON(e).uuid),
                            this.specularIntensityMap &&
                                this.specularIntensityMap.isTexture &&
                                (i.specularIntensityMap =
                                    this.specularIntensityMap.toJSON(e).uuid),
                            this.specularColorMap &&
                                this.specularColorMap.isTexture &&
                                (i.specularColorMap =
                                    this.specularColorMap.toJSON(e).uuid),
                            this.envMap &&
                                this.envMap.isTexture &&
                                ((i.envMap = this.envMap.toJSON(e).uuid),
                                void 0 !== this.combine &&
                                    (i.combine = this.combine)),
                            void 0 !== this.envMapIntensity &&
                                (i.envMapIntensity = this.envMapIntensity),
                            void 0 !== this.reflectivity &&
                                (i.reflectivity = this.reflectivity),
                            void 0 !== this.refractionRatio &&
                                (i.refractionRatio = this.refractionRatio),
                            this.gradientMap &&
                                this.gradientMap.isTexture &&
                                (i.gradientMap =
                                    this.gradientMap.toJSON(e).uuid),
                            void 0 !== this.transmission &&
                                (i.transmission = this.transmission),
                            this.transmissionMap &&
                                this.transmissionMap.isTexture &&
                                (i.transmissionMap =
                                    this.transmissionMap.toJSON(e).uuid),
                            void 0 !== this.thickness &&
                                (i.thickness = this.thickness),
                            this.thicknessMap &&
                                this.thicknessMap.isTexture &&
                                (i.thicknessMap =
                                    this.thicknessMap.toJSON(e).uuid),
                            void 0 !== this.attenuationDistance &&
                                (i.attenuationDistance =
                                    this.attenuationDistance),
                            void 0 !== this.attenuationColor &&
                                (i.attenuationColor =
                                    this.attenuationColor.getHex()),
                            void 0 !== this.size && (i.size = this.size),
                            null !== this.shadowSide &&
                                (i.shadowSide = this.shadowSide),
                            void 0 !== this.sizeAttenuation &&
                                (i.sizeAttenuation = this.sizeAttenuation),
                            this.blending !== Jt &&
                                (i.blending = this.blending),
                            this.side !== Wt && (i.side = this.side),
                            this.vertexColors && (i.vertexColors = !0),
                            this.opacity < 1 && (i.opacity = this.opacity),
                            this.format !== dn && (i.format = this.format),
                            !0 === this.transparent &&
                                (i.transparent = this.transparent),
                            (i.depthFunc = this.depthFunc),
                            (i.depthTest = this.depthTest),
                            (i.depthWrite = this.depthWrite),
                            (i.colorWrite = this.colorWrite),
                            (i.stencilWrite = this.stencilWrite),
                            (i.stencilWriteMask = this.stencilWriteMask),
                            (i.stencilFunc = this.stencilFunc),
                            (i.stencilRef = this.stencilRef),
                            (i.stencilFuncMask = this.stencilFuncMask),
                            (i.stencilFail = this.stencilFail),
                            (i.stencilZFail = this.stencilZFail),
                            (i.stencilZPass = this.stencilZPass),
                            this.rotation &&
                                0 !== this.rotation &&
                                (i.rotation = this.rotation),
                            !0 === this.polygonOffset && (i.polygonOffset = !0),
                            0 !== this.polygonOffsetFactor &&
                                (i.polygonOffsetFactor =
                                    this.polygonOffsetFactor),
                            0 !== this.polygonOffsetUnits &&
                                (i.polygonOffsetUnits =
                                    this.polygonOffsetUnits),
                            this.linewidth &&
                                1 !== this.linewidth &&
                                (i.linewidth = this.linewidth),
                            void 0 !== this.dashSize &&
                                (i.dashSize = this.dashSize),
                            void 0 !== this.gapSize &&
                                (i.gapSize = this.gapSize),
                            void 0 !== this.scale && (i.scale = this.scale),
                            !0 === this.dithering && (i.dithering = !0),
                            this.alphaTest > 0 &&
                                (i.alphaTest = this.alphaTest),
                            !0 === this.alphaToCoverage &&
                                (i.alphaToCoverage = this.alphaToCoverage),
                            !0 === this.premultipliedAlpha &&
                                (i.premultipliedAlpha =
                                    this.premultipliedAlpha),
                            !0 === this.wireframe &&
                                (i.wireframe = this.wireframe),
                            this.wireframeLinewidth > 1 &&
                                (i.wireframeLinewidth =
                                    this.wireframeLinewidth),
                            "round" !== this.wireframeLinecap &&
                                (i.wireframeLinecap = this.wireframeLinecap),
                            "round" !== this.wireframeLinejoin &&
                                (i.wireframeLinejoin = this.wireframeLinejoin),
                            !0 === this.flatShading &&
                                (i.flatShading = this.flatShading),
                            !1 === this.visible && (i.visible = !1),
                            !1 === this.toneMapped && (i.toneMapped = !1),
                            "{}" !== JSON.stringify(this.userData) &&
                                (i.userData = this.userData),
                            t)
                        ) {
                            const t = n(e.textures),
                                r = n(e.images);
                            t.length > 0 && (i.textures = t),
                                r.length > 0 && (i.images = r);
                        }
                        return i;
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(e) {
                        (this.name = e.name),
                            (this.fog = e.fog),
                            (this.blending = e.blending),
                            (this.side = e.side),
                            (this.vertexColors = e.vertexColors),
                            (this.opacity = e.opacity),
                            (this.format = e.format),
                            (this.transparent = e.transparent),
                            (this.blendSrc = e.blendSrc),
                            (this.blendDst = e.blendDst),
                            (this.blendEquation = e.blendEquation),
                            (this.blendSrcAlpha = e.blendSrcAlpha),
                            (this.blendDstAlpha = e.blendDstAlpha),
                            (this.blendEquationAlpha = e.blendEquationAlpha),
                            (this.depthFunc = e.depthFunc),
                            (this.depthTest = e.depthTest),
                            (this.depthWrite = e.depthWrite),
                            (this.stencilWriteMask = e.stencilWriteMask),
                            (this.stencilFunc = e.stencilFunc),
                            (this.stencilRef = e.stencilRef),
                            (this.stencilFuncMask = e.stencilFuncMask),
                            (this.stencilFail = e.stencilFail),
                            (this.stencilZFail = e.stencilZFail),
                            (this.stencilZPass = e.stencilZPass),
                            (this.stencilWrite = e.stencilWrite);
                        const t = e.clippingPlanes;
                        let i = null;
                        if (null !== t) {
                            const e = t.length;
                            i = new Array(e);
                            for (let n = 0; n !== e; ++n) i[n] = t[n].clone();
                        }
                        return (
                            (this.clippingPlanes = i),
                            (this.clipIntersection = e.clipIntersection),
                            (this.clipShadows = e.clipShadows),
                            (this.shadowSide = e.shadowSide),
                            (this.colorWrite = e.colorWrite),
                            (this.precision = e.precision),
                            (this.polygonOffset = e.polygonOffset),
                            (this.polygonOffsetFactor = e.polygonOffsetFactor),
                            (this.polygonOffsetUnits = e.polygonOffsetUnits),
                            (this.dithering = e.dithering),
                            (this.alphaTest = e.alphaTest),
                            (this.alphaToCoverage = e.alphaToCoverage),
                            (this.premultipliedAlpha = e.premultipliedAlpha),
                            (this.visible = e.visible),
                            (this.toneMapped = e.toneMapped),
                            (this.userData = JSON.parse(
                                JSON.stringify(e.userData)
                            )),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                    set needsUpdate(e) {
                        !0 === e && this.version++;
                    }
                }
                va.prototype.isMaterial = !0;
                const ya = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074,
                    },
                    xa = { h: 0, s: 0, l: 0 },
                    ba = { h: 0, s: 0, l: 0 };
                function wa(e, t, i) {
                    return (
                        i < 0 && (i += 1),
                        i > 1 && (i -= 1),
                        i < 1 / 6
                            ? e + 6 * (t - e) * i
                            : i < 0.5
                            ? t
                            : i < 2 / 3
                            ? e + 6 * (t - e) * (2 / 3 - i)
                            : e
                    );
                }
                function Ta(e) {
                    return e < 0.04045
                        ? 0.0773993808 * e
                        : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
                }
                function Sa(e) {
                    return e < 0.0031308
                        ? 12.92 * e
                        : 1.055 * Math.pow(e, 0.41666) - 0.055;
                }
                class Na {
                    constructor(e, t, i) {
                        return void 0 === t && void 0 === i
                            ? this.set(e)
                            : this.setRGB(e, t, i);
                    }
                    set(e) {
                        return (
                            e && e.isColor
                                ? this.copy(e)
                                : "number" == typeof e
                                ? this.setHex(e)
                                : "string" == typeof e && this.setStyle(e),
                            this
                        );
                    }
                    setScalar(e) {
                        return (this.r = e), (this.g = e), (this.b = e), this;
                    }
                    setHex(e) {
                        return (
                            (e = Math.floor(e)),
                            (this.r = ((e >> 16) & 255) / 255),
                            (this.g = ((e >> 8) & 255) / 255),
                            (this.b = (255 & e) / 255),
                            this
                        );
                    }
                    setRGB(e, t, i) {
                        return (this.r = e), (this.g = t), (this.b = i), this;
                    }
                    setHSL(e, t, i) {
                        if (
                            ((e = Ur(e, 1)),
                            (t = Pr(t, 0, 1)),
                            (i = Pr(i, 0, 1)),
                            0 === t)
                        )
                            this.r = this.g = this.b = i;
                        else {
                            const n = i <= 0.5 ? i * (1 + t) : i + t - i * t,
                                r = 2 * i - n;
                            (this.r = wa(r, n, e + 1 / 3)),
                                (this.g = wa(r, n, e)),
                                (this.b = wa(r, n, e - 1 / 3));
                        }
                        return this;
                    }
                    setStyle(e) {
                        function t(t) {
                            void 0 !== t &&
                                parseFloat(t) < 1 &&
                                console.warn(
                                    "THREE.Color: Alpha component of " +
                                        e +
                                        " will be ignored."
                                );
                        }
                        let i;
                        if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
                            let e;
                            const n = i[1],
                                r = i[2];
                            switch (n) {
                                case "rgb":
                                case "rgba":
                                    if (
                                        (e =
                                            /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                r
                                            ))
                                    )
                                        return (
                                            (this.r =
                                                Math.min(
                                                    255,
                                                    parseInt(e[1], 10)
                                                ) / 255),
                                            (this.g =
                                                Math.min(
                                                    255,
                                                    parseInt(e[2], 10)
                                                ) / 255),
                                            (this.b =
                                                Math.min(
                                                    255,
                                                    parseInt(e[3], 10)
                                                ) / 255),
                                            t(e[4]),
                                            this
                                        );
                                    if (
                                        (e =
                                            /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                r
                                            ))
                                    )
                                        return (
                                            (this.r =
                                                Math.min(
                                                    100,
                                                    parseInt(e[1], 10)
                                                ) / 100),
                                            (this.g =
                                                Math.min(
                                                    100,
                                                    parseInt(e[2], 10)
                                                ) / 100),
                                            (this.b =
                                                Math.min(
                                                    100,
                                                    parseInt(e[3], 10)
                                                ) / 100),
                                            t(e[4]),
                                            this
                                        );
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (
                                        (e =
                                            /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                                r
                                            ))
                                    ) {
                                        const i = parseFloat(e[1]) / 360,
                                            n = parseInt(e[2], 10) / 100,
                                            r = parseInt(e[3], 10) / 100;
                                        return t(e[4]), this.setHSL(i, n, r);
                                    }
                            }
                        } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
                            const e = i[1],
                                t = e.length;
                            if (3 === t)
                                return (
                                    (this.r =
                                        parseInt(
                                            e.charAt(0) + e.charAt(0),
                                            16
                                        ) / 255),
                                    (this.g =
                                        parseInt(
                                            e.charAt(1) + e.charAt(1),
                                            16
                                        ) / 255),
                                    (this.b =
                                        parseInt(
                                            e.charAt(2) + e.charAt(2),
                                            16
                                        ) / 255),
                                    this
                                );
                            if (6 === t)
                                return (
                                    (this.r =
                                        parseInt(
                                            e.charAt(0) + e.charAt(1),
                                            16
                                        ) / 255),
                                    (this.g =
                                        parseInt(
                                            e.charAt(2) + e.charAt(3),
                                            16
                                        ) / 255),
                                    (this.b =
                                        parseInt(
                                            e.charAt(4) + e.charAt(5),
                                            16
                                        ) / 255),
                                    this
                                );
                        }
                        return e && e.length > 0 ? this.setColorName(e) : this;
                    }
                    setColorName(e) {
                        const t = ya[e.toLowerCase()];
                        return (
                            void 0 !== t
                                ? this.setHex(t)
                                : console.warn(
                                      "THREE.Color: Unknown color " + e
                                  ),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor(this.r, this.g, this.b);
                    }
                    copy(e) {
                        return (
                            (this.r = e.r), (this.g = e.g), (this.b = e.b), this
                        );
                    }
                    copyGammaToLinear(e, t = 2) {
                        return (
                            (this.r = Math.pow(e.r, t)),
                            (this.g = Math.pow(e.g, t)),
                            (this.b = Math.pow(e.b, t)),
                            this
                        );
                    }
                    copyLinearToGamma(e, t = 2) {
                        const i = t > 0 ? 1 / t : 1;
                        return (
                            (this.r = Math.pow(e.r, i)),
                            (this.g = Math.pow(e.g, i)),
                            (this.b = Math.pow(e.b, i)),
                            this
                        );
                    }
                    convertGammaToLinear(e) {
                        return this.copyGammaToLinear(this, e), this;
                    }
                    convertLinearToGamma(e) {
                        return this.copyLinearToGamma(this, e), this;
                    }
                    copySRGBToLinear(e) {
                        return (
                            (this.r = Ta(e.r)),
                            (this.g = Ta(e.g)),
                            (this.b = Ta(e.b)),
                            this
                        );
                    }
                    copyLinearToSRGB(e) {
                        return (
                            (this.r = Sa(e.r)),
                            (this.g = Sa(e.g)),
                            (this.b = Sa(e.b)),
                            this
                        );
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this), this;
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this), this;
                    }
                    getHex() {
                        return (
                            ((255 * this.r) << 16) ^
                            ((255 * this.g) << 8) ^
                            (255 * this.b)
                        );
                    }
                    getHexString() {
                        return ("000000" + this.getHex().toString(16)).slice(
                            -6
                        );
                    }
                    getHSL(e) {
                        const t = this.r,
                            i = this.g,
                            n = this.b,
                            r = Math.max(t, i, n),
                            s = Math.min(t, i, n);
                        let a, o;
                        const c = (s + r) / 2;
                        if (s === r) (a = 0), (o = 0);
                        else {
                            const e = r - s;
                            switch (
                                ((o = c <= 0.5 ? e / (r + s) : e / (2 - r - s)),
                                r)
                            ) {
                                case t:
                                    a = (i - n) / e + (i < n ? 6 : 0);
                                    break;
                                case i:
                                    a = (n - t) / e + 2;
                                    break;
                                case n:
                                    a = (t - i) / e + 4;
                            }
                            a /= 6;
                        }
                        return (e.h = a), (e.s = o), (e.l = c), e;
                    }
                    getStyle() {
                        return (
                            "rgb(" +
                            ((255 * this.r) | 0) +
                            "," +
                            ((255 * this.g) | 0) +
                            "," +
                            ((255 * this.b) | 0) +
                            ")"
                        );
                    }
                    offsetHSL(e, t, i) {
                        return (
                            this.getHSL(xa),
                            (xa.h += e),
                            (xa.s += t),
                            (xa.l += i),
                            this.setHSL(xa.h, xa.s, xa.l),
                            this
                        );
                    }
                    add(e) {
                        return (
                            (this.r += e.r),
                            (this.g += e.g),
                            (this.b += e.b),
                            this
                        );
                    }
                    addColors(e, t) {
                        return (
                            (this.r = e.r + t.r),
                            (this.g = e.g + t.g),
                            (this.b = e.b + t.b),
                            this
                        );
                    }
                    addScalar(e) {
                        return (
                            (this.r += e), (this.g += e), (this.b += e), this
                        );
                    }
                    sub(e) {
                        return (
                            (this.r = Math.max(0, this.r - e.r)),
                            (this.g = Math.max(0, this.g - e.g)),
                            (this.b = Math.max(0, this.b - e.b)),
                            this
                        );
                    }
                    multiply(e) {
                        return (
                            (this.r *= e.r),
                            (this.g *= e.g),
                            (this.b *= e.b),
                            this
                        );
                    }
                    multiplyScalar(e) {
                        return (
                            (this.r *= e), (this.g *= e), (this.b *= e), this
                        );
                    }
                    lerp(e, t) {
                        return (
                            (this.r += (e.r - this.r) * t),
                            (this.g += (e.g - this.g) * t),
                            (this.b += (e.b - this.b) * t),
                            this
                        );
                    }
                    lerpColors(e, t, i) {
                        return (
                            (this.r = e.r + (t.r - e.r) * i),
                            (this.g = e.g + (t.g - e.g) * i),
                            (this.b = e.b + (t.b - e.b) * i),
                            this
                        );
                    }
                    lerpHSL(e, t) {
                        this.getHSL(xa), e.getHSL(ba);
                        const i = $r(xa.h, ba.h, t),
                            n = $r(xa.s, ba.s, t),
                            r = $r(xa.l, ba.l, t);
                        return this.setHSL(i, n, r), this;
                    }
                    equals(e) {
                        return (
                            e.r === this.r && e.g === this.g && e.b === this.b
                        );
                    }
                    fromArray(e, t = 0) {
                        return (
                            (this.r = e[t]),
                            (this.g = e[t + 1]),
                            (this.b = e[t + 2]),
                            this
                        );
                    }
                    toArray(e = [], t = 0) {
                        return (
                            (e[t] = this.r),
                            (e[t + 1] = this.g),
                            (e[t + 2] = this.b),
                            e
                        );
                    }
                    fromBufferAttribute(e, t) {
                        return (
                            (this.r = e.getX(t)),
                            (this.g = e.getY(t)),
                            (this.b = e.getZ(t)),
                            !0 === e.normalized &&
                                ((this.r /= 255),
                                (this.g /= 255),
                                (this.b /= 255)),
                            this
                        );
                    }
                    toJSON() {
                        return this.getHex();
                    }
                }
                (Na.NAMES = ya),
                    (Na.prototype.isColor = !0),
                    (Na.prototype.r = 1),
                    (Na.prototype.g = 1),
                    (Na.prototype.b = 1);
                class Da extends va {
                    constructor(e) {
                        super(),
                            (this.type = "MeshBasicMaterial"),
                            (this.color = new Na(16777215)),
                            (this.map = null),
                            (this.lightMap = null),
                            (this.lightMapIntensity = 1),
                            (this.aoMap = null),
                            (this.aoMapIntensity = 1),
                            (this.specularMap = null),
                            (this.alphaMap = null),
                            (this.envMap = null),
                            (this.combine = Di),
                            (this.reflectivity = 1),
                            (this.refractionRatio = 0.98),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.wireframeLinecap = "round"),
                            (this.wireframeLinejoin = "round"),
                            this.setValues(e);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.color.copy(e.color),
                            (this.map = e.map),
                            (this.lightMap = e.lightMap),
                            (this.lightMapIntensity = e.lightMapIntensity),
                            (this.aoMap = e.aoMap),
                            (this.aoMapIntensity = e.aoMapIntensity),
                            (this.specularMap = e.specularMap),
                            (this.alphaMap = e.alphaMap),
                            (this.envMap = e.envMap),
                            (this.combine = e.combine),
                            (this.reflectivity = e.reflectivity),
                            (this.refractionRatio = e.refractionRatio),
                            (this.wireframe = e.wireframe),
                            (this.wireframeLinewidth = e.wireframeLinewidth),
                            (this.wireframeLinecap = e.wireframeLinecap),
                            (this.wireframeLinejoin = e.wireframeLinejoin),
                            this
                        );
                    }
                }
                Da.prototype.isMeshBasicMaterial = !0;
                const Ia = new rs(),
                    Ca = new Gr();
                class Aa {
                    constructor(e, t, i) {
                        if (Array.isArray(e))
                            throw new TypeError(
                                "THREE.BufferAttribute: array should be a Typed Array."
                            );
                        (this.name = ""),
                            (this.array = e),
                            (this.itemSize = t),
                            (this.count = void 0 !== e ? e.length / t : 0),
                            (this.normalized = !0 === i),
                            (this.usage = Ir),
                            (this.updateRange = { offset: 0, count: -1 }),
                            (this.version = 0);
                    }
                    onUploadCallback() {}
                    set needsUpdate(e) {
                        !0 === e && this.version++;
                    }
                    setUsage(e) {
                        return (this.usage = e), this;
                    }
                    copy(e) {
                        return (
                            (this.name = e.name),
                            (this.array = new e.array.constructor(e.array)),
                            (this.itemSize = e.itemSize),
                            (this.count = e.count),
                            (this.normalized = e.normalized),
                            (this.usage = e.usage),
                            this
                        );
                    }
                    copyAt(e, t, i) {
                        (e *= this.itemSize), (i *= t.itemSize);
                        for (let n = 0, r = this.itemSize; n < r; n++)
                            this.array[e + n] = t.array[i + n];
                        return this;
                    }
                    copyArray(e) {
                        return this.array.set(e), this;
                    }
                    copyColorsArray(e) {
                        const t = this.array;
                        let i = 0;
                        for (let n = 0, r = e.length; n < r; n++) {
                            let r = e[n];
                            void 0 === r &&
                                (console.warn(
                                    "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                                    n
                                ),
                                (r = new Na())),
                                (t[i++] = r.r),
                                (t[i++] = r.g),
                                (t[i++] = r.b);
                        }
                        return this;
                    }
                    copyVector2sArray(e) {
                        const t = this.array;
                        let i = 0;
                        for (let n = 0, r = e.length; n < r; n++) {
                            let r = e[n];
                            void 0 === r &&
                                (console.warn(
                                    "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                                    n
                                ),
                                (r = new Gr())),
                                (t[i++] = r.x),
                                (t[i++] = r.y);
                        }
                        return this;
                    }
                    copyVector3sArray(e) {
                        const t = this.array;
                        let i = 0;
                        for (let n = 0, r = e.length; n < r; n++) {
                            let r = e[n];
                            void 0 === r &&
                                (console.warn(
                                    "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                                    n
                                ),
                                (r = new rs())),
                                (t[i++] = r.x),
                                (t[i++] = r.y),
                                (t[i++] = r.z);
                        }
                        return this;
                    }
                    copyVector4sArray(e) {
                        const t = this.array;
                        let i = 0;
                        for (let n = 0, r = e.length; n < r; n++) {
                            let r = e[n];
                            void 0 === r &&
                                (console.warn(
                                    "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                                    n
                                ),
                                (r = new es())),
                                (t[i++] = r.x),
                                (t[i++] = r.y),
                                (t[i++] = r.z),
                                (t[i++] = r.w);
                        }
                        return this;
                    }
                    applyMatrix3(e) {
                        if (2 === this.itemSize)
                            for (let t = 0, i = this.count; t < i; t++)
                                Ca.fromBufferAttribute(this, t),
                                    Ca.applyMatrix3(e),
                                    this.setXY(t, Ca.x, Ca.y);
                        else if (3 === this.itemSize)
                            for (let t = 0, i = this.count; t < i; t++)
                                Ia.fromBufferAttribute(this, t),
                                    Ia.applyMatrix3(e),
                                    this.setXYZ(t, Ia.x, Ia.y, Ia.z);
                        return this;
                    }
                    applyMatrix4(e) {
                        for (let t = 0, i = this.count; t < i; t++)
                            (Ia.x = this.getX(t)),
                                (Ia.y = this.getY(t)),
                                (Ia.z = this.getZ(t)),
                                Ia.applyMatrix4(e),
                                this.setXYZ(t, Ia.x, Ia.y, Ia.z);
                        return this;
                    }
                    applyNormalMatrix(e) {
                        for (let t = 0, i = this.count; t < i; t++)
                            (Ia.x = this.getX(t)),
                                (Ia.y = this.getY(t)),
                                (Ia.z = this.getZ(t)),
                                Ia.applyNormalMatrix(e),
                                this.setXYZ(t, Ia.x, Ia.y, Ia.z);
                        return this;
                    }
                    transformDirection(e) {
                        for (let t = 0, i = this.count; t < i; t++)
                            (Ia.x = this.getX(t)),
                                (Ia.y = this.getY(t)),
                                (Ia.z = this.getZ(t)),
                                Ia.transformDirection(e),
                                this.setXYZ(t, Ia.x, Ia.y, Ia.z);
                        return this;
                    }
                    set(e, t = 0) {
                        return this.array.set(e, t), this;
                    }
                    getX(e) {
                        return this.array[e * this.itemSize];
                    }
                    setX(e, t) {
                        return (this.array[e * this.itemSize] = t), this;
                    }
                    getY(e) {
                        return this.array[e * this.itemSize + 1];
                    }
                    setY(e, t) {
                        return (this.array[e * this.itemSize + 1] = t), this;
                    }
                    getZ(e) {
                        return this.array[e * this.itemSize + 2];
                    }
                    setZ(e, t) {
                        return (this.array[e * this.itemSize + 2] = t), this;
                    }
                    getW(e) {
                        return this.array[e * this.itemSize + 3];
                    }
                    setW(e, t) {
                        return (this.array[e * this.itemSize + 3] = t), this;
                    }
                    setXY(e, t, i) {
                        return (
                            (e *= this.itemSize),
                            (this.array[e + 0] = t),
                            (this.array[e + 1] = i),
                            this
                        );
                    }
                    setXYZ(e, t, i, n) {
                        return (
                            (e *= this.itemSize),
                            (this.array[e + 0] = t),
                            (this.array[e + 1] = i),
                            (this.array[e + 2] = n),
                            this
                        );
                    }
                    setXYZW(e, t, i, n, r) {
                        return (
                            (e *= this.itemSize),
                            (this.array[e + 0] = t),
                            (this.array[e + 1] = i),
                            (this.array[e + 2] = n),
                            (this.array[e + 3] = r),
                            this
                        );
                    }
                    onUpload(e) {
                        return (this.onUploadCallback = e), this;
                    }
                    clone() {
                        return new this.constructor(
                            this.array,
                            this.itemSize
                        ).copy(this);
                    }
                    toJSON() {
                        const e = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.prototype.slice.call(this.array),
                            normalized: this.normalized,
                        };
                        return (
                            "" !== this.name && (e.name = this.name),
                            this.usage !== Ir && (e.usage = this.usage),
                            (0 === this.updateRange.offset &&
                                -1 === this.updateRange.count) ||
                                (e.updateRange = this.updateRange),
                            e
                        );
                    }
                }
                Aa.prototype.isBufferAttribute = !0;
                class Ea extends Aa {
                    constructor(e, t, i) {
                        super(new Uint16Array(e), t, i);
                    }
                }
                class La extends Aa {
                    constructor(e, t, i) {
                        super(new Uint32Array(e), t, i);
                    }
                }
                (class extends Aa {
                    constructor(e, t, i) {
                        super(new Uint16Array(e), t, i);
                    }
                }).prototype.isFloat16BufferAttribute = !0;
                class za extends Aa {
                    constructor(e, t, i) {
                        super(new Float32Array(e), t, i);
                    }
                }
                let ja = 0;
                const Oa = new Os(),
                    ka = new aa(),
                    Ra = new rs(),
                    Pa = new os(),
                    Ua = new os(),
                    $a = new rs();
                class Ba extends Er {
                    constructor() {
                        super(),
                            Object.defineProperty(this, "id", { value: ja++ }),
                            (this.uuid = Rr()),
                            (this.name = ""),
                            (this.type = "BufferGeometry"),
                            (this.index = null),
                            (this.attributes = {}),
                            (this.morphAttributes = {}),
                            (this.morphTargetsRelative = !1),
                            (this.groups = []),
                            (this.boundingBox = null),
                            (this.boundingSphere = null),
                            (this.drawRange = { start: 0, count: 1 / 0 }),
                            (this.userData = {});
                    }
                    getIndex() {
                        return this.index;
                    }
                    setIndex(e) {
                        return (
                            Array.isArray(e)
                                ? (this.index = new (Yr(e) > 65535 ? La : Ea)(
                                      e,
                                      1
                                  ))
                                : (this.index = e),
                            this
                        );
                    }
                    getAttribute(e) {
                        return this.attributes[e];
                    }
                    setAttribute(e, t) {
                        return (this.attributes[e] = t), this;
                    }
                    deleteAttribute(e) {
                        return delete this.attributes[e], this;
                    }
                    hasAttribute(e) {
                        return void 0 !== this.attributes[e];
                    }
                    addGroup(e, t, i = 0) {
                        this.groups.push({
                            start: e,
                            count: t,
                            materialIndex: i,
                        });
                    }
                    clearGroups() {
                        this.groups = [];
                    }
                    setDrawRange(e, t) {
                        (this.drawRange.start = e), (this.drawRange.count = t);
                    }
                    applyMatrix4(e) {
                        const t = this.attributes.position;
                        void 0 !== t &&
                            (t.applyMatrix4(e), (t.needsUpdate = !0));
                        const i = this.attributes.normal;
                        if (void 0 !== i) {
                            const t = new Vr().getNormalMatrix(e);
                            i.applyNormalMatrix(t), (i.needsUpdate = !0);
                        }
                        const n = this.attributes.tangent;
                        return (
                            void 0 !== n &&
                                (n.transformDirection(e), (n.needsUpdate = !0)),
                            null !== this.boundingBox &&
                                this.computeBoundingBox(),
                            null !== this.boundingSphere &&
                                this.computeBoundingSphere(),
                            this
                        );
                    }
                    applyQuaternion(e) {
                        return (
                            Oa.makeRotationFromQuaternion(e),
                            this.applyMatrix4(Oa),
                            this
                        );
                    }
                    rotateX(e) {
                        return Oa.makeRotationX(e), this.applyMatrix4(Oa), this;
                    }
                    rotateY(e) {
                        return Oa.makeRotationY(e), this.applyMatrix4(Oa), this;
                    }
                    rotateZ(e) {
                        return Oa.makeRotationZ(e), this.applyMatrix4(Oa), this;
                    }
                    translate(e, t, i) {
                        return (
                            Oa.makeTranslation(e, t, i),
                            this.applyMatrix4(Oa),
                            this
                        );
                    }
                    scale(e, t, i) {
                        return (
                            Oa.makeScale(e, t, i), this.applyMatrix4(Oa), this
                        );
                    }
                    lookAt(e) {
                        return (
                            ka.lookAt(e),
                            ka.updateMatrix(),
                            this.applyMatrix4(ka.matrix),
                            this
                        );
                    }
                    center() {
                        return (
                            this.computeBoundingBox(),
                            this.boundingBox.getCenter(Ra).negate(),
                            this.translate(Ra.x, Ra.y, Ra.z),
                            this
                        );
                    }
                    setFromPoints(e) {
                        const t = [];
                        for (let i = 0, n = e.length; i < n; i++) {
                            const n = e[i];
                            t.push(n.x, n.y, n.z || 0);
                        }
                        return (
                            this.setAttribute("position", new za(t, 3)), this
                        );
                    }
                    computeBoundingBox() {
                        null === this.boundingBox &&
                            (this.boundingBox = new os());
                        const e = this.attributes.position,
                            t = this.morphAttributes.position;
                        if (e && e.isGLBufferAttribute)
                            return (
                                console.error(
                                    'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                                    this
                                ),
                                void this.boundingBox.set(
                                    new rs(-1 / 0, -1 / 0, -1 / 0),
                                    new rs(1 / 0, 1 / 0, 1 / 0)
                                )
                            );
                        if (void 0 !== e) {
                            if ((this.boundingBox.setFromBufferAttribute(e), t))
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e];
                                    Pa.setFromBufferAttribute(i),
                                        this.morphTargetsRelative
                                            ? ($a.addVectors(
                                                  this.boundingBox.min,
                                                  Pa.min
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  $a
                                              ),
                                              $a.addVectors(
                                                  this.boundingBox.max,
                                                  Pa.max
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  $a
                                              ))
                                            : (this.boundingBox.expandByPoint(
                                                  Pa.min
                                              ),
                                              this.boundingBox.expandByPoint(
                                                  Pa.max
                                              ));
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) ||
                            isNaN(this.boundingBox.min.y) ||
                            isNaN(this.boundingBox.min.z)) &&
                            console.error(
                                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                                this
                            );
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere &&
                            (this.boundingSphere = new Ns());
                        const e = this.attributes.position,
                            t = this.morphAttributes.position;
                        if (e && e.isGLBufferAttribute)
                            return (
                                console.error(
                                    'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                                    this
                                ),
                                void this.boundingSphere.set(new rs(), 1 / 0)
                            );
                        if (e) {
                            const i = this.boundingSphere.center;
                            if ((Pa.setFromBufferAttribute(e), t))
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e];
                                    Ua.setFromBufferAttribute(i),
                                        this.morphTargetsRelative
                                            ? ($a.addVectors(Pa.min, Ua.min),
                                              Pa.expandByPoint($a),
                                              $a.addVectors(Pa.max, Ua.max),
                                              Pa.expandByPoint($a))
                                            : (Pa.expandByPoint(Ua.min),
                                              Pa.expandByPoint(Ua.max));
                                }
                            Pa.getCenter(i);
                            let n = 0;
                            for (let t = 0, r = e.count; t < r; t++)
                                $a.fromBufferAttribute(e, t),
                                    (n = Math.max(n, i.distanceToSquared($a)));
                            if (t)
                                for (let r = 0, s = t.length; r < s; r++) {
                                    const s = t[r],
                                        a = this.morphTargetsRelative;
                                    for (let t = 0, r = s.count; t < r; t++)
                                        $a.fromBufferAttribute(s, t),
                                            a &&
                                                (Ra.fromBufferAttribute(e, t),
                                                $a.add(Ra)),
                                            (n = Math.max(
                                                n,
                                                i.distanceToSquared($a)
                                            ));
                                }
                            (this.boundingSphere.radius = Math.sqrt(n)),
                                isNaN(this.boundingSphere.radius) &&
                                    console.error(
                                        'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                                        this
                                    );
                        }
                    }
                    computeTangents() {
                        const e = this.index,
                            t = this.attributes;
                        if (
                            null === e ||
                            void 0 === t.position ||
                            void 0 === t.normal ||
                            void 0 === t.uv
                        )
                            return void console.error(
                                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
                            );
                        const i = e.array,
                            n = t.position.array,
                            r = t.normal.array,
                            s = t.uv.array,
                            a = n.length / 3;
                        void 0 === t.tangent &&
                            this.setAttribute(
                                "tangent",
                                new Aa(new Float32Array(4 * a), 4)
                            );
                        const o = t.tangent.array,
                            c = [],
                            l = [];
                        for (let e = 0; e < a; e++)
                            (c[e] = new rs()), (l[e] = new rs());
                        const h = new rs(),
                            u = new rs(),
                            d = new rs(),
                            p = new Gr(),
                            g = new Gr(),
                            m = new Gr(),
                            f = new rs(),
                            _ = new rs();
                        function M(e, t, i) {
                            h.fromArray(n, 3 * e),
                                u.fromArray(n, 3 * t),
                                d.fromArray(n, 3 * i),
                                p.fromArray(s, 2 * e),
                                g.fromArray(s, 2 * t),
                                m.fromArray(s, 2 * i),
                                u.sub(h),
                                d.sub(h),
                                g.sub(p),
                                m.sub(p);
                            const r = 1 / (g.x * m.y - m.x * g.y);
                            isFinite(r) &&
                                (f
                                    .copy(u)
                                    .multiplyScalar(m.y)
                                    .addScaledVector(d, -g.y)
                                    .multiplyScalar(r),
                                _.copy(d)
                                    .multiplyScalar(g.x)
                                    .addScaledVector(u, -m.x)
                                    .multiplyScalar(r),
                                c[e].add(f),
                                c[t].add(f),
                                c[i].add(f),
                                l[e].add(_),
                                l[t].add(_),
                                l[i].add(_));
                        }
                        let v = this.groups;
                        0 === v.length && (v = [{ start: 0, count: i.length }]);
                        for (let e = 0, t = v.length; e < t; ++e) {
                            const t = v[e],
                                n = t.start;
                            for (let e = n, r = n + t.count; e < r; e += 3)
                                M(i[e + 0], i[e + 1], i[e + 2]);
                        }
                        const y = new rs(),
                            x = new rs(),
                            b = new rs(),
                            w = new rs();
                        function T(e) {
                            b.fromArray(r, 3 * e), w.copy(b);
                            const t = c[e];
                            y.copy(t),
                                y.sub(b.multiplyScalar(b.dot(t))).normalize(),
                                x.crossVectors(w, t);
                            const i = x.dot(l[e]) < 0 ? -1 : 1;
                            (o[4 * e] = y.x),
                                (o[4 * e + 1] = y.y),
                                (o[4 * e + 2] = y.z),
                                (o[4 * e + 3] = i);
                        }
                        for (let e = 0, t = v.length; e < t; ++e) {
                            const t = v[e],
                                n = t.start;
                            for (let e = n, r = n + t.count; e < r; e += 3)
                                T(i[e + 0]), T(i[e + 1]), T(i[e + 2]);
                        }
                    }
                    computeVertexNormals() {
                        const e = this.index,
                            t = this.getAttribute("position");
                        if (void 0 !== t) {
                            let i = this.getAttribute("normal");
                            if (void 0 === i)
                                (i = new Aa(new Float32Array(3 * t.count), 3)),
                                    this.setAttribute("normal", i);
                            else
                                for (let e = 0, t = i.count; e < t; e++)
                                    i.setXYZ(e, 0, 0, 0);
                            const n = new rs(),
                                r = new rs(),
                                s = new rs(),
                                a = new rs(),
                                o = new rs(),
                                c = new rs(),
                                l = new rs(),
                                h = new rs();
                            if (e)
                                for (let u = 0, d = e.count; u < d; u += 3) {
                                    const d = e.getX(u + 0),
                                        p = e.getX(u + 1),
                                        g = e.getX(u + 2);
                                    n.fromBufferAttribute(t, d),
                                        r.fromBufferAttribute(t, p),
                                        s.fromBufferAttribute(t, g),
                                        l.subVectors(s, r),
                                        h.subVectors(n, r),
                                        l.cross(h),
                                        a.fromBufferAttribute(i, d),
                                        o.fromBufferAttribute(i, p),
                                        c.fromBufferAttribute(i, g),
                                        a.add(l),
                                        o.add(l),
                                        c.add(l),
                                        i.setXYZ(d, a.x, a.y, a.z),
                                        i.setXYZ(p, o.x, o.y, o.z),
                                        i.setXYZ(g, c.x, c.y, c.z);
                                }
                            else
                                for (let e = 0, a = t.count; e < a; e += 3)
                                    n.fromBufferAttribute(t, e + 0),
                                        r.fromBufferAttribute(t, e + 1),
                                        s.fromBufferAttribute(t, e + 2),
                                        l.subVectors(s, r),
                                        h.subVectors(n, r),
                                        l.cross(h),
                                        i.setXYZ(e + 0, l.x, l.y, l.z),
                                        i.setXYZ(e + 1, l.x, l.y, l.z),
                                        i.setXYZ(e + 2, l.x, l.y, l.z);
                            this.normalizeNormals(), (i.needsUpdate = !0);
                        }
                    }
                    merge(e, t) {
                        if (!e || !e.isBufferGeometry)
                            return void console.error(
                                "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                                e
                            );
                        void 0 === t &&
                            ((t = 0),
                            console.warn(
                                "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
                            ));
                        const i = this.attributes;
                        for (const n in i) {
                            if (void 0 === e.attributes[n]) continue;
                            const r = i[n].array,
                                s = e.attributes[n],
                                a = s.array,
                                o = s.itemSize * t,
                                c = Math.min(a.length, r.length - o);
                            for (let e = 0, t = o; e < c; e++, t++) r[t] = a[e];
                        }
                        return this;
                    }
                    normalizeNormals() {
                        const e = this.attributes.normal;
                        for (let t = 0, i = e.count; t < i; t++)
                            $a.fromBufferAttribute(e, t),
                                $a.normalize(),
                                e.setXYZ(t, $a.x, $a.y, $a.z);
                    }
                    toNonIndexed() {
                        function e(e, t) {
                            const i = e.array,
                                n = e.itemSize,
                                r = e.normalized,
                                s = new i.constructor(t.length * n);
                            let a = 0,
                                o = 0;
                            for (let r = 0, c = t.length; r < c; r++) {
                                a = e.isInterleavedBufferAttribute
                                    ? t[r] * e.data.stride + e.offset
                                    : t[r] * n;
                                for (let e = 0; e < n; e++) s[o++] = i[a++];
                            }
                            return new Aa(s, n, r);
                        }
                        if (null === this.index)
                            return (
                                console.warn(
                                    "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                                ),
                                this
                            );
                        const t = new Ba(),
                            i = this.index.array,
                            n = this.attributes;
                        for (const r in n) {
                            const s = e(n[r], i);
                            t.setAttribute(r, s);
                        }
                        const r = this.morphAttributes;
                        for (const n in r) {
                            const s = [],
                                a = r[n];
                            for (let t = 0, n = a.length; t < n; t++) {
                                const n = e(a[t], i);
                                s.push(n);
                            }
                            t.morphAttributes[n] = s;
                        }
                        t.morphTargetsRelative = this.morphTargetsRelative;
                        const s = this.groups;
                        for (let e = 0, i = s.length; e < i; e++) {
                            const i = s[e];
                            t.addGroup(i.start, i.count, i.materialIndex);
                        }
                        return t;
                    }
                    toJSON() {
                        const e = {
                            metadata: {
                                version: 4.5,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON",
                            },
                        };
                        if (
                            ((e.uuid = this.uuid),
                            (e.type = this.type),
                            "" !== this.name && (e.name = this.name),
                            Object.keys(this.userData).length > 0 &&
                                (e.userData = this.userData),
                            void 0 !== this.parameters)
                        ) {
                            const t = this.parameters;
                            for (const i in t) void 0 !== t[i] && (e[i] = t[i]);
                            return e;
                        }
                        e.data = { attributes: {} };
                        const t = this.index;
                        null !== t &&
                            (e.data.index = {
                                type: t.array.constructor.name,
                                array: Array.prototype.slice.call(t.array),
                            });
                        const i = this.attributes;
                        for (const t in i) {
                            const n = i[t];
                            e.data.attributes[t] = n.toJSON(e.data);
                        }
                        const n = {};
                        let r = !1;
                        for (const t in this.morphAttributes) {
                            const i = this.morphAttributes[t],
                                s = [];
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = i[t];
                                s.push(n.toJSON(e.data));
                            }
                            s.length > 0 && ((n[t] = s), (r = !0));
                        }
                        r &&
                            ((e.data.morphAttributes = n),
                            (e.data.morphTargetsRelative =
                                this.morphTargetsRelative));
                        const s = this.groups;
                        s.length > 0 &&
                            (e.data.groups = JSON.parse(JSON.stringify(s)));
                        const a = this.boundingSphere;
                        return (
                            null !== a &&
                                (e.data.boundingSphere = {
                                    center: a.center.toArray(),
                                    radius: a.radius,
                                }),
                            e
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(e) {
                        (this.index = null),
                            (this.attributes = {}),
                            (this.morphAttributes = {}),
                            (this.groups = []),
                            (this.boundingBox = null),
                            (this.boundingSphere = null);
                        const t = {};
                        this.name = e.name;
                        const i = e.index;
                        null !== i && this.setIndex(i.clone(t));
                        const n = e.attributes;
                        for (const e in n) {
                            const i = n[e];
                            this.setAttribute(e, i.clone(t));
                        }
                        const r = e.morphAttributes;
                        for (const e in r) {
                            const i = [],
                                n = r[e];
                            for (let e = 0, r = n.length; e < r; e++)
                                i.push(n[e].clone(t));
                            this.morphAttributes[e] = i;
                        }
                        this.morphTargetsRelative = e.morphTargetsRelative;
                        const s = e.groups;
                        for (let e = 0, t = s.length; e < t; e++) {
                            const t = s[e];
                            this.addGroup(t.start, t.count, t.materialIndex);
                        }
                        const a = e.boundingBox;
                        null !== a && (this.boundingBox = a.clone());
                        const o = e.boundingSphere;
                        return (
                            null !== o && (this.boundingSphere = o.clone()),
                            (this.drawRange.start = e.drawRange.start),
                            (this.drawRange.count = e.drawRange.count),
                            (this.userData = e.userData),
                            void 0 !== e.parameters &&
                                (this.parameters = Object.assign(
                                    {},
                                    e.parameters
                                )),
                            this
                        );
                    }
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                }
                Ba.prototype.isBufferGeometry = !0;
                const Fa = new Os(),
                    Ha = new js(),
                    Ga = new Ns(),
                    Va = new rs(),
                    Ya = new rs(),
                    qa = new rs(),
                    Wa = new rs(),
                    Qa = new rs(),
                    Za = new rs(),
                    Xa = new rs(),
                    Ja = new rs(),
                    Ka = new rs(),
                    eo = new Gr(),
                    to = new Gr(),
                    io = new Gr(),
                    no = new rs(),
                    ro = new rs();
                class so extends aa {
                    constructor(e = new Ba(), t = new Da()) {
                        super(),
                            (this.type = "Mesh"),
                            (this.geometry = e),
                            (this.material = t),
                            this.updateMorphTargets();
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            void 0 !== e.morphTargetInfluences &&
                                (this.morphTargetInfluences =
                                    e.morphTargetInfluences.slice()),
                            void 0 !== e.morphTargetDictionary &&
                                (this.morphTargetDictionary = Object.assign(
                                    {},
                                    e.morphTargetDictionary
                                )),
                            (this.material = e.material),
                            (this.geometry = e.geometry),
                            this
                        );
                    }
                    updateMorphTargets() {
                        const e = this.geometry;
                        if (e.isBufferGeometry) {
                            const t = e.morphAttributes,
                                i = Object.keys(t);
                            if (i.length > 0) {
                                const e = t[i[0]];
                                if (void 0 !== e) {
                                    (this.morphTargetInfluences = []),
                                        (this.morphTargetDictionary = {});
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = e[t].name || String(t);
                                        this.morphTargetInfluences.push(0),
                                            (this.morphTargetDictionary[i] = t);
                                    }
                                }
                            }
                        } else {
                            const t = e.morphTargets;
                            void 0 !== t &&
                                t.length > 0 &&
                                console.error(
                                    "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                                );
                        }
                    }
                    raycast(e, t) {
                        const i = this.geometry,
                            n = this.material,
                            r = this.matrixWorld;
                        if (void 0 === n) return;
                        if (
                            (null === i.boundingSphere &&
                                i.computeBoundingSphere(),
                            Ga.copy(i.boundingSphere),
                            Ga.applyMatrix4(r),
                            !1 === e.ray.intersectsSphere(Ga))
                        )
                            return;
                        if (
                            (Fa.copy(r).invert(),
                            Ha.copy(e.ray).applyMatrix4(Fa),
                            null !== i.boundingBox &&
                                !1 === Ha.intersectsBox(i.boundingBox))
                        )
                            return;
                        let s;
                        if (i.isBufferGeometry) {
                            const r = i.index,
                                a = i.attributes.position,
                                o = i.morphAttributes.position,
                                c = i.morphTargetsRelative,
                                l = i.attributes.uv,
                                h = i.attributes.uv2,
                                u = i.groups,
                                d = i.drawRange;
                            if (null !== r)
                                if (Array.isArray(n))
                                    for (let i = 0, p = u.length; i < p; i++) {
                                        const p = u[i],
                                            g = n[p.materialIndex];
                                        for (
                                            let i = Math.max(p.start, d.start),
                                                n = Math.min(
                                                    r.count,
                                                    Math.min(
                                                        p.start + p.count,
                                                        d.start + d.count
                                                    )
                                                );
                                            i < n;
                                            i += 3
                                        ) {
                                            const n = r.getX(i),
                                                u = r.getX(i + 1),
                                                d = r.getX(i + 2);
                                            (s = ao(
                                                this,
                                                g,
                                                e,
                                                Ha,
                                                a,
                                                o,
                                                c,
                                                l,
                                                h,
                                                n,
                                                u,
                                                d
                                            )),
                                                s &&
                                                    ((s.faceIndex = Math.floor(
                                                        i / 3
                                                    )),
                                                    (s.face.materialIndex =
                                                        p.materialIndex),
                                                    t.push(s));
                                        }
                                    }
                                else
                                    for (
                                        let i = Math.max(0, d.start),
                                            u = Math.min(
                                                r.count,
                                                d.start + d.count
                                            );
                                        i < u;
                                        i += 3
                                    ) {
                                        const u = r.getX(i),
                                            d = r.getX(i + 1),
                                            p = r.getX(i + 2);
                                        (s = ao(
                                            this,
                                            n,
                                            e,
                                            Ha,
                                            a,
                                            o,
                                            c,
                                            l,
                                            h,
                                            u,
                                            d,
                                            p
                                        )),
                                            s &&
                                                ((s.faceIndex = Math.floor(
                                                    i / 3
                                                )),
                                                t.push(s));
                                    }
                            else if (void 0 !== a)
                                if (Array.isArray(n))
                                    for (let i = 0, r = u.length; i < r; i++) {
                                        const r = u[i],
                                            p = n[r.materialIndex];
                                        for (
                                            let i = Math.max(r.start, d.start),
                                                n = Math.min(
                                                    a.count,
                                                    Math.min(
                                                        r.start + r.count,
                                                        d.start + d.count
                                                    )
                                                );
                                            i < n;
                                            i += 3
                                        )
                                            (s = ao(
                                                this,
                                                p,
                                                e,
                                                Ha,
                                                a,
                                                o,
                                                c,
                                                l,
                                                h,
                                                i,
                                                i + 1,
                                                i + 2
                                            )),
                                                s &&
                                                    ((s.faceIndex = Math.floor(
                                                        i / 3
                                                    )),
                                                    (s.face.materialIndex =
                                                        r.materialIndex),
                                                    t.push(s));
                                    }
                                else
                                    for (
                                        let i = Math.max(0, d.start),
                                            r = Math.min(
                                                a.count,
                                                d.start + d.count
                                            );
                                        i < r;
                                        i += 3
                                    )
                                        (s = ao(
                                            this,
                                            n,
                                            e,
                                            Ha,
                                            a,
                                            o,
                                            c,
                                            l,
                                            h,
                                            i,
                                            i + 1,
                                            i + 2
                                        )),
                                            s &&
                                                ((s.faceIndex = Math.floor(
                                                    i / 3
                                                )),
                                                t.push(s));
                        } else
                            i.isGeometry &&
                                console.error(
                                    "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                                );
                    }
                }
                function ao(e, t, i, n, r, s, a, o, c, l, h, u) {
                    Va.fromBufferAttribute(r, l),
                        Ya.fromBufferAttribute(r, h),
                        qa.fromBufferAttribute(r, u);
                    const d = e.morphTargetInfluences;
                    if (s && d) {
                        Xa.set(0, 0, 0), Ja.set(0, 0, 0), Ka.set(0, 0, 0);
                        for (let e = 0, t = s.length; e < t; e++) {
                            const t = d[e],
                                i = s[e];
                            0 !== t &&
                                (Wa.fromBufferAttribute(i, l),
                                Qa.fromBufferAttribute(i, h),
                                Za.fromBufferAttribute(i, u),
                                a
                                    ? (Xa.addScaledVector(Wa, t),
                                      Ja.addScaledVector(Qa, t),
                                      Ka.addScaledVector(Za, t))
                                    : (Xa.addScaledVector(Wa.sub(Va), t),
                                      Ja.addScaledVector(Qa.sub(Ya), t),
                                      Ka.addScaledVector(Za.sub(qa), t)));
                        }
                        Va.add(Xa), Ya.add(Ja), qa.add(Ka);
                    }
                    e.isSkinnedMesh &&
                        (e.boneTransform(l, Va),
                        e.boneTransform(h, Ya),
                        e.boneTransform(u, qa));
                    const p = (function (e, t, i, n, r, s, a, o) {
                        let c;
                        if (
                            ((c =
                                t.side === Qt
                                    ? n.intersectTriangle(a, s, r, !0, o)
                                    : n.intersectTriangle(
                                          r,
                                          s,
                                          a,
                                          t.side !== Zt,
                                          o
                                      )),
                            null === c)
                        )
                            return null;
                        ro.copy(o), ro.applyMatrix4(e.matrixWorld);
                        const l = i.ray.origin.distanceTo(ro);
                        return l < i.near || l > i.far
                            ? null
                            : { distance: l, point: ro.clone(), object: e };
                    })(e, t, i, n, Va, Ya, qa, no);
                    if (p) {
                        o &&
                            (eo.fromBufferAttribute(o, l),
                            to.fromBufferAttribute(o, h),
                            io.fromBufferAttribute(o, u),
                            (p.uv = _a.getUV(
                                no,
                                Va,
                                Ya,
                                qa,
                                eo,
                                to,
                                io,
                                new Gr()
                            ))),
                            c &&
                                (eo.fromBufferAttribute(c, l),
                                to.fromBufferAttribute(c, h),
                                io.fromBufferAttribute(c, u),
                                (p.uv2 = _a.getUV(
                                    no,
                                    Va,
                                    Ya,
                                    qa,
                                    eo,
                                    to,
                                    io,
                                    new Gr()
                                )));
                        const e = {
                            a: l,
                            b: h,
                            c: u,
                            normal: new rs(),
                            materialIndex: 0,
                        };
                        _a.getNormal(Va, Ya, qa, e.normal), (p.face = e);
                    }
                    return p;
                }
                so.prototype.isMesh = !0;
                class oo extends Ba {
                    constructor(e = 1, t = 1, i = 1, n = 1, r = 1, s = 1) {
                        super(),
                            (this.type = "BoxGeometry"),
                            (this.parameters = {
                                width: e,
                                height: t,
                                depth: i,
                                widthSegments: n,
                                heightSegments: r,
                                depthSegments: s,
                            });
                        const a = this;
                        (n = Math.floor(n)),
                            (r = Math.floor(r)),
                            (s = Math.floor(s));
                        const o = [],
                            c = [],
                            l = [],
                            h = [];
                        let u = 0,
                            d = 0;
                        function p(e, t, i, n, r, s, p, g, m, f, _) {
                            const M = s / m,
                                v = p / f,
                                y = s / 2,
                                x = p / 2,
                                b = g / 2,
                                w = m + 1,
                                T = f + 1;
                            let S = 0,
                                N = 0;
                            const D = new rs();
                            for (let s = 0; s < T; s++) {
                                const a = s * v - x;
                                for (let o = 0; o < w; o++) {
                                    const u = o * M - y;
                                    (D[e] = u * n),
                                        (D[t] = a * r),
                                        (D[i] = b),
                                        c.push(D.x, D.y, D.z),
                                        (D[e] = 0),
                                        (D[t] = 0),
                                        (D[i] = g > 0 ? 1 : -1),
                                        l.push(D.x, D.y, D.z),
                                        h.push(o / m),
                                        h.push(1 - s / f),
                                        (S += 1);
                                }
                            }
                            for (let e = 0; e < f; e++)
                                for (let t = 0; t < m; t++) {
                                    const i = u + t + w * e,
                                        n = u + t + w * (e + 1),
                                        r = u + (t + 1) + w * (e + 1),
                                        s = u + (t + 1) + w * e;
                                    o.push(i, n, s), o.push(n, r, s), (N += 6);
                                }
                            a.addGroup(d, N, _), (d += N), (u += S);
                        }
                        p("z", "y", "x", -1, -1, i, t, e, s, r, 0),
                            p("z", "y", "x", 1, -1, i, t, -e, s, r, 1),
                            p("x", "z", "y", 1, 1, e, i, t, n, s, 2),
                            p("x", "z", "y", 1, -1, e, i, -t, n, s, 3),
                            p("x", "y", "z", 1, -1, e, t, i, n, r, 4),
                            p("x", "y", "z", -1, -1, e, t, -i, n, r, 5),
                            this.setIndex(o),
                            this.setAttribute("position", new za(c, 3)),
                            this.setAttribute("normal", new za(l, 3)),
                            this.setAttribute("uv", new za(h, 2));
                    }
                    static fromJSON(e) {
                        return new oo(
                            e.width,
                            e.height,
                            e.depth,
                            e.widthSegments,
                            e.heightSegments,
                            e.depthSegments
                        );
                    }
                }
                function co(e) {
                    const t = {};
                    for (const i in e) {
                        t[i] = {};
                        for (const n in e[i]) {
                            const r = e[i][n];
                            r &&
                            (r.isColor ||
                                r.isMatrix3 ||
                                r.isMatrix4 ||
                                r.isVector2 ||
                                r.isVector3 ||
                                r.isVector4 ||
                                r.isTexture ||
                                r.isQuaternion)
                                ? (t[i][n] = r.clone())
                                : Array.isArray(r)
                                ? (t[i][n] = r.slice())
                                : (t[i][n] = r);
                        }
                    }
                    return t;
                }
                function lo(e) {
                    const t = {};
                    for (let i = 0; i < e.length; i++) {
                        const n = co(e[i]);
                        for (const e in n) t[e] = n[e];
                    }
                    return t;
                }
                const ho = { clone: co, merge: lo };
                class uo extends va {
                    constructor(e) {
                        super(),
                            (this.type = "ShaderMaterial"),
                            (this.defines = {}),
                            (this.uniforms = {}),
                            (this.vertexShader =
                                "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
                            (this.fragmentShader =
                                "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
                            (this.linewidth = 1),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.fog = !1),
                            (this.lights = !1),
                            (this.clipping = !1),
                            (this.extensions = {
                                derivatives: !1,
                                fragDepth: !1,
                                drawBuffers: !1,
                                shaderTextureLOD: !1,
                            }),
                            (this.defaultAttributeValues = {
                                color: [1, 1, 1],
                                uv: [0, 0],
                                uv2: [0, 0],
                            }),
                            (this.index0AttributeName = void 0),
                            (this.uniformsNeedUpdate = !1),
                            (this.glslVersion = null),
                            void 0 !== e &&
                                (void 0 !== e.attributes &&
                                    console.error(
                                        "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                                    ),
                                this.setValues(e));
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.fragmentShader = e.fragmentShader),
                            (this.vertexShader = e.vertexShader),
                            (this.uniforms = co(e.uniforms)),
                            (this.defines = Object.assign({}, e.defines)),
                            (this.wireframe = e.wireframe),
                            (this.wireframeLinewidth = e.wireframeLinewidth),
                            (this.lights = e.lights),
                            (this.clipping = e.clipping),
                            (this.extensions = Object.assign({}, e.extensions)),
                            (this.glslVersion = e.glslVersion),
                            this
                        );
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        (t.glslVersion = this.glslVersion), (t.uniforms = {});
                        for (const i in this.uniforms) {
                            const n = this.uniforms[i].value;
                            n && n.isTexture
                                ? (t.uniforms[i] = {
                                      type: "t",
                                      value: n.toJSON(e).uuid,
                                  })
                                : n && n.isColor
                                ? (t.uniforms[i] = {
                                      type: "c",
                                      value: n.getHex(),
                                  })
                                : n && n.isVector2
                                ? (t.uniforms[i] = {
                                      type: "v2",
                                      value: n.toArray(),
                                  })
                                : n && n.isVector3
                                ? (t.uniforms[i] = {
                                      type: "v3",
                                      value: n.toArray(),
                                  })
                                : n && n.isVector4
                                ? (t.uniforms[i] = {
                                      type: "v4",
                                      value: n.toArray(),
                                  })
                                : n && n.isMatrix3
                                ? (t.uniforms[i] = {
                                      type: "m3",
                                      value: n.toArray(),
                                  })
                                : n && n.isMatrix4
                                ? (t.uniforms[i] = {
                                      type: "m4",
                                      value: n.toArray(),
                                  })
                                : (t.uniforms[i] = { value: n });
                        }
                        Object.keys(this.defines).length > 0 &&
                            (t.defines = this.defines),
                            (t.vertexShader = this.vertexShader),
                            (t.fragmentShader = this.fragmentShader);
                        const i = {};
                        for (const e in this.extensions)
                            !0 === this.extensions[e] && (i[e] = !0);
                        return (
                            Object.keys(i).length > 0 && (t.extensions = i), t
                        );
                    }
                }
                uo.prototype.isShaderMaterial = !0;
                class po extends aa {
                    constructor() {
                        super(),
                            (this.type = "Camera"),
                            (this.matrixWorldInverse = new Os()),
                            (this.projectionMatrix = new Os()),
                            (this.projectionMatrixInverse = new Os());
                    }
                    copy(e, t) {
                        return (
                            super.copy(e, t),
                            this.matrixWorldInverse.copy(e.matrixWorldInverse),
                            this.projectionMatrix.copy(e.projectionMatrix),
                            this.projectionMatrixInverse.copy(
                                e.projectionMatrixInverse
                            ),
                            this
                        );
                    }
                    getWorldDirection(e) {
                        this.updateWorldMatrix(!0, !1);
                        const t = this.matrixWorld.elements;
                        return e.set(-t[8], -t[9], -t[10]).normalize();
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e),
                            this.matrixWorldInverse
                                .copy(this.matrixWorld)
                                .invert();
                    }
                    updateWorldMatrix(e, t) {
                        super.updateWorldMatrix(e, t),
                            this.matrixWorldInverse
                                .copy(this.matrixWorld)
                                .invert();
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                po.prototype.isCamera = !0;
                class go extends po {
                    constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
                        super(),
                            (this.type = "PerspectiveCamera"),
                            (this.fov = e),
                            (this.zoom = 1),
                            (this.near = i),
                            (this.far = n),
                            (this.focus = 10),
                            (this.aspect = t),
                            (this.view = null),
                            (this.filmGauge = 35),
                            (this.filmOffset = 0),
                            this.updateProjectionMatrix();
                    }
                    copy(e, t) {
                        return (
                            super.copy(e, t),
                            (this.fov = e.fov),
                            (this.zoom = e.zoom),
                            (this.near = e.near),
                            (this.far = e.far),
                            (this.focus = e.focus),
                            (this.aspect = e.aspect),
                            (this.view =
                                null === e.view
                                    ? null
                                    : Object.assign({}, e.view)),
                            (this.filmGauge = e.filmGauge),
                            (this.filmOffset = e.filmOffset),
                            this
                        );
                    }
                    setFocalLength(e) {
                        const t = (0.5 * this.getFilmHeight()) / e;
                        (this.fov = 2 * jr * Math.atan(t)),
                            this.updateProjectionMatrix();
                    }
                    getFocalLength() {
                        const e = Math.tan(0.5 * zr * this.fov);
                        return (0.5 * this.getFilmHeight()) / e;
                    }
                    getEffectiveFOV() {
                        return (
                            2 *
                            jr *
                            Math.atan(Math.tan(0.5 * zr * this.fov) / this.zoom)
                        );
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1);
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1);
                    }
                    setViewOffset(e, t, i, n, r, s) {
                        (this.aspect = e / t),
                            null === this.view &&
                                (this.view = {
                                    enabled: !0,
                                    fullWidth: 1,
                                    fullHeight: 1,
                                    offsetX: 0,
                                    offsetY: 0,
                                    width: 1,
                                    height: 1,
                                }),
                            (this.view.enabled = !0),
                            (this.view.fullWidth = e),
                            (this.view.fullHeight = t),
                            (this.view.offsetX = i),
                            (this.view.offsetY = n),
                            (this.view.width = r),
                            (this.view.height = s),
                            this.updateProjectionMatrix();
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1),
                            this.updateProjectionMatrix();
                    }
                    updateProjectionMatrix() {
                        const e = this.near;
                        let t = (e * Math.tan(0.5 * zr * this.fov)) / this.zoom,
                            i = 2 * t,
                            n = this.aspect * i,
                            r = -0.5 * n;
                        const s = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const e = s.fullWidth,
                                a = s.fullHeight;
                            (r += (s.offsetX * n) / e),
                                (t -= (s.offsetY * i) / a),
                                (n *= s.width / e),
                                (i *= s.height / a);
                        }
                        const a = this.filmOffset;
                        0 !== a && (r += (e * a) / this.getFilmWidth()),
                            this.projectionMatrix.makePerspective(
                                r,
                                r + n,
                                t,
                                t - i,
                                e,
                                this.far
                            ),
                            this.projectionMatrixInverse
                                .copy(this.projectionMatrix)
                                .invert();
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return (
                            (t.object.fov = this.fov),
                            (t.object.zoom = this.zoom),
                            (t.object.near = this.near),
                            (t.object.far = this.far),
                            (t.object.focus = this.focus),
                            (t.object.aspect = this.aspect),
                            null !== this.view &&
                                (t.object.view = Object.assign({}, this.view)),
                            (t.object.filmGauge = this.filmGauge),
                            (t.object.filmOffset = this.filmOffset),
                            t
                        );
                    }
                }
                go.prototype.isPerspectiveCamera = !0;
                const mo = 90;
                class fo extends aa {
                    constructor(e, t, i) {
                        if (
                            (super(),
                            (this.type = "CubeCamera"),
                            !0 !== i.isWebGLCubeRenderTarget)
                        )
                            return void console.error(
                                "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
                            );
                        this.renderTarget = i;
                        const n = new go(mo, 1, e, t);
                        (n.layers = this.layers),
                            n.up.set(0, -1, 0),
                            n.lookAt(new rs(1, 0, 0)),
                            this.add(n);
                        const r = new go(mo, 1, e, t);
                        (r.layers = this.layers),
                            r.up.set(0, -1, 0),
                            r.lookAt(new rs(-1, 0, 0)),
                            this.add(r);
                        const s = new go(mo, 1, e, t);
                        (s.layers = this.layers),
                            s.up.set(0, 0, 1),
                            s.lookAt(new rs(0, 1, 0)),
                            this.add(s);
                        const a = new go(mo, 1, e, t);
                        (a.layers = this.layers),
                            a.up.set(0, 0, -1),
                            a.lookAt(new rs(0, -1, 0)),
                            this.add(a);
                        const o = new go(mo, 1, e, t);
                        (o.layers = this.layers),
                            o.up.set(0, -1, 0),
                            o.lookAt(new rs(0, 0, 1)),
                            this.add(o);
                        const c = new go(mo, 1, e, t);
                        (c.layers = this.layers),
                            c.up.set(0, -1, 0),
                            c.lookAt(new rs(0, 0, -1)),
                            this.add(c);
                    }
                    update(e, t) {
                        null === this.parent && this.updateMatrixWorld();
                        const i = this.renderTarget,
                            [n, r, s, a, o, c] = this.children,
                            l = e.xr.enabled,
                            h = e.getRenderTarget();
                        e.xr.enabled = !1;
                        const u = i.texture.generateMipmaps;
                        (i.texture.generateMipmaps = !1),
                            e.setRenderTarget(i, 0),
                            e.render(t, n),
                            e.setRenderTarget(i, 1),
                            e.render(t, r),
                            e.setRenderTarget(i, 2),
                            e.render(t, s),
                            e.setRenderTarget(i, 3),
                            e.render(t, a),
                            e.setRenderTarget(i, 4),
                            e.render(t, o),
                            (i.texture.generateMipmaps = u),
                            e.setRenderTarget(i, 5),
                            e.render(t, c),
                            e.setRenderTarget(h),
                            (e.xr.enabled = l);
                    }
                }
                class _o extends Jr {
                    constructor(e, t, i, n, r, s, a, o, c, l) {
                        super(
                            (e = void 0 !== e ? e : []),
                            (t = void 0 !== t ? t : ki),
                            i,
                            n,
                            r,
                            s,
                            a,
                            o,
                            c,
                            l
                        ),
                            (this.flipY = !1);
                    }
                    get images() {
                        return this.image;
                    }
                    set images(e) {
                        this.image = e;
                    }
                }
                _o.prototype.isCubeTexture = !0;
                class Mo extends ts {
                    constructor(e, t, i) {
                        Number.isInteger(t) &&
                            (console.warn(
                                "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
                            ),
                            (t = i)),
                            super(e, e, t),
                            (t = t || {}),
                            (this.texture = new _o(
                                void 0,
                                t.mapping,
                                t.wrapS,
                                t.wrapT,
                                t.magFilter,
                                t.minFilter,
                                t.format,
                                t.type,
                                t.anisotropy,
                                t.encoding
                            )),
                            (this.texture.isRenderTargetTexture = !0),
                            (this.texture.generateMipmaps =
                                void 0 !== t.generateMipmaps &&
                                t.generateMipmaps),
                            (this.texture.minFilter =
                                void 0 !== t.minFilter ? t.minFilter : Wi),
                            (this.texture._needsFlipEnvMap = !1);
                    }
                    fromEquirectangularTexture(e, t) {
                        (this.texture.type = t.type),
                            (this.texture.format = dn),
                            (this.texture.encoding = t.encoding),
                            (this.texture.generateMipmaps = t.generateMipmaps),
                            (this.texture.minFilter = t.minFilter),
                            (this.texture.magFilter = t.magFilter);
                        const i = { tEquirect: { value: null } },
                            n =
                                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            r =
                                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                            s = new oo(5, 5, 5),
                            a = new uo({
                                name: "CubemapFromEquirect",
                                uniforms: co(i),
                                vertexShader: n,
                                fragmentShader: r,
                                side: Qt,
                                blending: Xt,
                            });
                        a.uniforms.tEquirect.value = t;
                        const o = new so(s, a),
                            c = t.minFilter;
                        return (
                            t.minFilter === Zi && (t.minFilter = Wi),
                            new fo(1, 10, this).update(e, o),
                            (t.minFilter = c),
                            o.geometry.dispose(),
                            o.material.dispose(),
                            this
                        );
                    }
                    clear(e, t, i, n) {
                        const r = e.getRenderTarget();
                        for (let r = 0; r < 6; r++)
                            e.setRenderTarget(this, r), e.clear(t, i, n);
                        e.setRenderTarget(r);
                    }
                }
                Mo.prototype.isWebGLCubeRenderTarget = !0;
                const vo = new rs(),
                    yo = new rs(),
                    xo = new Vr();
                class bo {
                    constructor(e = new rs(1, 0, 0), t = 0) {
                        (this.normal = e), (this.constant = t);
                    }
                    set(e, t) {
                        return this.normal.copy(e), (this.constant = t), this;
                    }
                    setComponents(e, t, i, n) {
                        return (
                            this.normal.set(e, t, i), (this.constant = n), this
                        );
                    }
                    setFromNormalAndCoplanarPoint(e, t) {
                        return (
                            this.normal.copy(e),
                            (this.constant = -t.dot(this.normal)),
                            this
                        );
                    }
                    setFromCoplanarPoints(e, t, i) {
                        const n = vo
                            .subVectors(i, t)
                            .cross(yo.subVectors(e, t))
                            .normalize();
                        return this.setFromNormalAndCoplanarPoint(n, e), this;
                    }
                    copy(e) {
                        return (
                            this.normal.copy(e.normal),
                            (this.constant = e.constant),
                            this
                        );
                    }
                    normalize() {
                        const e = 1 / this.normal.length();
                        return (
                            this.normal.multiplyScalar(e),
                            (this.constant *= e),
                            this
                        );
                    }
                    negate() {
                        return (
                            (this.constant *= -1), this.normal.negate(), this
                        );
                    }
                    distanceToPoint(e) {
                        return this.normal.dot(e) + this.constant;
                    }
                    distanceToSphere(e) {
                        return this.distanceToPoint(e.center) - e.radius;
                    }
                    projectPoint(e, t) {
                        return t
                            .copy(this.normal)
                            .multiplyScalar(-this.distanceToPoint(e))
                            .add(e);
                    }
                    intersectLine(e, t) {
                        const i = e.delta(vo),
                            n = this.normal.dot(i);
                        if (0 === n)
                            return 0 === this.distanceToPoint(e.start)
                                ? t.copy(e.start)
                                : null;
                        const r =
                            -(e.start.dot(this.normal) + this.constant) / n;
                        return r < 0 || r > 1
                            ? null
                            : t.copy(i).multiplyScalar(r).add(e.start);
                    }
                    intersectsLine(e) {
                        const t = this.distanceToPoint(e.start),
                            i = this.distanceToPoint(e.end);
                        return (t < 0 && i > 0) || (i < 0 && t > 0);
                    }
                    intersectsBox(e) {
                        return e.intersectsPlane(this);
                    }
                    intersectsSphere(e) {
                        return e.intersectsPlane(this);
                    }
                    coplanarPoint(e) {
                        return e
                            .copy(this.normal)
                            .multiplyScalar(-this.constant);
                    }
                    applyMatrix4(e, t) {
                        const i = t || xo.getNormalMatrix(e),
                            n = this.coplanarPoint(vo).applyMatrix4(e),
                            r = this.normal.applyMatrix3(i).normalize();
                        return (this.constant = -n.dot(r)), this;
                    }
                    translate(e) {
                        return (this.constant -= e.dot(this.normal)), this;
                    }
                    equals(e) {
                        return (
                            e.normal.equals(this.normal) &&
                            e.constant === this.constant
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                bo.prototype.isPlane = !0;
                const wo = new Ns(),
                    To = new rs();
                class So {
                    constructor(
                        e = new bo(),
                        t = new bo(),
                        i = new bo(),
                        n = new bo(),
                        r = new bo(),
                        s = new bo()
                    ) {
                        this.planes = [e, t, i, n, r, s];
                    }
                    set(e, t, i, n, r, s) {
                        const a = this.planes;
                        return (
                            a[0].copy(e),
                            a[1].copy(t),
                            a[2].copy(i),
                            a[3].copy(n),
                            a[4].copy(r),
                            a[5].copy(s),
                            this
                        );
                    }
                    copy(e) {
                        const t = this.planes;
                        for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
                        return this;
                    }
                    setFromProjectionMatrix(e) {
                        const t = this.planes,
                            i = e.elements,
                            n = i[0],
                            r = i[1],
                            s = i[2],
                            a = i[3],
                            o = i[4],
                            c = i[5],
                            l = i[6],
                            h = i[7],
                            u = i[8],
                            d = i[9],
                            p = i[10],
                            g = i[11],
                            m = i[12],
                            f = i[13],
                            _ = i[14],
                            M = i[15];
                        return (
                            t[0]
                                .setComponents(a - n, h - o, g - u, M - m)
                                .normalize(),
                            t[1]
                                .setComponents(a + n, h + o, g + u, M + m)
                                .normalize(),
                            t[2]
                                .setComponents(a + r, h + c, g + d, M + f)
                                .normalize(),
                            t[3]
                                .setComponents(a - r, h - c, g - d, M - f)
                                .normalize(),
                            t[4]
                                .setComponents(a - s, h - l, g - p, M - _)
                                .normalize(),
                            t[5]
                                .setComponents(a + s, h + l, g + p, M + _)
                                .normalize(),
                            this
                        );
                    }
                    intersectsObject(e) {
                        const t = e.geometry;
                        return (
                            null === t.boundingSphere &&
                                t.computeBoundingSphere(),
                            wo
                                .copy(t.boundingSphere)
                                .applyMatrix4(e.matrixWorld),
                            this.intersectsSphere(wo)
                        );
                    }
                    intersectsSprite(e) {
                        return (
                            wo.center.set(0, 0, 0),
                            (wo.radius = 0.7071067811865476),
                            wo.applyMatrix4(e.matrixWorld),
                            this.intersectsSphere(wo)
                        );
                    }
                    intersectsSphere(e) {
                        const t = this.planes,
                            i = e.center,
                            n = -e.radius;
                        for (let e = 0; e < 6; e++)
                            if (t[e].distanceToPoint(i) < n) return !1;
                        return !0;
                    }
                    intersectsBox(e) {
                        const t = this.planes;
                        for (let i = 0; i < 6; i++) {
                            const n = t[i];
                            if (
                                ((To.x = n.normal.x > 0 ? e.max.x : e.min.x),
                                (To.y = n.normal.y > 0 ? e.max.y : e.min.y),
                                (To.z = n.normal.z > 0 ? e.max.z : e.min.z),
                                n.distanceToPoint(To) < 0)
                            )
                                return !1;
                        }
                        return !0;
                    }
                    containsPoint(e) {
                        const t = this.planes;
                        for (let i = 0; i < 6; i++)
                            if (t[i].distanceToPoint(e) < 0) return !1;
                        return !0;
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                }
                function No() {
                    let e = null,
                        t = !1,
                        i = null,
                        n = null;
                    function r(t, s) {
                        i(t, s), (n = e.requestAnimationFrame(r));
                    }
                    return {
                        start: function () {
                            !0 !== t &&
                                null !== i &&
                                ((n = e.requestAnimationFrame(r)), (t = !0));
                        },
                        stop: function () {
                            e.cancelAnimationFrame(n), (t = !1);
                        },
                        setAnimationLoop: function (e) {
                            i = e;
                        },
                        setContext: function (t) {
                            e = t;
                        },
                    };
                }
                function Do(e, t) {
                    const i = t.isWebGL2,
                        n = new WeakMap();
                    return {
                        get: function (e) {
                            return (
                                e.isInterleavedBufferAttribute && (e = e.data),
                                n.get(e)
                            );
                        },
                        remove: function (t) {
                            t.isInterleavedBufferAttribute && (t = t.data);
                            const i = n.get(t);
                            i && (e.deleteBuffer(i.buffer), n.delete(t));
                        },
                        update: function (t, r) {
                            if (t.isGLBufferAttribute) {
                                const e = n.get(t);
                                return void (
                                    (!e || e.version < t.version) &&
                                    n.set(t, {
                                        buffer: t.buffer,
                                        type: t.type,
                                        bytesPerElement: t.elementSize,
                                        version: t.version,
                                    })
                                );
                            }
                            t.isInterleavedBufferAttribute && (t = t.data);
                            const s = n.get(t);
                            void 0 === s
                                ? n.set(
                                      t,
                                      (function (t, n) {
                                          const r = t.array,
                                              s = t.usage,
                                              a = e.createBuffer();
                                          e.bindBuffer(n, a),
                                              e.bufferData(n, r, s),
                                              t.onUploadCallback();
                                          let o = 5126;
                                          return (
                                              r instanceof Float32Array
                                                  ? (o = 5126)
                                                  : r instanceof Float64Array
                                                  ? console.warn(
                                                        "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                                                    )
                                                  : r instanceof Uint16Array
                                                  ? t.isFloat16BufferAttribute
                                                      ? i
                                                          ? (o = 5131)
                                                          : console.warn(
                                                                "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                                                            )
                                                      : (o = 5123)
                                                  : r instanceof Int16Array
                                                  ? (o = 5122)
                                                  : r instanceof Uint32Array
                                                  ? (o = 5125)
                                                  : r instanceof Int32Array
                                                  ? (o = 5124)
                                                  : r instanceof Int8Array
                                                  ? (o = 5120)
                                                  : (r instanceof Uint8Array ||
                                                        r instanceof
                                                            Uint8ClampedArray) &&
                                                    (o = 5121),
                                              {
                                                  buffer: a,
                                                  type: o,
                                                  bytesPerElement:
                                                      r.BYTES_PER_ELEMENT,
                                                  version: t.version,
                                              }
                                          );
                                      })(t, r)
                                  )
                                : s.version < t.version &&
                                  ((function (t, n, r) {
                                      const s = n.array,
                                          a = n.updateRange;
                                      e.bindBuffer(r, t),
                                          -1 === a.count
                                              ? e.bufferSubData(r, 0, s)
                                              : (i
                                                    ? e.bufferSubData(
                                                          r,
                                                          a.offset *
                                                              s.BYTES_PER_ELEMENT,
                                                          s,
                                                          a.offset,
                                                          a.count
                                                      )
                                                    : e.bufferSubData(
                                                          r,
                                                          a.offset *
                                                              s.BYTES_PER_ELEMENT,
                                                          s.subarray(
                                                              a.offset,
                                                              a.offset + a.count
                                                          )
                                                      ),
                                                (a.count = -1));
                                  })(s.buffer, t, r),
                                  (s.version = t.version));
                        },
                    };
                }
                class Io extends Ba {
                    constructor(e = 1, t = 1, i = 1, n = 1) {
                        super(),
                            (this.type = "PlaneGeometry"),
                            (this.parameters = {
                                width: e,
                                height: t,
                                widthSegments: i,
                                heightSegments: n,
                            });
                        const r = e / 2,
                            s = t / 2,
                            a = Math.floor(i),
                            o = Math.floor(n),
                            c = a + 1,
                            l = o + 1,
                            h = e / a,
                            u = t / o,
                            d = [],
                            p = [],
                            g = [],
                            m = [];
                        for (let e = 0; e < l; e++) {
                            const t = e * u - s;
                            for (let i = 0; i < c; i++) {
                                const n = i * h - r;
                                p.push(n, -t, 0),
                                    g.push(0, 0, 1),
                                    m.push(i / a),
                                    m.push(1 - e / o);
                            }
                        }
                        for (let e = 0; e < o; e++)
                            for (let t = 0; t < a; t++) {
                                const i = t + c * e,
                                    n = t + c * (e + 1),
                                    r = t + 1 + c * (e + 1),
                                    s = t + 1 + c * e;
                                d.push(i, n, s), d.push(n, r, s);
                            }
                        this.setIndex(d),
                            this.setAttribute("position", new za(p, 3)),
                            this.setAttribute("normal", new za(g, 3)),
                            this.setAttribute("uv", new za(m, 2));
                    }
                    static fromJSON(e) {
                        return new Io(
                            e.width,
                            e.height,
                            e.widthSegments,
                            e.heightSegments
                        );
                    }
                }
                const Co = {
                        alphamap_fragment:
                            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                        alphamap_pars_fragment:
                            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        alphatest_fragment:
                            "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                        alphatest_pars_fragment:
                            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                        aomap_fragment:
                            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                        aomap_pars_fragment:
                            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                        begin_vertex: "vec3 transformed = vec3( position );",
                        beginnormal_vertex:
                            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                        bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                        bumpmap_pars_fragment:
                            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                        clipping_planes_fragment:
                            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                        clipping_planes_pars_fragment:
                            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                        clipping_planes_pars_vertex:
                            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                        clipping_planes_vertex:
                            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                        color_fragment:
                            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                        color_pars_fragment:
                            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_pars_vertex:
                            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_vertex:
                            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                        cube_uv_reflection_fragment:
                            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                        defaultnormal_vertex:
                            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                        displacementmap_pars_vertex:
                            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                        displacementmap_vertex:
                            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                        emissivemap_fragment:
                            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                        emissivemap_pars_fragment:
                            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                        encodings_fragment:
                            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                        encodings_pars_fragment:
                            "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                        envmap_fragment:
                            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                        envmap_common_pars_fragment:
                            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                        envmap_pars_fragment:
                            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                        envmap_pars_vertex:
                            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                        envmap_physical_pars_fragment:
                            "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                        envmap_vertex:
                            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                        fog_vertex:
                            "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                        fog_pars_vertex:
                            "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                        fog_fragment:
                            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                        fog_pars_fragment:
                            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                        gradientmap_pars_fragment:
                            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                        lightmap_fragment:
                            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                        lightmap_pars_fragment:
                            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                        lights_lambert_vertex:
                            "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                        lights_pars_begin:
                            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                        lights_toon_fragment:
                            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                        lights_toon_pars_fragment:
                            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                        lights_phong_fragment:
                            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                        lights_phong_pars_fragment:
                            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                        lights_physical_fragment:
                            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                        lights_physical_pars_fragment:
                            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                        lights_fragment_begin:
                            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                        lights_fragment_maps:
                            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                        lights_fragment_end:
                            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                        logdepthbuf_fragment:
                            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                        logdepthbuf_pars_fragment:
                            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                        logdepthbuf_pars_vertex:
                            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                        logdepthbuf_vertex:
                            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                        map_fragment:
                            "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                        map_pars_fragment:
                            "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                        map_particle_fragment:
                            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                        map_particle_pars_fragment:
                            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        metalnessmap_fragment:
                            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                        metalnessmap_pars_fragment:
                            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                        morphnormal_vertex:
                            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                        morphtarget_pars_vertex:
                            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                        morphtarget_vertex:
                            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                        normal_fragment_begin:
                            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                        normal_fragment_maps:
                            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                        normal_pars_fragment:
                            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_pars_vertex:
                            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_vertex:
                            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                        normalmap_pars_fragment:
                            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                        clearcoat_normal_fragment_begin:
                            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                        clearcoat_normal_fragment_maps:
                            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                        clearcoat_pars_fragment:
                            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                        output_fragment:
                            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                        packing:
                            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                        premultiplied_alpha_fragment:
                            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                        project_vertex:
                            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                        dithering_fragment:
                            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                        dithering_pars_fragment:
                            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                        roughnessmap_fragment:
                            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                        roughnessmap_pars_fragment:
                            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                        shadowmap_pars_fragment:
                            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                        shadowmap_pars_vertex:
                            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                        shadowmap_vertex:
                            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                        shadowmask_pars_fragment:
                            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                        skinbase_vertex:
                            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                        skinning_pars_vertex:
                            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                        skinning_vertex:
                            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                        skinnormal_vertex:
                            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                        specularmap_fragment:
                            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                        specularmap_pars_fragment:
                            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                        tonemapping_fragment:
                            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                        tonemapping_pars_fragment:
                            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                        transmission_fragment:
                            "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                        transmission_pars_fragment:
                            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                        uv_pars_fragment:
                            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                        uv_pars_vertex:
                            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                        uv_vertex:
                            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                        uv2_pars_fragment:
                            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                        uv2_pars_vertex:
                            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                        uv2_vertex:
                            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                        worldpos_vertex:
                            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                        background_vert:
                            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                        background_frag:
                            "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        cube_vert:
                            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        cube_frag:
                            "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        depth_vert:
                            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                        depth_frag:
                            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                        distanceRGBA_vert:
                            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                        distanceRGBA_frag:
                            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                        equirect_vert:
                            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                        equirect_frag:
                            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        linedashed_vert:
                            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        linedashed_frag:
                            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        meshbasic_vert:
                            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshbasic_frag:
                            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshlambert_vert:
                            "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshlambert_frag:
                            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshmatcap_vert:
                            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                        meshmatcap_frag:
                            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshnormal_vert:
                            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                        meshnormal_frag:
                            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                        meshphong_vert:
                            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphong_frag:
                            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphysical_vert:
                            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                        meshphysical_frag:
                            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshtoon_vert:
                            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshtoon_frag:
                            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        points_vert:
                            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                        points_frag:
                            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        shadow_vert:
                            "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        shadow_frag:
                            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        sprite_vert:
                            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        sprite_frag:
                            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    },
                    Ao = {
                        common: {
                            diffuse: { value: new Na(16777215) },
                            opacity: { value: 1 },
                            map: { value: null },
                            uvTransform: { value: new Vr() },
                            uv2Transform: { value: new Vr() },
                            alphaMap: { value: null },
                            alphaTest: { value: 0 },
                        },
                        specularmap: { specularMap: { value: null } },
                        envmap: {
                            envMap: { value: null },
                            flipEnvMap: { value: -1 },
                            reflectivity: { value: 1 },
                            ior: { value: 1.5 },
                            refractionRatio: { value: 0.98 },
                            maxMipLevel: { value: 0 },
                        },
                        aomap: {
                            aoMap: { value: null },
                            aoMapIntensity: { value: 1 },
                        },
                        lightmap: {
                            lightMap: { value: null },
                            lightMapIntensity: { value: 1 },
                        },
                        emissivemap: { emissiveMap: { value: null } },
                        bumpmap: {
                            bumpMap: { value: null },
                            bumpScale: { value: 1 },
                        },
                        normalmap: {
                            normalMap: { value: null },
                            normalScale: { value: new Gr(1, 1) },
                        },
                        displacementmap: {
                            displacementMap: { value: null },
                            displacementScale: { value: 1 },
                            displacementBias: { value: 0 },
                        },
                        roughnessmap: { roughnessMap: { value: null } },
                        metalnessmap: { metalnessMap: { value: null } },
                        gradientmap: { gradientMap: { value: null } },
                        fog: {
                            fogDensity: { value: 25e-5 },
                            fogNear: { value: 1 },
                            fogFar: { value: 2e3 },
                            fogColor: { value: new Na(16777215) },
                        },
                        lights: {
                            ambientLightColor: { value: [] },
                            lightProbe: { value: [] },
                            directionalLights: {
                                value: [],
                                properties: { direction: {}, color: {} },
                            },
                            directionalLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                },
                            },
                            directionalShadowMap: { value: [] },
                            directionalShadowMatrix: { value: [] },
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {},
                                },
                            },
                            spotLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                },
                            },
                            spotShadowMap: { value: [] },
                            spotShadowMatrix: { value: [] },
                            pointLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    decay: {},
                                    distance: {},
                                },
                            },
                            pointLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {},
                                },
                            },
                            pointShadowMap: { value: [] },
                            pointShadowMatrix: { value: [] },
                            hemisphereLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    skyColor: {},
                                    groundColor: {},
                                },
                            },
                            rectAreaLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    width: {},
                                    height: {},
                                },
                            },
                            ltc_1: { value: null },
                            ltc_2: { value: null },
                        },
                        points: {
                            diffuse: { value: new Na(16777215) },
                            opacity: { value: 1 },
                            size: { value: 1 },
                            scale: { value: 1 },
                            map: { value: null },
                            alphaMap: { value: null },
                            alphaTest: { value: 0 },
                            uvTransform: { value: new Vr() },
                        },
                        sprite: {
                            diffuse: { value: new Na(16777215) },
                            opacity: { value: 1 },
                            center: { value: new Gr(0.5, 0.5) },
                            rotation: { value: 0 },
                            map: { value: null },
                            alphaMap: { value: null },
                            alphaTest: { value: 0 },
                            uvTransform: { value: new Vr() },
                        },
                    },
                    Eo = {
                        basic: {
                            uniforms: lo([
                                Ao.common,
                                Ao.specularmap,
                                Ao.envmap,
                                Ao.aomap,
                                Ao.lightmap,
                                Ao.fog,
                            ]),
                            vertexShader: Co.meshbasic_vert,
                            fragmentShader: Co.meshbasic_frag,
                        },
                        lambert: {
                            uniforms: lo([
                                Ao.common,
                                Ao.specularmap,
                                Ao.envmap,
                                Ao.aomap,
                                Ao.lightmap,
                                Ao.emissivemap,
                                Ao.fog,
                                Ao.lights,
                                { emissive: { value: new Na(0) } },
                            ]),
                            vertexShader: Co.meshlambert_vert,
                            fragmentShader: Co.meshlambert_frag,
                        },
                        phong: {
                            uniforms: lo([
                                Ao.common,
                                Ao.specularmap,
                                Ao.envmap,
                                Ao.aomap,
                                Ao.lightmap,
                                Ao.emissivemap,
                                Ao.bumpmap,
                                Ao.normalmap,
                                Ao.displacementmap,
                                Ao.fog,
                                Ao.lights,
                                {
                                    emissive: { value: new Na(0) },
                                    specular: { value: new Na(1118481) },
                                    shininess: { value: 30 },
                                },
                            ]),
                            vertexShader: Co.meshphong_vert,
                            fragmentShader: Co.meshphong_frag,
                        },
                        standard: {
                            uniforms: lo([
                                Ao.common,
                                Ao.envmap,
                                Ao.aomap,
                                Ao.lightmap,
                                Ao.emissivemap,
                                Ao.bumpmap,
                                Ao.normalmap,
                                Ao.displacementmap,
                                Ao.roughnessmap,
                                Ao.metalnessmap,
                                Ao.fog,
                                Ao.lights,
                                {
                                    emissive: { value: new Na(0) },
                                    roughness: { value: 1 },
                                    metalness: { value: 0 },
                                    envMapIntensity: { value: 1 },
                                },
                            ]),
                            vertexShader: Co.meshphysical_vert,
                            fragmentShader: Co.meshphysical_frag,
                        },
                        toon: {
                            uniforms: lo([
                                Ao.common,
                                Ao.aomap,
                                Ao.lightmap,
                                Ao.emissivemap,
                                Ao.bumpmap,
                                Ao.normalmap,
                                Ao.displacementmap,
                                Ao.gradientmap,
                                Ao.fog,
                                Ao.lights,
                                { emissive: { value: new Na(0) } },
                            ]),
                            vertexShader: Co.meshtoon_vert,
                            fragmentShader: Co.meshtoon_frag,
                        },
                        matcap: {
                            uniforms: lo([
                                Ao.common,
                                Ao.bumpmap,
                                Ao.normalmap,
                                Ao.displacementmap,
                                Ao.fog,
                                { matcap: { value: null } },
                            ]),
                            vertexShader: Co.meshmatcap_vert,
                            fragmentShader: Co.meshmatcap_frag,
                        },
                        points: {
                            uniforms: lo([Ao.points, Ao.fog]),
                            vertexShader: Co.points_vert,
                            fragmentShader: Co.points_frag,
                        },
                        dashed: {
                            uniforms: lo([
                                Ao.common,
                                Ao.fog,
                                {
                                    scale: { value: 1 },
                                    dashSize: { value: 1 },
                                    totalSize: { value: 2 },
                                },
                            ]),
                            vertexShader: Co.linedashed_vert,
                            fragmentShader: Co.linedashed_frag,
                        },
                        depth: {
                            uniforms: lo([Ao.common, Ao.displacementmap]),
                            vertexShader: Co.depth_vert,
                            fragmentShader: Co.depth_frag,
                        },
                        normal: {
                            uniforms: lo([
                                Ao.common,
                                Ao.bumpmap,
                                Ao.normalmap,
                                Ao.displacementmap,
                                { opacity: { value: 1 } },
                            ]),
                            vertexShader: Co.meshnormal_vert,
                            fragmentShader: Co.meshnormal_frag,
                        },
                        sprite: {
                            uniforms: lo([Ao.sprite, Ao.fog]),
                            vertexShader: Co.sprite_vert,
                            fragmentShader: Co.sprite_frag,
                        },
                        background: {
                            uniforms: {
                                uvTransform: { value: new Vr() },
                                t2D: { value: null },
                            },
                            vertexShader: Co.background_vert,
                            fragmentShader: Co.background_frag,
                        },
                        cube: {
                            uniforms: lo([
                                Ao.envmap,
                                { opacity: { value: 1 } },
                            ]),
                            vertexShader: Co.cube_vert,
                            fragmentShader: Co.cube_frag,
                        },
                        equirect: {
                            uniforms: { tEquirect: { value: null } },
                            vertexShader: Co.equirect_vert,
                            fragmentShader: Co.equirect_frag,
                        },
                        distanceRGBA: {
                            uniforms: lo([
                                Ao.common,
                                Ao.displacementmap,
                                {
                                    referencePosition: { value: new rs() },
                                    nearDistance: { value: 1 },
                                    farDistance: { value: 1e3 },
                                },
                            ]),
                            vertexShader: Co.distanceRGBA_vert,
                            fragmentShader: Co.distanceRGBA_frag,
                        },
                        shadow: {
                            uniforms: lo([
                                Ao.lights,
                                Ao.fog,
                                {
                                    color: { value: new Na(0) },
                                    opacity: { value: 1 },
                                },
                            ]),
                            vertexShader: Co.shadow_vert,
                            fragmentShader: Co.shadow_frag,
                        },
                    };
                function Lo(e, t, i, n, r) {
                    const s = new Na(0);
                    let a,
                        o,
                        c = 0,
                        l = null,
                        h = 0,
                        u = null;
                    function d(e, t) {
                        i.buffers.color.setClear(e.r, e.g, e.b, t, r);
                    }
                    return {
                        getClearColor: function () {
                            return s;
                        },
                        setClearColor: function (e, t = 1) {
                            s.set(e), (c = t), d(s, c);
                        },
                        getClearAlpha: function () {
                            return c;
                        },
                        setClearAlpha: function (e) {
                            (c = e), d(s, c);
                        },
                        render: function (i, r) {
                            let p = !1,
                                g = !0 === r.isScene ? r.background : null;
                            g && g.isTexture && (g = t.get(g));
                            const m = e.xr,
                                f = m.getSession && m.getSession();
                            f &&
                                "additive" === f.environmentBlendMode &&
                                (g = null),
                                null === g
                                    ? d(s, c)
                                    : g && g.isColor && (d(g, 1), (p = !0)),
                                (e.autoClear || p) &&
                                    e.clear(
                                        e.autoClearColor,
                                        e.autoClearDepth,
                                        e.autoClearStencil
                                    ),
                                g && (g.isCubeTexture || g.mapping === $i)
                                    ? (void 0 === o &&
                                          ((o = new so(
                                              new oo(1, 1, 1),
                                              new uo({
                                                  name: "BackgroundCubeMaterial",
                                                  uniforms: co(
                                                      Eo.cube.uniforms
                                                  ),
                                                  vertexShader:
                                                      Eo.cube.vertexShader,
                                                  fragmentShader:
                                                      Eo.cube.fragmentShader,
                                                  side: Qt,
                                                  depthTest: !1,
                                                  depthWrite: !1,
                                                  fog: !1,
                                              })
                                          )),
                                          o.geometry.deleteAttribute("normal"),
                                          o.geometry.deleteAttribute("uv"),
                                          (o.onBeforeRender = function (
                                              e,
                                              t,
                                              i
                                          ) {
                                              this.matrixWorld.copyPosition(
                                                  i.matrixWorld
                                              );
                                          }),
                                          Object.defineProperty(
                                              o.material,
                                              "envMap",
                                              {
                                                  get: function () {
                                                      return this.uniforms
                                                          .envMap.value;
                                                  },
                                              }
                                          ),
                                          n.update(o)),
                                      (o.material.uniforms.envMap.value = g),
                                      (o.material.uniforms.flipEnvMap.value =
                                          g.isCubeTexture &&
                                          !1 === g.isRenderTargetTexture
                                              ? -1
                                              : 1),
                                      (l === g &&
                                          h === g.version &&
                                          u === e.toneMapping) ||
                                          ((o.material.needsUpdate = !0),
                                          (l = g),
                                          (h = g.version),
                                          (u = e.toneMapping)),
                                      i.unshift(
                                          o,
                                          o.geometry,
                                          o.material,
                                          0,
                                          0,
                                          null
                                      ))
                                    : g &&
                                      g.isTexture &&
                                      (void 0 === a &&
                                          ((a = new so(
                                              new Io(2, 2),
                                              new uo({
                                                  name: "BackgroundMaterial",
                                                  uniforms: co(
                                                      Eo.background.uniforms
                                                  ),
                                                  vertexShader:
                                                      Eo.background
                                                          .vertexShader,
                                                  fragmentShader:
                                                      Eo.background
                                                          .fragmentShader,
                                                  side: Wt,
                                                  depthTest: !1,
                                                  depthWrite: !1,
                                                  fog: !1,
                                              })
                                          )),
                                          a.geometry.deleteAttribute("normal"),
                                          Object.defineProperty(
                                              a.material,
                                              "map",
                                              {
                                                  get: function () {
                                                      return this.uniforms.t2D
                                                          .value;
                                                  },
                                              }
                                          ),
                                          n.update(a)),
                                      (a.material.uniforms.t2D.value = g),
                                      !0 === g.matrixAutoUpdate &&
                                          g.updateMatrix(),
                                      a.material.uniforms.uvTransform.value.copy(
                                          g.matrix
                                      ),
                                      (l === g &&
                                          h === g.version &&
                                          u === e.toneMapping) ||
                                          ((a.material.needsUpdate = !0),
                                          (l = g),
                                          (h = g.version),
                                          (u = e.toneMapping)),
                                      i.unshift(
                                          a,
                                          a.geometry,
                                          a.material,
                                          0,
                                          0,
                                          null
                                      ));
                        },
                    };
                }
                function zo(e, t, i, n) {
                    const r = e.getParameter(34921),
                        s = n.isWebGL2
                            ? null
                            : t.get("OES_vertex_array_object"),
                        a = n.isWebGL2 || null !== s,
                        o = {},
                        c = d(null);
                    let l = c;
                    function h(t) {
                        return n.isWebGL2
                            ? e.bindVertexArray(t)
                            : s.bindVertexArrayOES(t);
                    }
                    function u(t) {
                        return n.isWebGL2
                            ? e.deleteVertexArray(t)
                            : s.deleteVertexArrayOES(t);
                    }
                    function d(e) {
                        const t = [],
                            i = [],
                            n = [];
                        for (let e = 0; e < r; e++)
                            (t[e] = 0), (i[e] = 0), (n[e] = 0);
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: t,
                            enabledAttributes: i,
                            attributeDivisors: n,
                            object: e,
                            attributes: {},
                            index: null,
                        };
                    }
                    function p() {
                        const e = l.newAttributes;
                        for (let t = 0, i = e.length; t < i; t++) e[t] = 0;
                    }
                    function g(e) {
                        m(e, 0);
                    }
                    function m(i, r) {
                        const s = l.newAttributes,
                            a = l.enabledAttributes,
                            o = l.attributeDivisors;
                        (s[i] = 1),
                            0 === a[i] &&
                                (e.enableVertexAttribArray(i), (a[i] = 1)),
                            o[i] !== r &&
                                ((n.isWebGL2
                                    ? e
                                    : t.get("ANGLE_instanced_arrays"))[
                                    n.isWebGL2
                                        ? "vertexAttribDivisor"
                                        : "vertexAttribDivisorANGLE"
                                ](i, r),
                                (o[i] = r));
                    }
                    function f() {
                        const t = l.newAttributes,
                            i = l.enabledAttributes;
                        for (let n = 0, r = i.length; n < r; n++)
                            i[n] !== t[n] &&
                                (e.disableVertexAttribArray(n), (i[n] = 0));
                    }
                    function _(t, i, r, s, a, o) {
                        !0 !== n.isWebGL2 || (5124 !== r && 5125 !== r)
                            ? e.vertexAttribPointer(t, i, r, s, a, o)
                            : e.vertexAttribIPointer(t, i, r, a, o);
                    }
                    function M() {
                        v(), l !== c && ((l = c), h(l.object));
                    }
                    function v() {
                        (c.geometry = null),
                            (c.program = null),
                            (c.wireframe = !1);
                    }
                    return {
                        setup: function (r, c, u, M, v) {
                            let y = !1;
                            if (a) {
                                const t = (function (t, i, r) {
                                    const a = !0 === r.wireframe;
                                    let c = o[t.id];
                                    void 0 === c && ((c = {}), (o[t.id] = c));
                                    let l = c[i.id];
                                    void 0 === l && ((l = {}), (c[i.id] = l));
                                    let h = l[a];
                                    return (
                                        void 0 === h &&
                                            ((h = d(
                                                n.isWebGL2
                                                    ? e.createVertexArray()
                                                    : s.createVertexArrayOES()
                                            )),
                                            (l[a] = h)),
                                        h
                                    );
                                })(M, u, c);
                                l !== t && ((l = t), h(l.object)),
                                    (y = (function (e, t) {
                                        const i = l.attributes,
                                            n = e.attributes;
                                        let r = 0;
                                        for (const e in n) {
                                            const t = i[e],
                                                s = n[e];
                                            if (void 0 === t) return !0;
                                            if (t.attribute !== s) return !0;
                                            if (t.data !== s.data) return !0;
                                            r++;
                                        }
                                        return (
                                            l.attributesNum !== r ||
                                            l.index !== t
                                        );
                                    })(M, v)),
                                    y &&
                                        (function (e, t) {
                                            const i = {},
                                                n = e.attributes;
                                            let r = 0;
                                            for (const e in n) {
                                                const t = n[e],
                                                    s = {};
                                                (s.attribute = t),
                                                    t.data && (s.data = t.data),
                                                    (i[e] = s),
                                                    r++;
                                            }
                                            (l.attributes = i),
                                                (l.attributesNum = r),
                                                (l.index = t);
                                        })(M, v);
                            } else {
                                const e = !0 === c.wireframe;
                                (l.geometry === M.id &&
                                    l.program === u.id &&
                                    l.wireframe === e) ||
                                    ((l.geometry = M.id),
                                    (l.program = u.id),
                                    (l.wireframe = e),
                                    (y = !0));
                            }
                            !0 === r.isInstancedMesh && (y = !0),
                                null !== v && i.update(v, 34963),
                                y &&
                                    ((function (r, s, a, o) {
                                        if (
                                            !1 === n.isWebGL2 &&
                                            (r.isInstancedMesh ||
                                                o.isInstancedBufferGeometry) &&
                                            null ===
                                                t.get("ANGLE_instanced_arrays")
                                        )
                                            return;
                                        p();
                                        const c = o.attributes,
                                            l = a.getAttributes(),
                                            h = s.defaultAttributeValues;
                                        for (const t in l) {
                                            const n = l[t];
                                            if (n.location >= 0) {
                                                let s = c[t];
                                                if (
                                                    (void 0 === s &&
                                                        ("instanceMatrix" ===
                                                            t &&
                                                            r.instanceMatrix &&
                                                            (s =
                                                                r.instanceMatrix),
                                                        "instanceColor" === t &&
                                                            r.instanceColor &&
                                                            (s =
                                                                r.instanceColor)),
                                                    void 0 !== s)
                                                ) {
                                                    const t = s.normalized,
                                                        a = s.itemSize,
                                                        c = i.get(s);
                                                    if (void 0 === c) continue;
                                                    const l = c.buffer,
                                                        h = c.type,
                                                        u = c.bytesPerElement;
                                                    if (
                                                        s.isInterleavedBufferAttribute
                                                    ) {
                                                        const i = s.data,
                                                            c = i.stride,
                                                            d = s.offset;
                                                        if (
                                                            i &&
                                                            i.isInstancedInterleavedBuffer
                                                        ) {
                                                            for (
                                                                let e = 0;
                                                                e <
                                                                n.locationSize;
                                                                e++
                                                            )
                                                                m(
                                                                    n.location +
                                                                        e,
                                                                    i.meshPerAttribute
                                                                );
                                                            !0 !==
                                                                r.isInstancedMesh &&
                                                                void 0 ===
                                                                    o._maxInstanceCount &&
                                                                (o._maxInstanceCount =
                                                                    i.meshPerAttribute *
                                                                    i.count);
                                                        } else
                                                            for (
                                                                let e = 0;
                                                                e <
                                                                n.locationSize;
                                                                e++
                                                            )
                                                                g(
                                                                    n.location +
                                                                        e
                                                                );
                                                        e.bindBuffer(34962, l);
                                                        for (
                                                            let e = 0;
                                                            e < n.locationSize;
                                                            e++
                                                        )
                                                            _(
                                                                n.location + e,
                                                                a /
                                                                    n.locationSize,
                                                                h,
                                                                t,
                                                                c * u,
                                                                (d +
                                                                    (a /
                                                                        n.locationSize) *
                                                                        e) *
                                                                    u
                                                            );
                                                    } else {
                                                        if (
                                                            s.isInstancedBufferAttribute
                                                        ) {
                                                            for (
                                                                let e = 0;
                                                                e <
                                                                n.locationSize;
                                                                e++
                                                            )
                                                                m(
                                                                    n.location +
                                                                        e,
                                                                    s.meshPerAttribute
                                                                );
                                                            !0 !==
                                                                r.isInstancedMesh &&
                                                                void 0 ===
                                                                    o._maxInstanceCount &&
                                                                (o._maxInstanceCount =
                                                                    s.meshPerAttribute *
                                                                    s.count);
                                                        } else
                                                            for (
                                                                let e = 0;
                                                                e <
                                                                n.locationSize;
                                                                e++
                                                            )
                                                                g(
                                                                    n.location +
                                                                        e
                                                                );
                                                        e.bindBuffer(34962, l);
                                                        for (
                                                            let e = 0;
                                                            e < n.locationSize;
                                                            e++
                                                        )
                                                            _(
                                                                n.location + e,
                                                                a /
                                                                    n.locationSize,
                                                                h,
                                                                t,
                                                                a * u,
                                                                (a /
                                                                    n.locationSize) *
                                                                    e *
                                                                    u
                                                            );
                                                    }
                                                } else if (void 0 !== h) {
                                                    const i = h[t];
                                                    if (void 0 !== i)
                                                        switch (i.length) {
                                                            case 2:
                                                                e.vertexAttrib2fv(
                                                                    n.location,
                                                                    i
                                                                );
                                                                break;
                                                            case 3:
                                                                e.vertexAttrib3fv(
                                                                    n.location,
                                                                    i
                                                                );
                                                                break;
                                                            case 4:
                                                                e.vertexAttrib4fv(
                                                                    n.location,
                                                                    i
                                                                );
                                                                break;
                                                            default:
                                                                e.vertexAttrib1fv(
                                                                    n.location,
                                                                    i
                                                                );
                                                        }
                                                }
                                            }
                                        }
                                        f();
                                    })(r, c, u, M),
                                    null !== v &&
                                        e.bindBuffer(34963, i.get(v).buffer));
                        },
                        reset: M,
                        resetDefaultState: v,
                        dispose: function () {
                            M();
                            for (const e in o) {
                                const t = o[e];
                                for (const e in t) {
                                    const i = t[e];
                                    for (const e in i)
                                        u(i[e].object), delete i[e];
                                    delete t[e];
                                }
                                delete o[e];
                            }
                        },
                        releaseStatesOfGeometry: function (e) {
                            if (void 0 === o[e.id]) return;
                            const t = o[e.id];
                            for (const e in t) {
                                const i = t[e];
                                for (const e in i) u(i[e].object), delete i[e];
                                delete t[e];
                            }
                            delete o[e.id];
                        },
                        releaseStatesOfProgram: function (e) {
                            for (const t in o) {
                                const i = o[t];
                                if (void 0 === i[e.id]) continue;
                                const n = i[e.id];
                                for (const e in n) u(n[e].object), delete n[e];
                                delete i[e.id];
                            }
                        },
                        initAttributes: p,
                        enableAttribute: g,
                        disableUnusedAttributes: f,
                    };
                }
                function jo(e, t, i, n) {
                    const r = n.isWebGL2;
                    let s;
                    (this.setMode = function (e) {
                        s = e;
                    }),
                        (this.render = function (t, n) {
                            e.drawArrays(s, t, n), i.update(n, s, 1);
                        }),
                        (this.renderInstances = function (n, a, o) {
                            if (0 === o) return;
                            let c, l;
                            if (r) (c = e), (l = "drawArraysInstanced");
                            else if (
                                ((c = t.get("ANGLE_instanced_arrays")),
                                (l = "drawArraysInstancedANGLE"),
                                null === c)
                            )
                                return void console.error(
                                    "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                                );
                            c[l](s, n, a, o), i.update(a, s, o);
                        });
                }
                function Oo(e, t, i) {
                    let n;
                    function r(t) {
                        if ("highp" === t) {
                            if (
                                e.getShaderPrecisionFormat(35633, 36338)
                                    .precision > 0 &&
                                e.getShaderPrecisionFormat(35632, 36338)
                                    .precision > 0
                            )
                                return "highp";
                            t = "mediump";
                        }
                        return "mediump" === t &&
                            e.getShaderPrecisionFormat(35633, 36337).precision >
                                0 &&
                            e.getShaderPrecisionFormat(35632, 36337).precision >
                                0
                            ? "mediump"
                            : "lowp";
                    }
                    const s =
                        ("undefined" != typeof WebGL2RenderingContext &&
                            e instanceof WebGL2RenderingContext) ||
                        ("undefined" != typeof WebGL2ComputeRenderingContext &&
                            e instanceof WebGL2ComputeRenderingContext);
                    let a = void 0 !== i.precision ? i.precision : "highp";
                    const o = r(a);
                    o !== a &&
                        (console.warn(
                            "THREE.WebGLRenderer:",
                            a,
                            "not supported, using",
                            o,
                            "instead."
                        ),
                        (a = o));
                    const c = s || t.has("WEBGL_draw_buffers"),
                        l = !0 === i.logarithmicDepthBuffer,
                        h = e.getParameter(34930),
                        u = e.getParameter(35660),
                        d = e.getParameter(3379),
                        p = e.getParameter(34076),
                        g = e.getParameter(34921),
                        m = e.getParameter(36347),
                        f = e.getParameter(36348),
                        _ = e.getParameter(36349),
                        M = u > 0,
                        v = s || t.has("OES_texture_float");
                    return {
                        isWebGL2: s,
                        drawBuffers: c,
                        getMaxAnisotropy: function () {
                            if (void 0 !== n) return n;
                            if (
                                !0 === t.has("EXT_texture_filter_anisotropic")
                            ) {
                                const i = t.get(
                                    "EXT_texture_filter_anisotropic"
                                );
                                n = e.getParameter(
                                    i.MAX_TEXTURE_MAX_ANISOTROPY_EXT
                                );
                            } else n = 0;
                            return n;
                        },
                        getMaxPrecision: r,
                        precision: a,
                        logarithmicDepthBuffer: l,
                        maxTextures: h,
                        maxVertexTextures: u,
                        maxTextureSize: d,
                        maxCubemapSize: p,
                        maxAttributes: g,
                        maxVertexUniforms: m,
                        maxVaryings: f,
                        maxFragmentUniforms: _,
                        vertexTextures: M,
                        floatFragmentTextures: v,
                        floatVertexTextures: M && v,
                        maxSamples: s ? e.getParameter(36183) : 0,
                    };
                }
                function ko(e) {
                    const t = this;
                    let i = null,
                        n = 0,
                        r = !1,
                        s = !1;
                    const a = new bo(),
                        o = new Vr(),
                        c = { value: null, needsUpdate: !1 };
                    function l() {
                        c.value !== i &&
                            ((c.value = i), (c.needsUpdate = n > 0)),
                            (t.numPlanes = n),
                            (t.numIntersection = 0);
                    }
                    function h(e, i, n, r) {
                        const s = null !== e ? e.length : 0;
                        let l = null;
                        if (0 !== s) {
                            if (((l = c.value), !0 !== r || null === l)) {
                                const t = n + 4 * s,
                                    r = i.matrixWorldInverse;
                                o.getNormalMatrix(r),
                                    (null === l || l.length < t) &&
                                        (l = new Float32Array(t));
                                for (let t = 0, i = n; t !== s; ++t, i += 4)
                                    a.copy(e[t]).applyMatrix4(r, o),
                                        a.normal.toArray(l, i),
                                        (l[i + 3] = a.constant);
                            }
                            (c.value = l), (c.needsUpdate = !0);
                        }
                        return (t.numPlanes = s), (t.numIntersection = 0), l;
                    }
                    (this.uniform = c),
                        (this.numPlanes = 0),
                        (this.numIntersection = 0),
                        (this.init = function (e, t, s) {
                            const a = 0 !== e.length || t || 0 !== n || r;
                            return (r = t), (i = h(e, s, 0)), (n = e.length), a;
                        }),
                        (this.beginShadows = function () {
                            (s = !0), h(null);
                        }),
                        (this.endShadows = function () {
                            (s = !1), l();
                        }),
                        (this.setState = function (t, a, o) {
                            const u = t.clippingPlanes,
                                d = t.clipIntersection,
                                p = t.clipShadows,
                                g = e.get(t);
                            if (!r || null === u || 0 === u.length || (s && !p))
                                s ? h(null) : l();
                            else {
                                const e = s ? 0 : n,
                                    t = 4 * e;
                                let r = g.clippingState || null;
                                (c.value = r), (r = h(u, a, t, o));
                                for (let e = 0; e !== t; ++e) r[e] = i[e];
                                (g.clippingState = r),
                                    (this.numIntersection = d
                                        ? this.numPlanes
                                        : 0),
                                    (this.numPlanes += e);
                            }
                        });
                }
                function Ro(e) {
                    let t = new WeakMap();
                    function i(e, t) {
                        return (
                            t === Pi
                                ? (e.mapping = ki)
                                : t === Ui && (e.mapping = Ri),
                            e
                        );
                    }
                    function n(e) {
                        const i = e.target;
                        i.removeEventListener("dispose", n);
                        const r = t.get(i);
                        void 0 !== r && (t.delete(i), r.dispose());
                    }
                    return {
                        get: function (r) {
                            if (
                                r &&
                                r.isTexture &&
                                !1 === r.isRenderTargetTexture
                            ) {
                                const s = r.mapping;
                                if (s === Pi || s === Ui) {
                                    if (t.has(r))
                                        return i(t.get(r).texture, r.mapping);
                                    {
                                        const s = r.image;
                                        if (s && s.height > 0) {
                                            const a = e.getRenderTarget(),
                                                o = new Mo(s.height / 2);
                                            return (
                                                o.fromEquirectangularTexture(
                                                    e,
                                                    r
                                                ),
                                                t.set(r, o),
                                                e.setRenderTarget(a),
                                                r.addEventListener(
                                                    "dispose",
                                                    n
                                                ),
                                                i(o.texture, r.mapping)
                                            );
                                        }
                                        return null;
                                    }
                                }
                            }
                            return r;
                        },
                        dispose: function () {
                            t = new WeakMap();
                        },
                    };
                }
                Eo.physical = {
                    uniforms: lo([
                        Eo.standard.uniforms,
                        {
                            clearcoat: { value: 0 },
                            clearcoatMap: { value: null },
                            clearcoatRoughness: { value: 0 },
                            clearcoatRoughnessMap: { value: null },
                            clearcoatNormalScale: { value: new Gr(1, 1) },
                            clearcoatNormalMap: { value: null },
                            sheen: { value: 0 },
                            sheenColor: { value: new Na(0) },
                            sheenColorMap: { value: null },
                            sheenRoughness: { value: 0 },
                            sheenRoughnessMap: { value: null },
                            transmission: { value: 0 },
                            transmissionMap: { value: null },
                            transmissionSamplerSize: { value: new Gr() },
                            transmissionSamplerMap: { value: null },
                            thickness: { value: 0 },
                            thicknessMap: { value: null },
                            attenuationDistance: { value: 0 },
                            attenuationColor: { value: new Na(0) },
                            specularIntensity: { value: 0 },
                            specularIntensityMap: { value: null },
                            specularColor: { value: new Na(1, 1, 1) },
                            specularColorMap: { value: null },
                        },
                    ]),
                    vertexShader: Co.meshphysical_vert,
                    fragmentShader: Co.meshphysical_frag,
                };
                class Po extends po {
                    constructor(
                        e = -1,
                        t = 1,
                        i = 1,
                        n = -1,
                        r = 0.1,
                        s = 2e3
                    ) {
                        super(),
                            (this.type = "OrthographicCamera"),
                            (this.zoom = 1),
                            (this.view = null),
                            (this.left = e),
                            (this.right = t),
                            (this.top = i),
                            (this.bottom = n),
                            (this.near = r),
                            (this.far = s),
                            this.updateProjectionMatrix();
                    }
                    copy(e, t) {
                        return (
                            super.copy(e, t),
                            (this.left = e.left),
                            (this.right = e.right),
                            (this.top = e.top),
                            (this.bottom = e.bottom),
                            (this.near = e.near),
                            (this.far = e.far),
                            (this.zoom = e.zoom),
                            (this.view =
                                null === e.view
                                    ? null
                                    : Object.assign({}, e.view)),
                            this
                        );
                    }
                    setViewOffset(e, t, i, n, r, s) {
                        null === this.view &&
                            (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1,
                            }),
                            (this.view.enabled = !0),
                            (this.view.fullWidth = e),
                            (this.view.fullHeight = t),
                            (this.view.offsetX = i),
                            (this.view.offsetY = n),
                            (this.view.width = r),
                            (this.view.height = s),
                            this.updateProjectionMatrix();
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1),
                            this.updateProjectionMatrix();
                    }
                    updateProjectionMatrix() {
                        const e = (this.right - this.left) / (2 * this.zoom),
                            t = (this.top - this.bottom) / (2 * this.zoom),
                            i = (this.right + this.left) / 2,
                            n = (this.top + this.bottom) / 2;
                        let r = i - e,
                            s = i + e,
                            a = n + t,
                            o = n - t;
                        if (null !== this.view && this.view.enabled) {
                            const e =
                                    (this.right - this.left) /
                                    this.view.fullWidth /
                                    this.zoom,
                                t =
                                    (this.top - this.bottom) /
                                    this.view.fullHeight /
                                    this.zoom;
                            (r += e * this.view.offsetX),
                                (s = r + e * this.view.width),
                                (a -= t * this.view.offsetY),
                                (o = a - t * this.view.height);
                        }
                        this.projectionMatrix.makeOrthographic(
                            r,
                            s,
                            a,
                            o,
                            this.near,
                            this.far
                        ),
                            this.projectionMatrixInverse
                                .copy(this.projectionMatrix)
                                .invert();
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return (
                            (t.object.zoom = this.zoom),
                            (t.object.left = this.left),
                            (t.object.right = this.right),
                            (t.object.top = this.top),
                            (t.object.bottom = this.bottom),
                            (t.object.near = this.near),
                            (t.object.far = this.far),
                            null !== this.view &&
                                (t.object.view = Object.assign({}, this.view)),
                            t
                        );
                    }
                }
                Po.prototype.isOrthographicCamera = !0;
                class Uo extends uo {
                    constructor(e) {
                        super(e), (this.type = "RawShaderMaterial");
                    }
                }
                Uo.prototype.isRawShaderMaterial = !0;
                const $o = Math.pow(2, 8),
                    Bo = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
                    Fo = 5 + Bo.length,
                    Ho = {
                        [fr]: 0,
                        [_r]: 1,
                        [vr]: 2,
                        [xr]: 3,
                        [br]: 4,
                        [wr]: 5,
                        [Mr]: 6,
                    },
                    Go = new Po(),
                    { _lodPlanes: Vo, _sizeLods: Yo, _sigmas: qo } = tc(),
                    Wo = new Na();
                let Qo = null;
                const Zo = (1 + Math.sqrt(5)) / 2,
                    Xo = 1 / Zo,
                    Jo = [
                        new rs(1, 1, 1),
                        new rs(-1, 1, 1),
                        new rs(1, 1, -1),
                        new rs(-1, 1, -1),
                        new rs(0, Zo, Xo),
                        new rs(0, Zo, -Xo),
                        new rs(Xo, 0, Zo),
                        new rs(-Xo, 0, Zo),
                        new rs(Zo, Xo, 0),
                        new rs(-Zo, Xo, 0),
                    ];
                class Ko {
                    constructor(e) {
                        (this._renderer = e),
                            (this._pingPongRenderTarget = null),
                            (this._blurMaterial = (function (e) {
                                const t = new Float32Array(20),
                                    i = new rs(0, 1, 0);
                                return new Uo({
                                    name: "SphericalGaussianBlur",
                                    defines: { n: 20 },
                                    uniforms: {
                                        envMap: { value: null },
                                        samples: { value: 1 },
                                        weights: { value: t },
                                        latitudinal: { value: !1 },
                                        dTheta: { value: 0 },
                                        mipInt: { value: 0 },
                                        poleAxis: { value: i },
                                        inputEncoding: { value: Ho[fr] },
                                        outputEncoding: { value: Ho[fr] },
                                    },
                                    vertexShader:
                                        "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                    fragmentShader:
                                        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                                    blending: Xt,
                                    depthTest: !1,
                                    depthWrite: !1,
                                });
                            })()),
                            (this._equirectShader = null),
                            (this._cubemapShader = null),
                            this._compileMaterial(this._blurMaterial);
                    }
                    fromScene(e, t = 0, i = 0.1, n = 100) {
                        Qo = this._renderer.getRenderTarget();
                        const r = this._allocateTargets();
                        return (
                            this._sceneToCubeUV(e, i, n, r),
                            t > 0 && this._blur(r, 0, 0, t),
                            this._applyPMREM(r),
                            this._cleanup(r),
                            r
                        );
                    }
                    fromEquirectangular(e) {
                        return this._fromTexture(e);
                    }
                    fromCubemap(e) {
                        return this._fromTexture(e);
                    }
                    compileCubemapShader() {
                        null === this._cubemapShader &&
                            ((this._cubemapShader = sc()),
                            this._compileMaterial(this._cubemapShader));
                    }
                    compileEquirectangularShader() {
                        null === this._equirectShader &&
                            ((this._equirectShader = rc()),
                            this._compileMaterial(this._equirectShader));
                    }
                    dispose() {
                        this._blurMaterial.dispose(),
                            null !== this._cubemapShader &&
                                this._cubemapShader.dispose(),
                            null !== this._equirectShader &&
                                this._equirectShader.dispose();
                        for (let e = 0; e < Vo.length; e++) Vo[e].dispose();
                    }
                    _cleanup(e) {
                        this._pingPongRenderTarget.dispose(),
                            this._renderer.setRenderTarget(Qo),
                            (e.scissorTest = !1),
                            nc(e, 0, 0, e.width, e.height);
                    }
                    _fromTexture(e) {
                        Qo = this._renderer.getRenderTarget();
                        const t = this._allocateTargets(e);
                        return (
                            this._textureToCubeUV(e, t),
                            this._applyPMREM(t),
                            this._cleanup(t),
                            t
                        );
                    }
                    _allocateTargets(e) {
                        const t = {
                                magFilter: Vi,
                                minFilter: Vi,
                                generateMipmaps: !1,
                                type: Xi,
                                format: mn,
                                encoding: ec(e) ? e.encoding : vr,
                                depthBuffer: !1,
                            },
                            i = ic(t);
                        return (
                            (i.depthBuffer = !e),
                            (this._pingPongRenderTarget = ic(t)),
                            i
                        );
                    }
                    _compileMaterial(e) {
                        const t = new so(Vo[0], e);
                        this._renderer.compile(t, Go);
                    }
                    _sceneToCubeUV(e, t, i, n) {
                        const r = new go(90, 1, t, i),
                            s = [1, -1, 1, 1, 1, 1],
                            a = [1, 1, 1, -1, -1, -1],
                            o = this._renderer,
                            c = o.autoClear,
                            l = o.outputEncoding,
                            h = o.toneMapping;
                        o.getClearColor(Wo),
                            (o.toneMapping = Ai),
                            (o.outputEncoding = fr),
                            (o.autoClear = !1);
                        const u = new Da({
                                name: "PMREM.Background",
                                side: Qt,
                                depthWrite: !1,
                                depthTest: !1,
                            }),
                            d = new so(new oo(), u);
                        let p = !1;
                        const g = e.background;
                        g
                            ? g.isColor &&
                              (u.color.copy(g), (e.background = null), (p = !0))
                            : (u.color.copy(Wo), (p = !0));
                        for (let t = 0; t < 6; t++) {
                            const i = t % 3;
                            0 == i
                                ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0))
                                : 1 == i
                                ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0))
                                : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t])),
                                nc(n, i * $o, t > 2 ? $o : 0, $o, $o),
                                o.setRenderTarget(n),
                                p && o.render(d, r),
                                o.render(e, r);
                        }
                        d.geometry.dispose(),
                            d.material.dispose(),
                            (o.toneMapping = h),
                            (o.outputEncoding = l),
                            (o.autoClear = c),
                            (e.background = g);
                    }
                    _setEncoding(e, t) {
                        !0 === this._renderer.capabilities.isWebGL2 &&
                        t.format === dn &&
                        t.type === Xi &&
                        t.encoding === _r
                            ? (e.value = Ho[fr])
                            : (e.value = Ho[t.encoding]);
                    }
                    _textureToCubeUV(e, t) {
                        const i = this._renderer,
                            n = e.mapping === ki || e.mapping === Ri;
                        n
                            ? null == this._cubemapShader &&
                              (this._cubemapShader = sc())
                            : null == this._equirectShader &&
                              (this._equirectShader = rc());
                        const r = n
                                ? this._cubemapShader
                                : this._equirectShader,
                            s = new so(Vo[0], r),
                            a = r.uniforms;
                        (a.envMap.value = e),
                            n ||
                                a.texelSize.value.set(
                                    1 / e.image.width,
                                    1 / e.image.height
                                ),
                            this._setEncoding(a.inputEncoding, e),
                            this._setEncoding(a.outputEncoding, t.texture),
                            nc(t, 0, 0, 3 * $o, 2 * $o),
                            i.setRenderTarget(t),
                            i.render(s, Go);
                    }
                    _applyPMREM(e) {
                        const t = this._renderer,
                            i = t.autoClear;
                        t.autoClear = !1;
                        for (let t = 1; t < Fo; t++) {
                            const i = Math.sqrt(
                                    qo[t] * qo[t] - qo[t - 1] * qo[t - 1]
                                ),
                                n = Jo[(t - 1) % Jo.length];
                            this._blur(e, t - 1, t, i, n);
                        }
                        t.autoClear = i;
                    }
                    _blur(e, t, i, n, r) {
                        const s = this._pingPongRenderTarget;
                        this._halfBlur(e, s, t, i, n, "latitudinal", r),
                            this._halfBlur(s, e, i, i, n, "longitudinal", r);
                    }
                    _halfBlur(e, t, i, n, r, s, a) {
                        const o = this._renderer,
                            c = this._blurMaterial;
                        "latitudinal" !== s &&
                            "longitudinal" !== s &&
                            console.error(
                                "blur direction must be either latitudinal or longitudinal!"
                            );
                        const l = new so(Vo[n], c),
                            h = c.uniforms,
                            u = Yo[i] - 1,
                            d = isFinite(r)
                                ? Math.PI / (2 * u)
                                : (2 * Math.PI) / 39,
                            p = r / d,
                            g = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                        g > 20 &&
                            console.warn(
                                `sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to 20`
                            );
                        const m = [];
                        let f = 0;
                        for (let e = 0; e < 20; ++e) {
                            const t = e / p,
                                i = Math.exp((-t * t) / 2);
                            m.push(i),
                                0 == e ? (f += i) : e < g && (f += 2 * i);
                        }
                        for (let e = 0; e < m.length; e++) m[e] = m[e] / f;
                        (h.envMap.value = e.texture),
                            (h.samples.value = g),
                            (h.weights.value = m),
                            (h.latitudinal.value = "latitudinal" === s),
                            a && (h.poleAxis.value = a),
                            (h.dTheta.value = d),
                            (h.mipInt.value = 8 - i),
                            this._setEncoding(h.inputEncoding, e.texture),
                            this._setEncoding(h.outputEncoding, e.texture);
                        const _ = Yo[n];
                        nc(
                            t,
                            3 * Math.max(0, $o - 2 * _),
                            (0 === n ? 0 : 2 * $o) +
                                2 * _ * (n > 4 ? n - 8 + 4 : 0),
                            3 * _,
                            2 * _
                        ),
                            o.setRenderTarget(t),
                            o.render(l, Go);
                    }
                }
                function ec(e) {
                    return (
                        void 0 !== e &&
                        e.type === Xi &&
                        (e.encoding === fr ||
                            e.encoding === _r ||
                            e.encoding === Mr)
                    );
                }
                function tc() {
                    const e = [],
                        t = [],
                        i = [];
                    let n = 8;
                    for (let r = 0; r < Fo; r++) {
                        const s = Math.pow(2, n);
                        t.push(s);
                        let a = 1 / s;
                        r > 4 ? (a = Bo[r - 8 + 4 - 1]) : 0 == r && (a = 0),
                            i.push(a);
                        const o = 1 / (s - 1),
                            c = -o / 2,
                            l = 1 + o / 2,
                            h = [c, c, l, c, l, l, c, c, l, l, c, l],
                            u = 6,
                            d = 6,
                            p = 3,
                            g = 2,
                            m = 1,
                            f = new Float32Array(p * d * u),
                            _ = new Float32Array(g * d * u),
                            M = new Float32Array(m * d * u);
                        for (let e = 0; e < u; e++) {
                            const t = ((e % 3) * 2) / 3 - 1,
                                i = e > 2 ? 0 : -1,
                                n = [
                                    t,
                                    i,
                                    0,
                                    t + 2 / 3,
                                    i,
                                    0,
                                    t + 2 / 3,
                                    i + 1,
                                    0,
                                    t,
                                    i,
                                    0,
                                    t + 2 / 3,
                                    i + 1,
                                    0,
                                    t,
                                    i + 1,
                                    0,
                                ];
                            f.set(n, p * d * e), _.set(h, g * d * e);
                            const r = [e, e, e, e, e, e];
                            M.set(r, m * d * e);
                        }
                        const v = new Ba();
                        v.setAttribute("position", new Aa(f, p)),
                            v.setAttribute("uv", new Aa(_, g)),
                            v.setAttribute("faceIndex", new Aa(M, m)),
                            e.push(v),
                            n > 4 && n--;
                    }
                    return { _lodPlanes: e, _sizeLods: t, _sigmas: i };
                }
                function ic(e) {
                    const t = new ts(3 * $o, 3 * $o, e);
                    return (
                        (t.texture.mapping = $i),
                        (t.texture.name = "PMREM.cubeUv"),
                        (t.scissorTest = !0),
                        t
                    );
                }
                function nc(e, t, i, n, r) {
                    e.viewport.set(t, i, n, r), e.scissor.set(t, i, n, r);
                }
                function rc() {
                    const e = new Gr(1, 1);
                    return new Uo({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: { value: null },
                            texelSize: { value: e },
                            inputEncoding: { value: Ho[fr] },
                            outputEncoding: { value: Ho[fr] },
                        },
                        vertexShader:
                            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader:
                            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                        blending: Xt,
                        depthTest: !1,
                        depthWrite: !1,
                    });
                }
                function sc() {
                    return new Uo({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: { value: null },
                            inputEncoding: { value: Ho[fr] },
                            outputEncoding: { value: Ho[fr] },
                        },
                        vertexShader:
                            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader:
                            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                        blending: Xt,
                        depthTest: !1,
                        depthWrite: !1,
                    });
                }
                function ac(e) {
                    let t = new WeakMap(),
                        i = null;
                    function n(e) {
                        const i = e.target;
                        i.removeEventListener("dispose", n);
                        const r = t.get(i);
                        void 0 !== r && (t.delete(i), r.dispose());
                    }
                    return {
                        get: function (r) {
                            if (
                                r &&
                                r.isTexture &&
                                !1 === r.isRenderTargetTexture
                            ) {
                                const s = r.mapping,
                                    a = s === Pi || s === Ui,
                                    o = s === ki || s === Ri;
                                if (a || o) {
                                    if (t.has(r)) return t.get(r).texture;
                                    {
                                        const s = r.image;
                                        if (
                                            (a && s && s.height > 0) ||
                                            (o &&
                                                s &&
                                                (function (e) {
                                                    let t = 0;
                                                    for (let i = 0; i < 6; i++)
                                                        void 0 !== e[i] && t++;
                                                    return 6 === t;
                                                })(s))
                                        ) {
                                            const s = e.getRenderTarget();
                                            null === i && (i = new Ko(e));
                                            const o = a
                                                ? i.fromEquirectangular(r)
                                                : i.fromCubemap(r);
                                            return (
                                                t.set(r, o),
                                                e.setRenderTarget(s),
                                                r.addEventListener(
                                                    "dispose",
                                                    n
                                                ),
                                                o.texture
                                            );
                                        }
                                        return null;
                                    }
                                }
                            }
                            return r;
                        },
                        dispose: function () {
                            (t = new WeakMap()),
                                null !== i && (i.dispose(), (i = null));
                        },
                    };
                }
                function oc(e) {
                    const t = {};
                    function i(i) {
                        if (void 0 !== t[i]) return t[i];
                        let n;
                        switch (i) {
                            case "WEBGL_depth_texture":
                                n =
                                    e.getExtension("WEBGL_depth_texture") ||
                                    e.getExtension("MOZ_WEBGL_depth_texture") ||
                                    e.getExtension(
                                        "WEBKIT_WEBGL_depth_texture"
                                    );
                                break;
                            case "EXT_texture_filter_anisotropic":
                                n =
                                    e.getExtension(
                                        "EXT_texture_filter_anisotropic"
                                    ) ||
                                    e.getExtension(
                                        "MOZ_EXT_texture_filter_anisotropic"
                                    ) ||
                                    e.getExtension(
                                        "WEBKIT_EXT_texture_filter_anisotropic"
                                    );
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                n =
                                    e.getExtension(
                                        "WEBGL_compressed_texture_s3tc"
                                    ) ||
                                    e.getExtension(
                                        "MOZ_WEBGL_compressed_texture_s3tc"
                                    ) ||
                                    e.getExtension(
                                        "WEBKIT_WEBGL_compressed_texture_s3tc"
                                    );
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                n =
                                    e.getExtension(
                                        "WEBGL_compressed_texture_pvrtc"
                                    ) ||
                                    e.getExtension(
                                        "WEBKIT_WEBGL_compressed_texture_pvrtc"
                                    );
                                break;
                            default:
                                n = e.getExtension(i);
                        }
                        return (t[i] = n), n;
                    }
                    return {
                        has: function (e) {
                            return null !== i(e);
                        },
                        init: function (e) {
                            e.isWebGL2
                                ? i("EXT_color_buffer_float")
                                : (i("WEBGL_depth_texture"),
                                  i("OES_texture_float"),
                                  i("OES_texture_half_float"),
                                  i("OES_texture_half_float_linear"),
                                  i("OES_standard_derivatives"),
                                  i("OES_element_index_uint"),
                                  i("OES_vertex_array_object"),
                                  i("ANGLE_instanced_arrays")),
                                i("OES_texture_float_linear"),
                                i("EXT_color_buffer_half_float");
                        },
                        get: function (e) {
                            const t = i(e);
                            return (
                                null === t &&
                                    console.warn(
                                        "THREE.WebGLRenderer: " +
                                            e +
                                            " extension not supported."
                                    ),
                                t
                            );
                        },
                    };
                }
                function cc(e, t, i, n) {
                    const r = {},
                        s = new WeakMap();
                    function a(e) {
                        const o = e.target;
                        null !== o.index && t.remove(o.index);
                        for (const e in o.attributes) t.remove(o.attributes[e]);
                        o.removeEventListener("dispose", a), delete r[o.id];
                        const c = s.get(o);
                        c && (t.remove(c), s.delete(o)),
                            n.releaseStatesOfGeometry(o),
                            !0 === o.isInstancedBufferGeometry &&
                                delete o._maxInstanceCount,
                            i.memory.geometries--;
                    }
                    function o(e) {
                        const i = [],
                            n = e.index,
                            r = e.attributes.position;
                        let a = 0;
                        if (null !== n) {
                            const e = n.array;
                            a = n.version;
                            for (let t = 0, n = e.length; t < n; t += 3) {
                                const n = e[t + 0],
                                    r = e[t + 1],
                                    s = e[t + 2];
                                i.push(n, r, r, s, s, n);
                            }
                        } else {
                            const e = r.array;
                            a = r.version;
                            for (
                                let t = 0, n = e.length / 3 - 1;
                                t < n;
                                t += 3
                            ) {
                                const e = t + 0,
                                    n = t + 1,
                                    r = t + 2;
                                i.push(e, n, n, r, r, e);
                            }
                        }
                        const o = new (Yr(i) > 65535 ? La : Ea)(i, 1);
                        o.version = a;
                        const c = s.get(e);
                        c && t.remove(c), s.set(e, o);
                    }
                    return {
                        get: function (e, t) {
                            return (
                                !0 === r[t.id] ||
                                    (t.addEventListener("dispose", a),
                                    (r[t.id] = !0),
                                    i.memory.geometries++),
                                t
                            );
                        },
                        update: function (e) {
                            const i = e.attributes;
                            for (const e in i) t.update(i[e], 34962);
                            const n = e.morphAttributes;
                            for (const e in n) {
                                const i = n[e];
                                for (let e = 0, n = i.length; e < n; e++)
                                    t.update(i[e], 34962);
                            }
                        },
                        getWireframeAttribute: function (e) {
                            const t = s.get(e);
                            if (t) {
                                const i = e.index;
                                null !== i && t.version < i.version && o(e);
                            } else o(e);
                            return s.get(e);
                        },
                    };
                }
                function lc(e, t, i, n) {
                    const r = n.isWebGL2;
                    let s, a, o;
                    (this.setMode = function (e) {
                        s = e;
                    }),
                        (this.setIndex = function (e) {
                            (a = e.type), (o = e.bytesPerElement);
                        }),
                        (this.render = function (t, n) {
                            e.drawElements(s, n, a, t * o), i.update(n, s, 1);
                        }),
                        (this.renderInstances = function (n, c, l) {
                            if (0 === l) return;
                            let h, u;
                            if (r) (h = e), (u = "drawElementsInstanced");
                            else if (
                                ((h = t.get("ANGLE_instanced_arrays")),
                                (u = "drawElementsInstancedANGLE"),
                                null === h)
                            )
                                return void console.error(
                                    "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                                );
                            h[u](s, c, a, n * o, l), i.update(c, s, l);
                        });
                }
                function hc(e) {
                    const t = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0,
                    };
                    return {
                        memory: { geometries: 0, textures: 0 },
                        render: t,
                        programs: null,
                        autoReset: !0,
                        reset: function () {
                            t.frame++,
                                (t.calls = 0),
                                (t.triangles = 0),
                                (t.points = 0),
                                (t.lines = 0);
                        },
                        update: function (e, i, n) {
                            switch ((t.calls++, i)) {
                                case 4:
                                    t.triangles += n * (e / 3);
                                    break;
                                case 1:
                                    t.lines += n * (e / 2);
                                    break;
                                case 3:
                                    t.lines += n * (e - 1);
                                    break;
                                case 2:
                                    t.lines += n * e;
                                    break;
                                case 0:
                                    t.points += n * e;
                                    break;
                                default:
                                    console.error(
                                        "THREE.WebGLInfo: Unknown draw mode:",
                                        i
                                    );
                            }
                        },
                    };
                }
                class uc extends Jr {
                    constructor(e = null, t = 1, i = 1, n = 1) {
                        super(null),
                            (this.image = {
                                data: e,
                                width: t,
                                height: i,
                                depth: n,
                            }),
                            (this.magFilter = Vi),
                            (this.minFilter = Vi),
                            (this.wrapR = Hi),
                            (this.generateMipmaps = !1),
                            (this.flipY = !1),
                            (this.unpackAlignment = 1),
                            (this.needsUpdate = !0);
                    }
                }
                function dc(e, t) {
                    return e[0] - t[0];
                }
                function pc(e, t) {
                    return Math.abs(t[1]) - Math.abs(e[1]);
                }
                function gc(e, t) {
                    let i = 1;
                    const n = t.isInterleavedBufferAttribute
                        ? t.data.array
                        : t.array;
                    n instanceof Int8Array
                        ? (i = 127)
                        : n instanceof Int16Array
                        ? (i = 32767)
                        : n instanceof Int32Array
                        ? (i = 2147483647)
                        : console.error(
                              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
                              n
                          ),
                        e.divideScalar(i);
                }
                function mc(e, t, i) {
                    const n = {},
                        r = new Float32Array(8),
                        s = new WeakMap(),
                        a = new rs(),
                        o = [];
                    for (let e = 0; e < 8; e++) o[e] = [e, 0];
                    return {
                        update: function (c, l, h, u) {
                            const d = c.morphTargetInfluences;
                            if (!0 === t.isWebGL2) {
                                const n = l.morphAttributes.position.length;
                                let r = s.get(l);
                                if (void 0 === r || r.count !== n) {
                                    void 0 !== r && r.texture.dispose();
                                    const e =
                                            void 0 !== l.morphAttributes.normal,
                                        i = l.morphAttributes.position,
                                        o = l.morphAttributes.normal || [],
                                        c = !0 === e ? 2 : 1;
                                    let h = l.attributes.position.count * c,
                                        u = 1;
                                    h > t.maxTextureSize &&
                                        ((u = Math.ceil(h / t.maxTextureSize)),
                                        (h = t.maxTextureSize));
                                    const d = new Float32Array(h * u * 4 * n),
                                        p = new uc(d, h, u, n);
                                    (p.format = dn), (p.type = rn);
                                    const g = 4 * c;
                                    for (let t = 0; t < n; t++) {
                                        const n = i[t],
                                            r = o[t],
                                            s = h * u * 4 * t;
                                        for (let t = 0; t < n.count; t++) {
                                            a.fromBufferAttribute(n, t),
                                                !0 === n.normalized && gc(a, n);
                                            const i = t * g;
                                            (d[s + i + 0] = a.x),
                                                (d[s + i + 1] = a.y),
                                                (d[s + i + 2] = a.z),
                                                (d[s + i + 3] = 0),
                                                !0 === e &&
                                                    (a.fromBufferAttribute(
                                                        r,
                                                        t
                                                    ),
                                                    !0 === r.normalized &&
                                                        gc(a, r),
                                                    (d[s + i + 4] = a.x),
                                                    (d[s + i + 5] = a.y),
                                                    (d[s + i + 6] = a.z),
                                                    (d[s + i + 7] = 0));
                                        }
                                    }
                                    (r = {
                                        count: n,
                                        texture: p,
                                        size: new Gr(h, u),
                                    }),
                                        s.set(l, r);
                                }
                                let o = 0;
                                for (let e = 0; e < d.length; e++) o += d[e];
                                const c = l.morphTargetsRelative ? 1 : 1 - o;
                                u
                                    .getUniforms()
                                    .setValue(e, "morphTargetBaseInfluence", c),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            e,
                                            "morphTargetInfluences",
                                            d
                                        ),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            e,
                                            "morphTargetsTexture",
                                            r.texture,
                                            i
                                        ),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            e,
                                            "morphTargetsTextureSize",
                                            r.size
                                        );
                            } else {
                                const t = void 0 === d ? 0 : d.length;
                                let i = n[l.id];
                                if (void 0 === i || i.length !== t) {
                                    i = [];
                                    for (let e = 0; e < t; e++) i[e] = [e, 0];
                                    n[l.id] = i;
                                }
                                for (let e = 0; e < t; e++) {
                                    const t = i[e];
                                    (t[0] = e), (t[1] = d[e]);
                                }
                                i.sort(pc);
                                for (let e = 0; e < 8; e++)
                                    e < t && i[e][1]
                                        ? ((o[e][0] = i[e][0]),
                                          (o[e][1] = i[e][1]))
                                        : ((o[e][0] = Number.MAX_SAFE_INTEGER),
                                          (o[e][1] = 0));
                                o.sort(dc);
                                const s = l.morphAttributes.position,
                                    a = l.morphAttributes.normal;
                                let c = 0;
                                for (let e = 0; e < 8; e++) {
                                    const t = o[e],
                                        i = t[0],
                                        n = t[1];
                                    i !== Number.MAX_SAFE_INTEGER && n
                                        ? (s &&
                                              l.getAttribute(
                                                  "morphTarget" + e
                                              ) !== s[i] &&
                                              l.setAttribute(
                                                  "morphTarget" + e,
                                                  s[i]
                                              ),
                                          a &&
                                              l.getAttribute(
                                                  "morphNormal" + e
                                              ) !== a[i] &&
                                              l.setAttribute(
                                                  "morphNormal" + e,
                                                  a[i]
                                              ),
                                          (r[e] = n),
                                          (c += n))
                                        : (s &&
                                              !0 ===
                                                  l.hasAttribute(
                                                      "morphTarget" + e
                                                  ) &&
                                              l.deleteAttribute(
                                                  "morphTarget" + e
                                              ),
                                          a &&
                                              !0 ===
                                                  l.hasAttribute(
                                                      "morphNormal" + e
                                                  ) &&
                                              l.deleteAttribute(
                                                  "morphNormal" + e
                                              ),
                                          (r[e] = 0));
                                }
                                const h = l.morphTargetsRelative ? 1 : 1 - c;
                                u
                                    .getUniforms()
                                    .setValue(e, "morphTargetBaseInfluence", h),
                                    u
                                        .getUniforms()
                                        .setValue(
                                            e,
                                            "morphTargetInfluences",
                                            r
                                        );
                            }
                        },
                    };
                }
                function fc(e, t, i, n) {
                    let r = new WeakMap();
                    function s(e) {
                        const t = e.target;
                        t.removeEventListener("dispose", s),
                            i.remove(t.instanceMatrix),
                            null !== t.instanceColor &&
                                i.remove(t.instanceColor);
                    }
                    return {
                        update: function (e) {
                            const a = n.render.frame,
                                o = e.geometry,
                                c = t.get(e, o);
                            return (
                                r.get(c) !== a && (t.update(c), r.set(c, a)),
                                e.isInstancedMesh &&
                                    (!1 === e.hasEventListener("dispose", s) &&
                                        e.addEventListener("dispose", s),
                                    i.update(e.instanceMatrix, 34962),
                                    null !== e.instanceColor &&
                                        i.update(e.instanceColor, 34962)),
                                c
                            );
                        },
                        dispose: function () {
                            r = new WeakMap();
                        },
                    };
                }
                uc.prototype.isDataTexture2DArray = !0;
                class _c extends Jr {
                    constructor(e = null, t = 1, i = 1, n = 1) {
                        super(null),
                            (this.image = {
                                data: e,
                                width: t,
                                height: i,
                                depth: n,
                            }),
                            (this.magFilter = Vi),
                            (this.minFilter = Vi),
                            (this.wrapR = Hi),
                            (this.generateMipmaps = !1),
                            (this.flipY = !1),
                            (this.unpackAlignment = 1),
                            (this.needsUpdate = !0);
                    }
                }
                _c.prototype.isDataTexture3D = !0;
                const Mc = new Jr(),
                    vc = new uc(),
                    yc = new _c(),
                    xc = new _o(),
                    bc = [],
                    wc = [],
                    Tc = new Float32Array(16),
                    Sc = new Float32Array(9),
                    Nc = new Float32Array(4);
                function Dc(e, t, i) {
                    const n = e[0];
                    if (n <= 0 || n > 0) return e;
                    const r = t * i;
                    let s = bc[r];
                    if (
                        (void 0 === s &&
                            ((s = new Float32Array(r)), (bc[r] = s)),
                        0 !== t)
                    ) {
                        n.toArray(s, 0);
                        for (let n = 1, r = 0; n !== t; ++n)
                            (r += i), e[n].toArray(s, r);
                    }
                    return s;
                }
                function Ic(e, t) {
                    if (e.length !== t.length) return !1;
                    for (let i = 0, n = e.length; i < n; i++)
                        if (e[i] !== t[i]) return !1;
                    return !0;
                }
                function Cc(e, t) {
                    for (let i = 0, n = t.length; i < n; i++) e[i] = t[i];
                }
                function Ac(e, t) {
                    let i = wc[t];
                    void 0 === i && ((i = new Int32Array(t)), (wc[t] = i));
                    for (let n = 0; n !== t; ++n)
                        i[n] = e.allocateTextureUnit();
                    return i;
                }
                function Ec(e, t) {
                    const i = this.cache;
                    i[0] !== t && (e.uniform1f(this.addr, t), (i[0] = t));
                }
                function Lc(e, t) {
                    const i = this.cache;
                    if (void 0 !== t.x)
                        (i[0] === t.x && i[1] === t.y) ||
                            (e.uniform2f(this.addr, t.x, t.y),
                            (i[0] = t.x),
                            (i[1] = t.y));
                    else {
                        if (Ic(i, t)) return;
                        e.uniform2fv(this.addr, t), Cc(i, t);
                    }
                }
                function zc(e, t) {
                    const i = this.cache;
                    if (void 0 !== t.x)
                        (i[0] === t.x && i[1] === t.y && i[2] === t.z) ||
                            (e.uniform3f(this.addr, t.x, t.y, t.z),
                            (i[0] = t.x),
                            (i[1] = t.y),
                            (i[2] = t.z));
                    else if (void 0 !== t.r)
                        (i[0] === t.r && i[1] === t.g && i[2] === t.b) ||
                            (e.uniform3f(this.addr, t.r, t.g, t.b),
                            (i[0] = t.r),
                            (i[1] = t.g),
                            (i[2] = t.b));
                    else {
                        if (Ic(i, t)) return;
                        e.uniform3fv(this.addr, t), Cc(i, t);
                    }
                }
                function jc(e, t) {
                    const i = this.cache;
                    if (void 0 !== t.x)
                        (i[0] === t.x &&
                            i[1] === t.y &&
                            i[2] === t.z &&
                            i[3] === t.w) ||
                            (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                            (i[0] = t.x),
                            (i[1] = t.y),
                            (i[2] = t.z),
                            (i[3] = t.w));
                    else {
                        if (Ic(i, t)) return;
                        e.uniform4fv(this.addr, t), Cc(i, t);
                    }
                }
                function Oc(e, t) {
                    const i = this.cache,
                        n = t.elements;
                    if (void 0 === n) {
                        if (Ic(i, t)) return;
                        e.uniformMatrix2fv(this.addr, !1, t), Cc(i, t);
                    } else {
                        if (Ic(i, n)) return;
                        Nc.set(n),
                            e.uniformMatrix2fv(this.addr, !1, Nc),
                            Cc(i, n);
                    }
                }
                function kc(e, t) {
                    const i = this.cache,
                        n = t.elements;
                    if (void 0 === n) {
                        if (Ic(i, t)) return;
                        e.uniformMatrix3fv(this.addr, !1, t), Cc(i, t);
                    } else {
                        if (Ic(i, n)) return;
                        Sc.set(n),
                            e.uniformMatrix3fv(this.addr, !1, Sc),
                            Cc(i, n);
                    }
                }
                function Rc(e, t) {
                    const i = this.cache,
                        n = t.elements;
                    if (void 0 === n) {
                        if (Ic(i, t)) return;
                        e.uniformMatrix4fv(this.addr, !1, t), Cc(i, t);
                    } else {
                        if (Ic(i, n)) return;
                        Tc.set(n),
                            e.uniformMatrix4fv(this.addr, !1, Tc),
                            Cc(i, n);
                    }
                }
                function Pc(e, t) {
                    const i = this.cache;
                    i[0] !== t && (e.uniform1i(this.addr, t), (i[0] = t));
                }
                function Uc(e, t) {
                    const i = this.cache;
                    Ic(i, t) || (e.uniform2iv(this.addr, t), Cc(i, t));
                }
                function $c(e, t) {
                    const i = this.cache;
                    Ic(i, t) || (e.uniform3iv(this.addr, t), Cc(i, t));
                }
                function Bc(e, t) {
                    const i = this.cache;
                    Ic(i, t) || (e.uniform4iv(this.addr, t), Cc(i, t));
                }
                function Fc(e, t) {
                    const i = this.cache;
                    i[0] !== t && (e.uniform1ui(this.addr, t), (i[0] = t));
                }
                function Hc(e, t) {
                    const i = this.cache;
                    Ic(i, t) || (e.uniform2uiv(this.addr, t), Cc(i, t));
                }
                function Gc(e, t) {
                    const i = this.cache;
                    Ic(i, t) || (e.uniform3uiv(this.addr, t), Cc(i, t));
                }
                function Vc(e, t) {
                    const i = this.cache;
                    Ic(i, t) || (e.uniform4uiv(this.addr, t), Cc(i, t));
                }
                function Yc(e, t, i) {
                    const n = this.cache,
                        r = i.allocateTextureUnit();
                    n[0] !== r && (e.uniform1i(this.addr, r), (n[0] = r)),
                        i.safeSetTexture2D(t || Mc, r);
                }
                function qc(e, t, i) {
                    const n = this.cache,
                        r = i.allocateTextureUnit();
                    n[0] !== r && (e.uniform1i(this.addr, r), (n[0] = r)),
                        i.setTexture3D(t || yc, r);
                }
                function Wc(e, t, i) {
                    const n = this.cache,
                        r = i.allocateTextureUnit();
                    n[0] !== r && (e.uniform1i(this.addr, r), (n[0] = r)),
                        i.safeSetTextureCube(t || xc, r);
                }
                function Qc(e, t, i) {
                    const n = this.cache,
                        r = i.allocateTextureUnit();
                    n[0] !== r && (e.uniform1i(this.addr, r), (n[0] = r)),
                        i.setTexture2DArray(t || vc, r);
                }
                function Zc(e, t) {
                    e.uniform1fv(this.addr, t);
                }
                function Xc(e, t) {
                    const i = Dc(t, this.size, 2);
                    e.uniform2fv(this.addr, i);
                }
                function Jc(e, t) {
                    const i = Dc(t, this.size, 3);
                    e.uniform3fv(this.addr, i);
                }
                function Kc(e, t) {
                    const i = Dc(t, this.size, 4);
                    e.uniform4fv(this.addr, i);
                }
                function el(e, t) {
                    const i = Dc(t, this.size, 4);
                    e.uniformMatrix2fv(this.addr, !1, i);
                }
                function tl(e, t) {
                    const i = Dc(t, this.size, 9);
                    e.uniformMatrix3fv(this.addr, !1, i);
                }
                function il(e, t) {
                    const i = Dc(t, this.size, 16);
                    e.uniformMatrix4fv(this.addr, !1, i);
                }
                function nl(e, t) {
                    e.uniform1iv(this.addr, t);
                }
                function rl(e, t) {
                    e.uniform2iv(this.addr, t);
                }
                function sl(e, t) {
                    e.uniform3iv(this.addr, t);
                }
                function al(e, t) {
                    e.uniform4iv(this.addr, t);
                }
                function ol(e, t) {
                    e.uniform1uiv(this.addr, t);
                }
                function cl(e, t) {
                    e.uniform2uiv(this.addr, t);
                }
                function ll(e, t) {
                    e.uniform3uiv(this.addr, t);
                }
                function hl(e, t) {
                    e.uniform4uiv(this.addr, t);
                }
                function ul(e, t, i) {
                    const n = t.length,
                        r = Ac(i, n);
                    e.uniform1iv(this.addr, r);
                    for (let e = 0; e !== n; ++e)
                        i.safeSetTexture2D(t[e] || Mc, r[e]);
                }
                function dl(e, t, i) {
                    const n = t.length,
                        r = Ac(i, n);
                    e.uniform1iv(this.addr, r);
                    for (let e = 0; e !== n; ++e)
                        i.safeSetTextureCube(t[e] || xc, r[e]);
                }
                function pl(e, t, i) {
                    (this.id = e),
                        (this.addr = i),
                        (this.cache = []),
                        (this.setValue = (function (e) {
                            switch (e) {
                                case 5126:
                                    return Ec;
                                case 35664:
                                    return Lc;
                                case 35665:
                                    return zc;
                                case 35666:
                                    return jc;
                                case 35674:
                                    return Oc;
                                case 35675:
                                    return kc;
                                case 35676:
                                    return Rc;
                                case 5124:
                                case 35670:
                                    return Pc;
                                case 35667:
                                case 35671:
                                    return Uc;
                                case 35668:
                                case 35672:
                                    return $c;
                                case 35669:
                                case 35673:
                                    return Bc;
                                case 5125:
                                    return Fc;
                                case 36294:
                                    return Hc;
                                case 36295:
                                    return Gc;
                                case 36296:
                                    return Vc;
                                case 35678:
                                case 36198:
                                case 36298:
                                case 36306:
                                case 35682:
                                    return Yc;
                                case 35679:
                                case 36299:
                                case 36307:
                                    return qc;
                                case 35680:
                                case 36300:
                                case 36308:
                                case 36293:
                                    return Wc;
                                case 36289:
                                case 36303:
                                case 36311:
                                case 36292:
                                    return Qc;
                            }
                        })(t.type));
                }
                function gl(e, t, i) {
                    (this.id = e),
                        (this.addr = i),
                        (this.cache = []),
                        (this.size = t.size),
                        (this.setValue = (function (e) {
                            switch (e) {
                                case 5126:
                                    return Zc;
                                case 35664:
                                    return Xc;
                                case 35665:
                                    return Jc;
                                case 35666:
                                    return Kc;
                                case 35674:
                                    return el;
                                case 35675:
                                    return tl;
                                case 35676:
                                    return il;
                                case 5124:
                                case 35670:
                                    return nl;
                                case 35667:
                                case 35671:
                                    return rl;
                                case 35668:
                                case 35672:
                                    return sl;
                                case 35669:
                                case 35673:
                                    return al;
                                case 5125:
                                    return ol;
                                case 36294:
                                    return cl;
                                case 36295:
                                    return ll;
                                case 36296:
                                    return hl;
                                case 35678:
                                case 36198:
                                case 36298:
                                case 36306:
                                case 35682:
                                    return ul;
                                case 35680:
                                case 36300:
                                case 36308:
                                case 36293:
                                    return dl;
                            }
                        })(t.type));
                }
                function ml(e) {
                    (this.id = e), (this.seq = []), (this.map = {});
                }
                (gl.prototype.updateCache = function (e) {
                    const t = this.cache;
                    e instanceof Float32Array &&
                        t.length !== e.length &&
                        (this.cache = new Float32Array(e.length)),
                        Cc(t, e);
                }),
                    (ml.prototype.setValue = function (e, t, i) {
                        const n = this.seq;
                        for (let r = 0, s = n.length; r !== s; ++r) {
                            const s = n[r];
                            s.setValue(e, t[s.id], i);
                        }
                    });
                const fl = /(\w+)(\])?(\[|\.)?/g;
                function _l(e, t) {
                    e.seq.push(t), (e.map[t.id] = t);
                }
                function Ml(e, t, i) {
                    const n = e.name,
                        r = n.length;
                    for (fl.lastIndex = 0; ; ) {
                        const s = fl.exec(n),
                            a = fl.lastIndex;
                        let o = s[1];
                        const c = "]" === s[2],
                            l = s[3];
                        if (
                            (c && (o |= 0),
                            void 0 === l || ("[" === l && a + 2 === r))
                        ) {
                            _l(
                                i,
                                void 0 === l ? new pl(o, e, t) : new gl(o, e, t)
                            );
                            break;
                        }
                        {
                            let e = i.map[o];
                            void 0 === e && ((e = new ml(o)), _l(i, e)),
                                (i = e);
                        }
                    }
                }
                function vl(e, t) {
                    (this.seq = []), (this.map = {});
                    const i = e.getProgramParameter(t, 35718);
                    for (let n = 0; n < i; ++n) {
                        const i = e.getActiveUniform(t, n);
                        Ml(i, e.getUniformLocation(t, i.name), this);
                    }
                }
                function yl(e, t, i) {
                    const n = e.createShader(t);
                    return e.shaderSource(n, i), e.compileShader(n), n;
                }
                (vl.prototype.setValue = function (e, t, i, n) {
                    const r = this.map[t];
                    void 0 !== r && r.setValue(e, i, n);
                }),
                    (vl.prototype.setOptional = function (e, t, i) {
                        const n = t[i];
                        void 0 !== n && this.setValue(e, i, n);
                    }),
                    (vl.upload = function (e, t, i, n) {
                        for (let r = 0, s = t.length; r !== s; ++r) {
                            const s = t[r],
                                a = i[s.id];
                            !1 !== a.needsUpdate && s.setValue(e, a.value, n);
                        }
                    }),
                    (vl.seqWithValue = function (e, t) {
                        const i = [];
                        for (let n = 0, r = e.length; n !== r; ++n) {
                            const r = e[n];
                            r.id in t && i.push(r);
                        }
                        return i;
                    });
                let xl = 0;
                function bl(e) {
                    switch (e) {
                        case fr:
                            return ["Linear", "( value )"];
                        case _r:
                            return ["sRGB", "( value )"];
                        case vr:
                            return ["RGBE", "( value )"];
                        case xr:
                            return ["RGBM", "( value, 7.0 )"];
                        case br:
                            return ["RGBM", "( value, 16.0 )"];
                        case wr:
                            return ["RGBD", "( value, 256.0 )"];
                        case Mr:
                            return [
                                "Gamma",
                                "( value, float( GAMMA_FACTOR ) )",
                            ];
                        case yr:
                            return ["LogLuv", "( value )"];
                        default:
                            return (
                                console.warn(
                                    "THREE.WebGLProgram: Unsupported encoding:",
                                    e
                                ),
                                ["Linear", "( value )"]
                            );
                    }
                }
                function wl(e, t, i) {
                    const n = e.getShaderParameter(t, 35713),
                        r = e.getShaderInfoLog(t).trim();
                    return n && "" === r
                        ? ""
                        : i.toUpperCase() +
                              "\n\n" +
                              r +
                              "\n\n" +
                              (function (e) {
                                  const t = e.split("\n");
                                  for (let e = 0; e < t.length; e++)
                                      t[e] = e + 1 + ": " + t[e];
                                  return t.join("\n");
                              })(e.getShaderSource(t));
                }
                function Tl(e, t) {
                    const i = bl(t);
                    return (
                        "vec4 " +
                        e +
                        "( vec4 value ) { return " +
                        i[0] +
                        "ToLinear" +
                        i[1] +
                        "; }"
                    );
                }
                function Sl(e, t) {
                    const i = bl(t);
                    return (
                        "vec4 " +
                        e +
                        "( vec4 value ) { return LinearTo" +
                        i[0] +
                        i[1] +
                        "; }"
                    );
                }
                function Nl(e, t) {
                    let i;
                    switch (t) {
                        case Ei:
                            i = "Linear";
                            break;
                        case Li:
                            i = "Reinhard";
                            break;
                        case zi:
                            i = "OptimizedCineon";
                            break;
                        case ji:
                            i = "ACESFilmic";
                            break;
                        case Oi:
                            i = "Custom";
                            break;
                        default:
                            console.warn(
                                "THREE.WebGLProgram: Unsupported toneMapping:",
                                t
                            ),
                                (i = "Linear");
                    }
                    return (
                        "vec3 " +
                        e +
                        "( vec3 color ) { return " +
                        i +
                        "ToneMapping( color ); }"
                    );
                }
                function Dl(e) {
                    return "" !== e;
                }
                function Il(e, t) {
                    return e
                        .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
                        .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
                        .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
                        .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
                        .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
                        .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
                        .replace(
                            /NUM_SPOT_LIGHT_SHADOWS/g,
                            t.numSpotLightShadows
                        )
                        .replace(
                            /NUM_POINT_LIGHT_SHADOWS/g,
                            t.numPointLightShadows
                        );
                }
                function Cl(e, t) {
                    return e
                        .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
                        .replace(
                            /UNION_CLIPPING_PLANES/g,
                            t.numClippingPlanes - t.numClipIntersection
                        );
                }
                const Al = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function El(e) {
                    return e.replace(Al, Ll);
                }
                function Ll(e, t) {
                    const i = Co[t];
                    if (void 0 === i)
                        throw new Error("Can not resolve #include <" + t + ">");
                    return El(i);
                }
                const zl =
                        /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                    jl =
                        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function Ol(e) {
                    return e.replace(jl, Rl).replace(zl, kl);
                }
                function kl(e, t, i, n) {
                    return (
                        console.warn(
                            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
                        ),
                        Rl(0, t, i, n)
                    );
                }
                function Rl(e, t, i, n) {
                    let r = "";
                    for (let e = parseInt(t); e < parseInt(i); e++)
                        r += n
                            .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
                            .replace(/UNROLLED_LOOP_INDEX/g, e);
                    return r;
                }
                function Pl(e) {
                    let t =
                        "precision " +
                        e.precision +
                        " float;\nprecision " +
                        e.precision +
                        " int;";
                    return (
                        "highp" === e.precision
                            ? (t += "\n#define HIGH_PRECISION")
                            : "mediump" === e.precision
                            ? (t += "\n#define MEDIUM_PRECISION")
                            : "lowp" === e.precision &&
                              (t += "\n#define LOW_PRECISION"),
                        t
                    );
                }
                function Ul(e, t, i, n) {
                    const r = e.getContext(),
                        s = i.defines;
                    let a = i.vertexShader,
                        o = i.fragmentShader;
                    const c = (function (e) {
                            let t = "SHADOWMAP_TYPE_BASIC";
                            return (
                                e.shadowMapType === Vt
                                    ? (t = "SHADOWMAP_TYPE_PCF")
                                    : e.shadowMapType === Yt
                                    ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
                                    : e.shadowMapType === qt &&
                                      (t = "SHADOWMAP_TYPE_VSM"),
                                t
                            );
                        })(i),
                        l = (function (e) {
                            let t = "ENVMAP_TYPE_CUBE";
                            if (e.envMap)
                                switch (e.envMapMode) {
                                    case ki:
                                    case Ri:
                                        t = "ENVMAP_TYPE_CUBE";
                                        break;
                                    case $i:
                                    case Bi:
                                        t = "ENVMAP_TYPE_CUBE_UV";
                                }
                            return t;
                        })(i),
                        h = (function (e) {
                            let t = "ENVMAP_MODE_REFLECTION";
                            if (e.envMap)
                                switch (e.envMapMode) {
                                    case Ri:
                                    case Bi:
                                        t = "ENVMAP_MODE_REFRACTION";
                                }
                            return t;
                        })(i),
                        u = (function (e) {
                            let t = "ENVMAP_BLENDING_NONE";
                            if (e.envMap)
                                switch (e.combine) {
                                    case Di:
                                        t = "ENVMAP_BLENDING_MULTIPLY";
                                        break;
                                    case Ii:
                                        t = "ENVMAP_BLENDING_MIX";
                                        break;
                                    case Ci:
                                        t = "ENVMAP_BLENDING_ADD";
                                }
                            return t;
                        })(i),
                        d = e.gammaFactor > 0 ? e.gammaFactor : 1,
                        p = i.isWebGL2
                            ? ""
                            : (function (e) {
                                  return [
                                      e.extensionDerivatives ||
                                      e.envMapCubeUV ||
                                      e.bumpMap ||
                                      e.tangentSpaceNormalMap ||
                                      e.clearcoatNormalMap ||
                                      e.flatShading ||
                                      "physical" === e.shaderID
                                          ? "#extension GL_OES_standard_derivatives : enable"
                                          : "",
                                      (e.extensionFragDepth ||
                                          e.logarithmicDepthBuffer) &&
                                      e.rendererExtensionFragDepth
                                          ? "#extension GL_EXT_frag_depth : enable"
                                          : "",
                                      e.extensionDrawBuffers &&
                                      e.rendererExtensionDrawBuffers
                                          ? "#extension GL_EXT_draw_buffers : require"
                                          : "",
                                      (e.extensionShaderTextureLOD ||
                                          e.envMap ||
                                          e.transmission) &&
                                      e.rendererExtensionShaderTextureLod
                                          ? "#extension GL_EXT_shader_texture_lod : enable"
                                          : "",
                                  ]
                                      .filter(Dl)
                                      .join("\n");
                              })(i),
                        g = (function (e) {
                            const t = [];
                            for (const i in e) {
                                const n = e[i];
                                !1 !== n && t.push("#define " + i + " " + n);
                            }
                            return t.join("\n");
                        })(s),
                        m = r.createProgram();
                    let f,
                        _,
                        M = i.glslVersion
                            ? "#version " + i.glslVersion + "\n"
                            : "";
                    i.isRawShaderMaterial
                        ? ((f = [g].filter(Dl).join("\n")),
                          f.length > 0 && (f += "\n"),
                          (_ = [p, g].filter(Dl).join("\n")),
                          _.length > 0 && (_ += "\n"))
                        : ((f = [
                              Pl(i),
                              "#define SHADER_NAME " + i.shaderName,
                              g,
                              i.instancing ? "#define USE_INSTANCING" : "",
                              i.instancingColor
                                  ? "#define USE_INSTANCING_COLOR"
                                  : "",
                              i.supportsVertexTextures
                                  ? "#define VERTEX_TEXTURES"
                                  : "",
                              "#define GAMMA_FACTOR " + d,
                              "#define MAX_BONES " + i.maxBones,
                              i.useFog && i.fog ? "#define USE_FOG" : "",
                              i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
                              i.map ? "#define USE_MAP" : "",
                              i.envMap ? "#define USE_ENVMAP" : "",
                              i.envMap ? "#define " + h : "",
                              i.lightMap ? "#define USE_LIGHTMAP" : "",
                              i.aoMap ? "#define USE_AOMAP" : "",
                              i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                              i.bumpMap ? "#define USE_BUMPMAP" : "",
                              i.normalMap ? "#define USE_NORMALMAP" : "",
                              i.normalMap && i.objectSpaceNormalMap
                                  ? "#define OBJECTSPACE_NORMALMAP"
                                  : "",
                              i.normalMap && i.tangentSpaceNormalMap
                                  ? "#define TANGENTSPACE_NORMALMAP"
                                  : "",
                              i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                              i.clearcoatRoughnessMap
                                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                                  : "",
                              i.clearcoatNormalMap
                                  ? "#define USE_CLEARCOAT_NORMALMAP"
                                  : "",
                              i.displacementMap && i.supportsVertexTextures
                                  ? "#define USE_DISPLACEMENTMAP"
                                  : "",
                              i.specularMap ? "#define USE_SPECULARMAP" : "",
                              i.specularIntensityMap
                                  ? "#define USE_SPECULARINTENSITYMAP"
                                  : "",
                              i.specularColorMap
                                  ? "#define USE_SPECULARCOLORMAP"
                                  : "",
                              i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                              i.metalnessMap ? "#define USE_METALNESSMAP" : "",
                              i.alphaMap ? "#define USE_ALPHAMAP" : "",
                              i.transmission ? "#define USE_TRANSMISSION" : "",
                              i.transmissionMap
                                  ? "#define USE_TRANSMISSIONMAP"
                                  : "",
                              i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                              i.sheenColorMap
                                  ? "#define USE_SHEENCOLORMAP"
                                  : "",
                              i.sheenRoughnessMap
                                  ? "#define USE_SHEENROUGHNESSMAP"
                                  : "",
                              i.vertexTangents ? "#define USE_TANGENT" : "",
                              i.vertexColors ? "#define USE_COLOR" : "",
                              i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                              i.vertexUvs ? "#define USE_UV" : "",
                              i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                              i.flatShading ? "#define FLAT_SHADED" : "",
                              i.skinning ? "#define USE_SKINNING" : "",
                              i.useVertexTexture ? "#define BONE_TEXTURE" : "",
                              i.morphTargets ? "#define USE_MORPHTARGETS" : "",
                              i.morphNormals && !1 === i.flatShading
                                  ? "#define USE_MORPHNORMALS"
                                  : "",
                              i.morphTargets && i.isWebGL2
                                  ? "#define MORPHTARGETS_TEXTURE"
                                  : "",
                              i.morphTargets && i.isWebGL2
                                  ? "#define MORPHTARGETS_COUNT " +
                                    i.morphTargetsCount
                                  : "",
                              i.doubleSided ? "#define DOUBLE_SIDED" : "",
                              i.flipSided ? "#define FLIP_SIDED" : "",
                              i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                              i.shadowMapEnabled ? "#define " + c : "",
                              i.sizeAttenuation
                                  ? "#define USE_SIZEATTENUATION"
                                  : "",
                              i.logarithmicDepthBuffer
                                  ? "#define USE_LOGDEPTHBUF"
                                  : "",
                              i.logarithmicDepthBuffer &&
                              i.rendererExtensionFragDepth
                                  ? "#define USE_LOGDEPTHBUF_EXT"
                                  : "",
                              "uniform mat4 modelMatrix;",
                              "uniform mat4 modelViewMatrix;",
                              "uniform mat4 projectionMatrix;",
                              "uniform mat4 viewMatrix;",
                              "uniform mat3 normalMatrix;",
                              "uniform vec3 cameraPosition;",
                              "uniform bool isOrthographic;",
                              "#ifdef USE_INSTANCING",
                              "\tattribute mat4 instanceMatrix;",
                              "#endif",
                              "#ifdef USE_INSTANCING_COLOR",
                              "\tattribute vec3 instanceColor;",
                              "#endif",
                              "attribute vec3 position;",
                              "attribute vec3 normal;",
                              "attribute vec2 uv;",
                              "#ifdef USE_TANGENT",
                              "\tattribute vec4 tangent;",
                              "#endif",
                              "#if defined( USE_COLOR_ALPHA )",
                              "\tattribute vec4 color;",
                              "#elif defined( USE_COLOR )",
                              "\tattribute vec3 color;",
                              "#endif",
                              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
                              "\tattribute vec3 morphTarget0;",
                              "\tattribute vec3 morphTarget1;",
                              "\tattribute vec3 morphTarget2;",
                              "\tattribute vec3 morphTarget3;",
                              "\t#ifdef USE_MORPHNORMALS",
                              "\t\tattribute vec3 morphNormal0;",
                              "\t\tattribute vec3 morphNormal1;",
                              "\t\tattribute vec3 morphNormal2;",
                              "\t\tattribute vec3 morphNormal3;",
                              "\t#else",
                              "\t\tattribute vec3 morphTarget4;",
                              "\t\tattribute vec3 morphTarget5;",
                              "\t\tattribute vec3 morphTarget6;",
                              "\t\tattribute vec3 morphTarget7;",
                              "\t#endif",
                              "#endif",
                              "#ifdef USE_SKINNING",
                              "\tattribute vec4 skinIndex;",
                              "\tattribute vec4 skinWeight;",
                              "#endif",
                              "\n",
                          ]
                              .filter(Dl)
                              .join("\n")),
                          (_ = [
                              p,
                              Pl(i),
                              "#define SHADER_NAME " + i.shaderName,
                              g,
                              "#define GAMMA_FACTOR " + d,
                              i.useFog && i.fog ? "#define USE_FOG" : "",
                              i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
                              i.map ? "#define USE_MAP" : "",
                              i.matcap ? "#define USE_MATCAP" : "",
                              i.envMap ? "#define USE_ENVMAP" : "",
                              i.envMap ? "#define " + l : "",
                              i.envMap ? "#define " + h : "",
                              i.envMap ? "#define " + u : "",
                              i.lightMap ? "#define USE_LIGHTMAP" : "",
                              i.aoMap ? "#define USE_AOMAP" : "",
                              i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                              i.bumpMap ? "#define USE_BUMPMAP" : "",
                              i.normalMap ? "#define USE_NORMALMAP" : "",
                              i.normalMap && i.objectSpaceNormalMap
                                  ? "#define OBJECTSPACE_NORMALMAP"
                                  : "",
                              i.normalMap && i.tangentSpaceNormalMap
                                  ? "#define TANGENTSPACE_NORMALMAP"
                                  : "",
                              i.clearcoat ? "#define USE_CLEARCOAT" : "",
                              i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                              i.clearcoatRoughnessMap
                                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                                  : "",
                              i.clearcoatNormalMap
                                  ? "#define USE_CLEARCOAT_NORMALMAP"
                                  : "",
                              i.specularMap ? "#define USE_SPECULARMAP" : "",
                              i.specularIntensityMap
                                  ? "#define USE_SPECULARINTENSITYMAP"
                                  : "",
                              i.specularColorMap
                                  ? "#define USE_SPECULARCOLORMAP"
                                  : "",
                              i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                              i.metalnessMap ? "#define USE_METALNESSMAP" : "",
                              i.alphaMap ? "#define USE_ALPHAMAP" : "",
                              i.alphaTest ? "#define USE_ALPHATEST" : "",
                              i.sheen ? "#define USE_SHEEN" : "",
                              i.sheenColorMap
                                  ? "#define USE_SHEENCOLORMAP"
                                  : "",
                              i.sheenRoughnessMap
                                  ? "#define USE_SHEENROUGHNESSMAP"
                                  : "",
                              i.transmission ? "#define USE_TRANSMISSION" : "",
                              i.transmissionMap
                                  ? "#define USE_TRANSMISSIONMAP"
                                  : "",
                              i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                              i.vertexTangents ? "#define USE_TANGENT" : "",
                              i.vertexColors || i.instancingColor
                                  ? "#define USE_COLOR"
                                  : "",
                              i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                              i.vertexUvs ? "#define USE_UV" : "",
                              i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                              i.gradientMap ? "#define USE_GRADIENTMAP" : "",
                              i.flatShading ? "#define FLAT_SHADED" : "",
                              i.doubleSided ? "#define DOUBLE_SIDED" : "",
                              i.flipSided ? "#define FLIP_SIDED" : "",
                              i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                              i.shadowMapEnabled ? "#define " + c : "",
                              i.premultipliedAlpha
                                  ? "#define PREMULTIPLIED_ALPHA"
                                  : "",
                              i.physicallyCorrectLights
                                  ? "#define PHYSICALLY_CORRECT_LIGHTS"
                                  : "",
                              i.logarithmicDepthBuffer
                                  ? "#define USE_LOGDEPTHBUF"
                                  : "",
                              i.logarithmicDepthBuffer &&
                              i.rendererExtensionFragDepth
                                  ? "#define USE_LOGDEPTHBUF_EXT"
                                  : "",
                              (i.extensionShaderTextureLOD || i.envMap) &&
                              i.rendererExtensionShaderTextureLod
                                  ? "#define TEXTURE_LOD_EXT"
                                  : "",
                              "uniform mat4 viewMatrix;",
                              "uniform vec3 cameraPosition;",
                              "uniform bool isOrthographic;",
                              i.toneMapping !== Ai
                                  ? "#define TONE_MAPPING"
                                  : "",
                              i.toneMapping !== Ai
                                  ? Co.tonemapping_pars_fragment
                                  : "",
                              i.toneMapping !== Ai
                                  ? Nl("toneMapping", i.toneMapping)
                                  : "",
                              i.dithering ? "#define DITHERING" : "",
                              i.format === un ? "#define OPAQUE" : "",
                              Co.encodings_pars_fragment,
                              i.map
                                  ? Tl("mapTexelToLinear", i.mapEncoding)
                                  : "",
                              i.matcap
                                  ? Tl("matcapTexelToLinear", i.matcapEncoding)
                                  : "",
                              i.envMap
                                  ? Tl("envMapTexelToLinear", i.envMapEncoding)
                                  : "",
                              i.emissiveMap
                                  ? Tl(
                                        "emissiveMapTexelToLinear",
                                        i.emissiveMapEncoding
                                    )
                                  : "",
                              i.specularColorMap
                                  ? Tl(
                                        "specularColorMapTexelToLinear",
                                        i.specularColorMapEncoding
                                    )
                                  : "",
                              i.sheenColorMap
                                  ? Tl(
                                        "sheenColorMapTexelToLinear",
                                        i.sheenColorMapEncoding
                                    )
                                  : "",
                              i.lightMap
                                  ? Tl(
                                        "lightMapTexelToLinear",
                                        i.lightMapEncoding
                                    )
                                  : "",
                              Sl("linearToOutputTexel", i.outputEncoding),
                              i.depthPacking
                                  ? "#define DEPTH_PACKING " + i.depthPacking
                                  : "",
                              "\n",
                          ]
                              .filter(Dl)
                              .join("\n"))),
                        (a = El(a)),
                        (a = Il(a, i)),
                        (a = Cl(a, i)),
                        (o = El(o)),
                        (o = Il(o, i)),
                        (o = Cl(o, i)),
                        (a = Ol(a)),
                        (o = Ol(o)),
                        i.isWebGL2 &&
                            !0 !== i.isRawShaderMaterial &&
                            ((M = "#version 300 es\n"),
                            (f =
                                [
                                    "precision mediump sampler2DArray;",
                                    "#define attribute in",
                                    "#define varying out",
                                    "#define texture2D texture",
                                ].join("\n") +
                                "\n" +
                                f),
                            (_ =
                                [
                                    "#define varying in",
                                    i.glslVersion === Ar
                                        ? ""
                                        : "out highp vec4 pc_fragColor;",
                                    i.glslVersion === Ar
                                        ? ""
                                        : "#define gl_FragColor pc_fragColor",
                                    "#define gl_FragDepthEXT gl_FragDepth",
                                    "#define texture2D texture",
                                    "#define textureCube texture",
                                    "#define texture2DProj textureProj",
                                    "#define texture2DLodEXT textureLod",
                                    "#define texture2DProjLodEXT textureProjLod",
                                    "#define textureCubeLodEXT textureLod",
                                    "#define texture2DGradEXT textureGrad",
                                    "#define texture2DProjGradEXT textureProjGrad",
                                    "#define textureCubeGradEXT textureGrad",
                                ].join("\n") +
                                "\n" +
                                _));
                    const v = M + _ + o,
                        y = yl(r, 35633, M + f + a),
                        x = yl(r, 35632, v);
                    if (
                        (r.attachShader(m, y),
                        r.attachShader(m, x),
                        void 0 !== i.index0AttributeName
                            ? r.bindAttribLocation(m, 0, i.index0AttributeName)
                            : !0 === i.morphTargets &&
                              r.bindAttribLocation(m, 0, "position"),
                        r.linkProgram(m),
                        e.debug.checkShaderErrors)
                    ) {
                        const e = r.getProgramInfoLog(m).trim(),
                            t = r.getShaderInfoLog(y).trim(),
                            i = r.getShaderInfoLog(x).trim();
                        let n = !0,
                            s = !0;
                        if (!1 === r.getProgramParameter(m, 35714)) {
                            n = !1;
                            const t = wl(r, y, "vertex"),
                                i = wl(r, x, "fragment");
                            console.error(
                                "THREE.WebGLProgram: Shader Error " +
                                    r.getError() +
                                    " - VALIDATE_STATUS " +
                                    r.getProgramParameter(m, 35715) +
                                    "\n\nProgram Info Log: " +
                                    e +
                                    "\n" +
                                    t +
                                    "\n" +
                                    i
                            );
                        } else
                            "" !== e
                                ? console.warn(
                                      "THREE.WebGLProgram: Program Info Log:",
                                      e
                                  )
                                : ("" !== t && "" !== i) || (s = !1);
                        s &&
                            (this.diagnostics = {
                                runnable: n,
                                programLog: e,
                                vertexShader: { log: t, prefix: f },
                                fragmentShader: { log: i, prefix: _ },
                            });
                    }
                    let b, w;
                    return (
                        r.deleteShader(y),
                        r.deleteShader(x),
                        (this.getUniforms = function () {
                            return void 0 === b && (b = new vl(r, m)), b;
                        }),
                        (this.getAttributes = function () {
                            return (
                                void 0 === w &&
                                    (w = (function (e, t) {
                                        const i = {},
                                            n = e.getProgramParameter(t, 35721);
                                        for (let r = 0; r < n; r++) {
                                            const n = e.getActiveAttrib(t, r),
                                                s = n.name;
                                            let a = 1;
                                            35674 === n.type && (a = 2),
                                                35675 === n.type && (a = 3),
                                                35676 === n.type && (a = 4),
                                                (i[s] = {
                                                    type: n.type,
                                                    location:
                                                        e.getAttribLocation(
                                                            t,
                                                            s
                                                        ),
                                                    locationSize: a,
                                                });
                                        }
                                        return i;
                                    })(r, m)),
                                w
                            );
                        }),
                        (this.destroy = function () {
                            n.releaseStatesOfProgram(this),
                                r.deleteProgram(m),
                                (this.program = void 0);
                        }),
                        (this.name = i.shaderName),
                        (this.id = xl++),
                        (this.cacheKey = t),
                        (this.usedTimes = 1),
                        (this.program = m),
                        (this.vertexShader = y),
                        (this.fragmentShader = x),
                        this
                    );
                }
                function $l(e, t, i, n, r, s, a) {
                    const o = [],
                        c = r.isWebGL2,
                        l = r.logarithmicDepthBuffer,
                        h = r.floatVertexTextures,
                        u = r.maxVertexUniforms,
                        d = r.vertexTextures;
                    let p = r.precision;
                    const g = {
                            MeshDepthMaterial: "depth",
                            MeshDistanceMaterial: "distanceRGBA",
                            MeshNormalMaterial: "normal",
                            MeshBasicMaterial: "basic",
                            MeshLambertMaterial: "lambert",
                            MeshPhongMaterial: "phong",
                            MeshToonMaterial: "toon",
                            MeshStandardMaterial: "physical",
                            MeshPhysicalMaterial: "physical",
                            MeshMatcapMaterial: "matcap",
                            LineBasicMaterial: "basic",
                            LineDashedMaterial: "dashed",
                            PointsMaterial: "points",
                            ShadowMaterial: "shadow",
                            SpriteMaterial: "sprite",
                        },
                        m = [
                            "precision",
                            "isWebGL2",
                            "supportsVertexTextures",
                            "outputEncoding",
                            "instancing",
                            "instancingColor",
                            "map",
                            "mapEncoding",
                            "matcap",
                            "matcapEncoding",
                            "envMap",
                            "envMapMode",
                            "envMapEncoding",
                            "envMapCubeUV",
                            "lightMap",
                            "lightMapEncoding",
                            "aoMap",
                            "emissiveMap",
                            "emissiveMapEncoding",
                            "bumpMap",
                            "normalMap",
                            "objectSpaceNormalMap",
                            "tangentSpaceNormalMap",
                            "clearcoat",
                            "clearcoatMap",
                            "clearcoatRoughnessMap",
                            "clearcoatNormalMap",
                            "displacementMap",
                            "specularMap",
                            ,
                            "roughnessMap",
                            "metalnessMap",
                            "gradientMap",
                            "alphaMap",
                            "alphaTest",
                            "combine",
                            "vertexColors",
                            "vertexAlphas",
                            "vertexTangents",
                            "vertexUvs",
                            "uvsVertexOnly",
                            "fog",
                            "useFog",
                            "fogExp2",
                            "flatShading",
                            "sizeAttenuation",
                            "logarithmicDepthBuffer",
                            "skinning",
                            "maxBones",
                            "useVertexTexture",
                            "morphTargets",
                            "morphNormals",
                            "morphTargetsCount",
                            "premultipliedAlpha",
                            "numDirLights",
                            "numPointLights",
                            "numSpotLights",
                            "numHemiLights",
                            "numRectAreaLights",
                            "numDirLightShadows",
                            "numPointLightShadows",
                            "numSpotLightShadows",
                            "shadowMapEnabled",
                            "shadowMapType",
                            "toneMapping",
                            "physicallyCorrectLights",
                            "doubleSided",
                            "flipSided",
                            "numClippingPlanes",
                            "numClipIntersection",
                            "depthPacking",
                            "dithering",
                            "format",
                            "specularIntensityMap",
                            "specularColorMap",
                            "specularColorMapEncoding",
                            "transmission",
                            "transmissionMap",
                            "thicknessMap",
                            "sheen",
                            "sheenColorMap",
                            "sheenColorMapEncoding",
                            "sheenRoughnessMap",
                        ];
                    function f(e) {
                        let t;
                        return (
                            e && e.isTexture
                                ? (t = e.encoding)
                                : e && e.isWebGLRenderTarget
                                ? (console.warn(
                                      "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                                  ),
                                  (t = e.texture.encoding))
                                : (t = fr),
                            c &&
                                e &&
                                e.isTexture &&
                                e.format === dn &&
                                e.type === Xi &&
                                e.encoding === _r &&
                                (t = fr),
                            t
                        );
                    }
                    return {
                        getParameters: function (s, o, m, _, M) {
                            const v = _.fog,
                                y = s.isMeshStandardMaterial
                                    ? _.environment
                                    : null,
                                x = (s.isMeshStandardMaterial ? i : t).get(
                                    s.envMap || y
                                ),
                                b = g[s.type],
                                w = M.isSkinnedMesh
                                    ? (function (e) {
                                          const t = e.skeleton.bones;
                                          if (h) return 1024;
                                          {
                                              const e = u,
                                                  i = Math.floor((e - 20) / 4),
                                                  n = Math.min(i, t.length);
                                              return n < t.length
                                                  ? (console.warn(
                                                        "THREE.WebGLRenderer: Skeleton has " +
                                                            t.length +
                                                            " bones. This GPU supports " +
                                                            n +
                                                            "."
                                                    ),
                                                    0)
                                                  : n;
                                          }
                                      })(M)
                                    : 0;
                            let T, S;
                            if (
                                (null !== s.precision &&
                                    ((p = r.getMaxPrecision(s.precision)),
                                    p !== s.precision &&
                                        console.warn(
                                            "THREE.WebGLProgram.getParameters:",
                                            s.precision,
                                            "not supported, using",
                                            p,
                                            "instead."
                                        )),
                                b)
                            ) {
                                const e = Eo[b];
                                (T = e.vertexShader), (S = e.fragmentShader);
                            } else (T = s.vertexShader), (S = s.fragmentShader);
                            const N = e.getRenderTarget(),
                                D = s.alphaTest > 0,
                                I = s.clearcoat > 0;
                            return {
                                isWebGL2: c,
                                shaderID: b,
                                shaderName: s.type,
                                vertexShader: T,
                                fragmentShader: S,
                                defines: s.defines,
                                isRawShaderMaterial:
                                    !0 === s.isRawShaderMaterial,
                                glslVersion: s.glslVersion,
                                precision: p,
                                instancing: !0 === M.isInstancedMesh,
                                instancingColor:
                                    !0 === M.isInstancedMesh &&
                                    null !== M.instanceColor,
                                supportsVertexTextures: d,
                                outputEncoding:
                                    null !== N
                                        ? f(N.texture)
                                        : e.outputEncoding,
                                map: !!s.map,
                                mapEncoding: f(s.map),
                                matcap: !!s.matcap,
                                matcapEncoding: f(s.matcap),
                                envMap: !!x,
                                envMapMode: x && x.mapping,
                                envMapEncoding: f(x),
                                envMapCubeUV:
                                    !!x &&
                                    (x.mapping === $i || x.mapping === Bi),
                                lightMap: !!s.lightMap,
                                lightMapEncoding: f(s.lightMap),
                                aoMap: !!s.aoMap,
                                emissiveMap: !!s.emissiveMap,
                                emissiveMapEncoding: f(s.emissiveMap),
                                bumpMap: !!s.bumpMap,
                                normalMap: !!s.normalMap,
                                objectSpaceNormalMap: s.normalMapType === Nr,
                                tangentSpaceNormalMap: s.normalMapType === Sr,
                                clearcoat: I,
                                clearcoatMap: I && !!s.clearcoatMap,
                                clearcoatRoughnessMap:
                                    I && !!s.clearcoatRoughnessMap,
                                clearcoatNormalMap: I && !!s.clearcoatNormalMap,
                                displacementMap: !!s.displacementMap,
                                roughnessMap: !!s.roughnessMap,
                                metalnessMap: !!s.metalnessMap,
                                specularMap: !!s.specularMap,
                                specularIntensityMap: !!s.specularIntensityMap,
                                specularColorMap: !!s.specularColorMap,
                                specularColorMapEncoding: f(s.specularColorMap),
                                alphaMap: !!s.alphaMap,
                                alphaTest: D,
                                gradientMap: !!s.gradientMap,
                                sheen: s.sheen > 0,
                                sheenColorMap: !!s.sheenColorMap,
                                sheenColorMapEncoding: f(s.sheenColorMap),
                                sheenRoughnessMap: !!s.sheenRoughnessMap,
                                transmission: s.transmission > 0,
                                transmissionMap: !!s.transmissionMap,
                                thicknessMap: !!s.thicknessMap,
                                combine: s.combine,
                                vertexTangents:
                                    !!s.normalMap &&
                                    !!M.geometry &&
                                    !!M.geometry.attributes.tangent,
                                vertexColors: s.vertexColors,
                                vertexAlphas:
                                    !0 === s.vertexColors &&
                                    !!M.geometry &&
                                    !!M.geometry.attributes.color &&
                                    4 === M.geometry.attributes.color.itemSize,
                                vertexUvs:
                                    !!s.map ||
                                    !!s.bumpMap ||
                                    !!s.normalMap ||
                                    !!s.specularMap ||
                                    !!s.alphaMap ||
                                    !!s.emissiveMap ||
                                    !!s.roughnessMap ||
                                    !!s.metalnessMap ||
                                    !!s.clearcoatMap ||
                                    !!s.clearcoatRoughnessMap ||
                                    !!s.clearcoatNormalMap ||
                                    !!s.displacementMap ||
                                    !!s.transmissionMap ||
                                    !!s.thicknessMap ||
                                    !!s.specularIntensityMap ||
                                    !!s.specularColorMap ||
                                    !!s.sheenColorMap ||
                                    s.sheenRoughnessMap,
                                uvsVertexOnly: !(
                                    s.map ||
                                    s.bumpMap ||
                                    s.normalMap ||
                                    s.specularMap ||
                                    s.alphaMap ||
                                    s.emissiveMap ||
                                    s.roughnessMap ||
                                    s.metalnessMap ||
                                    s.clearcoatNormalMap ||
                                    s.transmission > 0 ||
                                    s.transmissionMap ||
                                    s.thicknessMap ||
                                    s.specularIntensityMap ||
                                    s.specularColorMap ||
                                    !!s.sheen > 0 ||
                                    s.sheenColorMap ||
                                    s.sheenRoughnessMap ||
                                    !s.displacementMap
                                ),
                                fog: !!v,
                                useFog: s.fog,
                                fogExp2: v && v.isFogExp2,
                                flatShading: !!s.flatShading,
                                sizeAttenuation: s.sizeAttenuation,
                                logarithmicDepthBuffer: l,
                                skinning: !0 === M.isSkinnedMesh && w > 0,
                                maxBones: w,
                                useVertexTexture: h,
                                morphTargets:
                                    !!M.geometry &&
                                    !!M.geometry.morphAttributes.position,
                                morphNormals:
                                    !!M.geometry &&
                                    !!M.geometry.morphAttributes.normal,
                                morphTargetsCount:
                                    M.geometry &&
                                    M.geometry.morphAttributes.position
                                        ? M.geometry.morphAttributes.position
                                              .length
                                        : 0,
                                numDirLights: o.directional.length,
                                numPointLights: o.point.length,
                                numSpotLights: o.spot.length,
                                numRectAreaLights: o.rectArea.length,
                                numHemiLights: o.hemi.length,
                                numDirLightShadows:
                                    o.directionalShadowMap.length,
                                numPointLightShadows: o.pointShadowMap.length,
                                numSpotLightShadows: o.spotShadowMap.length,
                                numClippingPlanes: a.numPlanes,
                                numClipIntersection: a.numIntersection,
                                format: s.format,
                                dithering: s.dithering,
                                shadowMapEnabled:
                                    e.shadowMap.enabled && m.length > 0,
                                shadowMapType: e.shadowMap.type,
                                toneMapping: s.toneMapped ? e.toneMapping : Ai,
                                physicallyCorrectLights:
                                    e.physicallyCorrectLights,
                                premultipliedAlpha: s.premultipliedAlpha,
                                doubleSided: s.side === Zt,
                                flipSided: s.side === Qt,
                                depthPacking:
                                    void 0 !== s.depthPacking && s.depthPacking,
                                index0AttributeName: s.index0AttributeName,
                                extensionDerivatives:
                                    s.extensions && s.extensions.derivatives,
                                extensionFragDepth:
                                    s.extensions && s.extensions.fragDepth,
                                extensionDrawBuffers:
                                    s.extensions && s.extensions.drawBuffers,
                                extensionShaderTextureLOD:
                                    s.extensions &&
                                    s.extensions.shaderTextureLOD,
                                rendererExtensionFragDepth:
                                    c || n.has("EXT_frag_depth"),
                                rendererExtensionDrawBuffers:
                                    c || n.has("WEBGL_draw_buffers"),
                                rendererExtensionShaderTextureLod:
                                    c || n.has("EXT_shader_texture_lod"),
                                customProgramCacheKey:
                                    s.customProgramCacheKey(),
                            };
                        },
                        getProgramCacheKey: function (t) {
                            const i = [];
                            if (
                                (t.shaderID
                                    ? i.push(t.shaderID)
                                    : (i.push(Wr(t.fragmentShader)),
                                      i.push(Wr(t.vertexShader))),
                                void 0 !== t.defines)
                            )
                                for (const e in t.defines)
                                    i.push(e), i.push(t.defines[e]);
                            if (!1 === t.isRawShaderMaterial) {
                                for (let e = 0; e < m.length; e++)
                                    i.push(t[m[e]]);
                                i.push(e.outputEncoding), i.push(e.gammaFactor);
                            }
                            return i.push(t.customProgramCacheKey), i.join();
                        },
                        getUniforms: function (e) {
                            const t = g[e.type];
                            let i;
                            if (t) {
                                const e = Eo[t];
                                i = ho.clone(e.uniforms);
                            } else i = e.uniforms;
                            return i;
                        },
                        acquireProgram: function (t, i) {
                            let n;
                            for (let e = 0, t = o.length; e < t; e++) {
                                const t = o[e];
                                if (t.cacheKey === i) {
                                    (n = t), ++n.usedTimes;
                                    break;
                                }
                            }
                            return (
                                void 0 === n &&
                                    ((n = new Ul(e, i, t, s)), o.push(n)),
                                n
                            );
                        },
                        releaseProgram: function (e) {
                            if (0 == --e.usedTimes) {
                                const t = o.indexOf(e);
                                (o[t] = o[o.length - 1]), o.pop(), e.destroy();
                            }
                        },
                        programs: o,
                    };
                }
                function Bl() {
                    let e = new WeakMap();
                    return {
                        get: function (t) {
                            let i = e.get(t);
                            return void 0 === i && ((i = {}), e.set(t, i)), i;
                        },
                        remove: function (t) {
                            e.delete(t);
                        },
                        update: function (t, i, n) {
                            e.get(t)[i] = n;
                        },
                        dispose: function () {
                            e = new WeakMap();
                        },
                    };
                }
                function Fl(e, t) {
                    return e.groupOrder !== t.groupOrder
                        ? e.groupOrder - t.groupOrder
                        : e.renderOrder !== t.renderOrder
                        ? e.renderOrder - t.renderOrder
                        : e.program !== t.program
                        ? e.program.id - t.program.id
                        : e.material.id !== t.material.id
                        ? e.material.id - t.material.id
                        : e.z !== t.z
                        ? e.z - t.z
                        : e.id - t.id;
                }
                function Hl(e, t) {
                    return e.groupOrder !== t.groupOrder
                        ? e.groupOrder - t.groupOrder
                        : e.renderOrder !== t.renderOrder
                        ? e.renderOrder - t.renderOrder
                        : e.z !== t.z
                        ? t.z - e.z
                        : e.id - t.id;
                }
                function Gl(e) {
                    const t = [];
                    let i = 0;
                    const n = [],
                        r = [],
                        s = [],
                        a = { id: -1 };
                    function o(n, r, s, o, c, l) {
                        let h = t[i];
                        const u = e.get(s);
                        return (
                            void 0 === h
                                ? ((h = {
                                      id: n.id,
                                      object: n,
                                      geometry: r,
                                      material: s,
                                      program: u.program || a,
                                      groupOrder: o,
                                      renderOrder: n.renderOrder,
                                      z: c,
                                      group: l,
                                  }),
                                  (t[i] = h))
                                : ((h.id = n.id),
                                  (h.object = n),
                                  (h.geometry = r),
                                  (h.material = s),
                                  (h.program = u.program || a),
                                  (h.groupOrder = o),
                                  (h.renderOrder = n.renderOrder),
                                  (h.z = c),
                                  (h.group = l)),
                            i++,
                            h
                        );
                    }
                    return {
                        opaque: n,
                        transmissive: r,
                        transparent: s,
                        init: function () {
                            (i = 0),
                                (n.length = 0),
                                (r.length = 0),
                                (s.length = 0);
                        },
                        push: function (e, t, i, a, c, l) {
                            const h = o(e, t, i, a, c, l);
                            i.transmission > 0
                                ? r.push(h)
                                : !0 === i.transparent
                                ? s.push(h)
                                : n.push(h);
                        },
                        unshift: function (e, t, i, a, c, l) {
                            const h = o(e, t, i, a, c, l);
                            i.transmission > 0
                                ? r.unshift(h)
                                : !0 === i.transparent
                                ? s.unshift(h)
                                : n.unshift(h);
                        },
                        finish: function () {
                            for (let e = i, n = t.length; e < n; e++) {
                                const i = t[e];
                                if (null === i.id) break;
                                (i.id = null),
                                    (i.object = null),
                                    (i.geometry = null),
                                    (i.material = null),
                                    (i.program = null),
                                    (i.group = null);
                            }
                        },
                        sort: function (e, t) {
                            n.length > 1 && n.sort(e || Fl),
                                r.length > 1 && r.sort(t || Hl),
                                s.length > 1 && s.sort(t || Hl);
                        },
                    };
                }
                function Vl(e) {
                    let t = new WeakMap();
                    return {
                        get: function (i, n) {
                            let r;
                            return (
                                !1 === t.has(i)
                                    ? ((r = new Gl(e)), t.set(i, [r]))
                                    : n >= t.get(i).length
                                    ? ((r = new Gl(e)), t.get(i).push(r))
                                    : (r = t.get(i)[n]),
                                r
                            );
                        },
                        dispose: function () {
                            t = new WeakMap();
                        },
                    };
                }
                function Yl() {
                    const e = {};
                    return {
                        get: function (t) {
                            if (void 0 !== e[t.id]) return e[t.id];
                            let i;
                            switch (t.type) {
                                case "DirectionalLight":
                                    i = {
                                        direction: new rs(),
                                        color: new Na(),
                                    };
                                    break;
                                case "SpotLight":
                                    i = {
                                        position: new rs(),
                                        direction: new rs(),
                                        color: new Na(),
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0,
                                    };
                                    break;
                                case "PointLight":
                                    i = {
                                        position: new rs(),
                                        color: new Na(),
                                        distance: 0,
                                        decay: 0,
                                    };
                                    break;
                                case "HemisphereLight":
                                    i = {
                                        direction: new rs(),
                                        skyColor: new Na(),
                                        groundColor: new Na(),
                                    };
                                    break;
                                case "RectAreaLight":
                                    i = {
                                        color: new Na(),
                                        position: new rs(),
                                        halfWidth: new rs(),
                                        halfHeight: new rs(),
                                    };
                            }
                            return (e[t.id] = i), i;
                        },
                    };
                }
                let ql = 0;
                function Wl(e, t) {
                    return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
                }
                function Ql(e, t) {
                    const i = new Yl(),
                        n = (function () {
                            const e = {};
                            return {
                                get: function (t) {
                                    if (void 0 !== e[t.id]) return e[t.id];
                                    let i;
                                    switch (t.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            i = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new Gr(),
                                            };
                                            break;
                                        case "PointLight":
                                            i = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new Gr(),
                                                shadowCameraNear: 1,
                                                shadowCameraFar: 1e3,
                                            };
                                    }
                                    return (e[t.id] = i), i;
                                },
                            };
                        })(),
                        r = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1,
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotShadowMatrix: [],
                            rectArea: [],
                            rectAreaLTC1: null,
                            rectAreaLTC2: null,
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: [],
                        };
                    for (let e = 0; e < 9; e++) r.probe.push(new rs());
                    const s = new rs(),
                        a = new Os(),
                        o = new Os();
                    return {
                        setup: function (s, a) {
                            let o = 0,
                                c = 0,
                                l = 0;
                            for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
                            let h = 0,
                                u = 0,
                                d = 0,
                                p = 0,
                                g = 0,
                                m = 0,
                                f = 0,
                                _ = 0;
                            s.sort(Wl);
                            const M = !0 !== a ? Math.PI : 1;
                            for (let e = 0, t = s.length; e < t; e++) {
                                const t = s[e],
                                    a = t.color,
                                    v = t.intensity,
                                    y = t.distance,
                                    x =
                                        t.shadow && t.shadow.map
                                            ? t.shadow.map.texture
                                            : null;
                                if (t.isAmbientLight)
                                    (o += a.r * v * M),
                                        (c += a.g * v * M),
                                        (l += a.b * v * M);
                                else if (t.isLightProbe)
                                    for (let e = 0; e < 9; e++)
                                        r.probe[e].addScaledVector(
                                            t.sh.coefficients[e],
                                            v
                                        );
                                else if (t.isDirectionalLight) {
                                    const e = i.get(t);
                                    if (
                                        (e.color
                                            .copy(t.color)
                                            .multiplyScalar(t.intensity * M),
                                        t.castShadow)
                                    ) {
                                        const e = t.shadow,
                                            i = n.get(t);
                                        (i.shadowBias = e.bias),
                                            (i.shadowNormalBias = e.normalBias),
                                            (i.shadowRadius = e.radius),
                                            (i.shadowMapSize = e.mapSize),
                                            (r.directionalShadow[h] = i),
                                            (r.directionalShadowMap[h] = x),
                                            (r.directionalShadowMatrix[h] =
                                                t.shadow.matrix),
                                            m++;
                                    }
                                    (r.directional[h] = e), h++;
                                } else if (t.isSpotLight) {
                                    const e = i.get(t);
                                    if (
                                        (e.position.setFromMatrixPosition(
                                            t.matrixWorld
                                        ),
                                        e.color.copy(a).multiplyScalar(v * M),
                                        (e.distance = y),
                                        (e.coneCos = Math.cos(t.angle)),
                                        (e.penumbraCos = Math.cos(
                                            t.angle * (1 - t.penumbra)
                                        )),
                                        (e.decay = t.decay),
                                        t.castShadow)
                                    ) {
                                        const e = t.shadow,
                                            i = n.get(t);
                                        (i.shadowBias = e.bias),
                                            (i.shadowNormalBias = e.normalBias),
                                            (i.shadowRadius = e.radius),
                                            (i.shadowMapSize = e.mapSize),
                                            (r.spotShadow[d] = i),
                                            (r.spotShadowMap[d] = x),
                                            (r.spotShadowMatrix[d] =
                                                t.shadow.matrix),
                                            _++;
                                    }
                                    (r.spot[d] = e), d++;
                                } else if (t.isRectAreaLight) {
                                    const e = i.get(t);
                                    e.color.copy(a).multiplyScalar(v),
                                        e.halfWidth.set(0.5 * t.width, 0, 0),
                                        e.halfHeight.set(0, 0.5 * t.height, 0),
                                        (r.rectArea[p] = e),
                                        p++;
                                } else if (t.isPointLight) {
                                    const e = i.get(t);
                                    if (
                                        (e.color
                                            .copy(t.color)
                                            .multiplyScalar(t.intensity * M),
                                        (e.distance = t.distance),
                                        (e.decay = t.decay),
                                        t.castShadow)
                                    ) {
                                        const e = t.shadow,
                                            i = n.get(t);
                                        (i.shadowBias = e.bias),
                                            (i.shadowNormalBias = e.normalBias),
                                            (i.shadowRadius = e.radius),
                                            (i.shadowMapSize = e.mapSize),
                                            (i.shadowCameraNear =
                                                e.camera.near),
                                            (i.shadowCameraFar = e.camera.far),
                                            (r.pointShadow[u] = i),
                                            (r.pointShadowMap[u] = x),
                                            (r.pointShadowMatrix[u] =
                                                t.shadow.matrix),
                                            f++;
                                    }
                                    (r.point[u] = e), u++;
                                } else if (t.isHemisphereLight) {
                                    const e = i.get(t);
                                    e.skyColor
                                        .copy(t.color)
                                        .multiplyScalar(v * M),
                                        e.groundColor
                                            .copy(t.groundColor)
                                            .multiplyScalar(v * M),
                                        (r.hemi[g] = e),
                                        g++;
                                }
                            }
                            p > 0 &&
                                (t.isWebGL2 ||
                                !0 === e.has("OES_texture_float_linear")
                                    ? ((r.rectAreaLTC1 = Ao.LTC_FLOAT_1),
                                      (r.rectAreaLTC2 = Ao.LTC_FLOAT_2))
                                    : !0 ===
                                      e.has("OES_texture_half_float_linear")
                                    ? ((r.rectAreaLTC1 = Ao.LTC_HALF_1),
                                      (r.rectAreaLTC2 = Ao.LTC_HALF_2))
                                    : console.error(
                                          "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                                      )),
                                (r.ambient[0] = o),
                                (r.ambient[1] = c),
                                (r.ambient[2] = l);
                            const v = r.hash;
                            (v.directionalLength === h &&
                                v.pointLength === u &&
                                v.spotLength === d &&
                                v.rectAreaLength === p &&
                                v.hemiLength === g &&
                                v.numDirectionalShadows === m &&
                                v.numPointShadows === f &&
                                v.numSpotShadows === _) ||
                                ((r.directional.length = h),
                                (r.spot.length = d),
                                (r.rectArea.length = p),
                                (r.point.length = u),
                                (r.hemi.length = g),
                                (r.directionalShadow.length = m),
                                (r.directionalShadowMap.length = m),
                                (r.pointShadow.length = f),
                                (r.pointShadowMap.length = f),
                                (r.spotShadow.length = _),
                                (r.spotShadowMap.length = _),
                                (r.directionalShadowMatrix.length = m),
                                (r.pointShadowMatrix.length = f),
                                (r.spotShadowMatrix.length = _),
                                (v.directionalLength = h),
                                (v.pointLength = u),
                                (v.spotLength = d),
                                (v.rectAreaLength = p),
                                (v.hemiLength = g),
                                (v.numDirectionalShadows = m),
                                (v.numPointShadows = f),
                                (v.numSpotShadows = _),
                                (r.version = ql++));
                        },
                        setupView: function (e, t) {
                            let i = 0,
                                n = 0,
                                c = 0,
                                l = 0,
                                h = 0;
                            const u = t.matrixWorldInverse;
                            for (let t = 0, d = e.length; t < d; t++) {
                                const d = e[t];
                                if (d.isDirectionalLight) {
                                    const e = r.directional[i];
                                    e.direction.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        s.setFromMatrixPosition(
                                            d.target.matrixWorld
                                        ),
                                        e.direction.sub(s),
                                        e.direction.transformDirection(u),
                                        i++;
                                } else if (d.isSpotLight) {
                                    const e = r.spot[c];
                                    e.position.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        e.position.applyMatrix4(u),
                                        e.direction.setFromMatrixPosition(
                                            d.matrixWorld
                                        ),
                                        s.setFromMatrixPosition(
                                            d.target.matrixWorld
                                        ),
                                        e.direction.sub(s),
                                        e.direction.transformDirection(u),
                                        c++;
                                } else if (d.isRectAreaLight) {
                                    const e = r.rectArea[l];
                                    e.position.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        e.position.applyMatrix4(u),
                                        o.identity(),
                                        a.copy(d.matrixWorld),
                                        a.premultiply(u),
                                        o.extractRotation(a),
                                        e.halfWidth.set(0.5 * d.width, 0, 0),
                                        e.halfHeight.set(0, 0.5 * d.height, 0),
                                        e.halfWidth.applyMatrix4(o),
                                        e.halfHeight.applyMatrix4(o),
                                        l++;
                                } else if (d.isPointLight) {
                                    const e = r.point[n];
                                    e.position.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        e.position.applyMatrix4(u),
                                        n++;
                                } else if (d.isHemisphereLight) {
                                    const e = r.hemi[h];
                                    e.direction.setFromMatrixPosition(
                                        d.matrixWorld
                                    ),
                                        e.direction.transformDirection(u),
                                        e.direction.normalize(),
                                        h++;
                                }
                            }
                        },
                        state: r,
                    };
                }
                function Zl(e, t) {
                    const i = new Ql(e, t),
                        n = [],
                        r = [];
                    return {
                        init: function () {
                            (n.length = 0), (r.length = 0);
                        },
                        state: { lightsArray: n, shadowsArray: r, lights: i },
                        setupLights: function (e) {
                            i.setup(n, e);
                        },
                        setupLightsView: function (e) {
                            i.setupView(n, e);
                        },
                        pushLight: function (e) {
                            n.push(e);
                        },
                        pushShadow: function (e) {
                            r.push(e);
                        },
                    };
                }
                function Xl(e, t) {
                    let i = new WeakMap();
                    return {
                        get: function (n, r = 0) {
                            let s;
                            return (
                                !1 === i.has(n)
                                    ? ((s = new Zl(e, t)), i.set(n, [s]))
                                    : r >= i.get(n).length
                                    ? ((s = new Zl(e, t)), i.get(n).push(s))
                                    : (s = i.get(n)[r]),
                                s
                            );
                        },
                        dispose: function () {
                            i = new WeakMap();
                        },
                    };
                }
                class Jl extends va {
                    constructor(e) {
                        super(),
                            (this.type = "MeshDepthMaterial"),
                            (this.depthPacking = 3200),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.fog = !1),
                            this.setValues(e);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.depthPacking = e.depthPacking),
                            (this.map = e.map),
                            (this.alphaMap = e.alphaMap),
                            (this.displacementMap = e.displacementMap),
                            (this.displacementScale = e.displacementScale),
                            (this.displacementBias = e.displacementBias),
                            (this.wireframe = e.wireframe),
                            (this.wireframeLinewidth = e.wireframeLinewidth),
                            this
                        );
                    }
                }
                Jl.prototype.isMeshDepthMaterial = !0;
                class Kl extends va {
                    constructor(e) {
                        super(),
                            (this.type = "MeshDistanceMaterial"),
                            (this.referencePosition = new rs()),
                            (this.nearDistance = 1),
                            (this.farDistance = 1e3),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.fog = !1),
                            this.setValues(e);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.referencePosition.copy(e.referencePosition),
                            (this.nearDistance = e.nearDistance),
                            (this.farDistance = e.farDistance),
                            (this.map = e.map),
                            (this.alphaMap = e.alphaMap),
                            (this.displacementMap = e.displacementMap),
                            (this.displacementScale = e.displacementScale),
                            (this.displacementBias = e.displacementBias),
                            this
                        );
                    }
                }
                Kl.prototype.isMeshDistanceMaterial = !0;
                const eh =
                        "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    th =
                        "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
                function ih(e, t, i) {
                    let n = new So();
                    const r = new Gr(),
                        s = new Gr(),
                        a = new es(),
                        o = new Jl({ depthPacking: Tr }),
                        c = new Kl(),
                        l = {},
                        h = i.maxTextureSize,
                        u = { 0: Qt, 1: Wt, 2: Zt },
                        d = new uo({
                            defines: { VSM_SAMPLES: 8 },
                            uniforms: {
                                shadow_pass: { value: null },
                                resolution: { value: new Gr() },
                                radius: { value: 4 },
                            },
                            vertexShader: eh,
                            fragmentShader: th,
                        }),
                        p = d.clone();
                    p.defines.HORIZONTAL_PASS = 1;
                    const g = new Ba();
                    g.setAttribute(
                        "position",
                        new Aa(
                            new Float32Array([
                                -1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5,
                            ]),
                            3
                        )
                    );
                    const m = new so(g, d),
                        f = this;
                    function _(i, n) {
                        const r = t.update(m);
                        d.defines.VSM_SAMPLES !== i.blurSamples &&
                            ((d.defines.VSM_SAMPLES = i.blurSamples),
                            (p.defines.VSM_SAMPLES = i.blurSamples),
                            (d.needsUpdate = !0),
                            (p.needsUpdate = !0)),
                            (d.uniforms.shadow_pass.value = i.map.texture),
                            (d.uniforms.resolution.value = i.mapSize),
                            (d.uniforms.radius.value = i.radius),
                            e.setRenderTarget(i.mapPass),
                            e.clear(),
                            e.renderBufferDirect(n, null, r, d, m, null),
                            (p.uniforms.shadow_pass.value = i.mapPass.texture),
                            (p.uniforms.resolution.value = i.mapSize),
                            (p.uniforms.radius.value = i.radius),
                            e.setRenderTarget(i.map),
                            e.clear(),
                            e.renderBufferDirect(n, null, r, p, m, null);
                    }
                    function M(t, i, n, r, s, a, h) {
                        let d = null;
                        const p =
                            !0 === r.isPointLight
                                ? t.customDistanceMaterial
                                : t.customDepthMaterial;
                        if (
                            ((d =
                                void 0 !== p
                                    ? p
                                    : !0 === r.isPointLight
                                    ? c
                                    : o),
                            (e.localClippingEnabled &&
                                !0 === n.clipShadows &&
                                0 !== n.clippingPlanes.length) ||
                                (n.displacementMap &&
                                    0 !== n.displacementScale) ||
                                (n.alphaMap && n.alphaTest > 0))
                        ) {
                            const e = d.uuid,
                                t = n.uuid;
                            let i = l[e];
                            void 0 === i && ((i = {}), (l[e] = i));
                            let r = i[t];
                            void 0 === r && ((r = d.clone()), (i[t] = r)),
                                (d = r);
                        }
                        return (
                            (d.visible = n.visible),
                            (d.wireframe = n.wireframe),
                            (d.side =
                                h === qt
                                    ? null !== n.shadowSide
                                        ? n.shadowSide
                                        : n.side
                                    : null !== n.shadowSide
                                    ? n.shadowSide
                                    : u[n.side]),
                            (d.alphaMap = n.alphaMap),
                            (d.alphaTest = n.alphaTest),
                            (d.clipShadows = n.clipShadows),
                            (d.clippingPlanes = n.clippingPlanes),
                            (d.clipIntersection = n.clipIntersection),
                            (d.displacementMap = n.displacementMap),
                            (d.displacementScale = n.displacementScale),
                            (d.displacementBias = n.displacementBias),
                            (d.wireframeLinewidth = n.wireframeLinewidth),
                            (d.linewidth = n.linewidth),
                            !0 === r.isPointLight &&
                                !0 === d.isMeshDistanceMaterial &&
                                (d.referencePosition.setFromMatrixPosition(
                                    r.matrixWorld
                                ),
                                (d.nearDistance = s),
                                (d.farDistance = a)),
                            d
                        );
                    }
                    function v(i, r, s, a, o) {
                        if (!1 === i.visible) return;
                        if (
                            i.layers.test(r.layers) &&
                            (i.isMesh || i.isLine || i.isPoints) &&
                            (i.castShadow || (i.receiveShadow && o === qt)) &&
                            (!i.frustumCulled || n.intersectsObject(i))
                        ) {
                            i.modelViewMatrix.multiplyMatrices(
                                s.matrixWorldInverse,
                                i.matrixWorld
                            );
                            const n = t.update(i),
                                r = i.material;
                            if (Array.isArray(r)) {
                                const t = n.groups;
                                for (let c = 0, l = t.length; c < l; c++) {
                                    const l = t[c],
                                        h = r[l.materialIndex];
                                    if (h && h.visible) {
                                        const t = M(
                                            i,
                                            0,
                                            h,
                                            a,
                                            s.near,
                                            s.far,
                                            o
                                        );
                                        e.renderBufferDirect(
                                            s,
                                            null,
                                            n,
                                            t,
                                            i,
                                            l
                                        );
                                    }
                                }
                            } else if (r.visible) {
                                const t = M(i, 0, r, a, s.near, s.far, o);
                                e.renderBufferDirect(s, null, n, t, i, null);
                            }
                        }
                        const c = i.children;
                        for (let e = 0, t = c.length; e < t; e++)
                            v(c[e], r, s, a, o);
                    }
                    (this.enabled = !1),
                        (this.autoUpdate = !0),
                        (this.needsUpdate = !1),
                        (this.type = Vt),
                        (this.render = function (t, i, o) {
                            if (!1 === f.enabled) return;
                            if (!1 === f.autoUpdate && !1 === f.needsUpdate)
                                return;
                            if (0 === t.length) return;
                            const c = e.getRenderTarget(),
                                l = e.getActiveCubeFace(),
                                u = e.getActiveMipmapLevel(),
                                d = e.state;
                            d.setBlending(Xt),
                                d.buffers.color.setClear(1, 1, 1, 1),
                                d.buffers.depth.setTest(!0),
                                d.setScissorTest(!1);
                            for (let c = 0, l = t.length; c < l; c++) {
                                const l = t[c],
                                    u = l.shadow;
                                if (void 0 === u) {
                                    console.warn(
                                        "THREE.WebGLShadowMap:",
                                        l,
                                        "has no shadow."
                                    );
                                    continue;
                                }
                                if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                                    continue;
                                r.copy(u.mapSize);
                                const p = u.getFrameExtents();
                                if (
                                    (r.multiply(p),
                                    s.copy(u.mapSize),
                                    (r.x > h || r.y > h) &&
                                        (r.x > h &&
                                            ((s.x = Math.floor(h / p.x)),
                                            (r.x = s.x * p.x),
                                            (u.mapSize.x = s.x)),
                                        r.y > h &&
                                            ((s.y = Math.floor(h / p.y)),
                                            (r.y = s.y * p.y),
                                            (u.mapSize.y = s.y))),
                                    null === u.map &&
                                        !u.isPointLightShadow &&
                                        this.type === qt)
                                ) {
                                    const e = {
                                        minFilter: Wi,
                                        magFilter: Wi,
                                        format: dn,
                                    };
                                    (u.map = new ts(r.x, r.y, e)),
                                        (u.map.texture.name =
                                            l.name + ".shadowMap"),
                                        (u.mapPass = new ts(r.x, r.y, e)),
                                        u.camera.updateProjectionMatrix();
                                }
                                if (null === u.map) {
                                    const e = {
                                        minFilter: Vi,
                                        magFilter: Vi,
                                        format: dn,
                                    };
                                    (u.map = new ts(r.x, r.y, e)),
                                        (u.map.texture.name =
                                            l.name + ".shadowMap"),
                                        u.camera.updateProjectionMatrix();
                                }
                                e.setRenderTarget(u.map), e.clear();
                                const g = u.getViewportCount();
                                for (let e = 0; e < g; e++) {
                                    const t = u.getViewport(e);
                                    a.set(
                                        s.x * t.x,
                                        s.y * t.y,
                                        s.x * t.z,
                                        s.y * t.w
                                    ),
                                        d.viewport(a),
                                        u.updateMatrices(l, e),
                                        (n = u.getFrustum()),
                                        v(i, o, u.camera, l, this.type);
                                }
                                u.isPointLightShadow ||
                                    this.type !== qt ||
                                    _(u, o),
                                    (u.needsUpdate = !1);
                            }
                            (f.needsUpdate = !1), e.setRenderTarget(c, l, u);
                        });
                }
                function nh(e, t, i) {
                    const n = i.isWebGL2,
                        r = new (function () {
                            let t = !1;
                            const i = new es();
                            let n = null;
                            const r = new es(0, 0, 0, 0);
                            return {
                                setMask: function (i) {
                                    n === i ||
                                        t ||
                                        (e.colorMask(i, i, i, i), (n = i));
                                },
                                setLocked: function (e) {
                                    t = e;
                                },
                                setClear: function (t, n, s, a, o) {
                                    !0 === o && ((t *= a), (n *= a), (s *= a)),
                                        i.set(t, n, s, a),
                                        !1 === r.equals(i) &&
                                            (e.clearColor(t, n, s, a),
                                            r.copy(i));
                                },
                                reset: function () {
                                    (t = !1), (n = null), r.set(-1, 0, 0, 0);
                                },
                            };
                        })(),
                        s = new (function () {
                            let t = !1,
                                i = null,
                                n = null,
                                r = null;
                            return {
                                setTest: function (e) {
                                    e ? R(2929) : P(2929);
                                },
                                setMask: function (n) {
                                    i === n || t || (e.depthMask(n), (i = n));
                                },
                                setFunc: function (t) {
                                    if (n !== t) {
                                        if (t)
                                            switch (t) {
                                                case vi:
                                                    e.depthFunc(512);
                                                    break;
                                                case yi:
                                                    e.depthFunc(519);
                                                    break;
                                                case xi:
                                                    e.depthFunc(513);
                                                    break;
                                                case bi:
                                                    e.depthFunc(515);
                                                    break;
                                                case wi:
                                                    e.depthFunc(514);
                                                    break;
                                                case Ti:
                                                    e.depthFunc(518);
                                                    break;
                                                case Si:
                                                    e.depthFunc(516);
                                                    break;
                                                case Ni:
                                                    e.depthFunc(517);
                                                    break;
                                                default:
                                                    e.depthFunc(515);
                                            }
                                        else e.depthFunc(515);
                                        n = t;
                                    }
                                },
                                setLocked: function (e) {
                                    t = e;
                                },
                                setClear: function (t) {
                                    r !== t && (e.clearDepth(t), (r = t));
                                },
                                reset: function () {
                                    (t = !1),
                                        (i = null),
                                        (n = null),
                                        (r = null);
                                },
                            };
                        })(),
                        a = new (function () {
                            let t = !1,
                                i = null,
                                n = null,
                                r = null,
                                s = null,
                                a = null,
                                o = null,
                                c = null,
                                l = null;
                            return {
                                setTest: function (e) {
                                    t || (e ? R(2960) : P(2960));
                                },
                                setMask: function (n) {
                                    i === n || t || (e.stencilMask(n), (i = n));
                                },
                                setFunc: function (t, i, a) {
                                    (n === t && r === i && s === a) ||
                                        (e.stencilFunc(t, i, a),
                                        (n = t),
                                        (r = i),
                                        (s = a));
                                },
                                setOp: function (t, i, n) {
                                    (a === t && o === i && c === n) ||
                                        (e.stencilOp(t, i, n),
                                        (a = t),
                                        (o = i),
                                        (c = n));
                                },
                                setLocked: function (e) {
                                    t = e;
                                },
                                setClear: function (t) {
                                    l !== t && (e.clearStencil(t), (l = t));
                                },
                                reset: function () {
                                    (t = !1),
                                        (i = null),
                                        (n = null),
                                        (r = null),
                                        (s = null),
                                        (a = null),
                                        (o = null),
                                        (c = null),
                                        (l = null);
                                },
                            };
                        })();
                    let o = {},
                        c = null,
                        l = {},
                        h = null,
                        u = !1,
                        d = null,
                        p = null,
                        g = null,
                        m = null,
                        f = null,
                        _ = null,
                        M = null,
                        v = !1,
                        y = null,
                        x = null,
                        b = null,
                        w = null,
                        T = null;
                    const S = e.getParameter(35661);
                    let N = !1,
                        D = 0;
                    const I = e.getParameter(7938);
                    -1 !== I.indexOf("WebGL")
                        ? ((D = parseFloat(/^WebGL (\d)/.exec(I)[1])),
                          (N = D >= 1))
                        : -1 !== I.indexOf("OpenGL ES") &&
                          ((D = parseFloat(/^OpenGL ES (\d)/.exec(I)[1])),
                          (N = D >= 2));
                    let C = null,
                        A = {};
                    const E = e.getParameter(3088),
                        L = e.getParameter(2978),
                        z = new es().fromArray(E),
                        j = new es().fromArray(L);
                    function O(t, i, n) {
                        const r = new Uint8Array(4),
                            s = e.createTexture();
                        e.bindTexture(t, s),
                            e.texParameteri(t, 10241, 9728),
                            e.texParameteri(t, 10240, 9728);
                        for (let t = 0; t < n; t++)
                            e.texImage2D(
                                i + t,
                                0,
                                6408,
                                1,
                                1,
                                0,
                                6408,
                                5121,
                                r
                            );
                        return s;
                    }
                    const k = {};
                    function R(t) {
                        !0 !== o[t] && (e.enable(t), (o[t] = !0));
                    }
                    function P(t) {
                        !1 !== o[t] && (e.disable(t), (o[t] = !1));
                    }
                    (k[3553] = O(3553, 3553, 1)),
                        (k[34067] = O(34067, 34069, 6)),
                        r.setClear(0, 0, 0, 1),
                        s.setClear(1),
                        a.setClear(0),
                        R(2929),
                        s.setFunc(bi),
                        F(!1),
                        H(Ht),
                        R(2884),
                        B(Xt);
                    const U = { [ni]: 32774, [ri]: 32778, [si]: 32779 };
                    if (n) (U[ai] = 32775), (U[oi] = 32776);
                    else {
                        const e = t.get("EXT_blend_minmax");
                        null !== e &&
                            ((U[ai] = e.MIN_EXT), (U[oi] = e.MAX_EXT));
                    }
                    const $ = {
                        [ci]: 0,
                        [li]: 1,
                        [hi]: 768,
                        [di]: 770,
                        [Mi]: 776,
                        [fi]: 774,
                        [gi]: 772,
                        [ui]: 769,
                        [pi]: 771,
                        [_i]: 775,
                        [mi]: 773,
                    };
                    function B(t, i, n, r, s, a, o, c) {
                        if (t !== Xt) {
                            if ((!1 === u && (R(3042), (u = !0)), t === ii))
                                (s = s || i),
                                    (a = a || n),
                                    (o = o || r),
                                    (i === p && s === f) ||
                                        (e.blendEquationSeparate(U[i], U[s]),
                                        (p = i),
                                        (f = s)),
                                    (n === g &&
                                        r === m &&
                                        a === _ &&
                                        o === M) ||
                                        (e.blendFuncSeparate(
                                            $[n],
                                            $[r],
                                            $[a],
                                            $[o]
                                        ),
                                        (g = n),
                                        (m = r),
                                        (_ = a),
                                        (M = o)),
                                    (d = t),
                                    (v = null);
                            else if (t !== d || c !== v) {
                                if (
                                    ((p === ni && f === ni) ||
                                        (e.blendEquation(32774),
                                        (p = ni),
                                        (f = ni)),
                                    c)
                                )
                                    switch (t) {
                                        case Jt:
                                            e.blendFuncSeparate(1, 771, 1, 771);
                                            break;
                                        case Kt:
                                            e.blendFunc(1, 1);
                                            break;
                                        case ei:
                                            e.blendFuncSeparate(0, 0, 769, 771);
                                            break;
                                        case ti:
                                            e.blendFuncSeparate(0, 768, 0, 770);
                                            break;
                                        default:
                                            console.error(
                                                "THREE.WebGLState: Invalid blending: ",
                                                t
                                            );
                                    }
                                else
                                    switch (t) {
                                        case Jt:
                                            e.blendFuncSeparate(
                                                770,
                                                771,
                                                1,
                                                771
                                            );
                                            break;
                                        case Kt:
                                            e.blendFunc(770, 1);
                                            break;
                                        case ei:
                                            e.blendFunc(0, 769);
                                            break;
                                        case ti:
                                            e.blendFunc(0, 768);
                                            break;
                                        default:
                                            console.error(
                                                "THREE.WebGLState: Invalid blending: ",
                                                t
                                            );
                                    }
                                (g = null),
                                    (m = null),
                                    (_ = null),
                                    (M = null),
                                    (d = t),
                                    (v = c);
                            }
                        } else !0 === u && (P(3042), (u = !1));
                    }
                    function F(t) {
                        y !== t &&
                            (t ? e.frontFace(2304) : e.frontFace(2305),
                            (y = t));
                    }
                    function H(t) {
                        t !== Ft
                            ? (R(2884),
                              t !== x &&
                                  (t === Ht
                                      ? e.cullFace(1029)
                                      : t === Gt
                                      ? e.cullFace(1028)
                                      : e.cullFace(1032)))
                            : P(2884),
                            (x = t);
                    }
                    function G(t, i, n) {
                        t
                            ? (R(32823),
                              (w === i && T === n) ||
                                  (e.polygonOffset(i, n), (w = i), (T = n)))
                            : P(32823);
                    }
                    function V(t) {
                        void 0 === t && (t = 33984 + S - 1),
                            C !== t && (e.activeTexture(t), (C = t));
                    }
                    return {
                        buffers: { color: r, depth: s, stencil: a },
                        enable: R,
                        disable: P,
                        bindFramebuffer: function (t, i) {
                            return (
                                null === i && null !== c && (i = c),
                                l[t] !== i &&
                                    (e.bindFramebuffer(t, i),
                                    (l[t] = i),
                                    n &&
                                        (36009 === t && (l[36160] = i),
                                        36160 === t && (l[36009] = i)),
                                    !0)
                            );
                        },
                        bindXRFramebuffer: function (t) {
                            t !== c && (e.bindFramebuffer(36160, t), (c = t));
                        },
                        useProgram: function (t) {
                            return h !== t && (e.useProgram(t), (h = t), !0);
                        },
                        setBlending: B,
                        setMaterial: function (e, t) {
                            e.side === Zt ? P(2884) : R(2884);
                            let i = e.side === Qt;
                            t && (i = !i),
                                F(i),
                                e.blending === Jt && !1 === e.transparent
                                    ? B(Xt)
                                    : B(
                                          e.blending,
                                          e.blendEquation,
                                          e.blendSrc,
                                          e.blendDst,
                                          e.blendEquationAlpha,
                                          e.blendSrcAlpha,
                                          e.blendDstAlpha,
                                          e.premultipliedAlpha
                                      ),
                                s.setFunc(e.depthFunc),
                                s.setTest(e.depthTest),
                                s.setMask(e.depthWrite),
                                r.setMask(e.colorWrite);
                            const n = e.stencilWrite;
                            a.setTest(n),
                                n &&
                                    (a.setMask(e.stencilWriteMask),
                                    a.setFunc(
                                        e.stencilFunc,
                                        e.stencilRef,
                                        e.stencilFuncMask
                                    ),
                                    a.setOp(
                                        e.stencilFail,
                                        e.stencilZFail,
                                        e.stencilZPass
                                    )),
                                G(
                                    e.polygonOffset,
                                    e.polygonOffsetFactor,
                                    e.polygonOffsetUnits
                                ),
                                !0 === e.alphaToCoverage ? R(32926) : P(32926);
                        },
                        setFlipSided: F,
                        setCullFace: H,
                        setLineWidth: function (t) {
                            t !== b && (N && e.lineWidth(t), (b = t));
                        },
                        setPolygonOffset: G,
                        setScissorTest: function (e) {
                            e ? R(3089) : P(3089);
                        },
                        activeTexture: V,
                        bindTexture: function (t, i) {
                            null === C && V();
                            let n = A[C];
                            void 0 === n &&
                                ((n = { type: void 0, texture: void 0 }),
                                (A[C] = n)),
                                (n.type === t && n.texture === i) ||
                                    (e.bindTexture(t, i || k[t]),
                                    (n.type = t),
                                    (n.texture = i));
                        },
                        unbindTexture: function () {
                            const t = A[C];
                            void 0 !== t &&
                                void 0 !== t.type &&
                                (e.bindTexture(t.type, null),
                                (t.type = void 0),
                                (t.texture = void 0));
                        },
                        compressedTexImage2D: function () {
                            try {
                                e.compressedTexImage2D.apply(e, arguments);
                            } catch (e) {
                                console.error("THREE.WebGLState:", e);
                            }
                        },
                        texImage2D: function () {
                            try {
                                e.texImage2D.apply(e, arguments);
                            } catch (e) {
                                console.error("THREE.WebGLState:", e);
                            }
                        },
                        texImage3D: function () {
                            try {
                                e.texImage3D.apply(e, arguments);
                            } catch (e) {
                                console.error("THREE.WebGLState:", e);
                            }
                        },
                        scissor: function (t) {
                            !1 === z.equals(t) &&
                                (e.scissor(t.x, t.y, t.z, t.w), z.copy(t));
                        },
                        viewport: function (t) {
                            !1 === j.equals(t) &&
                                (e.viewport(t.x, t.y, t.z, t.w), j.copy(t));
                        },
                        reset: function () {
                            e.disable(3042),
                                e.disable(2884),
                                e.disable(2929),
                                e.disable(32823),
                                e.disable(3089),
                                e.disable(2960),
                                e.disable(32926),
                                e.blendEquation(32774),
                                e.blendFunc(1, 0),
                                e.blendFuncSeparate(1, 0, 1, 0),
                                e.colorMask(!0, !0, !0, !0),
                                e.clearColor(0, 0, 0, 0),
                                e.depthMask(!0),
                                e.depthFunc(513),
                                e.clearDepth(1),
                                e.stencilMask(4294967295),
                                e.stencilFunc(519, 0, 4294967295),
                                e.stencilOp(7680, 7680, 7680),
                                e.clearStencil(0),
                                e.cullFace(1029),
                                e.frontFace(2305),
                                e.polygonOffset(0, 0),
                                e.activeTexture(33984),
                                e.bindFramebuffer(36160, null),
                                !0 === n &&
                                    (e.bindFramebuffer(36009, null),
                                    e.bindFramebuffer(36008, null)),
                                e.useProgram(null),
                                e.lineWidth(1),
                                e.scissor(
                                    0,
                                    0,
                                    e.canvas.width,
                                    e.canvas.height
                                ),
                                e.viewport(
                                    0,
                                    0,
                                    e.canvas.width,
                                    e.canvas.height
                                ),
                                (o = {}),
                                (C = null),
                                (A = {}),
                                (c = null),
                                (l = {}),
                                (h = null),
                                (u = !1),
                                (d = null),
                                (p = null),
                                (g = null),
                                (m = null),
                                (f = null),
                                (_ = null),
                                (M = null),
                                (v = !1),
                                (y = null),
                                (x = null),
                                (b = null),
                                (w = null),
                                (T = null),
                                z.set(0, 0, e.canvas.width, e.canvas.height),
                                j.set(0, 0, e.canvas.width, e.canvas.height),
                                r.reset(),
                                s.reset(),
                                a.reset();
                        },
                    };
                }
                function rh(e, t, i, n, r, s, a) {
                    const o = r.isWebGL2,
                        c = r.maxTextures,
                        l = r.maxCubemapSize,
                        h = r.maxTextureSize,
                        u = r.maxSamples,
                        d = new WeakMap();
                    let p,
                        g = !1;
                    try {
                        g =
                            "undefined" != typeof OffscreenCanvas &&
                            null !== new OffscreenCanvas(1, 1).getContext("2d");
                    } catch (e) {}
                    function m(e, t) {
                        return g ? new OffscreenCanvas(e, t) : qr("canvas");
                    }
                    function f(e, t, i, n) {
                        let r = 1;
                        if (
                            ((e.width > n || e.height > n) &&
                                (r = n / Math.max(e.width, e.height)),
                            r < 1 || !0 === t)
                        ) {
                            if (
                                ("undefined" != typeof HTMLImageElement &&
                                    e instanceof HTMLImageElement) ||
                                ("undefined" != typeof HTMLCanvasElement &&
                                    e instanceof HTMLCanvasElement) ||
                                ("undefined" != typeof ImageBitmap &&
                                    e instanceof ImageBitmap)
                            ) {
                                const n = t ? Fr : Math.floor,
                                    s = n(r * e.width),
                                    a = n(r * e.height);
                                void 0 === p && (p = m(s, a));
                                const o = i ? m(s, a) : p;
                                return (
                                    (o.width = s),
                                    (o.height = a),
                                    o.getContext("2d").drawImage(e, 0, 0, s, a),
                                    console.warn(
                                        "THREE.WebGLRenderer: Texture has been resized from (" +
                                            e.width +
                                            "x" +
                                            e.height +
                                            ") to (" +
                                            s +
                                            "x" +
                                            a +
                                            ")."
                                    ),
                                    o
                                );
                            }
                            return (
                                "data" in e &&
                                    console.warn(
                                        "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                                            e.width +
                                            "x" +
                                            e.height +
                                            ")."
                                    ),
                                e
                            );
                        }
                        return e;
                    }
                    function _(e) {
                        return Br(e.width) && Br(e.height);
                    }
                    function M(e, t) {
                        return (
                            e.generateMipmaps &&
                            t &&
                            e.minFilter !== Vi &&
                            e.minFilter !== Wi
                        );
                    }
                    function v(t, i, r, s, a = 1) {
                        e.generateMipmap(t),
                            (n.get(i).__maxMipLevel = Math.log2(
                                Math.max(r, s, a)
                            ));
                    }
                    function y(i, n, r, s) {
                        if (!1 === o) return n;
                        if (null !== i) {
                            if (void 0 !== e[i]) return e[i];
                            console.warn(
                                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                                    i +
                                    "'"
                            );
                        }
                        let a = n;
                        return (
                            6403 === n &&
                                (5126 === r && (a = 33326),
                                5131 === r && (a = 33325),
                                5121 === r && (a = 33321)),
                            6407 === n &&
                                (5126 === r && (a = 34837),
                                5131 === r && (a = 34843),
                                5121 === r && (a = 32849)),
                            6408 === n &&
                                (5126 === r && (a = 34836),
                                5131 === r && (a = 34842),
                                5121 === r && (a = s === _r ? 35907 : 32856)),
                            (33325 !== a &&
                                33326 !== a &&
                                34842 !== a &&
                                34836 !== a) ||
                                t.get("EXT_color_buffer_float"),
                            a
                        );
                    }
                    function x(e) {
                        return e === Vi || e === Yi || e === qi ? 9728 : 9729;
                    }
                    function b(t) {
                        const i = t.target;
                        i.removeEventListener("dispose", b),
                            (function (t) {
                                const i = n.get(t);
                                void 0 !== i.__webglInit &&
                                    (e.deleteTexture(i.__webglTexture),
                                    n.remove(t));
                            })(i),
                            i.isVideoTexture && d.delete(i),
                            a.memory.textures--;
                    }
                    function w(t) {
                        const i = t.target;
                        i.removeEventListener("dispose", w),
                            (function (t) {
                                const i = t.texture,
                                    r = n.get(t),
                                    s = n.get(i);
                                if (t) {
                                    if (
                                        (void 0 !== s.__webglTexture &&
                                            (e.deleteTexture(s.__webglTexture),
                                            a.memory.textures--),
                                        t.depthTexture &&
                                            t.depthTexture.dispose(),
                                        t.isWebGLCubeRenderTarget)
                                    )
                                        for (let t = 0; t < 6; t++)
                                            e.deleteFramebuffer(
                                                r.__webglFramebuffer[t]
                                            ),
                                                r.__webglDepthbuffer &&
                                                    e.deleteRenderbuffer(
                                                        r.__webglDepthbuffer[t]
                                                    );
                                    else
                                        e.deleteFramebuffer(
                                            r.__webglFramebuffer
                                        ),
                                            r.__webglDepthbuffer &&
                                                e.deleteRenderbuffer(
                                                    r.__webglDepthbuffer
                                                ),
                                            r.__webglMultisampledFramebuffer &&
                                                e.deleteFramebuffer(
                                                    r.__webglMultisampledFramebuffer
                                                ),
                                            r.__webglColorRenderbuffer &&
                                                e.deleteRenderbuffer(
                                                    r.__webglColorRenderbuffer
                                                ),
                                            r.__webglDepthRenderbuffer &&
                                                e.deleteRenderbuffer(
                                                    r.__webglDepthRenderbuffer
                                                );
                                    if (t.isWebGLMultipleRenderTargets)
                                        for (
                                            let t = 0, r = i.length;
                                            t < r;
                                            t++
                                        ) {
                                            const r = n.get(i[t]);
                                            r.__webglTexture &&
                                                (e.deleteTexture(
                                                    r.__webglTexture
                                                ),
                                                a.memory.textures--),
                                                n.remove(i[t]);
                                        }
                                    n.remove(i), n.remove(t);
                                }
                            })(i);
                    }
                    let T = 0;
                    function S(e, t) {
                        const r = n.get(e);
                        if (
                            (e.isVideoTexture &&
                                (function (e) {
                                    const t = a.render.frame;
                                    d.get(e) !== t && (d.set(e, t), e.update());
                                })(e),
                            e.version > 0 && r.__version !== e.version)
                        ) {
                            const i = e.image;
                            if (void 0 === i)
                                console.warn(
                                    "THREE.WebGLRenderer: Texture marked for update but image is undefined"
                                );
                            else {
                                if (!1 !== i.complete) return void E(r, e, t);
                                console.warn(
                                    "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                                );
                            }
                        }
                        i.activeTexture(33984 + t),
                            i.bindTexture(3553, r.__webglTexture);
                    }
                    function N(t, r) {
                        const a = n.get(t);
                        t.version > 0 && a.__version !== t.version
                            ? (function (t, n, r) {
                                  if (6 !== n.image.length) return;
                                  A(t, n),
                                      i.activeTexture(33984 + r),
                                      i.bindTexture(34067, t.__webglTexture),
                                      e.pixelStorei(37440, n.flipY),
                                      e.pixelStorei(37441, n.premultiplyAlpha),
                                      e.pixelStorei(3317, n.unpackAlignment),
                                      e.pixelStorei(37443, 0);
                                  const a =
                                          n &&
                                          (n.isCompressedTexture ||
                                              n.image[0].isCompressedTexture),
                                      c =
                                          n.image[0] &&
                                          n.image[0].isDataTexture,
                                      h = [];
                                  for (let e = 0; e < 6; e++)
                                      h[e] =
                                          a || c
                                              ? c
                                                  ? n.image[e].image
                                                  : n.image[e]
                                              : f(n.image[e], !1, !0, l);
                                  const u = h[0],
                                      d = _(u) || o,
                                      p = s.convert(n.format),
                                      g = s.convert(n.type),
                                      m = y(n.internalFormat, p, g, n.encoding);
                                  let x;
                                  if ((C(34067, n, d), a)) {
                                      for (let e = 0; e < 6; e++) {
                                          x = h[e].mipmaps;
                                          for (let t = 0; t < x.length; t++) {
                                              const r = x[t];
                                              n.format !== dn && n.format !== un
                                                  ? null !== p
                                                      ? i.compressedTexImage2D(
                                                            34069 + e,
                                                            t,
                                                            m,
                                                            r.width,
                                                            r.height,
                                                            0,
                                                            r.data
                                                        )
                                                      : console.warn(
                                                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                                        )
                                                  : i.texImage2D(
                                                        34069 + e,
                                                        t,
                                                        m,
                                                        r.width,
                                                        r.height,
                                                        0,
                                                        p,
                                                        g,
                                                        r.data
                                                    );
                                          }
                                      }
                                      t.__maxMipLevel = x.length - 1;
                                  } else {
                                      x = n.mipmaps;
                                      for (let e = 0; e < 6; e++)
                                          if (c) {
                                              i.texImage2D(
                                                  34069 + e,
                                                  0,
                                                  m,
                                                  h[e].width,
                                                  h[e].height,
                                                  0,
                                                  p,
                                                  g,
                                                  h[e].data
                                              );
                                              for (
                                                  let t = 0;
                                                  t < x.length;
                                                  t++
                                              ) {
                                                  const n = x[t].image[e].image;
                                                  i.texImage2D(
                                                      34069 + e,
                                                      t + 1,
                                                      m,
                                                      n.width,
                                                      n.height,
                                                      0,
                                                      p,
                                                      g,
                                                      n.data
                                                  );
                                              }
                                          } else {
                                              i.texImage2D(
                                                  34069 + e,
                                                  0,
                                                  m,
                                                  p,
                                                  g,
                                                  h[e]
                                              );
                                              for (
                                                  let t = 0;
                                                  t < x.length;
                                                  t++
                                              ) {
                                                  const n = x[t];
                                                  i.texImage2D(
                                                      34069 + e,
                                                      t + 1,
                                                      m,
                                                      p,
                                                      g,
                                                      n.image[e]
                                                  );
                                              }
                                          }
                                      t.__maxMipLevel = x.length;
                                  }
                                  M(n, d) && v(34067, n, u.width, u.height),
                                      (t.__version = n.version),
                                      n.onUpdate && n.onUpdate(n);
                              })(a, t, r)
                            : (i.activeTexture(33984 + r),
                              i.bindTexture(34067, a.__webglTexture));
                    }
                    const D = { [Fi]: 10497, [Hi]: 33071, [Gi]: 33648 },
                        I = {
                            [Vi]: 9728,
                            [Yi]: 9984,
                            [qi]: 9986,
                            [Wi]: 9729,
                            [Qi]: 9985,
                            [Zi]: 9987,
                        };
                    function C(i, s, a) {
                        if (
                            (a
                                ? (e.texParameteri(i, 10242, D[s.wrapS]),
                                  e.texParameteri(i, 10243, D[s.wrapT]),
                                  (32879 !== i && 35866 !== i) ||
                                      e.texParameteri(i, 32882, D[s.wrapR]),
                                  e.texParameteri(i, 10240, I[s.magFilter]),
                                  e.texParameteri(i, 10241, I[s.minFilter]))
                                : (e.texParameteri(i, 10242, 33071),
                                  e.texParameteri(i, 10243, 33071),
                                  (32879 !== i && 35866 !== i) ||
                                      e.texParameteri(i, 32882, 33071),
                                  (s.wrapS === Hi && s.wrapT === Hi) ||
                                      console.warn(
                                          "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                                      ),
                                  e.texParameteri(i, 10240, x(s.magFilter)),
                                  e.texParameteri(i, 10241, x(s.minFilter)),
                                  s.minFilter !== Vi &&
                                      s.minFilter !== Wi &&
                                      console.warn(
                                          "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                                      )),
                            !0 === t.has("EXT_texture_filter_anisotropic"))
                        ) {
                            const a = t.get("EXT_texture_filter_anisotropic");
                            if (
                                s.type === rn &&
                                !1 === t.has("OES_texture_float_linear")
                            )
                                return;
                            if (
                                !1 === o &&
                                s.type === sn &&
                                !1 === t.has("OES_texture_half_float_linear")
                            )
                                return;
                            (s.anisotropy > 1 ||
                                n.get(s).__currentAnisotropy) &&
                                (e.texParameterf(
                                    i,
                                    a.TEXTURE_MAX_ANISOTROPY_EXT,
                                    Math.min(s.anisotropy, r.getMaxAnisotropy())
                                ),
                                (n.get(s).__currentAnisotropy = s.anisotropy));
                        }
                    }
                    function A(t, i) {
                        void 0 === t.__webglInit &&
                            ((t.__webglInit = !0),
                            i.addEventListener("dispose", b),
                            (t.__webglTexture = e.createTexture()),
                            a.memory.textures++);
                    }
                    function E(t, n, r) {
                        let a = 3553;
                        n.isDataTexture2DArray && (a = 35866),
                            n.isDataTexture3D && (a = 32879),
                            A(t, n),
                            i.activeTexture(33984 + r),
                            i.bindTexture(a, t.__webglTexture),
                            e.pixelStorei(37440, n.flipY),
                            e.pixelStorei(37441, n.premultiplyAlpha),
                            e.pixelStorei(3317, n.unpackAlignment),
                            e.pixelStorei(37443, 0);
                        const c =
                                (function (e) {
                                    return (
                                        !o &&
                                        (e.wrapS !== Hi ||
                                            e.wrapT !== Hi ||
                                            (e.minFilter !== Vi &&
                                                e.minFilter !== Wi))
                                    );
                                })(n) && !1 === _(n.image),
                            l = f(n.image, c, !1, h),
                            u = _(l) || o,
                            d = s.convert(n.format);
                        let p,
                            g = s.convert(n.type),
                            m = y(n.internalFormat, d, g, n.encoding);
                        C(a, n, u);
                        const x = n.mipmaps;
                        if (n.isDepthTexture)
                            (m = 6402),
                                o
                                    ? (m =
                                          n.type === rn
                                              ? 36012
                                              : n.type === nn
                                              ? 33190
                                              : n.type === ln
                                              ? 35056
                                              : 33189)
                                    : n.type === rn &&
                                      console.error(
                                          "WebGLRenderer: Floating point depth texture requires WebGL2."
                                      ),
                                n.format === fn &&
                                    6402 === m &&
                                    n.type !== en &&
                                    n.type !== nn &&
                                    (console.warn(
                                        "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                                    ),
                                    (n.type = en),
                                    (g = s.convert(n.type))),
                                n.format === _n &&
                                    6402 === m &&
                                    ((m = 34041),
                                    n.type !== ln &&
                                        (console.warn(
                                            "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                                        ),
                                        (n.type = ln),
                                        (g = s.convert(n.type)))),
                                i.texImage2D(
                                    3553,
                                    0,
                                    m,
                                    l.width,
                                    l.height,
                                    0,
                                    d,
                                    g,
                                    null
                                );
                        else if (n.isDataTexture)
                            if (x.length > 0 && u) {
                                for (let e = 0, t = x.length; e < t; e++)
                                    (p = x[e]),
                                        i.texImage2D(
                                            3553,
                                            e,
                                            m,
                                            p.width,
                                            p.height,
                                            0,
                                            d,
                                            g,
                                            p.data
                                        );
                                (n.generateMipmaps = !1),
                                    (t.__maxMipLevel = x.length - 1);
                            } else
                                i.texImage2D(
                                    3553,
                                    0,
                                    m,
                                    l.width,
                                    l.height,
                                    0,
                                    d,
                                    g,
                                    l.data
                                ),
                                    (t.__maxMipLevel = 0);
                        else if (n.isCompressedTexture) {
                            for (let e = 0, t = x.length; e < t; e++)
                                (p = x[e]),
                                    n.format !== dn && n.format !== un
                                        ? null !== d
                                            ? i.compressedTexImage2D(
                                                  3553,
                                                  e,
                                                  m,
                                                  p.width,
                                                  p.height,
                                                  0,
                                                  p.data
                                              )
                                            : console.warn(
                                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                                              )
                                        : i.texImage2D(
                                              3553,
                                              e,
                                              m,
                                              p.width,
                                              p.height,
                                              0,
                                              d,
                                              g,
                                              p.data
                                          );
                            t.__maxMipLevel = x.length - 1;
                        } else if (n.isDataTexture2DArray)
                            i.texImage3D(
                                35866,
                                0,
                                m,
                                l.width,
                                l.height,
                                l.depth,
                                0,
                                d,
                                g,
                                l.data
                            ),
                                (t.__maxMipLevel = 0);
                        else if (n.isDataTexture3D)
                            i.texImage3D(
                                32879,
                                0,
                                m,
                                l.width,
                                l.height,
                                l.depth,
                                0,
                                d,
                                g,
                                l.data
                            ),
                                (t.__maxMipLevel = 0);
                        else if (x.length > 0 && u) {
                            for (let e = 0, t = x.length; e < t; e++)
                                (p = x[e]), i.texImage2D(3553, e, m, d, g, p);
                            (n.generateMipmaps = !1),
                                (t.__maxMipLevel = x.length - 1);
                        } else
                            i.texImage2D(3553, 0, m, d, g, l),
                                (t.__maxMipLevel = 0);
                        M(n, u) && v(a, n, l.width, l.height),
                            (t.__version = n.version),
                            n.onUpdate && n.onUpdate(n);
                    }
                    function L(t, r, a, o, c) {
                        const l = s.convert(a.format),
                            h = s.convert(a.type),
                            u = y(a.internalFormat, l, h, a.encoding);
                        32879 === c || 35866 === c
                            ? i.texImage3D(
                                  c,
                                  0,
                                  u,
                                  r.width,
                                  r.height,
                                  r.depth,
                                  0,
                                  l,
                                  h,
                                  null
                              )
                            : i.texImage2D(
                                  c,
                                  0,
                                  u,
                                  r.width,
                                  r.height,
                                  0,
                                  l,
                                  h,
                                  null
                              ),
                            i.bindFramebuffer(36160, t),
                            e.framebufferTexture2D(
                                36160,
                                o,
                                c,
                                n.get(a).__webglTexture,
                                0
                            ),
                            i.bindFramebuffer(36160, null);
                    }
                    function z(t, i, n) {
                        if (
                            (e.bindRenderbuffer(36161, t),
                            i.depthBuffer && !i.stencilBuffer)
                        ) {
                            let r = 33189;
                            if (n) {
                                const t = i.depthTexture;
                                t &&
                                    t.isDepthTexture &&
                                    (t.type === rn
                                        ? (r = 36012)
                                        : t.type === nn && (r = 33190));
                                const n = j(i);
                                e.renderbufferStorageMultisample(
                                    36161,
                                    n,
                                    r,
                                    i.width,
                                    i.height
                                );
                            } else
                                e.renderbufferStorage(
                                    36161,
                                    r,
                                    i.width,
                                    i.height
                                );
                            e.framebufferRenderbuffer(36160, 36096, 36161, t);
                        } else if (i.depthBuffer && i.stencilBuffer) {
                            if (n) {
                                const t = j(i);
                                e.renderbufferStorageMultisample(
                                    36161,
                                    t,
                                    35056,
                                    i.width,
                                    i.height
                                );
                            } else
                                e.renderbufferStorage(
                                    36161,
                                    34041,
                                    i.width,
                                    i.height
                                );
                            e.framebufferRenderbuffer(36160, 33306, 36161, t);
                        } else {
                            const t =
                                    !0 === i.isWebGLMultipleRenderTargets
                                        ? i.texture[0]
                                        : i.texture,
                                r = s.convert(t.format),
                                a = s.convert(t.type),
                                o = y(t.internalFormat, r, a, t.encoding);
                            if (n) {
                                const t = j(i);
                                e.renderbufferStorageMultisample(
                                    36161,
                                    t,
                                    o,
                                    i.width,
                                    i.height
                                );
                            } else
                                e.renderbufferStorage(
                                    36161,
                                    o,
                                    i.width,
                                    i.height
                                );
                        }
                        e.bindRenderbuffer(36161, null);
                    }
                    function j(e) {
                        return o && e.isWebGLMultisampleRenderTarget
                            ? Math.min(u, e.samples)
                            : 0;
                    }
                    let O = !1,
                        k = !1;
                    (this.allocateTextureUnit = function () {
                        const e = T;
                        return (
                            e >= c &&
                                console.warn(
                                    "THREE.WebGLTextures: Trying to use " +
                                        e +
                                        " texture units while this GPU supports only " +
                                        c
                                ),
                            (T += 1),
                            e
                        );
                    }),
                        (this.resetTextureUnits = function () {
                            T = 0;
                        }),
                        (this.setTexture2D = S),
                        (this.setTexture2DArray = function (e, t) {
                            const r = n.get(e);
                            e.version > 0 && r.__version !== e.version
                                ? E(r, e, t)
                                : (i.activeTexture(33984 + t),
                                  i.bindTexture(35866, r.__webglTexture));
                        }),
                        (this.setTexture3D = function (e, t) {
                            const r = n.get(e);
                            e.version > 0 && r.__version !== e.version
                                ? E(r, e, t)
                                : (i.activeTexture(33984 + t),
                                  i.bindTexture(32879, r.__webglTexture));
                        }),
                        (this.setTextureCube = N),
                        (this.setupRenderTarget = function (t) {
                            const c = t.texture,
                                l = n.get(t),
                                h = n.get(c);
                            t.addEventListener("dispose", w),
                                !0 !== t.isWebGLMultipleRenderTargets &&
                                    ((h.__webglTexture = e.createTexture()),
                                    (h.__version = c.version),
                                    a.memory.textures++);
                            const u = !0 === t.isWebGLCubeRenderTarget,
                                d = !0 === t.isWebGLMultipleRenderTargets,
                                p = !0 === t.isWebGLMultisampleRenderTarget,
                                g = c.isDataTexture3D || c.isDataTexture2DArray,
                                m = _(t) || o;
                            if (
                                (!o ||
                                    c.format !== un ||
                                    (c.type !== rn && c.type !== sn) ||
                                    ((c.format = dn),
                                    console.warn(
                                        "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
                                    )),
                                u)
                            ) {
                                l.__webglFramebuffer = [];
                                for (let t = 0; t < 6; t++)
                                    l.__webglFramebuffer[t] =
                                        e.createFramebuffer();
                            } else if (
                                ((l.__webglFramebuffer = e.createFramebuffer()),
                                d)
                            )
                                if (r.drawBuffers) {
                                    const i = t.texture;
                                    for (let t = 0, r = i.length; t < r; t++) {
                                        const r = n.get(i[t]);
                                        void 0 === r.__webglTexture &&
                                            ((r.__webglTexture =
                                                e.createTexture()),
                                            a.memory.textures++);
                                    }
                                } else
                                    console.warn(
                                        "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                                    );
                            else if (p)
                                if (o) {
                                    (l.__webglMultisampledFramebuffer =
                                        e.createFramebuffer()),
                                        (l.__webglColorRenderbuffer =
                                            e.createRenderbuffer()),
                                        e.bindRenderbuffer(
                                            36161,
                                            l.__webglColorRenderbuffer
                                        );
                                    const n = s.convert(c.format),
                                        r = s.convert(c.type),
                                        a = y(
                                            c.internalFormat,
                                            n,
                                            r,
                                            c.encoding
                                        ),
                                        o = j(t);
                                    e.renderbufferStorageMultisample(
                                        36161,
                                        o,
                                        a,
                                        t.width,
                                        t.height
                                    ),
                                        i.bindFramebuffer(
                                            36160,
                                            l.__webglMultisampledFramebuffer
                                        ),
                                        e.framebufferRenderbuffer(
                                            36160,
                                            36064,
                                            36161,
                                            l.__webglColorRenderbuffer
                                        ),
                                        e.bindRenderbuffer(36161, null),
                                        t.depthBuffer &&
                                            ((l.__webglDepthRenderbuffer =
                                                e.createRenderbuffer()),
                                            z(
                                                l.__webglDepthRenderbuffer,
                                                t,
                                                !0
                                            )),
                                        i.bindFramebuffer(36160, null);
                                } else
                                    console.warn(
                                        "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                                    );
                            if (u) {
                                i.bindTexture(34067, h.__webglTexture),
                                    C(34067, c, m);
                                for (let e = 0; e < 6; e++)
                                    L(
                                        l.__webglFramebuffer[e],
                                        t,
                                        c,
                                        36064,
                                        34069 + e
                                    );
                                M(c, m) && v(34067, c, t.width, t.height),
                                    i.unbindTexture();
                            } else if (d) {
                                const e = t.texture;
                                for (let r = 0, s = e.length; r < s; r++) {
                                    const s = e[r],
                                        a = n.get(s);
                                    i.bindTexture(3553, a.__webglTexture),
                                        C(3553, s, m),
                                        L(
                                            l.__webglFramebuffer,
                                            t,
                                            s,
                                            36064 + r,
                                            3553
                                        ),
                                        M(s, m) &&
                                            v(3553, s, t.width, t.height);
                                }
                                i.unbindTexture();
                            } else {
                                let e = 3553;
                                g &&
                                    (o
                                        ? (e = c.isDataTexture3D
                                              ? 32879
                                              : 35866)
                                        : console.warn(
                                              "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                                          )),
                                    i.bindTexture(e, h.__webglTexture),
                                    C(e, c, m),
                                    L(l.__webglFramebuffer, t, c, 36064, e),
                                    M(c, m) &&
                                        v(e, c, t.width, t.height, t.depth),
                                    i.unbindTexture();
                            }
                            t.depthBuffer &&
                                (function (t) {
                                    const r = n.get(t),
                                        s = !0 === t.isWebGLCubeRenderTarget;
                                    if (t.depthTexture) {
                                        if (s)
                                            throw new Error(
                                                "target.depthTexture not supported in Cube render targets"
                                            );
                                        !(function (t, r) {
                                            if (r && r.isWebGLCubeRenderTarget)
                                                throw new Error(
                                                    "Depth Texture with cube render targets is not supported"
                                                );
                                            if (
                                                (i.bindFramebuffer(36160, t),
                                                !r.depthTexture ||
                                                    !r.depthTexture
                                                        .isDepthTexture)
                                            )
                                                throw new Error(
                                                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                                                );
                                            (n.get(r.depthTexture)
                                                .__webglTexture &&
                                                r.depthTexture.image.width ===
                                                    r.width &&
                                                r.depthTexture.image.height ===
                                                    r.height) ||
                                                ((r.depthTexture.image.width =
                                                    r.width),
                                                (r.depthTexture.image.height =
                                                    r.height),
                                                (r.depthTexture.needsUpdate =
                                                    !0)),
                                                S(r.depthTexture, 0);
                                            const s = n.get(
                                                r.depthTexture
                                            ).__webglTexture;
                                            if (r.depthTexture.format === fn)
                                                e.framebufferTexture2D(
                                                    36160,
                                                    36096,
                                                    3553,
                                                    s,
                                                    0
                                                );
                                            else {
                                                if (
                                                    r.depthTexture.format !== _n
                                                )
                                                    throw new Error(
                                                        "Unknown depthTexture format"
                                                    );
                                                e.framebufferTexture2D(
                                                    36160,
                                                    33306,
                                                    3553,
                                                    s,
                                                    0
                                                );
                                            }
                                        })(r.__webglFramebuffer, t);
                                    } else if (s) {
                                        r.__webglDepthbuffer = [];
                                        for (let n = 0; n < 6; n++)
                                            i.bindFramebuffer(
                                                36160,
                                                r.__webglFramebuffer[n]
                                            ),
                                                (r.__webglDepthbuffer[n] =
                                                    e.createRenderbuffer()),
                                                z(
                                                    r.__webglDepthbuffer[n],
                                                    t,
                                                    !1
                                                );
                                    } else
                                        i.bindFramebuffer(
                                            36160,
                                            r.__webglFramebuffer
                                        ),
                                            (r.__webglDepthbuffer =
                                                e.createRenderbuffer()),
                                            z(r.__webglDepthbuffer, t, !1);
                                    i.bindFramebuffer(36160, null);
                                })(t);
                        }),
                        (this.updateRenderTargetMipmap = function (e) {
                            const t = _(e) || o,
                                r =
                                    !0 === e.isWebGLMultipleRenderTargets
                                        ? e.texture
                                        : [e.texture];
                            for (let s = 0, a = r.length; s < a; s++) {
                                const a = r[s];
                                if (M(a, t)) {
                                    const t = e.isWebGLCubeRenderTarget
                                            ? 34067
                                            : 3553,
                                        r = n.get(a).__webglTexture;
                                    i.bindTexture(t, r),
                                        v(t, a, e.width, e.height),
                                        i.unbindTexture();
                                }
                            }
                        }),
                        (this.updateMultisampleRenderTarget = function (t) {
                            if (t.isWebGLMultisampleRenderTarget)
                                if (o) {
                                    const r = t.width,
                                        s = t.height;
                                    let a = 16384;
                                    t.depthBuffer && (a |= 256),
                                        t.stencilBuffer && (a |= 1024);
                                    const o = n.get(t);
                                    i.bindFramebuffer(
                                        36008,
                                        o.__webglMultisampledFramebuffer
                                    ),
                                        i.bindFramebuffer(
                                            36009,
                                            o.__webglFramebuffer
                                        ),
                                        e.blitFramebuffer(
                                            0,
                                            0,
                                            r,
                                            s,
                                            0,
                                            0,
                                            r,
                                            s,
                                            a,
                                            9728
                                        ),
                                        i.bindFramebuffer(36008, null),
                                        i.bindFramebuffer(
                                            36009,
                                            o.__webglMultisampledFramebuffer
                                        );
                                } else
                                    console.warn(
                                        "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                                    );
                        }),
                        (this.safeSetTexture2D = function (e, t) {
                            e &&
                                e.isWebGLRenderTarget &&
                                (!1 === O &&
                                    (console.warn(
                                        "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                                    ),
                                    (O = !0)),
                                (e = e.texture)),
                                S(e, t);
                        }),
                        (this.safeSetTextureCube = function (e, t) {
                            e &&
                                e.isWebGLCubeRenderTarget &&
                                (!1 === k &&
                                    (console.warn(
                                        "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                                    ),
                                    (k = !0)),
                                (e = e.texture)),
                                N(e, t);
                        });
                }
                function sh(e, t, i) {
                    const n = i.isWebGL2;
                    return {
                        convert: function (e) {
                            let i;
                            if (e === Xi) return 5121;
                            if (e === an) return 32819;
                            if (e === on) return 32820;
                            if (e === cn) return 33635;
                            if (e === Ji) return 5120;
                            if (e === Ki) return 5122;
                            if (e === en) return 5123;
                            if (e === tn) return 5124;
                            if (e === nn) return 5125;
                            if (e === rn) return 5126;
                            if (e === sn)
                                return n
                                    ? 5131
                                    : ((i = t.get("OES_texture_half_float")),
                                      null !== i ? i.HALF_FLOAT_OES : null);
                            if (e === hn) return 6406;
                            if (e === un) return 6407;
                            if (e === dn) return 6408;
                            if (e === pn) return 6409;
                            if (e === gn) return 6410;
                            if (e === fn) return 6402;
                            if (e === _n) return 34041;
                            if (e === Mn) return 6403;
                            if (e === vn) return 36244;
                            if (e === yn) return 33319;
                            if (e === xn) return 33320;
                            if (e === bn) return 36248;
                            if (e === wn) return 36249;
                            if (e === Tn || e === Sn || e === Nn || e === Dn) {
                                if (
                                    ((i = t.get(
                                        "WEBGL_compressed_texture_s3tc"
                                    )),
                                    null === i)
                                )
                                    return null;
                                if (e === Tn)
                                    return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (e === Sn)
                                    return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (e === Nn)
                                    return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (e === Dn)
                                    return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                            }
                            if (e === In || e === Cn || e === An || e === En) {
                                if (
                                    ((i = t.get(
                                        "WEBGL_compressed_texture_pvrtc"
                                    )),
                                    null === i)
                                )
                                    return null;
                                if (e === In)
                                    return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (e === Cn)
                                    return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (e === An)
                                    return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (e === En)
                                    return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                            }
                            if (e === Ln)
                                return (
                                    (i = t.get(
                                        "WEBGL_compressed_texture_etc1"
                                    )),
                                    null !== i
                                        ? i.COMPRESSED_RGB_ETC1_WEBGL
                                        : null
                                );
                            if (
                                (e === zn || e === jn) &&
                                ((i = t.get("WEBGL_compressed_texture_etc")),
                                null !== i)
                            ) {
                                if (e === zn) return i.COMPRESSED_RGB8_ETC2;
                                if (e === jn)
                                    return i.COMPRESSED_RGBA8_ETC2_EAC;
                            }
                            return e === On ||
                                e === kn ||
                                e === Rn ||
                                e === Pn ||
                                e === Un ||
                                e === $n ||
                                e === Bn ||
                                e === Fn ||
                                e === Hn ||
                                e === Gn ||
                                e === Vn ||
                                e === Yn ||
                                e === qn ||
                                e === Wn ||
                                e === Zn ||
                                e === Xn ||
                                e === Jn ||
                                e === Kn ||
                                e === er ||
                                e === tr ||
                                e === ir ||
                                e === nr ||
                                e === rr ||
                                e === sr ||
                                e === ar ||
                                e === or ||
                                e === cr ||
                                e === lr
                                ? ((i = t.get("WEBGL_compressed_texture_astc")),
                                  null !== i ? e : null)
                                : e === Qn
                                ? ((i = t.get("EXT_texture_compression_bptc")),
                                  null !== i ? e : null)
                                : e === ln
                                ? n
                                    ? 34042
                                    : ((i = t.get("WEBGL_depth_texture")),
                                      null !== i
                                          ? i.UNSIGNED_INT_24_8_WEBGL
                                          : null)
                                : void 0;
                        },
                    };
                }
                class ah extends go {
                    constructor(e = []) {
                        super(), (this.cameras = e);
                    }
                }
                ah.prototype.isArrayCamera = !0;
                class oh extends aa {
                    constructor() {
                        super(), (this.type = "Group");
                    }
                }
                oh.prototype.isGroup = !0;
                const ch = { type: "move" };
                class lh {
                    constructor() {
                        (this._targetRay = null),
                            (this._grip = null),
                            (this._hand = null);
                    }
                    getHandSpace() {
                        return (
                            null === this._hand &&
                                ((this._hand = new oh()),
                                (this._hand.matrixAutoUpdate = !1),
                                (this._hand.visible = !1),
                                (this._hand.joints = {}),
                                (this._hand.inputState = { pinching: !1 })),
                            this._hand
                        );
                    }
                    getTargetRaySpace() {
                        return (
                            null === this._targetRay &&
                                ((this._targetRay = new oh()),
                                (this._targetRay.matrixAutoUpdate = !1),
                                (this._targetRay.visible = !1),
                                (this._targetRay.hasLinearVelocity = !1),
                                (this._targetRay.linearVelocity = new rs()),
                                (this._targetRay.hasAngularVelocity = !1),
                                (this._targetRay.angularVelocity = new rs())),
                            this._targetRay
                        );
                    }
                    getGripSpace() {
                        return (
                            null === this._grip &&
                                ((this._grip = new oh()),
                                (this._grip.matrixAutoUpdate = !1),
                                (this._grip.visible = !1),
                                (this._grip.hasLinearVelocity = !1),
                                (this._grip.linearVelocity = new rs()),
                                (this._grip.hasAngularVelocity = !1),
                                (this._grip.angularVelocity = new rs())),
                            this._grip
                        );
                    }
                    dispatchEvent(e) {
                        return (
                            null !== this._targetRay &&
                                this._targetRay.dispatchEvent(e),
                            null !== this._grip && this._grip.dispatchEvent(e),
                            null !== this._hand && this._hand.dispatchEvent(e),
                            this
                        );
                    }
                    disconnect(e) {
                        return (
                            this.dispatchEvent({
                                type: "disconnected",
                                data: e,
                            }),
                            null !== this._targetRay &&
                                (this._targetRay.visible = !1),
                            null !== this._grip && (this._grip.visible = !1),
                            null !== this._hand && (this._hand.visible = !1),
                            this
                        );
                    }
                    update(e, t, i) {
                        let n = null,
                            r = null,
                            s = null;
                        const a = this._targetRay,
                            o = this._grip,
                            c = this._hand;
                        if (
                            e &&
                            "visible-blurred" !== t.session.visibilityState
                        )
                            if (
                                (null !== a &&
                                    ((n = t.getPose(e.targetRaySpace, i)),
                                    null !== n &&
                                        (a.matrix.fromArray(n.transform.matrix),
                                        a.matrix.decompose(
                                            a.position,
                                            a.rotation,
                                            a.scale
                                        ),
                                        n.linearVelocity
                                            ? ((a.hasLinearVelocity = !0),
                                              a.linearVelocity.copy(
                                                  n.linearVelocity
                                              ))
                                            : (a.hasLinearVelocity = !1),
                                        n.angularVelocity
                                            ? ((a.hasAngularVelocity = !0),
                                              a.angularVelocity.copy(
                                                  n.angularVelocity
                                              ))
                                            : (a.hasAngularVelocity = !1),
                                        this.dispatchEvent(ch))),
                                c && e.hand)
                            ) {
                                s = !0;
                                for (const n of e.hand.values()) {
                                    const e = t.getJointPose(n, i);
                                    if (void 0 === c.joints[n.jointName]) {
                                        const e = new oh();
                                        (e.matrixAutoUpdate = !1),
                                            (e.visible = !1),
                                            (c.joints[n.jointName] = e),
                                            c.add(e);
                                    }
                                    const r = c.joints[n.jointName];
                                    null !== e &&
                                        (r.matrix.fromArray(e.transform.matrix),
                                        r.matrix.decompose(
                                            r.position,
                                            r.rotation,
                                            r.scale
                                        ),
                                        (r.jointRadius = e.radius)),
                                        (r.visible = null !== e);
                                }
                                const n = c.joints["index-finger-tip"],
                                    r = c.joints["thumb-tip"],
                                    a = n.position.distanceTo(r.position),
                                    o = 0.02,
                                    l = 0.005;
                                c.inputState.pinching && a > o + l
                                    ? ((c.inputState.pinching = !1),
                                      this.dispatchEvent({
                                          type: "pinchend",
                                          handedness: e.handedness,
                                          target: this,
                                      }))
                                    : !c.inputState.pinching &&
                                      a <= o - l &&
                                      ((c.inputState.pinching = !0),
                                      this.dispatchEvent({
                                          type: "pinchstart",
                                          handedness: e.handedness,
                                          target: this,
                                      }));
                            } else
                                null !== o &&
                                    e.gripSpace &&
                                    ((r = t.getPose(e.gripSpace, i)),
                                    null !== r &&
                                        (o.matrix.fromArray(r.transform.matrix),
                                        o.matrix.decompose(
                                            o.position,
                                            o.rotation,
                                            o.scale
                                        ),
                                        r.linearVelocity
                                            ? ((o.hasLinearVelocity = !0),
                                              o.linearVelocity.copy(
                                                  r.linearVelocity
                                              ))
                                            : (o.hasLinearVelocity = !1),
                                        r.angularVelocity
                                            ? ((o.hasAngularVelocity = !0),
                                              o.angularVelocity.copy(
                                                  r.angularVelocity
                                              ))
                                            : (o.hasAngularVelocity = !1)));
                        return (
                            null !== a && (a.visible = null !== n),
                            null !== o && (o.visible = null !== r),
                            null !== c && (c.visible = null !== s),
                            this
                        );
                    }
                }
                class hh extends Er {
                    constructor(e, t) {
                        super();
                        const i = this,
                            n = e.state;
                        let r = null,
                            s = 1,
                            a = null,
                            o = "local-floor",
                            c = null,
                            l = null,
                            h = null,
                            u = null,
                            d = null,
                            p = !1,
                            g = null,
                            m = null,
                            f = null,
                            _ = null,
                            M = null,
                            v = null;
                        const y = [],
                            x = new Map(),
                            b = new go();
                        b.layers.enable(1), (b.viewport = new es());
                        const w = new go();
                        w.layers.enable(2), (w.viewport = new es());
                        const T = [b, w],
                            S = new ah();
                        S.layers.enable(1), S.layers.enable(2);
                        let N = null,
                            D = null;
                        function I(e) {
                            const t = x.get(e.inputSource);
                            t &&
                                t.dispatchEvent({
                                    type: e.type,
                                    data: e.inputSource,
                                });
                        }
                        function C() {
                            x.forEach(function (e, t) {
                                e.disconnect(t);
                            }),
                                x.clear(),
                                (N = null),
                                (D = null),
                                n.bindXRFramebuffer(null),
                                e.setRenderTarget(e.getRenderTarget()),
                                h && t.deleteFramebuffer(h),
                                g && t.deleteFramebuffer(g),
                                m && t.deleteRenderbuffer(m),
                                f && t.deleteRenderbuffer(f),
                                (h = null),
                                (g = null),
                                (m = null),
                                (f = null),
                                (d = null),
                                (u = null),
                                (l = null),
                                (r = null),
                                O.stop(),
                                (i.isPresenting = !1),
                                i.dispatchEvent({ type: "sessionend" });
                        }
                        function A(e) {
                            const t = r.inputSources;
                            for (let e = 0; e < y.length; e++)
                                x.set(t[e], y[e]);
                            for (let t = 0; t < e.removed.length; t++) {
                                const i = e.removed[t],
                                    n = x.get(i);
                                n &&
                                    (n.dispatchEvent({
                                        type: "disconnected",
                                        data: i,
                                    }),
                                    x.delete(i));
                            }
                            for (let t = 0; t < e.added.length; t++) {
                                const i = e.added[t],
                                    n = x.get(i);
                                n &&
                                    n.dispatchEvent({
                                        type: "connected",
                                        data: i,
                                    });
                            }
                        }
                        (this.cameraAutoUpdate = !0),
                            (this.enabled = !1),
                            (this.isPresenting = !1),
                            (this.getController = function (e) {
                                let t = y[e];
                                return (
                                    void 0 === t &&
                                        ((t = new lh()), (y[e] = t)),
                                    t.getTargetRaySpace()
                                );
                            }),
                            (this.getControllerGrip = function (e) {
                                let t = y[e];
                                return (
                                    void 0 === t &&
                                        ((t = new lh()), (y[e] = t)),
                                    t.getGripSpace()
                                );
                            }),
                            (this.getHand = function (e) {
                                let t = y[e];
                                return (
                                    void 0 === t &&
                                        ((t = new lh()), (y[e] = t)),
                                    t.getHandSpace()
                                );
                            }),
                            (this.setFramebufferScaleFactor = function (e) {
                                (s = e),
                                    !0 === i.isPresenting &&
                                        console.warn(
                                            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                                        );
                            }),
                            (this.setReferenceSpaceType = function (e) {
                                (o = e),
                                    !0 === i.isPresenting &&
                                        console.warn(
                                            "THREE.WebXRManager: Cannot change reference space type while presenting."
                                        );
                            }),
                            (this.getReferenceSpace = function () {
                                return a;
                            }),
                            (this.getBaseLayer = function () {
                                return null !== u ? u : d;
                            }),
                            (this.getBinding = function () {
                                return l;
                            }),
                            (this.getFrame = function () {
                                return _;
                            }),
                            (this.getSession = function () {
                                return r;
                            }),
                            (this.setSession = async function (e) {
                                if (((r = e), null !== r)) {
                                    r.addEventListener("select", I),
                                        r.addEventListener("selectstart", I),
                                        r.addEventListener("selectend", I),
                                        r.addEventListener("squeeze", I),
                                        r.addEventListener("squeezestart", I),
                                        r.addEventListener("squeezeend", I),
                                        r.addEventListener("end", C),
                                        r.addEventListener(
                                            "inputsourceschange",
                                            A
                                        );
                                    const e = t.getContextAttributes();
                                    if (
                                        (!0 !== e.xrCompatible &&
                                            (await t.makeXRCompatible()),
                                        void 0 === r.renderState.layers)
                                    ) {
                                        const i = {
                                            antialias: e.antialias,
                                            alpha: e.alpha,
                                            depth: e.depth,
                                            stencil: e.stencil,
                                            framebufferScaleFactor: s,
                                        };
                                        (d = new XRWebGLLayer(r, t, i)),
                                            r.updateRenderState({
                                                baseLayer: d,
                                            });
                                    } else if (
                                        t instanceof WebGLRenderingContext
                                    ) {
                                        const i = {
                                            antialias: !0,
                                            alpha: e.alpha,
                                            depth: e.depth,
                                            stencil: e.stencil,
                                            framebufferScaleFactor: s,
                                        };
                                        (d = new XRWebGLLayer(r, t, i)),
                                            r.updateRenderState({
                                                layers: [d],
                                            });
                                    } else {
                                        p = e.antialias;
                                        let i = null;
                                        e.depth &&
                                            ((v = 256),
                                            e.stencil && (v |= 1024),
                                            (M = e.stencil ? 33306 : 36096),
                                            (i = e.stencil ? 35056 : 33190));
                                        const a = {
                                            colorFormat: e.alpha
                                                ? 32856
                                                : 32849,
                                            depthFormat: i,
                                            scaleFactor: s,
                                        };
                                        (l = new XRWebGLBinding(r, t)),
                                            (u = l.createProjectionLayer(a)),
                                            (h = t.createFramebuffer()),
                                            r.updateRenderState({
                                                layers: [u],
                                            }),
                                            p &&
                                                ((g = t.createFramebuffer()),
                                                (m = t.createRenderbuffer()),
                                                t.bindRenderbuffer(36161, m),
                                                t.renderbufferStorageMultisample(
                                                    36161,
                                                    4,
                                                    32856,
                                                    u.textureWidth,
                                                    u.textureHeight
                                                ),
                                                n.bindFramebuffer(36160, g),
                                                t.framebufferRenderbuffer(
                                                    36160,
                                                    36064,
                                                    36161,
                                                    m
                                                ),
                                                t.bindRenderbuffer(36161, null),
                                                null !== i &&
                                                    ((f =
                                                        t.createRenderbuffer()),
                                                    t.bindRenderbuffer(
                                                        36161,
                                                        f
                                                    ),
                                                    t.renderbufferStorageMultisample(
                                                        36161,
                                                        4,
                                                        i,
                                                        u.textureWidth,
                                                        u.textureHeight
                                                    ),
                                                    t.framebufferRenderbuffer(
                                                        36160,
                                                        M,
                                                        36161,
                                                        f
                                                    ),
                                                    t.bindRenderbuffer(
                                                        36161,
                                                        null
                                                    )),
                                                n.bindFramebuffer(36160, null));
                                    }
                                    (a = await r.requestReferenceSpace(o)),
                                        O.setContext(r),
                                        O.start(),
                                        (i.isPresenting = !0),
                                        i.dispatchEvent({
                                            type: "sessionstart",
                                        });
                                }
                            });
                        const E = new rs(),
                            L = new rs();
                        function z(e, t) {
                            null === t
                                ? e.matrixWorld.copy(e.matrix)
                                : e.matrixWorld.multiplyMatrices(
                                      t.matrixWorld,
                                      e.matrix
                                  ),
                                e.matrixWorldInverse
                                    .copy(e.matrixWorld)
                                    .invert();
                        }
                        (this.updateCamera = function (e) {
                            if (null === r) return;
                            (S.near = w.near = b.near = e.near),
                                (S.far = w.far = b.far = e.far),
                                (N === S.near && D === S.far) ||
                                    (r.updateRenderState({
                                        depthNear: S.near,
                                        depthFar: S.far,
                                    }),
                                    (N = S.near),
                                    (D = S.far));
                            const t = e.parent,
                                i = S.cameras;
                            z(S, t);
                            for (let e = 0; e < i.length; e++) z(i[e], t);
                            S.matrixWorld.decompose(
                                S.position,
                                S.quaternion,
                                S.scale
                            ),
                                e.position.copy(S.position),
                                e.quaternion.copy(S.quaternion),
                                e.scale.copy(S.scale),
                                e.matrix.copy(S.matrix),
                                e.matrixWorld.copy(S.matrixWorld);
                            const n = e.children;
                            for (let e = 0, t = n.length; e < t; e++)
                                n[e].updateMatrixWorld(!0);
                            2 === i.length
                                ? (function (e, t, i) {
                                      E.setFromMatrixPosition(t.matrixWorld),
                                          L.setFromMatrixPosition(
                                              i.matrixWorld
                                          );
                                      const n = E.distanceTo(L),
                                          r = t.projectionMatrix.elements,
                                          s = i.projectionMatrix.elements,
                                          a = r[14] / (r[10] - 1),
                                          o = r[14] / (r[10] + 1),
                                          c = (r[9] + 1) / r[5],
                                          l = (r[9] - 1) / r[5],
                                          h = (r[8] - 1) / r[0],
                                          u = (s[8] + 1) / s[0],
                                          d = a * h,
                                          p = a * u,
                                          g = n / (-h + u),
                                          m = g * -h;
                                      t.matrixWorld.decompose(
                                          e.position,
                                          e.quaternion,
                                          e.scale
                                      ),
                                          e.translateX(m),
                                          e.translateZ(g),
                                          e.matrixWorld.compose(
                                              e.position,
                                              e.quaternion,
                                              e.scale
                                          ),
                                          e.matrixWorldInverse
                                              .copy(e.matrixWorld)
                                              .invert();
                                      const f = a + g,
                                          _ = o + g,
                                          M = d - m,
                                          v = p + (n - m),
                                          y = ((c * o) / _) * f,
                                          x = ((l * o) / _) * f;
                                      e.projectionMatrix.makePerspective(
                                          M,
                                          v,
                                          y,
                                          x,
                                          f,
                                          _
                                      );
                                  })(S, b, w)
                                : S.projectionMatrix.copy(b.projectionMatrix);
                        }),
                            (this.getCamera = function () {
                                return S;
                            }),
                            (this.getFoveation = function () {
                                return null !== u
                                    ? u.fixedFoveation
                                    : null !== d
                                    ? d.fixedFoveation
                                    : void 0;
                            }),
                            (this.setFoveation = function (e) {
                                null !== u && (u.fixedFoveation = e),
                                    null !== d &&
                                        void 0 !== d.fixedFoveation &&
                                        (d.fixedFoveation = e);
                            });
                        let j = null;
                        const O = new No();
                        O.setAnimationLoop(function (e, i) {
                            if (
                                ((c = i.getViewerPose(a)), (_ = i), null !== c)
                            ) {
                                const e = c.views;
                                null !== d &&
                                    n.bindXRFramebuffer(d.framebuffer);
                                let i = !1;
                                e.length !== S.cameras.length &&
                                    ((S.cameras.length = 0), (i = !0));
                                for (let r = 0; r < e.length; r++) {
                                    const s = e[r];
                                    let a = null;
                                    if (null !== d) a = d.getViewport(s);
                                    else {
                                        const e = l.getViewSubImage(u, s);
                                        n.bindXRFramebuffer(h),
                                            void 0 !== e.depthStencilTexture &&
                                                t.framebufferTexture2D(
                                                    36160,
                                                    M,
                                                    3553,
                                                    e.depthStencilTexture,
                                                    0
                                                ),
                                            t.framebufferTexture2D(
                                                36160,
                                                36064,
                                                3553,
                                                e.colorTexture,
                                                0
                                            ),
                                            (a = e.viewport);
                                    }
                                    const o = T[r];
                                    o.matrix.fromArray(s.transform.matrix),
                                        o.projectionMatrix.fromArray(
                                            s.projectionMatrix
                                        ),
                                        o.viewport.set(
                                            a.x,
                                            a.y,
                                            a.width,
                                            a.height
                                        ),
                                        0 === r && S.matrix.copy(o.matrix),
                                        !0 === i && S.cameras.push(o);
                                }
                                p &&
                                    (n.bindXRFramebuffer(g),
                                    null !== v && t.clear(v));
                            }
                            const s = r.inputSources;
                            for (let e = 0; e < y.length; e++) {
                                const t = y[e],
                                    n = s[e];
                                t.update(n, i, a);
                            }
                            if ((j && j(e, i), p)) {
                                const e = u.textureWidth,
                                    i = u.textureHeight;
                                n.bindFramebuffer(36008, g),
                                    n.bindFramebuffer(36009, h),
                                    t.invalidateFramebuffer(36008, [M]),
                                    t.invalidateFramebuffer(36009, [M]),
                                    t.blitFramebuffer(
                                        0,
                                        0,
                                        e,
                                        i,
                                        0,
                                        0,
                                        e,
                                        i,
                                        16384,
                                        9728
                                    ),
                                    t.invalidateFramebuffer(36008, [36064]),
                                    n.bindFramebuffer(36008, null),
                                    n.bindFramebuffer(36009, null),
                                    n.bindFramebuffer(36160, g);
                            }
                            _ = null;
                        }),
                            (this.setAnimationLoop = function (e) {
                                j = e;
                            }),
                            (this.dispose = function () {});
                    }
                }
                function uh(e) {
                    function t(t, i) {
                        (t.opacity.value = i.opacity),
                            i.color && t.diffuse.value.copy(i.color),
                            i.emissive &&
                                t.emissive.value
                                    .copy(i.emissive)
                                    .multiplyScalar(i.emissiveIntensity),
                            i.map && (t.map.value = i.map),
                            i.alphaMap && (t.alphaMap.value = i.alphaMap),
                            i.specularMap &&
                                (t.specularMap.value = i.specularMap),
                            i.alphaTest > 0 &&
                                (t.alphaTest.value = i.alphaTest);
                        const n = e.get(i).envMap;
                        if (n) {
                            (t.envMap.value = n),
                                (t.flipEnvMap.value =
                                    n.isCubeTexture &&
                                    !1 === n.isRenderTargetTexture
                                        ? -1
                                        : 1),
                                (t.reflectivity.value = i.reflectivity),
                                (t.ior.value = i.ior),
                                (t.refractionRatio.value = i.refractionRatio);
                            const r = e.get(n).__maxMipLevel;
                            void 0 !== r && (t.maxMipLevel.value = r);
                        }
                        let r, s;
                        i.lightMap &&
                            ((t.lightMap.value = i.lightMap),
                            (t.lightMapIntensity.value = i.lightMapIntensity)),
                            i.aoMap &&
                                ((t.aoMap.value = i.aoMap),
                                (t.aoMapIntensity.value = i.aoMapIntensity)),
                            i.map
                                ? (r = i.map)
                                : i.specularMap
                                ? (r = i.specularMap)
                                : i.displacementMap
                                ? (r = i.displacementMap)
                                : i.normalMap
                                ? (r = i.normalMap)
                                : i.bumpMap
                                ? (r = i.bumpMap)
                                : i.roughnessMap
                                ? (r = i.roughnessMap)
                                : i.metalnessMap
                                ? (r = i.metalnessMap)
                                : i.alphaMap
                                ? (r = i.alphaMap)
                                : i.emissiveMap
                                ? (r = i.emissiveMap)
                                : i.clearcoatMap
                                ? (r = i.clearcoatMap)
                                : i.clearcoatNormalMap
                                ? (r = i.clearcoatNormalMap)
                                : i.clearcoatRoughnessMap
                                ? (r = i.clearcoatRoughnessMap)
                                : i.specularIntensityMap
                                ? (r = i.specularIntensityMap)
                                : i.specularColorMap
                                ? (r = i.specularColorMap)
                                : i.transmissionMap
                                ? (r = i.transmissionMap)
                                : i.thicknessMap
                                ? (r = i.thicknessMap)
                                : i.sheenColorMap
                                ? (r = i.sheenColorMap)
                                : i.sheenRoughnessMap &&
                                  (r = i.sheenRoughnessMap),
                            void 0 !== r &&
                                (r.isWebGLRenderTarget && (r = r.texture),
                                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                                t.uvTransform.value.copy(r.matrix)),
                            i.aoMap
                                ? (s = i.aoMap)
                                : i.lightMap && (s = i.lightMap),
                            void 0 !== s &&
                                (s.isWebGLRenderTarget && (s = s.texture),
                                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                                t.uv2Transform.value.copy(s.matrix));
                    }
                    function i(t, i) {
                        (t.roughness.value = i.roughness),
                            (t.metalness.value = i.metalness),
                            i.roughnessMap &&
                                (t.roughnessMap.value = i.roughnessMap),
                            i.metalnessMap &&
                                (t.metalnessMap.value = i.metalnessMap),
                            i.emissiveMap &&
                                (t.emissiveMap.value = i.emissiveMap),
                            i.bumpMap &&
                                ((t.bumpMap.value = i.bumpMap),
                                (t.bumpScale.value = i.bumpScale),
                                i.side === Qt && (t.bumpScale.value *= -1)),
                            i.normalMap &&
                                ((t.normalMap.value = i.normalMap),
                                t.normalScale.value.copy(i.normalScale),
                                i.side === Qt && t.normalScale.value.negate()),
                            i.displacementMap &&
                                ((t.displacementMap.value = i.displacementMap),
                                (t.displacementScale.value =
                                    i.displacementScale),
                                (t.displacementBias.value =
                                    i.displacementBias)),
                            e.get(i).envMap &&
                                (t.envMapIntensity.value = i.envMapIntensity);
                    }
                    return {
                        refreshFogUniforms: function (e, t) {
                            e.fogColor.value.copy(t.color),
                                t.isFog
                                    ? ((e.fogNear.value = t.near),
                                      (e.fogFar.value = t.far))
                                    : t.isFogExp2 &&
                                      (e.fogDensity.value = t.density);
                        },
                        refreshMaterialUniforms: function (e, n, r, s, a) {
                            n.isMeshBasicMaterial
                                ? t(e, n)
                                : n.isMeshLambertMaterial
                                ? (t(e, n),
                                  (function (e, t) {
                                      t.emissiveMap &&
                                          (e.emissiveMap.value = t.emissiveMap);
                                  })(e, n))
                                : n.isMeshToonMaterial
                                ? (t(e, n),
                                  (function (e, t) {
                                      t.gradientMap &&
                                          (e.gradientMap.value = t.gradientMap),
                                          t.emissiveMap &&
                                              (e.emissiveMap.value =
                                                  t.emissiveMap),
                                          t.bumpMap &&
                                              ((e.bumpMap.value = t.bumpMap),
                                              (e.bumpScale.value = t.bumpScale),
                                              t.side === Qt &&
                                                  (e.bumpScale.value *= -1)),
                                          t.normalMap &&
                                              ((e.normalMap.value =
                                                  t.normalMap),
                                              e.normalScale.value.copy(
                                                  t.normalScale
                                              ),
                                              t.side === Qt &&
                                                  e.normalScale.value.negate()),
                                          t.displacementMap &&
                                              ((e.displacementMap.value =
                                                  t.displacementMap),
                                              (e.displacementScale.value =
                                                  t.displacementScale),
                                              (e.displacementBias.value =
                                                  t.displacementBias));
                                  })(e, n))
                                : n.isMeshPhongMaterial
                                ? (t(e, n),
                                  (function (e, t) {
                                      e.specular.value.copy(t.specular),
                                          (e.shininess.value = Math.max(
                                              t.shininess,
                                              1e-4
                                          )),
                                          t.emissiveMap &&
                                              (e.emissiveMap.value =
                                                  t.emissiveMap),
                                          t.bumpMap &&
                                              ((e.bumpMap.value = t.bumpMap),
                                              (e.bumpScale.value = t.bumpScale),
                                              t.side === Qt &&
                                                  (e.bumpScale.value *= -1)),
                                          t.normalMap &&
                                              ((e.normalMap.value =
                                                  t.normalMap),
                                              e.normalScale.value.copy(
                                                  t.normalScale
                                              ),
                                              t.side === Qt &&
                                                  e.normalScale.value.negate()),
                                          t.displacementMap &&
                                              ((e.displacementMap.value =
                                                  t.displacementMap),
                                              (e.displacementScale.value =
                                                  t.displacementScale),
                                              (e.displacementBias.value =
                                                  t.displacementBias));
                                  })(e, n))
                                : n.isMeshStandardMaterial
                                ? (t(e, n),
                                  n.isMeshPhysicalMaterial
                                      ? (function (e, t, n) {
                                            i(e, t),
                                                (e.ior.value = t.ior),
                                                t.sheen > 0 &&
                                                    (e.sheenColor.value
                                                        .copy(t.sheenColor)
                                                        .multiplyScalar(
                                                            t.sheen
                                                        ),
                                                    (e.sheenRoughness.value =
                                                        t.sheenRoughness),
                                                    t.sheenColorMap &&
                                                        (e.sheenColorMap.value =
                                                            t.sheenColorMap),
                                                    t.sheenRoughnessMap &&
                                                        (e.sheenRoughnessMap.value =
                                                            t.sheenRoughnessMap)),
                                                t.clearcoat > 0 &&
                                                    ((e.clearcoat.value =
                                                        t.clearcoat),
                                                    (e.clearcoatRoughness.value =
                                                        t.clearcoatRoughness),
                                                    t.clearcoatMap &&
                                                        (e.clearcoatMap.value =
                                                            t.clearcoatMap),
                                                    t.clearcoatRoughnessMap &&
                                                        (e.clearcoatRoughnessMap.value =
                                                            t.clearcoatRoughnessMap),
                                                    t.clearcoatNormalMap &&
                                                        (e.clearcoatNormalScale.value.copy(
                                                            t.clearcoatNormalScale
                                                        ),
                                                        (e.clearcoatNormalMap.value =
                                                            t.clearcoatNormalMap),
                                                        t.side === Qt &&
                                                            e.clearcoatNormalScale.value.negate())),
                                                t.transmission > 0 &&
                                                    ((e.transmission.value =
                                                        t.transmission),
                                                    (e.transmissionSamplerMap.value =
                                                        n.texture),
                                                    e.transmissionSamplerSize.value.set(
                                                        n.width,
                                                        n.height
                                                    ),
                                                    t.transmissionMap &&
                                                        (e.transmissionMap.value =
                                                            t.transmissionMap),
                                                    (e.thickness.value =
                                                        t.thickness),
                                                    t.thicknessMap &&
                                                        (e.thicknessMap.value =
                                                            t.thicknessMap),
                                                    (e.attenuationDistance.value =
                                                        t.attenuationDistance),
                                                    e.attenuationColor.value.copy(
                                                        t.attenuationColor
                                                    )),
                                                (e.specularIntensity.value =
                                                    t.specularIntensity),
                                                e.specularColor.value.copy(
                                                    t.specularColor
                                                ),
                                                t.specularIntensityMap &&
                                                    (e.specularIntensityMap.value =
                                                        t.specularIntensityMap),
                                                t.specularColorMap &&
                                                    (e.specularColorMap.value =
                                                        t.specularColorMap);
                                        })(e, n, a)
                                      : i(e, n))
                                : n.isMeshMatcapMaterial
                                ? (t(e, n),
                                  (function (e, t) {
                                      t.matcap && (e.matcap.value = t.matcap),
                                          t.bumpMap &&
                                              ((e.bumpMap.value = t.bumpMap),
                                              (e.bumpScale.value = t.bumpScale),
                                              t.side === Qt &&
                                                  (e.bumpScale.value *= -1)),
                                          t.normalMap &&
                                              ((e.normalMap.value =
                                                  t.normalMap),
                                              e.normalScale.value.copy(
                                                  t.normalScale
                                              ),
                                              t.side === Qt &&
                                                  e.normalScale.value.negate()),
                                          t.displacementMap &&
                                              ((e.displacementMap.value =
                                                  t.displacementMap),
                                              (e.displacementScale.value =
                                                  t.displacementScale),
                                              (e.displacementBias.value =
                                                  t.displacementBias));
                                  })(e, n))
                                : n.isMeshDepthMaterial
                                ? (t(e, n),
                                  (function (e, t) {
                                      t.displacementMap &&
                                          ((e.displacementMap.value =
                                              t.displacementMap),
                                          (e.displacementScale.value =
                                              t.displacementScale),
                                          (e.displacementBias.value =
                                              t.displacementBias));
                                  })(e, n))
                                : n.isMeshDistanceMaterial
                                ? (t(e, n),
                                  (function (e, t) {
                                      t.displacementMap &&
                                          ((e.displacementMap.value =
                                              t.displacementMap),
                                          (e.displacementScale.value =
                                              t.displacementScale),
                                          (e.displacementBias.value =
                                              t.displacementBias)),
                                          e.referencePosition.value.copy(
                                              t.referencePosition
                                          ),
                                          (e.nearDistance.value =
                                              t.nearDistance),
                                          (e.farDistance.value = t.farDistance);
                                  })(e, n))
                                : n.isMeshNormalMaterial
                                ? (t(e, n),
                                  (function (e, t) {
                                      t.bumpMap &&
                                          ((e.bumpMap.value = t.bumpMap),
                                          (e.bumpScale.value = t.bumpScale),
                                          t.side === Qt &&
                                              (e.bumpScale.value *= -1)),
                                          t.normalMap &&
                                              ((e.normalMap.value =
                                                  t.normalMap),
                                              e.normalScale.value.copy(
                                                  t.normalScale
                                              ),
                                              t.side === Qt &&
                                                  e.normalScale.value.negate()),
                                          t.displacementMap &&
                                              ((e.displacementMap.value =
                                                  t.displacementMap),
                                              (e.displacementScale.value =
                                                  t.displacementScale),
                                              (e.displacementBias.value =
                                                  t.displacementBias));
                                  })(e, n))
                                : n.isLineBasicMaterial
                                ? ((function (e, t) {
                                      e.diffuse.value.copy(t.color),
                                          (e.opacity.value = t.opacity);
                                  })(e, n),
                                  n.isLineDashedMaterial &&
                                      (function (e, t) {
                                          (e.dashSize.value = t.dashSize),
                                              (e.totalSize.value =
                                                  t.dashSize + t.gapSize),
                                              (e.scale.value = t.scale);
                                      })(e, n))
                                : n.isPointsMaterial
                                ? (function (e, t, i, n) {
                                      let r;
                                      e.diffuse.value.copy(t.color),
                                          (e.opacity.value = t.opacity),
                                          (e.size.value = t.size * i),
                                          (e.scale.value = 0.5 * n),
                                          t.map && (e.map.value = t.map),
                                          t.alphaMap &&
                                              (e.alphaMap.value = t.alphaMap),
                                          t.alphaTest > 0 &&
                                              (e.alphaTest.value = t.alphaTest),
                                          t.map
                                              ? (r = t.map)
                                              : t.alphaMap && (r = t.alphaMap),
                                          void 0 !== r &&
                                              (!0 === r.matrixAutoUpdate &&
                                                  r.updateMatrix(),
                                              e.uvTransform.value.copy(
                                                  r.matrix
                                              ));
                                  })(e, n, r, s)
                                : n.isSpriteMaterial
                                ? (function (e, t) {
                                      let i;
                                      e.diffuse.value.copy(t.color),
                                          (e.opacity.value = t.opacity),
                                          (e.rotation.value = t.rotation),
                                          t.map && (e.map.value = t.map),
                                          t.alphaMap &&
                                              (e.alphaMap.value = t.alphaMap),
                                          t.alphaTest > 0 &&
                                              (e.alphaTest.value = t.alphaTest),
                                          t.map
                                              ? (i = t.map)
                                              : t.alphaMap && (i = t.alphaMap),
                                          void 0 !== i &&
                                              (!0 === i.matrixAutoUpdate &&
                                                  i.updateMatrix(),
                                              e.uvTransform.value.copy(
                                                  i.matrix
                                              ));
                                  })(e, n)
                                : n.isShadowMaterial
                                ? (e.color.value.copy(n.color),
                                  (e.opacity.value = n.opacity))
                                : n.isShaderMaterial &&
                                  (n.uniformsNeedUpdate = !1);
                        },
                    };
                }
                function dh(e = {}) {
                    const t =
                            void 0 !== e.canvas
                                ? e.canvas
                                : (function () {
                                      const e = qr("canvas");
                                      return (e.style.display = "block"), e;
                                  })(),
                        i = void 0 !== e.context ? e.context : null,
                        n = void 0 !== e.alpha && e.alpha,
                        r = void 0 === e.depth || e.depth,
                        s = void 0 === e.stencil || e.stencil,
                        a = void 0 !== e.antialias && e.antialias,
                        o =
                            void 0 === e.premultipliedAlpha ||
                            e.premultipliedAlpha,
                        c =
                            void 0 !== e.preserveDrawingBuffer &&
                            e.preserveDrawingBuffer,
                        l =
                            void 0 !== e.powerPreference
                                ? e.powerPreference
                                : "default",
                        h =
                            void 0 !== e.failIfMajorPerformanceCaveat &&
                            e.failIfMajorPerformanceCaveat;
                    let u = null,
                        d = null;
                    const p = [],
                        g = [];
                    (this.domElement = t),
                        (this.debug = { checkShaderErrors: !0 }),
                        (this.autoClear = !0),
                        (this.autoClearColor = !0),
                        (this.autoClearDepth = !0),
                        (this.autoClearStencil = !0),
                        (this.sortObjects = !0),
                        (this.clippingPlanes = []),
                        (this.localClippingEnabled = !1),
                        (this.gammaFactor = 2),
                        (this.outputEncoding = fr),
                        (this.physicallyCorrectLights = !1),
                        (this.toneMapping = Ai),
                        (this.toneMappingExposure = 1);
                    const m = this;
                    let f = !1,
                        _ = 0,
                        M = 0,
                        v = null,
                        y = -1,
                        x = null;
                    const b = new es(),
                        w = new es();
                    let T = null,
                        S = t.width,
                        N = t.height,
                        D = 1,
                        I = null,
                        C = null;
                    const A = new es(0, 0, S, N),
                        E = new es(0, 0, S, N);
                    let L = !1;
                    const z = [],
                        j = new So();
                    let O = !1,
                        k = !1,
                        R = null;
                    const P = new Os(),
                        U = new rs(),
                        $ = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0,
                        };
                    function B() {
                        return null === v ? D : 1;
                    }
                    let F,
                        H,
                        G,
                        V,
                        Y,
                        q,
                        W,
                        Q,
                        Z,
                        X,
                        J,
                        K,
                        ee,
                        te,
                        ie,
                        ne,
                        re,
                        se,
                        ae,
                        oe,
                        ce,
                        le,
                        he,
                        ue = i;
                    function de(e, i) {
                        for (let n = 0; n < e.length; n++) {
                            const r = e[n],
                                s = t.getContext(r, i);
                            if (null !== s) return s;
                        }
                        return null;
                    }
                    try {
                        const e = {
                            alpha: n,
                            depth: r,
                            stencil: s,
                            antialias: a,
                            premultipliedAlpha: o,
                            preserveDrawingBuffer: c,
                            powerPreference: l,
                            failIfMajorPerformanceCaveat: h,
                        };
                        if (
                            (t.addEventListener("webglcontextlost", me, !1),
                            t.addEventListener("webglcontextrestored", fe, !1),
                            null === ue)
                        ) {
                            const t = ["webgl2", "webgl", "experimental-webgl"];
                            if (
                                (!0 === m.isWebGL1Renderer && t.shift(),
                                (ue = de(t, e)),
                                null === ue)
                            )
                                throw de(t)
                                    ? new Error(
                                          "Error creating WebGL context with your selected attributes."
                                      )
                                    : new Error(
                                          "Error creating WebGL context."
                                      );
                        }
                        void 0 === ue.getShaderPrecisionFormat &&
                            (ue.getShaderPrecisionFormat = function () {
                                return {
                                    rangeMin: 1,
                                    rangeMax: 1,
                                    precision: 1,
                                };
                            });
                    } catch (e) {
                        throw (
                            (console.error("THREE.WebGLRenderer: " + e.message),
                            e)
                        );
                    }
                    function pe() {
                        (F = new oc(ue)),
                            (H = new Oo(ue, F, e)),
                            F.init(H),
                            (le = new sh(ue, F, H)),
                            (G = new nh(ue, F, H)),
                            (z[0] = 1029),
                            (V = new hc(ue)),
                            (Y = new Bl()),
                            (q = new rh(ue, F, G, Y, H, le, V)),
                            (W = new Ro(m)),
                            (Q = new ac(m)),
                            (Z = new Do(ue, H)),
                            (he = new zo(ue, F, Z, H)),
                            (X = new cc(ue, Z, V, he)),
                            (J = new fc(ue, X, Z, V)),
                            (ae = new mc(ue, H, q)),
                            (ne = new ko(Y)),
                            (K = new $l(m, W, Q, F, H, he, ne)),
                            (ee = new uh(Y)),
                            (te = new Vl(Y)),
                            (ie = new Xl(F, H)),
                            (se = new Lo(m, W, G, J, o)),
                            (re = new ih(m, J, H)),
                            (oe = new jo(ue, F, V, H)),
                            (ce = new lc(ue, F, V, H)),
                            (V.programs = K.programs),
                            (m.capabilities = H),
                            (m.extensions = F),
                            (m.properties = Y),
                            (m.renderLists = te),
                            (m.shadowMap = re),
                            (m.state = G),
                            (m.info = V);
                    }
                    pe();
                    const ge = new hh(m, ue);
                    function me(e) {
                        e.preventDefault(),
                            console.log("THREE.WebGLRenderer: Context Lost."),
                            (f = !0);
                    }
                    function fe() {
                        console.log("THREE.WebGLRenderer: Context Restored."),
                            (f = !1);
                        const e = V.autoReset,
                            t = re.enabled,
                            i = re.autoUpdate,
                            n = re.needsUpdate,
                            r = re.type;
                        pe(),
                            (V.autoReset = e),
                            (re.enabled = t),
                            (re.autoUpdate = i),
                            (re.needsUpdate = n),
                            (re.type = r);
                    }
                    function _e(e) {
                        const t = e.target;
                        t.removeEventListener("dispose", _e),
                            (function (e) {
                                (function (e) {
                                    const t = Y.get(e).programs;
                                    void 0 !== t &&
                                        t.forEach(function (e) {
                                            K.releaseProgram(e);
                                        });
                                })(e),
                                    Y.remove(e);
                            })(t);
                    }
                    (this.xr = ge),
                        (this.getContext = function () {
                            return ue;
                        }),
                        (this.getContextAttributes = function () {
                            return ue.getContextAttributes();
                        }),
                        (this.forceContextLoss = function () {
                            const e = F.get("WEBGL_lose_context");
                            e && e.loseContext();
                        }),
                        (this.forceContextRestore = function () {
                            const e = F.get("WEBGL_lose_context");
                            e && e.restoreContext();
                        }),
                        (this.getPixelRatio = function () {
                            return D;
                        }),
                        (this.setPixelRatio = function (e) {
                            void 0 !== e && ((D = e), this.setSize(S, N, !1));
                        }),
                        (this.getSize = function (e) {
                            return e.set(S, N);
                        }),
                        (this.setSize = function (e, i, n) {
                            ge.isPresenting
                                ? console.warn(
                                      "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                                  )
                                : ((S = e),
                                  (N = i),
                                  (t.width = Math.floor(e * D)),
                                  (t.height = Math.floor(i * D)),
                                  !1 !== n &&
                                      ((t.style.width = e + "px"),
                                      (t.style.height = i + "px")),
                                  this.setViewport(0, 0, e, i));
                        }),
                        (this.getDrawingBufferSize = function (e) {
                            return e.set(S * D, N * D).floor();
                        }),
                        (this.setDrawingBufferSize = function (e, i, n) {
                            (S = e),
                                (N = i),
                                (D = n),
                                (t.width = Math.floor(e * n)),
                                (t.height = Math.floor(i * n)),
                                this.setViewport(0, 0, e, i);
                        }),
                        (this.getCurrentViewport = function (e) {
                            return e.copy(b);
                        }),
                        (this.getViewport = function (e) {
                            return e.copy(A);
                        }),
                        (this.setViewport = function (e, t, i, n) {
                            e.isVector4
                                ? A.set(e.x, e.y, e.z, e.w)
                                : A.set(e, t, i, n),
                                G.viewport(b.copy(A).multiplyScalar(D).floor());
                        }),
                        (this.getScissor = function (e) {
                            return e.copy(E);
                        }),
                        (this.setScissor = function (e, t, i, n) {
                            e.isVector4
                                ? E.set(e.x, e.y, e.z, e.w)
                                : E.set(e, t, i, n),
                                G.scissor(w.copy(E).multiplyScalar(D).floor());
                        }),
                        (this.getScissorTest = function () {
                            return L;
                        }),
                        (this.setScissorTest = function (e) {
                            G.setScissorTest((L = e));
                        }),
                        (this.setOpaqueSort = function (e) {
                            I = e;
                        }),
                        (this.setTransparentSort = function (e) {
                            C = e;
                        }),
                        (this.getClearColor = function (e) {
                            return e.copy(se.getClearColor());
                        }),
                        (this.setClearColor = function () {
                            se.setClearColor.apply(se, arguments);
                        }),
                        (this.getClearAlpha = function () {
                            return se.getClearAlpha();
                        }),
                        (this.setClearAlpha = function () {
                            se.setClearAlpha.apply(se, arguments);
                        }),
                        (this.clear = function (e, t, i) {
                            let n = 0;
                            (void 0 === e || e) && (n |= 16384),
                                (void 0 === t || t) && (n |= 256),
                                (void 0 === i || i) && (n |= 1024),
                                ue.clear(n);
                        }),
                        (this.clearColor = function () {
                            this.clear(!0, !1, !1);
                        }),
                        (this.clearDepth = function () {
                            this.clear(!1, !0, !1);
                        }),
                        (this.clearStencil = function () {
                            this.clear(!1, !1, !0);
                        }),
                        (this.dispose = function () {
                            t.removeEventListener("webglcontextlost", me, !1),
                                t.removeEventListener(
                                    "webglcontextrestored",
                                    fe,
                                    !1
                                ),
                                te.dispose(),
                                ie.dispose(),
                                Y.dispose(),
                                W.dispose(),
                                Q.dispose(),
                                J.dispose(),
                                he.dispose(),
                                ge.dispose(),
                                ge.removeEventListener("sessionstart", ve),
                                ge.removeEventListener("sessionend", ye),
                                R && (R.dispose(), (R = null)),
                                xe.stop();
                        }),
                        (this.renderBufferDirect = function (e, t, i, n, r, s) {
                            null === t && (t = $);
                            const a =
                                    r.isMesh && r.matrixWorld.determinant() < 0,
                                o = (function (e, t, i, n, r) {
                                    !0 !== t.isScene && (t = $),
                                        q.resetTextureUnits();
                                    const s = t.fog,
                                        a = n.isMeshStandardMaterial
                                            ? t.environment
                                            : null,
                                        o =
                                            null === v
                                                ? m.outputEncoding
                                                : v.texture.encoding,
                                        c = (
                                            n.isMeshStandardMaterial ? Q : W
                                        ).get(n.envMap || a),
                                        l =
                                            !0 === n.vertexColors &&
                                            !!i.attributes.color &&
                                            4 === i.attributes.color.itemSize,
                                        h =
                                            !!n.normalMap &&
                                            !!i.attributes.tangent,
                                        u = !!i.morphAttributes.position,
                                        p = !!i.morphAttributes.normal,
                                        g = i.morphAttributes.position
                                            ? i.morphAttributes.position.length
                                            : 0,
                                        f = Y.get(n),
                                        _ = d.state.lights;
                                    if (!0 === O && (!0 === k || e !== x)) {
                                        const t = e === x && n.id === y;
                                        ne.setState(n, e, t);
                                    }
                                    let M = !1;
                                    n.version === f.__version
                                        ? (f.needsLights &&
                                              f.lightsStateVersion !==
                                                  _.state.version) ||
                                          f.outputEncoding !== o ||
                                          (r.isInstancedMesh &&
                                              !1 === f.instancing)
                                            ? (M = !0)
                                            : r.isInstancedMesh ||
                                              !0 !== f.instancing
                                            ? r.isSkinnedMesh &&
                                              !1 === f.skinning
                                                ? (M = !0)
                                                : r.isSkinnedMesh ||
                                                  !0 !== f.skinning
                                                ? f.envMap !== c ||
                                                  (n.fog && f.fog !== s)
                                                    ? (M = !0)
                                                    : void 0 ===
                                                          f.numClippingPlanes ||
                                                      (f.numClippingPlanes ===
                                                          ne.numPlanes &&
                                                          f.numIntersection ===
                                                              ne.numIntersection)
                                                    ? (f.vertexAlphas !== l ||
                                                          f.vertexTangents !==
                                                              h ||
                                                          f.morphTargets !==
                                                              u ||
                                                          f.morphNormals !==
                                                              p ||
                                                          (!0 === H.isWebGL2 &&
                                                              f.morphTargetsCount !==
                                                                  g)) &&
                                                      (M = !0)
                                                    : (M = !0)
                                                : (M = !0)
                                            : (M = !0)
                                        : ((M = !0), (f.__version = n.version));
                                    let b = f.currentProgram;
                                    !0 === M && (b = Ne(n, t, r));
                                    let w = !1,
                                        T = !1,
                                        S = !1;
                                    const I = b.getUniforms(),
                                        C = f.uniforms;
                                    if (
                                        (G.useProgram(b.program) &&
                                            ((w = !0), (T = !0), (S = !0)),
                                        n.id !== y && ((y = n.id), (T = !0)),
                                        w || x !== e)
                                    ) {
                                        if (
                                            (I.setValue(
                                                ue,
                                                "projectionMatrix",
                                                e.projectionMatrix
                                            ),
                                            H.logarithmicDepthBuffer &&
                                                I.setValue(
                                                    ue,
                                                    "logDepthBufFC",
                                                    2 /
                                                        (Math.log(e.far + 1) /
                                                            Math.LN2)
                                                ),
                                            x !== e &&
                                                ((x = e), (T = !0), (S = !0)),
                                            n.isShaderMaterial ||
                                                n.isMeshPhongMaterial ||
                                                n.isMeshToonMaterial ||
                                                n.isMeshStandardMaterial ||
                                                n.envMap)
                                        ) {
                                            const t = I.map.cameraPosition;
                                            void 0 !== t &&
                                                t.setValue(
                                                    ue,
                                                    U.setFromMatrixPosition(
                                                        e.matrixWorld
                                                    )
                                                );
                                        }
                                        (n.isMeshPhongMaterial ||
                                            n.isMeshToonMaterial ||
                                            n.isMeshLambertMaterial ||
                                            n.isMeshBasicMaterial ||
                                            n.isMeshStandardMaterial ||
                                            n.isShaderMaterial) &&
                                            I.setValue(
                                                ue,
                                                "isOrthographic",
                                                !0 === e.isOrthographicCamera
                                            ),
                                            (n.isMeshPhongMaterial ||
                                                n.isMeshToonMaterial ||
                                                n.isMeshLambertMaterial ||
                                                n.isMeshBasicMaterial ||
                                                n.isMeshStandardMaterial ||
                                                n.isShaderMaterial ||
                                                n.isShadowMaterial ||
                                                r.isSkinnedMesh) &&
                                                I.setValue(
                                                    ue,
                                                    "viewMatrix",
                                                    e.matrixWorldInverse
                                                );
                                    }
                                    if (r.isSkinnedMesh) {
                                        I.setOptional(ue, r, "bindMatrix"),
                                            I.setOptional(
                                                ue,
                                                r,
                                                "bindMatrixInverse"
                                            );
                                        const e = r.skeleton;
                                        e &&
                                            (H.floatVertexTextures
                                                ? (null === e.boneTexture &&
                                                      e.computeBoneTexture(),
                                                  I.setValue(
                                                      ue,
                                                      "boneTexture",
                                                      e.boneTexture,
                                                      q
                                                  ),
                                                  I.setValue(
                                                      ue,
                                                      "boneTextureSize",
                                                      e.boneTextureSize
                                                  ))
                                                : I.setOptional(
                                                      ue,
                                                      e,
                                                      "boneMatrices"
                                                  ));
                                    }
                                    var A, E;
                                    return (
                                        !i ||
                                            (void 0 ===
                                                i.morphAttributes.position &&
                                                void 0 ===
                                                    i.morphAttributes.normal) ||
                                            ae.update(r, i, n, b),
                                        (T ||
                                            f.receiveShadow !==
                                                r.receiveShadow) &&
                                            ((f.receiveShadow =
                                                r.receiveShadow),
                                            I.setValue(
                                                ue,
                                                "receiveShadow",
                                                r.receiveShadow
                                            )),
                                        T &&
                                            (I.setValue(
                                                ue,
                                                "toneMappingExposure",
                                                m.toneMappingExposure
                                            ),
                                            f.needsLights &&
                                                ((E = S),
                                                ((A =
                                                    C).ambientLightColor.needsUpdate =
                                                    E),
                                                (A.lightProbe.needsUpdate = E),
                                                (A.directionalLights.needsUpdate =
                                                    E),
                                                (A.directionalLightShadows.needsUpdate =
                                                    E),
                                                (A.pointLights.needsUpdate = E),
                                                (A.pointLightShadows.needsUpdate =
                                                    E),
                                                (A.spotLights.needsUpdate = E),
                                                (A.spotLightShadows.needsUpdate =
                                                    E),
                                                (A.rectAreaLights.needsUpdate =
                                                    E),
                                                (A.hemisphereLights.needsUpdate =
                                                    E)),
                                            s &&
                                                n.fog &&
                                                ee.refreshFogUniforms(C, s),
                                            ee.refreshMaterialUniforms(
                                                C,
                                                n,
                                                D,
                                                N,
                                                R
                                            ),
                                            vl.upload(
                                                ue,
                                                f.uniformsList,
                                                C,
                                                q
                                            )),
                                        n.isShaderMaterial &&
                                            !0 === n.uniformsNeedUpdate &&
                                            (vl.upload(
                                                ue,
                                                f.uniformsList,
                                                C,
                                                q
                                            ),
                                            (n.uniformsNeedUpdate = !1)),
                                        n.isSpriteMaterial &&
                                            I.setValue(ue, "center", r.center),
                                        I.setValue(
                                            ue,
                                            "modelViewMatrix",
                                            r.modelViewMatrix
                                        ),
                                        I.setValue(
                                            ue,
                                            "normalMatrix",
                                            r.normalMatrix
                                        ),
                                        I.setValue(
                                            ue,
                                            "modelMatrix",
                                            r.matrixWorld
                                        ),
                                        b
                                    );
                                })(e, t, i, n, r);
                            G.setMaterial(n, a);
                            let c = i.index;
                            const l = i.attributes.position;
                            if (null === c) {
                                if (void 0 === l || 0 === l.count) return;
                            } else if (0 === c.count) return;
                            let h,
                                u = 1;
                            !0 === n.wireframe &&
                                ((c = X.getWireframeAttribute(i)), (u = 2)),
                                he.setup(r, n, o, i, c);
                            let p = oe;
                            null !== c &&
                                ((h = Z.get(c)), (p = ce), p.setIndex(h));
                            const g = null !== c ? c.count : l.count,
                                f = i.drawRange.start * u,
                                _ = i.drawRange.count * u,
                                M = null !== s ? s.start * u : 0,
                                b = null !== s ? s.count * u : 1 / 0,
                                w = Math.max(f, M),
                                T = Math.min(g, f + _, M + b) - 1,
                                S = Math.max(0, T - w + 1);
                            if (0 !== S) {
                                if (r.isMesh)
                                    !0 === n.wireframe
                                        ? (G.setLineWidth(
                                              n.wireframeLinewidth * B()
                                          ),
                                          p.setMode(1))
                                        : p.setMode(4);
                                else if (r.isLine) {
                                    let e = n.linewidth;
                                    void 0 === e && (e = 1),
                                        G.setLineWidth(e * B()),
                                        r.isLineSegments
                                            ? p.setMode(1)
                                            : r.isLineLoop
                                            ? p.setMode(2)
                                            : p.setMode(3);
                                } else
                                    r.isPoints
                                        ? p.setMode(0)
                                        : r.isSprite && p.setMode(4);
                                if (r.isInstancedMesh)
                                    p.renderInstances(w, S, r.count);
                                else if (i.isInstancedBufferGeometry) {
                                    const e = Math.min(
                                        i.instanceCount,
                                        i._maxInstanceCount
                                    );
                                    p.renderInstances(w, S, e);
                                } else p.render(w, S);
                            }
                        }),
                        (this.compile = function (e, t) {
                            (d = ie.get(e)),
                                d.init(),
                                g.push(d),
                                e.traverseVisible(function (e) {
                                    e.isLight &&
                                        e.layers.test(t.layers) &&
                                        (d.pushLight(e),
                                        e.castShadow && d.pushShadow(e));
                                }),
                                d.setupLights(m.physicallyCorrectLights),
                                e.traverse(function (t) {
                                    const i = t.material;
                                    if (i)
                                        if (Array.isArray(i))
                                            for (let n = 0; n < i.length; n++)
                                                Ne(i[n], e, t);
                                        else Ne(i, e, t);
                                }),
                                g.pop(),
                                (d = null);
                        });
                    let Me = null;
                    function ve() {
                        xe.stop();
                    }
                    function ye() {
                        xe.start();
                    }
                    const xe = new No();
                    function be(e, t, i, n) {
                        if (!1 === e.visible) return;
                        if (e.layers.test(t.layers))
                            if (e.isGroup) i = e.renderOrder;
                            else if (e.isLOD)
                                !0 === e.autoUpdate && e.update(t);
                            else if (e.isLight)
                                d.pushLight(e), e.castShadow && d.pushShadow(e);
                            else if (e.isSprite) {
                                if (!e.frustumCulled || j.intersectsSprite(e)) {
                                    n &&
                                        U.setFromMatrixPosition(
                                            e.matrixWorld
                                        ).applyMatrix4(P);
                                    const t = J.update(e),
                                        r = e.material;
                                    r.visible && u.push(e, t, r, i, U.z, null);
                                }
                            } else if (
                                (e.isMesh || e.isLine || e.isPoints) &&
                                (e.isSkinnedMesh &&
                                    e.skeleton.frame !== V.render.frame &&
                                    (e.skeleton.update(),
                                    (e.skeleton.frame = V.render.frame)),
                                !e.frustumCulled || j.intersectsObject(e))
                            ) {
                                n &&
                                    U.setFromMatrixPosition(
                                        e.matrixWorld
                                    ).applyMatrix4(P);
                                const t = J.update(e),
                                    r = e.material;
                                if (Array.isArray(r)) {
                                    const n = t.groups;
                                    for (let s = 0, a = n.length; s < a; s++) {
                                        const a = n[s],
                                            o = r[a.materialIndex];
                                        o &&
                                            o.visible &&
                                            u.push(e, t, o, i, U.z, a);
                                    }
                                } else
                                    r.visible && u.push(e, t, r, i, U.z, null);
                            }
                        const r = e.children;
                        for (let e = 0, s = r.length; e < s; e++)
                            be(r[e], t, i, n);
                    }
                    function we(e, t, i, n) {
                        const r = e.opaque,
                            s = e.transmissive,
                            o = e.transparent;
                        d.setupLightsView(i),
                            s.length > 0 &&
                                (function (e, t, i) {
                                    if (null === R) {
                                        const e = !0 === a && !0 === H.isWebGL2;
                                        R = new (e ? is : ts)(1024, 1024, {
                                            generateMipmaps: !0,
                                            type:
                                                null !== le.convert(sn)
                                                    ? sn
                                                    : Xi,
                                            minFilter: Zi,
                                            magFilter: Vi,
                                            wrapS: Hi,
                                            wrapT: Hi,
                                        });
                                    }
                                    const n = m.getRenderTarget();
                                    m.setRenderTarget(R), m.clear();
                                    const r = m.toneMapping;
                                    (m.toneMapping = Ai),
                                        Te(e, t, i),
                                        (m.toneMapping = r),
                                        q.updateMultisampleRenderTarget(R),
                                        q.updateRenderTargetMipmap(R),
                                        m.setRenderTarget(n);
                                })(r, t, i),
                            n && G.viewport(b.copy(n)),
                            r.length > 0 && Te(r, t, i),
                            s.length > 0 && Te(s, t, i),
                            o.length > 0 && Te(o, t, i);
                    }
                    function Te(e, t, i) {
                        const n = !0 === t.isScene ? t.overrideMaterial : null;
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r],
                                a = s.object,
                                o = s.geometry,
                                c = null === n ? s.material : n,
                                l = s.group;
                            a.layers.test(i.layers) && Se(a, t, i, o, c, l);
                        }
                    }
                    function Se(e, t, i, n, r, s) {
                        e.onBeforeRender(m, t, i, n, r, s),
                            e.modelViewMatrix.multiplyMatrices(
                                i.matrixWorldInverse,
                                e.matrixWorld
                            ),
                            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                            r.onBeforeRender(m, t, i, n, e, s),
                            !0 === r.transparent && r.side === Zt
                                ? ((r.side = Qt),
                                  (r.needsUpdate = !0),
                                  m.renderBufferDirect(i, t, n, r, e, s),
                                  (r.side = Wt),
                                  (r.needsUpdate = !0),
                                  m.renderBufferDirect(i, t, n, r, e, s),
                                  (r.side = Zt))
                                : m.renderBufferDirect(i, t, n, r, e, s),
                            e.onAfterRender(m, t, i, n, r, s);
                    }
                    function Ne(e, t, i) {
                        !0 !== t.isScene && (t = $);
                        const n = Y.get(e),
                            r = d.state.lights,
                            s = d.state.shadowsArray,
                            a = r.state.version,
                            o = K.getParameters(e, r.state, s, t, i),
                            c = K.getProgramCacheKey(o);
                        let l = n.programs;
                        (n.environment = e.isMeshStandardMaterial
                            ? t.environment
                            : null),
                            (n.fog = t.fog),
                            (n.envMap = (e.isMeshStandardMaterial ? Q : W).get(
                                e.envMap || n.environment
                            )),
                            void 0 === l &&
                                (e.addEventListener("dispose", _e),
                                (l = new Map()),
                                (n.programs = l));
                        let h = l.get(c);
                        if (void 0 !== h) {
                            if (
                                n.currentProgram === h &&
                                n.lightsStateVersion === a
                            )
                                return De(e, o), h;
                        } else
                            (o.uniforms = K.getUniforms(e)),
                                e.onBuild(i, o, m),
                                e.onBeforeCompile(o, m),
                                (h = K.acquireProgram(o, c)),
                                l.set(c, h),
                                (n.uniforms = o.uniforms);
                        const u = n.uniforms;
                        ((e.isShaderMaterial || e.isRawShaderMaterial) &&
                            !0 !== e.clipping) ||
                            (u.clippingPlanes = ne.uniform),
                            De(e, o),
                            (n.needsLights = (function (e) {
                                return (
                                    e.isMeshLambertMaterial ||
                                    e.isMeshToonMaterial ||
                                    e.isMeshPhongMaterial ||
                                    e.isMeshStandardMaterial ||
                                    e.isShadowMaterial ||
                                    (e.isShaderMaterial && !0 === e.lights)
                                );
                            })(e)),
                            (n.lightsStateVersion = a),
                            n.needsLights &&
                                ((u.ambientLightColor.value = r.state.ambient),
                                (u.lightProbe.value = r.state.probe),
                                (u.directionalLights.value =
                                    r.state.directional),
                                (u.directionalLightShadows.value =
                                    r.state.directionalShadow),
                                (u.spotLights.value = r.state.spot),
                                (u.spotLightShadows.value = r.state.spotShadow),
                                (u.rectAreaLights.value = r.state.rectArea),
                                (u.ltc_1.value = r.state.rectAreaLTC1),
                                (u.ltc_2.value = r.state.rectAreaLTC2),
                                (u.pointLights.value = r.state.point),
                                (u.pointLightShadows.value =
                                    r.state.pointShadow),
                                (u.hemisphereLights.value = r.state.hemi),
                                (u.directionalShadowMap.value =
                                    r.state.directionalShadowMap),
                                (u.directionalShadowMatrix.value =
                                    r.state.directionalShadowMatrix),
                                (u.spotShadowMap.value = r.state.spotShadowMap),
                                (u.spotShadowMatrix.value =
                                    r.state.spotShadowMatrix),
                                (u.pointShadowMap.value =
                                    r.state.pointShadowMap),
                                (u.pointShadowMatrix.value =
                                    r.state.pointShadowMatrix));
                        const p = h.getUniforms(),
                            g = vl.seqWithValue(p.seq, u);
                        return (n.currentProgram = h), (n.uniformsList = g), h;
                    }
                    function De(e, t) {
                        const i = Y.get(e);
                        (i.outputEncoding = t.outputEncoding),
                            (i.instancing = t.instancing),
                            (i.skinning = t.skinning),
                            (i.morphTargets = t.morphTargets),
                            (i.morphNormals = t.morphNormals),
                            (i.morphTargetsCount = t.morphTargetsCount),
                            (i.numClippingPlanes = t.numClippingPlanes),
                            (i.numIntersection = t.numClipIntersection),
                            (i.vertexAlphas = t.vertexAlphas),
                            (i.vertexTangents = t.vertexTangents);
                    }
                    xe.setAnimationLoop(function (e) {
                        Me && Me(e);
                    }),
                        "undefined" != typeof window && xe.setContext(window),
                        (this.setAnimationLoop = function (e) {
                            (Me = e),
                                ge.setAnimationLoop(e),
                                null === e ? xe.stop() : xe.start();
                        }),
                        ge.addEventListener("sessionstart", ve),
                        ge.addEventListener("sessionend", ye),
                        (this.render = function (e, t) {
                            if (void 0 !== t && !0 !== t.isCamera)
                                return void console.error(
                                    "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                                );
                            if (!0 === f) return;
                            !0 === e.autoUpdate && e.updateMatrixWorld(),
                                null === t.parent && t.updateMatrixWorld(),
                                !0 === ge.enabled &&
                                    !0 === ge.isPresenting &&
                                    (!0 === ge.cameraAutoUpdate &&
                                        ge.updateCamera(t),
                                    (t = ge.getCamera())),
                                !0 === e.isScene &&
                                    e.onBeforeRender(m, e, t, v),
                                (d = ie.get(e, g.length)),
                                d.init(),
                                g.push(d),
                                P.multiplyMatrices(
                                    t.projectionMatrix,
                                    t.matrixWorldInverse
                                ),
                                j.setFromProjectionMatrix(P),
                                (k = this.localClippingEnabled),
                                (O = ne.init(this.clippingPlanes, k, t)),
                                (u = te.get(e, p.length)),
                                u.init(),
                                p.push(u),
                                be(e, t, 0, m.sortObjects),
                                u.finish(),
                                !0 === m.sortObjects && u.sort(I, C),
                                !0 === O && ne.beginShadows();
                            const i = d.state.shadowsArray;
                            if (
                                (re.render(i, e, t),
                                !0 === O && ne.endShadows(),
                                !0 === this.info.autoReset && this.info.reset(),
                                se.render(u, e),
                                d.setupLights(m.physicallyCorrectLights),
                                t.isArrayCamera)
                            ) {
                                const i = t.cameras;
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = i[t];
                                    we(u, e, n, n.viewport);
                                }
                            } else we(u, e, t);
                            null !== v &&
                                (q.updateMultisampleRenderTarget(v),
                                q.updateRenderTargetMipmap(v)),
                                !0 === e.isScene && e.onAfterRender(m, e, t),
                                G.buffers.depth.setTest(!0),
                                G.buffers.depth.setMask(!0),
                                G.buffers.color.setMask(!0),
                                G.setPolygonOffset(!1),
                                he.resetDefaultState(),
                                (y = -1),
                                (x = null),
                                g.pop(),
                                (d = g.length > 0 ? g[g.length - 1] : null),
                                p.pop(),
                                (u = p.length > 0 ? p[p.length - 1] : null);
                        }),
                        (this.getActiveCubeFace = function () {
                            return _;
                        }),
                        (this.getActiveMipmapLevel = function () {
                            return M;
                        }),
                        (this.getRenderTarget = function () {
                            return v;
                        }),
                        (this.setRenderTarget = function (e, t = 0, i = 0) {
                            (v = e),
                                (_ = t),
                                (M = i),
                                e &&
                                    void 0 === Y.get(e).__webglFramebuffer &&
                                    q.setupRenderTarget(e);
                            let n = null,
                                r = !1,
                                s = !1;
                            if (e) {
                                const i = e.texture;
                                (i.isDataTexture3D || i.isDataTexture2DArray) &&
                                    (s = !0);
                                const a = Y.get(e).__webglFramebuffer;
                                e.isWebGLCubeRenderTarget
                                    ? ((n = a[t]), (r = !0))
                                    : (n = e.isWebGLMultisampleRenderTarget
                                          ? Y.get(e)
                                                .__webglMultisampledFramebuffer
                                          : a),
                                    b.copy(e.viewport),
                                    w.copy(e.scissor),
                                    (T = e.scissorTest);
                            } else
                                b.copy(A).multiplyScalar(D).floor(),
                                    w.copy(E).multiplyScalar(D).floor(),
                                    (T = L);
                            if (G.bindFramebuffer(36160, n) && H.drawBuffers) {
                                let t = !1;
                                if (e)
                                    if (e.isWebGLMultipleRenderTargets) {
                                        const i = e.texture;
                                        if (
                                            z.length !== i.length ||
                                            36064 !== z[0]
                                        ) {
                                            for (
                                                let e = 0, t = i.length;
                                                e < t;
                                                e++
                                            )
                                                z[e] = 36064 + e;
                                            (z.length = i.length), (t = !0);
                                        }
                                    } else
                                        (1 === z.length && 36064 === z[0]) ||
                                            ((z[0] = 36064),
                                            (z.length = 1),
                                            (t = !0));
                                else
                                    (1 === z.length && 1029 === z[0]) ||
                                        ((z[0] = 1029),
                                        (z.length = 1),
                                        (t = !0));
                                t &&
                                    (H.isWebGL2
                                        ? ue.drawBuffers(z)
                                        : F.get(
                                              "WEBGL_draw_buffers"
                                          ).drawBuffersWEBGL(z));
                            }
                            if (
                                (G.viewport(b),
                                G.scissor(w),
                                G.setScissorTest(T),
                                r)
                            ) {
                                const n = Y.get(e.texture);
                                ue.framebufferTexture2D(
                                    36160,
                                    36064,
                                    34069 + t,
                                    n.__webglTexture,
                                    i
                                );
                            } else if (s) {
                                const n = Y.get(e.texture),
                                    r = t || 0;
                                ue.framebufferTextureLayer(
                                    36160,
                                    36064,
                                    n.__webglTexture,
                                    i || 0,
                                    r
                                );
                            }
                            y = -1;
                        }),
                        (this.readRenderTargetPixels = function (
                            e,
                            t,
                            i,
                            n,
                            r,
                            s,
                            a
                        ) {
                            if (!e || !e.isWebGLRenderTarget)
                                return void console.error(
                                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                                );
                            let o = Y.get(e).__webglFramebuffer;
                            if (
                                (e.isWebGLCubeRenderTarget &&
                                    void 0 !== a &&
                                    (o = o[a]),
                                o)
                            ) {
                                G.bindFramebuffer(36160, o);
                                try {
                                    const a = e.texture,
                                        o = a.format,
                                        c = a.type;
                                    if (
                                        o !== dn &&
                                        le.convert(o) !== ue.getParameter(35739)
                                    )
                                        return void console.error(
                                            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                                        );
                                    const l =
                                        c === sn &&
                                        (F.has("EXT_color_buffer_half_float") ||
                                            (H.isWebGL2 &&
                                                F.has(
                                                    "EXT_color_buffer_float"
                                                )));
                                    if (
                                        !(
                                            c === Xi ||
                                            le.convert(c) ===
                                                ue.getParameter(35738) ||
                                            (c === rn &&
                                                (H.isWebGL2 ||
                                                    F.has(
                                                        "OES_texture_float"
                                                    ) ||
                                                    F.has(
                                                        "WEBGL_color_buffer_float"
                                                    ))) ||
                                            l
                                        )
                                    )
                                        return void console.error(
                                            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                                        );
                                    36053 === ue.checkFramebufferStatus(36160)
                                        ? t >= 0 &&
                                          t <= e.width - n &&
                                          i >= 0 &&
                                          i <= e.height - r &&
                                          ue.readPixels(
                                              t,
                                              i,
                                              n,
                                              r,
                                              le.convert(o),
                                              le.convert(c),
                                              s
                                          )
                                        : console.error(
                                              "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                                          );
                                } finally {
                                    const e =
                                        null !== v
                                            ? Y.get(v).__webglFramebuffer
                                            : null;
                                    G.bindFramebuffer(36160, e);
                                }
                            }
                        }),
                        (this.copyFramebufferToTexture = function (
                            e,
                            t,
                            i = 0
                        ) {
                            const n = Math.pow(2, -i),
                                r = Math.floor(t.image.width * n),
                                s = Math.floor(t.image.height * n);
                            let a = le.convert(t.format);
                            H.isWebGL2 &&
                                (6407 === a && (a = 32849),
                                6408 === a && (a = 32856)),
                                q.setTexture2D(t, 0),
                                ue.copyTexImage2D(
                                    3553,
                                    i,
                                    a,
                                    e.x,
                                    e.y,
                                    r,
                                    s,
                                    0
                                ),
                                G.unbindTexture();
                        }),
                        (this.copyTextureToTexture = function (e, t, i, n = 0) {
                            const r = t.image.width,
                                s = t.image.height,
                                a = le.convert(i.format),
                                o = le.convert(i.type);
                            q.setTexture2D(i, 0),
                                ue.pixelStorei(37440, i.flipY),
                                ue.pixelStorei(37441, i.premultiplyAlpha),
                                ue.pixelStorei(3317, i.unpackAlignment),
                                t.isDataTexture
                                    ? ue.texSubImage2D(
                                          3553,
                                          n,
                                          e.x,
                                          e.y,
                                          r,
                                          s,
                                          a,
                                          o,
                                          t.image.data
                                      )
                                    : t.isCompressedTexture
                                    ? ue.compressedTexSubImage2D(
                                          3553,
                                          n,
                                          e.x,
                                          e.y,
                                          t.mipmaps[0].width,
                                          t.mipmaps[0].height,
                                          a,
                                          t.mipmaps[0].data
                                      )
                                    : ue.texSubImage2D(
                                          3553,
                                          n,
                                          e.x,
                                          e.y,
                                          a,
                                          o,
                                          t.image
                                      ),
                                0 === n &&
                                    i.generateMipmaps &&
                                    ue.generateMipmap(3553),
                                G.unbindTexture();
                        }),
                        (this.copyTextureToTexture3D = function (
                            e,
                            t,
                            i,
                            n,
                            r = 0
                        ) {
                            if (m.isWebGL1Renderer)
                                return void console.warn(
                                    "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                                );
                            const s = e.max.x - e.min.x + 1,
                                a = e.max.y - e.min.y + 1,
                                o = e.max.z - e.min.z + 1,
                                c = le.convert(n.format),
                                l = le.convert(n.type);
                            let h;
                            if (n.isDataTexture3D)
                                q.setTexture3D(n, 0), (h = 32879);
                            else {
                                if (!n.isDataTexture2DArray)
                                    return void console.warn(
                                        "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                                    );
                                q.setTexture2DArray(n, 0), (h = 35866);
                            }
                            ue.pixelStorei(37440, n.flipY),
                                ue.pixelStorei(37441, n.premultiplyAlpha),
                                ue.pixelStorei(3317, n.unpackAlignment);
                            const u = ue.getParameter(3314),
                                d = ue.getParameter(32878),
                                p = ue.getParameter(3316),
                                g = ue.getParameter(3315),
                                f = ue.getParameter(32877),
                                _ = i.isCompressedTexture
                                    ? i.mipmaps[0]
                                    : i.image;
                            ue.pixelStorei(3314, _.width),
                                ue.pixelStorei(32878, _.height),
                                ue.pixelStorei(3316, e.min.x),
                                ue.pixelStorei(3315, e.min.y),
                                ue.pixelStorei(32877, e.min.z),
                                i.isDataTexture || i.isDataTexture3D
                                    ? ue.texSubImage3D(
                                          h,
                                          r,
                                          t.x,
                                          t.y,
                                          t.z,
                                          s,
                                          a,
                                          o,
                                          c,
                                          l,
                                          _.data
                                      )
                                    : i.isCompressedTexture
                                    ? (console.warn(
                                          "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                                      ),
                                      ue.compressedTexSubImage3D(
                                          h,
                                          r,
                                          t.x,
                                          t.y,
                                          t.z,
                                          s,
                                          a,
                                          o,
                                          c,
                                          _.data
                                      ))
                                    : ue.texSubImage3D(
                                          h,
                                          r,
                                          t.x,
                                          t.y,
                                          t.z,
                                          s,
                                          a,
                                          o,
                                          c,
                                          l,
                                          _
                                      ),
                                ue.pixelStorei(3314, u),
                                ue.pixelStorei(32878, d),
                                ue.pixelStorei(3316, p),
                                ue.pixelStorei(3315, g),
                                ue.pixelStorei(32877, f),
                                0 === r &&
                                    n.generateMipmaps &&
                                    ue.generateMipmap(h),
                                G.unbindTexture();
                        }),
                        (this.initTexture = function (e) {
                            q.setTexture2D(e, 0), G.unbindTexture();
                        }),
                        (this.resetState = function () {
                            (_ = 0), (M = 0), (v = null), G.reset(), he.reset();
                        }),
                        "undefined" != typeof __THREE_DEVTOOLS__ &&
                            __THREE_DEVTOOLS__.dispatchEvent(
                                new CustomEvent("observe", { detail: this })
                            );
                }
                (dh.prototype.isWebGLRenderer = !0),
                    (class extends dh {}.prototype.isWebGL1Renderer = !0);
                class ph extends aa {
                    constructor() {
                        super(),
                            (this.type = "Scene"),
                            (this.background = null),
                            (this.environment = null),
                            (this.fog = null),
                            (this.overrideMaterial = null),
                            (this.autoUpdate = !0),
                            "undefined" != typeof __THREE_DEVTOOLS__ &&
                                __THREE_DEVTOOLS__.dispatchEvent(
                                    new CustomEvent("observe", { detail: this })
                                );
                    }
                    copy(e, t) {
                        return (
                            super.copy(e, t),
                            null !== e.background &&
                                (this.background = e.background.clone()),
                            null !== e.environment &&
                                (this.environment = e.environment.clone()),
                            null !== e.fog && (this.fog = e.fog.clone()),
                            null !== e.overrideMaterial &&
                                (this.overrideMaterial =
                                    e.overrideMaterial.clone()),
                            (this.autoUpdate = e.autoUpdate),
                            (this.matrixAutoUpdate = e.matrixAutoUpdate),
                            this
                        );
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return (
                            null !== this.fog &&
                                (t.object.fog = this.fog.toJSON()),
                            t
                        );
                    }
                }
                ph.prototype.isScene = !0;
                class gh {
                    constructor(e, t) {
                        (this.array = e),
                            (this.stride = t),
                            (this.count = void 0 !== e ? e.length / t : 0),
                            (this.usage = Ir),
                            (this.updateRange = { offset: 0, count: -1 }),
                            (this.version = 0),
                            (this.uuid = Rr());
                    }
                    onUploadCallback() {}
                    set needsUpdate(e) {
                        !0 === e && this.version++;
                    }
                    setUsage(e) {
                        return (this.usage = e), this;
                    }
                    copy(e) {
                        return (
                            (this.array = new e.array.constructor(e.array)),
                            (this.count = e.count),
                            (this.stride = e.stride),
                            (this.usage = e.usage),
                            this
                        );
                    }
                    copyAt(e, t, i) {
                        (e *= this.stride), (i *= t.stride);
                        for (let n = 0, r = this.stride; n < r; n++)
                            this.array[e + n] = t.array[i + n];
                        return this;
                    }
                    set(e, t = 0) {
                        return this.array.set(e, t), this;
                    }
                    clone(e) {
                        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                            void 0 === this.array.buffer._uuid &&
                                (this.array.buffer._uuid = Rr()),
                            void 0 ===
                                e.arrayBuffers[this.array.buffer._uuid] &&
                                (e.arrayBuffers[this.array.buffer._uuid] =
                                    this.array.slice(0).buffer);
                        const t = new this.array.constructor(
                                e.arrayBuffers[this.array.buffer._uuid]
                            ),
                            i = new this.constructor(t, this.stride);
                        return i.setUsage(this.usage), i;
                    }
                    onUpload(e) {
                        return (this.onUploadCallback = e), this;
                    }
                    toJSON(e) {
                        return (
                            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                            void 0 === this.array.buffer._uuid &&
                                (this.array.buffer._uuid = Rr()),
                            void 0 ===
                                e.arrayBuffers[this.array.buffer._uuid] &&
                                (e.arrayBuffers[this.array.buffer._uuid] =
                                    Array.prototype.slice.call(
                                        new Uint32Array(this.array.buffer)
                                    )),
                            {
                                uuid: this.uuid,
                                buffer: this.array.buffer._uuid,
                                type: this.array.constructor.name,
                                stride: this.stride,
                            }
                        );
                    }
                }
                gh.prototype.isInterleavedBuffer = !0;
                const mh = new rs();
                class fh {
                    constructor(e, t, i, n = !1) {
                        (this.name = ""),
                            (this.data = e),
                            (this.itemSize = t),
                            (this.offset = i),
                            (this.normalized = !0 === n);
                    }
                    get count() {
                        return this.data.count;
                    }
                    get array() {
                        return this.data.array;
                    }
                    set needsUpdate(e) {
                        this.data.needsUpdate = e;
                    }
                    applyMatrix4(e) {
                        for (let t = 0, i = this.data.count; t < i; t++)
                            (mh.x = this.getX(t)),
                                (mh.y = this.getY(t)),
                                (mh.z = this.getZ(t)),
                                mh.applyMatrix4(e),
                                this.setXYZ(t, mh.x, mh.y, mh.z);
                        return this;
                    }
                    applyNormalMatrix(e) {
                        for (let t = 0, i = this.count; t < i; t++)
                            (mh.x = this.getX(t)),
                                (mh.y = this.getY(t)),
                                (mh.z = this.getZ(t)),
                                mh.applyNormalMatrix(e),
                                this.setXYZ(t, mh.x, mh.y, mh.z);
                        return this;
                    }
                    transformDirection(e) {
                        for (let t = 0, i = this.count; t < i; t++)
                            (mh.x = this.getX(t)),
                                (mh.y = this.getY(t)),
                                (mh.z = this.getZ(t)),
                                mh.transformDirection(e),
                                this.setXYZ(t, mh.x, mh.y, mh.z);
                        return this;
                    }
                    setX(e, t) {
                        return (
                            (this.data.array[
                                e * this.data.stride + this.offset
                            ] = t),
                            this
                        );
                    }
                    setY(e, t) {
                        return (
                            (this.data.array[
                                e * this.data.stride + this.offset + 1
                            ] = t),
                            this
                        );
                    }
                    setZ(e, t) {
                        return (
                            (this.data.array[
                                e * this.data.stride + this.offset + 2
                            ] = t),
                            this
                        );
                    }
                    setW(e, t) {
                        return (
                            (this.data.array[
                                e * this.data.stride + this.offset + 3
                            ] = t),
                            this
                        );
                    }
                    getX(e) {
                        return this.data.array[
                            e * this.data.stride + this.offset
                        ];
                    }
                    getY(e) {
                        return this.data.array[
                            e * this.data.stride + this.offset + 1
                        ];
                    }
                    getZ(e) {
                        return this.data.array[
                            e * this.data.stride + this.offset + 2
                        ];
                    }
                    getW(e) {
                        return this.data.array[
                            e * this.data.stride + this.offset + 3
                        ];
                    }
                    setXY(e, t, i) {
                        return (
                            (e = e * this.data.stride + this.offset),
                            (this.data.array[e + 0] = t),
                            (this.data.array[e + 1] = i),
                            this
                        );
                    }
                    setXYZ(e, t, i, n) {
                        return (
                            (e = e * this.data.stride + this.offset),
                            (this.data.array[e + 0] = t),
                            (this.data.array[e + 1] = i),
                            (this.data.array[e + 2] = n),
                            this
                        );
                    }
                    setXYZW(e, t, i, n, r) {
                        return (
                            (e = e * this.data.stride + this.offset),
                            (this.data.array[e + 0] = t),
                            (this.data.array[e + 1] = i),
                            (this.data.array[e + 2] = n),
                            (this.data.array[e + 3] = r),
                            this
                        );
                    }
                    clone(e) {
                        if (void 0 === e) {
                            console.log(
                                "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
                            );
                            const e = [];
                            for (let t = 0; t < this.count; t++) {
                                const i = t * this.data.stride + this.offset;
                                for (let t = 0; t < this.itemSize; t++)
                                    e.push(this.data.array[i + t]);
                            }
                            return new Aa(
                                new this.array.constructor(e),
                                this.itemSize,
                                this.normalized
                            );
                        }
                        return (
                            void 0 === e.interleavedBuffers &&
                                (e.interleavedBuffers = {}),
                            void 0 === e.interleavedBuffers[this.data.uuid] &&
                                (e.interleavedBuffers[this.data.uuid] =
                                    this.data.clone(e)),
                            new fh(
                                e.interleavedBuffers[this.data.uuid],
                                this.itemSize,
                                this.offset,
                                this.normalized
                            )
                        );
                    }
                    toJSON(e) {
                        if (void 0 === e) {
                            console.log(
                                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
                            );
                            const e = [];
                            for (let t = 0; t < this.count; t++) {
                                const i = t * this.data.stride + this.offset;
                                for (let t = 0; t < this.itemSize; t++)
                                    e.push(this.data.array[i + t]);
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: e,
                                normalized: this.normalized,
                            };
                        }
                        return (
                            void 0 === e.interleavedBuffers &&
                                (e.interleavedBuffers = {}),
                            void 0 === e.interleavedBuffers[this.data.uuid] &&
                                (e.interleavedBuffers[this.data.uuid] =
                                    this.data.toJSON(e)),
                            {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized,
                            }
                        );
                    }
                }
                fh.prototype.isInterleavedBufferAttribute = !0;
                class _h extends va {
                    constructor(e) {
                        super(),
                            (this.type = "SpriteMaterial"),
                            (this.color = new Na(16777215)),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.rotation = 0),
                            (this.sizeAttenuation = !0),
                            (this.transparent = !0),
                            this.setValues(e);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.color.copy(e.color),
                            (this.map = e.map),
                            (this.alphaMap = e.alphaMap),
                            (this.rotation = e.rotation),
                            (this.sizeAttenuation = e.sizeAttenuation),
                            this
                        );
                    }
                }
                let Mh;
                _h.prototype.isSpriteMaterial = !0;
                const vh = new rs(),
                    yh = new rs(),
                    xh = new rs(),
                    bh = new Gr(),
                    wh = new Gr(),
                    Th = new Os(),
                    Sh = new rs(),
                    Nh = new rs(),
                    Dh = new rs(),
                    Ih = new Gr(),
                    Ch = new Gr(),
                    Ah = new Gr();
                class Eh extends aa {
                    constructor(e) {
                        if ((super(), (this.type = "Sprite"), void 0 === Mh)) {
                            Mh = new Ba();
                            const e = new Float32Array([
                                    -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0,
                                    0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1,
                                ]),
                                t = new gh(e, 5);
                            Mh.setIndex([0, 1, 2, 0, 2, 3]),
                                Mh.setAttribute(
                                    "position",
                                    new fh(t, 3, 0, !1)
                                ),
                                Mh.setAttribute("uv", new fh(t, 2, 3, !1));
                        }
                        (this.geometry = Mh),
                            (this.material = void 0 !== e ? e : new _h()),
                            (this.center = new Gr(0.5, 0.5));
                    }
                    raycast(e, t) {
                        null === e.camera &&
                            console.error(
                                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
                            ),
                            yh.setFromMatrixScale(this.matrixWorld),
                            Th.copy(e.camera.matrixWorld),
                            this.modelViewMatrix.multiplyMatrices(
                                e.camera.matrixWorldInverse,
                                this.matrixWorld
                            ),
                            xh.setFromMatrixPosition(this.modelViewMatrix),
                            e.camera.isPerspectiveCamera &&
                                !1 === this.material.sizeAttenuation &&
                                yh.multiplyScalar(-xh.z);
                        const i = this.material.rotation;
                        let n, r;
                        0 !== i && ((r = Math.cos(i)), (n = Math.sin(i)));
                        const s = this.center;
                        Lh(Sh.set(-0.5, -0.5, 0), xh, s, yh, n, r),
                            Lh(Nh.set(0.5, -0.5, 0), xh, s, yh, n, r),
                            Lh(Dh.set(0.5, 0.5, 0), xh, s, yh, n, r),
                            Ih.set(0, 0),
                            Ch.set(1, 0),
                            Ah.set(1, 1);
                        let a = e.ray.intersectTriangle(Sh, Nh, Dh, !1, vh);
                        if (
                            null === a &&
                            (Lh(Nh.set(-0.5, 0.5, 0), xh, s, yh, n, r),
                            Ch.set(0, 1),
                            (a = e.ray.intersectTriangle(Sh, Dh, Nh, !1, vh)),
                            null === a)
                        )
                            return;
                        const o = e.ray.origin.distanceTo(vh);
                        o < e.near ||
                            o > e.far ||
                            t.push({
                                distance: o,
                                point: vh.clone(),
                                uv: _a.getUV(
                                    vh,
                                    Sh,
                                    Nh,
                                    Dh,
                                    Ih,
                                    Ch,
                                    Ah,
                                    new Gr()
                                ),
                                face: null,
                                object: this,
                            });
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            void 0 !== e.center && this.center.copy(e.center),
                            (this.material = e.material),
                            this
                        );
                    }
                }
                function Lh(e, t, i, n, r, s) {
                    bh.subVectors(e, i).addScalar(0.5).multiply(n),
                        void 0 !== r
                            ? ((wh.x = s * bh.x - r * bh.y),
                              (wh.y = r * bh.x + s * bh.y))
                            : wh.copy(bh),
                        e.copy(t),
                        (e.x += wh.x),
                        (e.y += wh.y),
                        e.applyMatrix4(Th);
                }
                Eh.prototype.isSprite = !0;
                const zh = new rs(),
                    jh = new es(),
                    Oh = new es(),
                    kh = new rs(),
                    Rh = new Os();
                class Ph extends so {
                    constructor(e, t) {
                        super(e, t),
                            (this.type = "SkinnedMesh"),
                            (this.bindMode = "attached"),
                            (this.bindMatrix = new Os()),
                            (this.bindMatrixInverse = new Os());
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.bindMode = e.bindMode),
                            this.bindMatrix.copy(e.bindMatrix),
                            this.bindMatrixInverse.copy(e.bindMatrixInverse),
                            (this.skeleton = e.skeleton),
                            this
                        );
                    }
                    bind(e, t) {
                        (this.skeleton = e),
                            void 0 === t &&
                                (this.updateMatrixWorld(!0),
                                this.skeleton.calculateInverses(),
                                (t = this.matrixWorld)),
                            this.bindMatrix.copy(t),
                            this.bindMatrixInverse.copy(t).invert();
                    }
                    pose() {
                        this.skeleton.pose();
                    }
                    normalizeSkinWeights() {
                        const e = new es(),
                            t = this.geometry.attributes.skinWeight;
                        for (let i = 0, n = t.count; i < n; i++) {
                            (e.x = t.getX(i)),
                                (e.y = t.getY(i)),
                                (e.z = t.getZ(i)),
                                (e.w = t.getW(i));
                            const n = 1 / e.manhattanLength();
                            n !== 1 / 0
                                ? e.multiplyScalar(n)
                                : e.set(1, 0, 0, 0),
                                t.setXYZW(i, e.x, e.y, e.z, e.w);
                        }
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e),
                            "attached" === this.bindMode
                                ? this.bindMatrixInverse
                                      .copy(this.matrixWorld)
                                      .invert()
                                : "detached" === this.bindMode
                                ? this.bindMatrixInverse
                                      .copy(this.bindMatrix)
                                      .invert()
                                : console.warn(
                                      "THREE.SkinnedMesh: Unrecognized bindMode: " +
                                          this.bindMode
                                  );
                    }
                    boneTransform(e, t) {
                        const i = this.skeleton,
                            n = this.geometry;
                        jh.fromBufferAttribute(n.attributes.skinIndex, e),
                            Oh.fromBufferAttribute(n.attributes.skinWeight, e),
                            zh.copy(t).applyMatrix4(this.bindMatrix),
                            t.set(0, 0, 0);
                        for (let e = 0; e < 4; e++) {
                            const n = Oh.getComponent(e);
                            if (0 !== n) {
                                const r = jh.getComponent(e);
                                Rh.multiplyMatrices(
                                    i.bones[r].matrixWorld,
                                    i.boneInverses[r]
                                ),
                                    t.addScaledVector(
                                        kh.copy(zh).applyMatrix4(Rh),
                                        n
                                    );
                            }
                        }
                        return t.applyMatrix4(this.bindMatrixInverse);
                    }
                }
                (Ph.prototype.isSkinnedMesh = !0),
                    (class extends aa {
                        constructor() {
                            super(), (this.type = "Bone");
                        }
                    }.prototype.isBone = !0),
                    (class extends Jr {
                        constructor(
                            e = null,
                            t = 1,
                            i = 1,
                            n,
                            r,
                            s,
                            a,
                            o,
                            c = Vi,
                            l = Vi,
                            h,
                            u
                        ) {
                            super(null, s, a, o, c, l, n, r, h, u),
                                (this.image = { data: e, width: t, height: i }),
                                (this.magFilter = c),
                                (this.minFilter = l),
                                (this.generateMipmaps = !1),
                                (this.flipY = !1),
                                (this.unpackAlignment = 1),
                                (this.needsUpdate = !0);
                        }
                    }.prototype.isDataTexture = !0);
                class Uh extends Aa {
                    constructor(e, t, i, n = 1) {
                        "number" == typeof i &&
                            ((n = i),
                            (i = !1),
                            console.error(
                                "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
                            )),
                            super(e, t, i),
                            (this.meshPerAttribute = n);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.meshPerAttribute = e.meshPerAttribute),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (
                            (e.meshPerAttribute = this.meshPerAttribute),
                            (e.isInstancedBufferAttribute = !0),
                            e
                        );
                    }
                }
                Uh.prototype.isInstancedBufferAttribute = !0;
                const $h = new Os(),
                    Bh = new Os(),
                    Fh = [],
                    Hh = new so();
                (class extends so {
                    constructor(e, t, i) {
                        super(e, t),
                            (this.instanceMatrix = new Uh(
                                new Float32Array(16 * i),
                                16
                            )),
                            (this.instanceColor = null),
                            (this.count = i),
                            (this.frustumCulled = !1);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.instanceMatrix.copy(e.instanceMatrix),
                            null !== e.instanceColor &&
                                (this.instanceColor = e.instanceColor.clone()),
                            (this.count = e.count),
                            this
                        );
                    }
                    getColorAt(e, t) {
                        t.fromArray(this.instanceColor.array, 3 * e);
                    }
                    getMatrixAt(e, t) {
                        t.fromArray(this.instanceMatrix.array, 16 * e);
                    }
                    raycast(e, t) {
                        const i = this.matrixWorld,
                            n = this.count;
                        if (
                            ((Hh.geometry = this.geometry),
                            (Hh.material = this.material),
                            void 0 !== Hh.material)
                        )
                            for (let r = 0; r < n; r++) {
                                this.getMatrixAt(r, $h),
                                    Bh.multiplyMatrices(i, $h),
                                    (Hh.matrixWorld = Bh),
                                    Hh.raycast(e, Fh);
                                for (let e = 0, i = Fh.length; e < i; e++) {
                                    const i = Fh[e];
                                    (i.instanceId = r),
                                        (i.object = this),
                                        t.push(i);
                                }
                                Fh.length = 0;
                            }
                    }
                    setColorAt(e, t) {
                        null === this.instanceColor &&
                            (this.instanceColor = new Uh(
                                new Float32Array(3 * this.instanceMatrix.count),
                                3
                            )),
                            t.toArray(this.instanceColor.array, 3 * e);
                    }
                    setMatrixAt(e, t) {
                        t.toArray(this.instanceMatrix.array, 16 * e);
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({ type: "dispose" });
                    }
                }).prototype.isInstancedMesh = !0;
                class Gh extends va {
                    constructor(e) {
                        super(),
                            (this.type = "LineBasicMaterial"),
                            (this.color = new Na(16777215)),
                            (this.linewidth = 1),
                            (this.linecap = "round"),
                            (this.linejoin = "round"),
                            this.setValues(e);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.color.copy(e.color),
                            (this.linewidth = e.linewidth),
                            (this.linecap = e.linecap),
                            (this.linejoin = e.linejoin),
                            this
                        );
                    }
                }
                Gh.prototype.isLineBasicMaterial = !0;
                const Vh = new rs(),
                    Yh = new rs(),
                    qh = new Os(),
                    Wh = new js(),
                    Qh = new Ns();
                class Zh extends aa {
                    constructor(e = new Ba(), t = new Gh()) {
                        super(),
                            (this.type = "Line"),
                            (this.geometry = e),
                            (this.material = t),
                            this.updateMorphTargets();
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.material = e.material),
                            (this.geometry = e.geometry),
                            this
                        );
                    }
                    computeLineDistances() {
                        const e = this.geometry;
                        if (e.isBufferGeometry)
                            if (null === e.index) {
                                const t = e.attributes.position,
                                    i = [0];
                                for (let e = 1, n = t.count; e < n; e++)
                                    Vh.fromBufferAttribute(t, e - 1),
                                        Yh.fromBufferAttribute(t, e),
                                        (i[e] = i[e - 1]),
                                        (i[e] += Vh.distanceTo(Yh));
                                e.setAttribute("lineDistance", new za(i, 1));
                            } else
                                console.warn(
                                    "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                                );
                        else
                            e.isGeometry &&
                                console.error(
                                    "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                                );
                        return this;
                    }
                    raycast(e, t) {
                        const i = this.geometry,
                            n = this.matrixWorld,
                            r = e.params.Line.threshold,
                            s = i.drawRange;
                        if (
                            (null === i.boundingSphere &&
                                i.computeBoundingSphere(),
                            Qh.copy(i.boundingSphere),
                            Qh.applyMatrix4(n),
                            (Qh.radius += r),
                            !1 === e.ray.intersectsSphere(Qh))
                        )
                            return;
                        qh.copy(n).invert(), Wh.copy(e.ray).applyMatrix4(qh);
                        const a =
                                r /
                                ((this.scale.x + this.scale.y + this.scale.z) /
                                    3),
                            o = a * a,
                            c = new rs(),
                            l = new rs(),
                            h = new rs(),
                            u = new rs(),
                            d = this.isLineSegments ? 2 : 1;
                        if (i.isBufferGeometry) {
                            const n = i.index,
                                r = i.attributes.position;
                            if (null !== n)
                                for (
                                    let i = Math.max(0, s.start),
                                        a =
                                            Math.min(
                                                n.count,
                                                s.start + s.count
                                            ) - 1;
                                    i < a;
                                    i += d
                                ) {
                                    const s = n.getX(i),
                                        a = n.getX(i + 1);
                                    if (
                                        (c.fromBufferAttribute(r, s),
                                        l.fromBufferAttribute(r, a),
                                        Wh.distanceSqToSegment(c, l, u, h) > o)
                                    )
                                        continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const d = e.ray.origin.distanceTo(u);
                                    d < e.near ||
                                        d > e.far ||
                                        t.push({
                                            distance: d,
                                            point: h
                                                .clone()
                                                .applyMatrix4(this.matrixWorld),
                                            index: i,
                                            face: null,
                                            faceIndex: null,
                                            object: this,
                                        });
                                }
                            else
                                for (
                                    let i = Math.max(0, s.start),
                                        n =
                                            Math.min(
                                                r.count,
                                                s.start + s.count
                                            ) - 1;
                                    i < n;
                                    i += d
                                ) {
                                    if (
                                        (c.fromBufferAttribute(r, i),
                                        l.fromBufferAttribute(r, i + 1),
                                        Wh.distanceSqToSegment(c, l, u, h) > o)
                                    )
                                        continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const n = e.ray.origin.distanceTo(u);
                                    n < e.near ||
                                        n > e.far ||
                                        t.push({
                                            distance: n,
                                            point: h
                                                .clone()
                                                .applyMatrix4(this.matrixWorld),
                                            index: i,
                                            face: null,
                                            faceIndex: null,
                                            object: this,
                                        });
                                }
                        } else
                            i.isGeometry &&
                                console.error(
                                    "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                                );
                    }
                    updateMorphTargets() {
                        const e = this.geometry;
                        if (e.isBufferGeometry) {
                            const t = e.morphAttributes,
                                i = Object.keys(t);
                            if (i.length > 0) {
                                const e = t[i[0]];
                                if (void 0 !== e) {
                                    (this.morphTargetInfluences = []),
                                        (this.morphTargetDictionary = {});
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = e[t].name || String(t);
                                        this.morphTargetInfluences.push(0),
                                            (this.morphTargetDictionary[i] = t);
                                    }
                                }
                            }
                        } else {
                            const t = e.morphTargets;
                            void 0 !== t &&
                                t.length > 0 &&
                                console.error(
                                    "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                                );
                        }
                    }
                }
                Zh.prototype.isLine = !0;
                const Xh = new rs(),
                    Jh = new rs();
                class Kh extends Zh {
                    constructor(e, t) {
                        super(e, t), (this.type = "LineSegments");
                    }
                    computeLineDistances() {
                        const e = this.geometry;
                        if (e.isBufferGeometry)
                            if (null === e.index) {
                                const t = e.attributes.position,
                                    i = [];
                                for (let e = 0, n = t.count; e < n; e += 2)
                                    Xh.fromBufferAttribute(t, e),
                                        Jh.fromBufferAttribute(t, e + 1),
                                        (i[e] = 0 === e ? 0 : i[e - 1]),
                                        (i[e + 1] = i[e] + Xh.distanceTo(Jh));
                                e.setAttribute("lineDistance", new za(i, 1));
                            } else
                                console.warn(
                                    "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                                );
                        else
                            e.isGeometry &&
                                console.error(
                                    "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                                );
                        return this;
                    }
                }
                (Kh.prototype.isLineSegments = !0),
                    (class extends Zh {
                        constructor(e, t) {
                            super(e, t), (this.type = "LineLoop");
                        }
                    }.prototype.isLineLoop = !0);
                class eu extends va {
                    constructor(e) {
                        super(),
                            (this.type = "PointsMaterial"),
                            (this.color = new Na(16777215)),
                            (this.map = null),
                            (this.alphaMap = null),
                            (this.size = 1),
                            (this.sizeAttenuation = !0),
                            this.setValues(e);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.color.copy(e.color),
                            (this.map = e.map),
                            (this.alphaMap = e.alphaMap),
                            (this.size = e.size),
                            (this.sizeAttenuation = e.sizeAttenuation),
                            this
                        );
                    }
                }
                eu.prototype.isPointsMaterial = !0;
                const tu = new Os(),
                    iu = new js(),
                    nu = new Ns(),
                    ru = new rs();
                class su extends aa {
                    constructor(e = new Ba(), t = new eu()) {
                        super(),
                            (this.type = "Points"),
                            (this.geometry = e),
                            (this.material = t),
                            this.updateMorphTargets();
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.material = e.material),
                            (this.geometry = e.geometry),
                            this
                        );
                    }
                    raycast(e, t) {
                        const i = this.geometry,
                            n = this.matrixWorld,
                            r = e.params.Points.threshold,
                            s = i.drawRange;
                        if (
                            (null === i.boundingSphere &&
                                i.computeBoundingSphere(),
                            nu.copy(i.boundingSphere),
                            nu.applyMatrix4(n),
                            (nu.radius += r),
                            !1 === e.ray.intersectsSphere(nu))
                        )
                            return;
                        tu.copy(n).invert(), iu.copy(e.ray).applyMatrix4(tu);
                        const a =
                                r /
                                ((this.scale.x + this.scale.y + this.scale.z) /
                                    3),
                            o = a * a;
                        if (i.isBufferGeometry) {
                            const r = i.index,
                                a = i.attributes.position;
                            if (null !== r)
                                for (
                                    let i = Math.max(0, s.start),
                                        c = Math.min(
                                            r.count,
                                            s.start + s.count
                                        );
                                    i < c;
                                    i++
                                ) {
                                    const s = r.getX(i);
                                    ru.fromBufferAttribute(a, s),
                                        au(ru, s, o, n, e, t, this);
                                }
                            else
                                for (
                                    let i = Math.max(0, s.start),
                                        r = Math.min(
                                            a.count,
                                            s.start + s.count
                                        );
                                    i < r;
                                    i++
                                )
                                    ru.fromBufferAttribute(a, i),
                                        au(ru, i, o, n, e, t, this);
                        } else
                            console.error(
                                "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                            );
                    }
                    updateMorphTargets() {
                        const e = this.geometry;
                        if (e.isBufferGeometry) {
                            const t = e.morphAttributes,
                                i = Object.keys(t);
                            if (i.length > 0) {
                                const e = t[i[0]];
                                if (void 0 !== e) {
                                    (this.morphTargetInfluences = []),
                                        (this.morphTargetDictionary = {});
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = e[t].name || String(t);
                                        this.morphTargetInfluences.push(0),
                                            (this.morphTargetDictionary[i] = t);
                                    }
                                }
                            }
                        } else {
                            const t = e.morphTargets;
                            void 0 !== t &&
                                t.length > 0 &&
                                console.error(
                                    "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                                );
                        }
                    }
                }
                function au(e, t, i, n, r, s, a) {
                    const o = iu.distanceSqToPoint(e);
                    if (o < i) {
                        const i = new rs();
                        iu.closestPointToPoint(e, i), i.applyMatrix4(n);
                        const c = r.ray.origin.distanceTo(i);
                        if (c < r.near || c > r.far) return;
                        s.push({
                            distance: c,
                            distanceToRay: Math.sqrt(o),
                            point: i,
                            index: t,
                            face: null,
                            object: a,
                        });
                    }
                }
                (su.prototype.isPoints = !0),
                    (class extends Jr {
                        constructor(e, t, i, n, r, s, a, o, c) {
                            super(e, t, i, n, r, s, a, o, c),
                                (this.format = void 0 !== a ? a : un),
                                (this.minFilter = void 0 !== s ? s : Wi),
                                (this.magFilter = void 0 !== r ? r : Wi),
                                (this.generateMipmaps = !1);
                            const l = this;
                            "requestVideoFrameCallback" in e &&
                                e.requestVideoFrameCallback(function t() {
                                    (l.needsUpdate = !0),
                                        e.requestVideoFrameCallback(t);
                                });
                        }
                        clone() {
                            return new this.constructor(this.image).copy(this);
                        }
                        update() {
                            const e = this.image;
                            !1 == "requestVideoFrameCallback" in e &&
                                e.readyState >= e.HAVE_CURRENT_DATA &&
                                (this.needsUpdate = !0);
                        }
                    }.prototype.isVideoTexture = !0),
                    (class extends Jr {
                        constructor(e, t, i, n, r, s, a, o, c, l, h, u) {
                            super(null, s, a, o, c, l, n, r, h, u),
                                (this.image = { width: t, height: i }),
                                (this.mipmaps = e),
                                (this.flipY = !1),
                                (this.generateMipmaps = !1);
                        }
                    }.prototype.isCompressedTexture = !0),
                    (class extends Jr {
                        constructor(e, t, i, n, r, s, a, o, c) {
                            super(e, t, i, n, r, s, a, o, c),
                                (this.needsUpdate = !0);
                        }
                    }.prototype.isCanvasTexture = !0),
                    (class extends Jr {
                        constructor(e, t, i, n, r, s, a, o, c, l) {
                            if ((l = void 0 !== l ? l : fn) !== fn && l !== _n)
                                throw new Error(
                                    "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
                                );
                            void 0 === i && l === fn && (i = en),
                                void 0 === i && l === _n && (i = ln),
                                super(null, n, r, s, a, o, l, i, c),
                                (this.image = { width: e, height: t }),
                                (this.magFilter = void 0 !== a ? a : Vi),
                                (this.minFilter = void 0 !== o ? o : Vi),
                                (this.flipY = !1),
                                (this.generateMipmaps = !1);
                        }
                    }.prototype.isDepthTexture = !0),
                    new rs(),
                    new rs(),
                    new rs(),
                    new _a();
                class ou {
                    constructor() {
                        (this.type = "Curve"), (this.arcLengthDivisions = 200);
                    }
                    getPoint() {
                        return (
                            console.warn(
                                "THREE.Curve: .getPoint() not implemented."
                            ),
                            null
                        );
                    }
                    getPointAt(e, t) {
                        const i = this.getUtoTmapping(e);
                        return this.getPoint(i, t);
                    }
                    getPoints(e = 5) {
                        const t = [];
                        for (let i = 0; i <= e; i++)
                            t.push(this.getPoint(i / e));
                        return t;
                    }
                    getSpacedPoints(e = 5) {
                        const t = [];
                        for (let i = 0; i <= e; i++)
                            t.push(this.getPointAt(i / e));
                        return t;
                    }
                    getLength() {
                        const e = this.getLengths();
                        return e[e.length - 1];
                    }
                    getLengths(e = this.arcLengthDivisions) {
                        if (
                            this.cacheArcLengths &&
                            this.cacheArcLengths.length === e + 1 &&
                            !this.needsUpdate
                        )
                            return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const t = [];
                        let i,
                            n = this.getPoint(0),
                            r = 0;
                        t.push(0);
                        for (let s = 1; s <= e; s++)
                            (i = this.getPoint(s / e)),
                                (r += i.distanceTo(n)),
                                t.push(r),
                                (n = i);
                        return (this.cacheArcLengths = t), t;
                    }
                    updateArcLengths() {
                        (this.needsUpdate = !0), this.getLengths();
                    }
                    getUtoTmapping(e, t) {
                        const i = this.getLengths();
                        let n = 0;
                        const r = i.length;
                        let s;
                        s = t || e * i[r - 1];
                        let a,
                            o = 0,
                            c = r - 1;
                        for (; o <= c; )
                            if (
                                ((n = Math.floor(o + (c - o) / 2)),
                                (a = i[n] - s),
                                a < 0)
                            )
                                o = n + 1;
                            else {
                                if (!(a > 0)) {
                                    c = n;
                                    break;
                                }
                                c = n - 1;
                            }
                        if (((n = c), i[n] === s)) return n / (r - 1);
                        const l = i[n];
                        return (n + (s - l) / (i[n + 1] - l)) / (r - 1);
                    }
                    getTangent(e, t) {
                        const i = 1e-4;
                        let n = e - i,
                            r = e + i;
                        n < 0 && (n = 0), r > 1 && (r = 1);
                        const s = this.getPoint(n),
                            a = this.getPoint(r),
                            o = t || (s.isVector2 ? new Gr() : new rs());
                        return o.copy(a).sub(s).normalize(), o;
                    }
                    getTangentAt(e, t) {
                        const i = this.getUtoTmapping(e);
                        return this.getTangent(i, t);
                    }
                    computeFrenetFrames(e, t) {
                        const i = new rs(),
                            n = [],
                            r = [],
                            s = [],
                            a = new rs(),
                            o = new Os();
                        for (let t = 0; t <= e; t++) {
                            const i = t / e;
                            n[t] = this.getTangentAt(i, new rs());
                        }
                        (r[0] = new rs()), (s[0] = new rs());
                        let c = Number.MAX_VALUE;
                        const l = Math.abs(n[0].x),
                            h = Math.abs(n[0].y),
                            u = Math.abs(n[0].z);
                        l <= c && ((c = l), i.set(1, 0, 0)),
                            h <= c && ((c = h), i.set(0, 1, 0)),
                            u <= c && i.set(0, 0, 1),
                            a.crossVectors(n[0], i).normalize(),
                            r[0].crossVectors(n[0], a),
                            s[0].crossVectors(n[0], r[0]);
                        for (let t = 1; t <= e; t++) {
                            if (
                                ((r[t] = r[t - 1].clone()),
                                (s[t] = s[t - 1].clone()),
                                a.crossVectors(n[t - 1], n[t]),
                                a.length() > Number.EPSILON)
                            ) {
                                a.normalize();
                                const e = Math.acos(
                                    Pr(n[t - 1].dot(n[t]), -1, 1)
                                );
                                r[t].applyMatrix4(o.makeRotationAxis(a, e));
                            }
                            s[t].crossVectors(n[t], r[t]);
                        }
                        if (!0 === t) {
                            let t = Math.acos(Pr(r[0].dot(r[e]), -1, 1));
                            (t /= e),
                                n[0].dot(a.crossVectors(r[0], r[e])) > 0 &&
                                    (t = -t);
                            for (let i = 1; i <= e; i++)
                                r[i].applyMatrix4(
                                    o.makeRotationAxis(n[i], t * i)
                                ),
                                    s[i].crossVectors(n[i], r[i]);
                        }
                        return { tangents: n, normals: r, binormals: s };
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    copy(e) {
                        return (
                            (this.arcLengthDivisions = e.arcLengthDivisions),
                            this
                        );
                    }
                    toJSON() {
                        const e = {
                            metadata: {
                                version: 4.5,
                                type: "Curve",
                                generator: "Curve.toJSON",
                            },
                        };
                        return (
                            (e.arcLengthDivisions = this.arcLengthDivisions),
                            (e.type = this.type),
                            e
                        );
                    }
                    fromJSON(e) {
                        return (
                            (this.arcLengthDivisions = e.arcLengthDivisions),
                            this
                        );
                    }
                }
                class cu extends ou {
                    constructor(
                        e = 0,
                        t = 0,
                        i = 1,
                        n = 1,
                        r = 0,
                        s = 2 * Math.PI,
                        a = !1,
                        o = 0
                    ) {
                        super(),
                            (this.type = "EllipseCurve"),
                            (this.aX = e),
                            (this.aY = t),
                            (this.xRadius = i),
                            (this.yRadius = n),
                            (this.aStartAngle = r),
                            (this.aEndAngle = s),
                            (this.aClockwise = a),
                            (this.aRotation = o);
                    }
                    getPoint(e, t) {
                        const i = t || new Gr(),
                            n = 2 * Math.PI;
                        let r = this.aEndAngle - this.aStartAngle;
                        const s = Math.abs(r) < Number.EPSILON;
                        for (; r < 0; ) r += n;
                        for (; r > n; ) r -= n;
                        r < Number.EPSILON && (r = s ? 0 : n),
                            !0 !== this.aClockwise ||
                                s ||
                                (r === n ? (r = -n) : (r -= n));
                        const a = this.aStartAngle + e * r;
                        let o = this.aX + this.xRadius * Math.cos(a),
                            c = this.aY + this.yRadius * Math.sin(a);
                        if (0 !== this.aRotation) {
                            const e = Math.cos(this.aRotation),
                                t = Math.sin(this.aRotation),
                                i = o - this.aX,
                                n = c - this.aY;
                            (o = i * e - n * t + this.aX),
                                (c = i * t + n * e + this.aY);
                        }
                        return i.set(o, c);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.aX = e.aX),
                            (this.aY = e.aY),
                            (this.xRadius = e.xRadius),
                            (this.yRadius = e.yRadius),
                            (this.aStartAngle = e.aStartAngle),
                            (this.aEndAngle = e.aEndAngle),
                            (this.aClockwise = e.aClockwise),
                            (this.aRotation = e.aRotation),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (
                            (e.aX = this.aX),
                            (e.aY = this.aY),
                            (e.xRadius = this.xRadius),
                            (e.yRadius = this.yRadius),
                            (e.aStartAngle = this.aStartAngle),
                            (e.aEndAngle = this.aEndAngle),
                            (e.aClockwise = this.aClockwise),
                            (e.aRotation = this.aRotation),
                            e
                        );
                    }
                    fromJSON(e) {
                        return (
                            super.fromJSON(e),
                            (this.aX = e.aX),
                            (this.aY = e.aY),
                            (this.xRadius = e.xRadius),
                            (this.yRadius = e.yRadius),
                            (this.aStartAngle = e.aStartAngle),
                            (this.aEndAngle = e.aEndAngle),
                            (this.aClockwise = e.aClockwise),
                            (this.aRotation = e.aRotation),
                            this
                        );
                    }
                }
                cu.prototype.isEllipseCurve = !0;
                class lu extends cu {
                    constructor(e, t, i, n, r, s) {
                        super(e, t, i, i, n, r, s), (this.type = "ArcCurve");
                    }
                }
                function hu() {
                    let e = 0,
                        t = 0,
                        i = 0,
                        n = 0;
                    function r(r, s, a, o) {
                        (e = r),
                            (t = a),
                            (i = -3 * r + 3 * s - 2 * a - o),
                            (n = 2 * r - 2 * s + a + o);
                    }
                    return {
                        initCatmullRom: function (e, t, i, n, s) {
                            r(t, i, s * (i - e), s * (n - t));
                        },
                        initNonuniformCatmullRom: function (
                            e,
                            t,
                            i,
                            n,
                            s,
                            a,
                            o
                        ) {
                            let c =
                                    (t - e) / s -
                                    (i - e) / (s + a) +
                                    (i - t) / a,
                                l =
                                    (i - t) / a -
                                    (n - t) / (a + o) +
                                    (n - i) / o;
                            (c *= a), (l *= a), r(t, i, c, l);
                        },
                        calc: function (r) {
                            const s = r * r;
                            return e + t * r + i * s + n * (s * r);
                        },
                    };
                }
                lu.prototype.isArcCurve = !0;
                const uu = new rs(),
                    du = new hu(),
                    pu = new hu(),
                    gu = new hu();
                class mu extends ou {
                    constructor(e = [], t = !1, i = "centripetal", n = 0.5) {
                        super(),
                            (this.type = "CatmullRomCurve3"),
                            (this.points = e),
                            (this.closed = t),
                            (this.curveType = i),
                            (this.tension = n);
                    }
                    getPoint(e, t = new rs()) {
                        const i = t,
                            n = this.points,
                            r = n.length,
                            s = (r - (this.closed ? 0 : 1)) * e;
                        let a,
                            o,
                            c = Math.floor(s),
                            l = s - c;
                        this.closed
                            ? (c +=
                                  c > 0
                                      ? 0
                                      : (Math.floor(Math.abs(c) / r) + 1) * r)
                            : 0 === l && c === r - 1 && ((c = r - 2), (l = 1)),
                            this.closed || c > 0
                                ? (a = n[(c - 1) % r])
                                : (uu.subVectors(n[0], n[1]).add(n[0]),
                                  (a = uu));
                        const h = n[c % r],
                            u = n[(c + 1) % r];
                        if (
                            (this.closed || c + 2 < r
                                ? (o = n[(c + 2) % r])
                                : (uu
                                      .subVectors(n[r - 1], n[r - 2])
                                      .add(n[r - 1]),
                                  (o = uu)),
                            "centripetal" === this.curveType ||
                                "chordal" === this.curveType)
                        ) {
                            const e = "chordal" === this.curveType ? 0.5 : 0.25;
                            let t = Math.pow(a.distanceToSquared(h), e),
                                i = Math.pow(h.distanceToSquared(u), e),
                                n = Math.pow(u.distanceToSquared(o), e);
                            i < 1e-4 && (i = 1),
                                t < 1e-4 && (t = i),
                                n < 1e-4 && (n = i),
                                du.initNonuniformCatmullRom(
                                    a.x,
                                    h.x,
                                    u.x,
                                    o.x,
                                    t,
                                    i,
                                    n
                                ),
                                pu.initNonuniformCatmullRom(
                                    a.y,
                                    h.y,
                                    u.y,
                                    o.y,
                                    t,
                                    i,
                                    n
                                ),
                                gu.initNonuniformCatmullRom(
                                    a.z,
                                    h.z,
                                    u.z,
                                    o.z,
                                    t,
                                    i,
                                    n
                                );
                        } else
                            "catmullrom" === this.curveType &&
                                (du.initCatmullRom(
                                    a.x,
                                    h.x,
                                    u.x,
                                    o.x,
                                    this.tension
                                ),
                                pu.initCatmullRom(
                                    a.y,
                                    h.y,
                                    u.y,
                                    o.y,
                                    this.tension
                                ),
                                gu.initCatmullRom(
                                    a.z,
                                    h.z,
                                    u.z,
                                    o.z,
                                    this.tension
                                ));
                        return i.set(du.calc(l), pu.calc(l), gu.calc(l)), i;
                    }
                    copy(e) {
                        super.copy(e), (this.points = []);
                        for (let t = 0, i = e.points.length; t < i; t++) {
                            const i = e.points[t];
                            this.points.push(i.clone());
                        }
                        return (
                            (this.closed = e.closed),
                            (this.curveType = e.curveType),
                            (this.tension = e.tension),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, i = this.points.length; t < i; t++) {
                            const i = this.points[t];
                            e.points.push(i.toArray());
                        }
                        return (
                            (e.closed = this.closed),
                            (e.curveType = this.curveType),
                            (e.tension = this.tension),
                            e
                        );
                    }
                    fromJSON(e) {
                        super.fromJSON(e), (this.points = []);
                        for (let t = 0, i = e.points.length; t < i; t++) {
                            const i = e.points[t];
                            this.points.push(new rs().fromArray(i));
                        }
                        return (
                            (this.closed = e.closed),
                            (this.curveType = e.curveType),
                            (this.tension = e.tension),
                            this
                        );
                    }
                }
                function fu(e, t, i, n, r) {
                    const s = 0.5 * (n - t),
                        a = 0.5 * (r - i),
                        o = e * e;
                    return (
                        (2 * i - 2 * n + s + a) * (e * o) +
                        (-3 * i + 3 * n - 2 * s - a) * o +
                        s * e +
                        i
                    );
                }
                function _u(e, t, i, n) {
                    return (
                        (function (e, t) {
                            const i = 1 - e;
                            return i * i * t;
                        })(e, t) +
                        (function (e, t) {
                            return 2 * (1 - e) * e * t;
                        })(e, i) +
                        (function (e, t) {
                            return e * e * t;
                        })(e, n)
                    );
                }
                function Mu(e, t, i, n, r) {
                    return (
                        (function (e, t) {
                            const i = 1 - e;
                            return i * i * i * t;
                        })(e, t) +
                        (function (e, t) {
                            const i = 1 - e;
                            return 3 * i * i * e * t;
                        })(e, i) +
                        (function (e, t) {
                            return 3 * (1 - e) * e * e * t;
                        })(e, n) +
                        (function (e, t) {
                            return e * e * e * t;
                        })(e, r)
                    );
                }
                mu.prototype.isCatmullRomCurve3 = !0;
                class vu extends ou {
                    constructor(
                        e = new Gr(),
                        t = new Gr(),
                        i = new Gr(),
                        n = new Gr()
                    ) {
                        super(),
                            (this.type = "CubicBezierCurve"),
                            (this.v0 = e),
                            (this.v1 = t),
                            (this.v2 = i),
                            (this.v3 = n);
                    }
                    getPoint(e, t = new Gr()) {
                        const i = t,
                            n = this.v0,
                            r = this.v1,
                            s = this.v2,
                            a = this.v3;
                        return (
                            i.set(
                                Mu(e, n.x, r.x, s.x, a.x),
                                Mu(e, n.y, r.y, s.y, a.y)
                            ),
                            i
                        );
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.v0.copy(e.v0),
                            this.v1.copy(e.v1),
                            this.v2.copy(e.v2),
                            this.v3.copy(e.v3),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (
                            (e.v0 = this.v0.toArray()),
                            (e.v1 = this.v1.toArray()),
                            (e.v2 = this.v2.toArray()),
                            (e.v3 = this.v3.toArray()),
                            e
                        );
                    }
                    fromJSON(e) {
                        return (
                            super.fromJSON(e),
                            this.v0.fromArray(e.v0),
                            this.v1.fromArray(e.v1),
                            this.v2.fromArray(e.v2),
                            this.v3.fromArray(e.v3),
                            this
                        );
                    }
                }
                vu.prototype.isCubicBezierCurve = !0;
                class yu extends ou {
                    constructor(
                        e = new rs(),
                        t = new rs(),
                        i = new rs(),
                        n = new rs()
                    ) {
                        super(),
                            (this.type = "CubicBezierCurve3"),
                            (this.v0 = e),
                            (this.v1 = t),
                            (this.v2 = i),
                            (this.v3 = n);
                    }
                    getPoint(e, t = new rs()) {
                        const i = t,
                            n = this.v0,
                            r = this.v1,
                            s = this.v2,
                            a = this.v3;
                        return (
                            i.set(
                                Mu(e, n.x, r.x, s.x, a.x),
                                Mu(e, n.y, r.y, s.y, a.y),
                                Mu(e, n.z, r.z, s.z, a.z)
                            ),
                            i
                        );
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.v0.copy(e.v0),
                            this.v1.copy(e.v1),
                            this.v2.copy(e.v2),
                            this.v3.copy(e.v3),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (
                            (e.v0 = this.v0.toArray()),
                            (e.v1 = this.v1.toArray()),
                            (e.v2 = this.v2.toArray()),
                            (e.v3 = this.v3.toArray()),
                            e
                        );
                    }
                    fromJSON(e) {
                        return (
                            super.fromJSON(e),
                            this.v0.fromArray(e.v0),
                            this.v1.fromArray(e.v1),
                            this.v2.fromArray(e.v2),
                            this.v3.fromArray(e.v3),
                            this
                        );
                    }
                }
                yu.prototype.isCubicBezierCurve3 = !0;
                class xu extends ou {
                    constructor(e = new Gr(), t = new Gr()) {
                        super(),
                            (this.type = "LineCurve"),
                            (this.v1 = e),
                            (this.v2 = t);
                    }
                    getPoint(e, t = new Gr()) {
                        const i = t;
                        return (
                            1 === e
                                ? i.copy(this.v2)
                                : (i.copy(this.v2).sub(this.v1),
                                  i.multiplyScalar(e).add(this.v1)),
                            i
                        );
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t);
                    }
                    getTangent(e, t) {
                        const i = t || new Gr();
                        return i.copy(this.v2).sub(this.v1).normalize(), i;
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.v1.copy(e.v1),
                            this.v2.copy(e.v2),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (
                            (e.v1 = this.v1.toArray()),
                            (e.v2 = this.v2.toArray()),
                            e
                        );
                    }
                    fromJSON(e) {
                        return (
                            super.fromJSON(e),
                            this.v1.fromArray(e.v1),
                            this.v2.fromArray(e.v2),
                            this
                        );
                    }
                }
                xu.prototype.isLineCurve = !0;
                class bu extends ou {
                    constructor(e = new Gr(), t = new Gr(), i = new Gr()) {
                        super(),
                            (this.type = "QuadraticBezierCurve"),
                            (this.v0 = e),
                            (this.v1 = t),
                            (this.v2 = i);
                    }
                    getPoint(e, t = new Gr()) {
                        const i = t,
                            n = this.v0,
                            r = this.v1,
                            s = this.v2;
                        return (
                            i.set(_u(e, n.x, r.x, s.x), _u(e, n.y, r.y, s.y)), i
                        );
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.v0.copy(e.v0),
                            this.v1.copy(e.v1),
                            this.v2.copy(e.v2),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (
                            (e.v0 = this.v0.toArray()),
                            (e.v1 = this.v1.toArray()),
                            (e.v2 = this.v2.toArray()),
                            e
                        );
                    }
                    fromJSON(e) {
                        return (
                            super.fromJSON(e),
                            this.v0.fromArray(e.v0),
                            this.v1.fromArray(e.v1),
                            this.v2.fromArray(e.v2),
                            this
                        );
                    }
                }
                bu.prototype.isQuadraticBezierCurve = !0;
                class wu extends ou {
                    constructor(e = new rs(), t = new rs(), i = new rs()) {
                        super(),
                            (this.type = "QuadraticBezierCurve3"),
                            (this.v0 = e),
                            (this.v1 = t),
                            (this.v2 = i);
                    }
                    getPoint(e, t = new rs()) {
                        const i = t,
                            n = this.v0,
                            r = this.v1,
                            s = this.v2;
                        return (
                            i.set(
                                _u(e, n.x, r.x, s.x),
                                _u(e, n.y, r.y, s.y),
                                _u(e, n.z, r.z, s.z)
                            ),
                            i
                        );
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.v0.copy(e.v0),
                            this.v1.copy(e.v1),
                            this.v2.copy(e.v2),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (
                            (e.v0 = this.v0.toArray()),
                            (e.v1 = this.v1.toArray()),
                            (e.v2 = this.v2.toArray()),
                            e
                        );
                    }
                    fromJSON(e) {
                        return (
                            super.fromJSON(e),
                            this.v0.fromArray(e.v0),
                            this.v1.fromArray(e.v1),
                            this.v2.fromArray(e.v2),
                            this
                        );
                    }
                }
                wu.prototype.isQuadraticBezierCurve3 = !0;
                class Tu extends ou {
                    constructor(e = []) {
                        super(), (this.type = "SplineCurve"), (this.points = e);
                    }
                    getPoint(e, t = new Gr()) {
                        const i = t,
                            n = this.points,
                            r = (n.length - 1) * e,
                            s = Math.floor(r),
                            a = r - s,
                            o = n[0 === s ? s : s - 1],
                            c = n[s],
                            l = n[s > n.length - 2 ? n.length - 1 : s + 1],
                            h = n[s > n.length - 3 ? n.length - 1 : s + 2];
                        return (
                            i.set(
                                fu(a, o.x, c.x, l.x, h.x),
                                fu(a, o.y, c.y, l.y, h.y)
                            ),
                            i
                        );
                    }
                    copy(e) {
                        super.copy(e), (this.points = []);
                        for (let t = 0, i = e.points.length; t < i; t++) {
                            const i = e.points[t];
                            this.points.push(i.clone());
                        }
                        return this;
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, i = this.points.length; t < i; t++) {
                            const i = this.points[t];
                            e.points.push(i.toArray());
                        }
                        return e;
                    }
                    fromJSON(e) {
                        super.fromJSON(e), (this.points = []);
                        for (let t = 0, i = e.points.length; t < i; t++) {
                            const i = e.points[t];
                            this.points.push(new Gr().fromArray(i));
                        }
                        return this;
                    }
                }
                Tu.prototype.isSplineCurve = !0;
                var Su = Object.freeze({
                    __proto__: null,
                    ArcCurve: lu,
                    CatmullRomCurve3: mu,
                    CubicBezierCurve: vu,
                    CubicBezierCurve3: yu,
                    EllipseCurve: cu,
                    LineCurve: xu,
                    LineCurve3: class extends ou {
                        constructor(e = new rs(), t = new rs()) {
                            super(),
                                (this.type = "LineCurve3"),
                                (this.isLineCurve3 = !0),
                                (this.v1 = e),
                                (this.v2 = t);
                        }
                        getPoint(e, t = new rs()) {
                            const i = t;
                            return (
                                1 === e
                                    ? i.copy(this.v2)
                                    : (i.copy(this.v2).sub(this.v1),
                                      i.multiplyScalar(e).add(this.v1)),
                                i
                            );
                        }
                        getPointAt(e, t) {
                            return this.getPoint(e, t);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                this.v1.copy(e.v1),
                                this.v2.copy(e.v2),
                                this
                            );
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return (
                                (e.v1 = this.v1.toArray()),
                                (e.v2 = this.v2.toArray()),
                                e
                            );
                        }
                        fromJSON(e) {
                            return (
                                super.fromJSON(e),
                                this.v1.fromArray(e.v1),
                                this.v2.fromArray(e.v2),
                                this
                            );
                        }
                    },
                    QuadraticBezierCurve: bu,
                    QuadraticBezierCurve3: wu,
                    SplineCurve: Tu,
                });
                class Nu extends ou {
                    constructor() {
                        super(),
                            (this.type = "CurvePath"),
                            (this.curves = []),
                            (this.autoClose = !1);
                    }
                    add(e) {
                        this.curves.push(e);
                    }
                    closePath() {
                        const e = this.curves[0].getPoint(0),
                            t = this.curves[this.curves.length - 1].getPoint(1);
                        e.equals(t) || this.curves.push(new xu(t, e));
                    }
                    getPoint(e, t) {
                        const i = e * this.getLength(),
                            n = this.getCurveLengths();
                        let r = 0;
                        for (; r < n.length; ) {
                            if (n[r] >= i) {
                                const e = n[r] - i,
                                    s = this.curves[r],
                                    a = s.getLength(),
                                    o = 0 === a ? 0 : 1 - e / a;
                                return s.getPointAt(o, t);
                            }
                            r++;
                        }
                        return null;
                    }
                    getLength() {
                        const e = this.getCurveLengths();
                        return e[e.length - 1];
                    }
                    updateArcLengths() {
                        (this.needsUpdate = !0),
                            (this.cacheLengths = null),
                            this.getCurveLengths();
                    }
                    getCurveLengths() {
                        if (
                            this.cacheLengths &&
                            this.cacheLengths.length === this.curves.length
                        )
                            return this.cacheLengths;
                        const e = [];
                        let t = 0;
                        for (let i = 0, n = this.curves.length; i < n; i++)
                            (t += this.curves[i].getLength()), e.push(t);
                        return (this.cacheLengths = e), e;
                    }
                    getSpacedPoints(e = 40) {
                        const t = [];
                        for (let i = 0; i <= e; i++)
                            t.push(this.getPoint(i / e));
                        return this.autoClose && t.push(t[0]), t;
                    }
                    getPoints(e = 12) {
                        const t = [];
                        let i;
                        for (let n = 0, r = this.curves; n < r.length; n++) {
                            const s = r[n],
                                a =
                                    s && s.isEllipseCurve
                                        ? 2 * e
                                        : s && (s.isLineCurve || s.isLineCurve3)
                                        ? 1
                                        : s && s.isSplineCurve
                                        ? e * s.points.length
                                        : e,
                                o = s.getPoints(a);
                            for (let e = 0; e < o.length; e++) {
                                const n = o[e];
                                (i && i.equals(n)) || (t.push(n), (i = n));
                            }
                        }
                        return (
                            this.autoClose &&
                                t.length > 1 &&
                                !t[t.length - 1].equals(t[0]) &&
                                t.push(t[0]),
                            t
                        );
                    }
                    copy(e) {
                        super.copy(e), (this.curves = []);
                        for (let t = 0, i = e.curves.length; t < i; t++) {
                            const i = e.curves[t];
                            this.curves.push(i.clone());
                        }
                        return (this.autoClose = e.autoClose), this;
                    }
                    toJSON() {
                        const e = super.toJSON();
                        (e.autoClose = this.autoClose), (e.curves = []);
                        for (let t = 0, i = this.curves.length; t < i; t++) {
                            const i = this.curves[t];
                            e.curves.push(i.toJSON());
                        }
                        return e;
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                            (this.autoClose = e.autoClose),
                            (this.curves = []);
                        for (let t = 0, i = e.curves.length; t < i; t++) {
                            const i = e.curves[t];
                            this.curves.push(new Su[i.type]().fromJSON(i));
                        }
                        return this;
                    }
                }
                class Du extends Nu {
                    constructor(e) {
                        super(),
                            (this.type = "Path"),
                            (this.currentPoint = new Gr()),
                            e && this.setFromPoints(e);
                    }
                    setFromPoints(e) {
                        this.moveTo(e[0].x, e[0].y);
                        for (let t = 1, i = e.length; t < i; t++)
                            this.lineTo(e[t].x, e[t].y);
                        return this;
                    }
                    moveTo(e, t) {
                        return this.currentPoint.set(e, t), this;
                    }
                    lineTo(e, t) {
                        const i = new xu(
                            this.currentPoint.clone(),
                            new Gr(e, t)
                        );
                        return (
                            this.curves.push(i),
                            this.currentPoint.set(e, t),
                            this
                        );
                    }
                    quadraticCurveTo(e, t, i, n) {
                        const r = new bu(
                            this.currentPoint.clone(),
                            new Gr(e, t),
                            new Gr(i, n)
                        );
                        return (
                            this.curves.push(r),
                            this.currentPoint.set(i, n),
                            this
                        );
                    }
                    bezierCurveTo(e, t, i, n, r, s) {
                        const a = new vu(
                            this.currentPoint.clone(),
                            new Gr(e, t),
                            new Gr(i, n),
                            new Gr(r, s)
                        );
                        return (
                            this.curves.push(a),
                            this.currentPoint.set(r, s),
                            this
                        );
                    }
                    splineThru(e) {
                        const t = [this.currentPoint.clone()].concat(e),
                            i = new Tu(t);
                        return (
                            this.curves.push(i),
                            this.currentPoint.copy(e[e.length - 1]),
                            this
                        );
                    }
                    arc(e, t, i, n, r, s) {
                        const a = this.currentPoint.x,
                            o = this.currentPoint.y;
                        return this.absarc(e + a, t + o, i, n, r, s), this;
                    }
                    absarc(e, t, i, n, r, s) {
                        return this.absellipse(e, t, i, i, n, r, s), this;
                    }
                    ellipse(e, t, i, n, r, s, a, o) {
                        const c = this.currentPoint.x,
                            l = this.currentPoint.y;
                        return (
                            this.absellipse(e + c, t + l, i, n, r, s, a, o),
                            this
                        );
                    }
                    absellipse(e, t, i, n, r, s, a, o) {
                        const c = new cu(e, t, i, n, r, s, a, o);
                        if (this.curves.length > 0) {
                            const e = c.getPoint(0);
                            e.equals(this.currentPoint) ||
                                this.lineTo(e.x, e.y);
                        }
                        this.curves.push(c);
                        const l = c.getPoint(1);
                        return this.currentPoint.copy(l), this;
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            this.currentPoint.copy(e.currentPoint),
                            this
                        );
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (
                            (e.currentPoint = this.currentPoint.toArray()), e
                        );
                    }
                    fromJSON(e) {
                        return (
                            super.fromJSON(e),
                            this.currentPoint.fromArray(e.currentPoint),
                            this
                        );
                    }
                }
                class Iu extends Du {
                    constructor(e) {
                        super(e),
                            (this.uuid = Rr()),
                            (this.type = "Shape"),
                            (this.holes = []);
                    }
                    getPointsHoles(e) {
                        const t = [];
                        for (let i = 0, n = this.holes.length; i < n; i++)
                            t[i] = this.holes[i].getPoints(e);
                        return t;
                    }
                    extractPoints(e) {
                        return {
                            shape: this.getPoints(e),
                            holes: this.getPointsHoles(e),
                        };
                    }
                    copy(e) {
                        super.copy(e), (this.holes = []);
                        for (let t = 0, i = e.holes.length; t < i; t++) {
                            const i = e.holes[t];
                            this.holes.push(i.clone());
                        }
                        return this;
                    }
                    toJSON() {
                        const e = super.toJSON();
                        (e.uuid = this.uuid), (e.holes = []);
                        for (let t = 0, i = this.holes.length; t < i; t++) {
                            const i = this.holes[t];
                            e.holes.push(i.toJSON());
                        }
                        return e;
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                            (this.uuid = e.uuid),
                            (this.holes = []);
                        for (let t = 0, i = e.holes.length; t < i; t++) {
                            const i = e.holes[t];
                            this.holes.push(new Du().fromJSON(i));
                        }
                        return this;
                    }
                }
                function Cu(e, t, i, n, r) {
                    let s, a;
                    if (
                        r ===
                        (function (e, t, i, n) {
                            let r = 0;
                            for (let s = t, a = i - n; s < i; s += n)
                                (r += (e[a] - e[s]) * (e[s + 1] + e[a + 1])),
                                    (a = s);
                            return r;
                        })(e, t, i, n) >
                            0
                    )
                        for (s = t; s < i; s += n) a = Zu(s, e[s], e[s + 1], a);
                    else
                        for (s = i - n; s >= t; s -= n)
                            a = Zu(s, e[s], e[s + 1], a);
                    return a && Gu(a, a.next) && (Xu(a), (a = a.next)), a;
                }
                function Au(e, t) {
                    if (!e) return e;
                    t || (t = e);
                    let i,
                        n = e;
                    do {
                        if (
                            ((i = !1),
                            n.steiner ||
                                (!Gu(n, n.next) && 0 !== Hu(n.prev, n, n.next)))
                        )
                            n = n.next;
                        else {
                            if ((Xu(n), (n = t = n.prev), n === n.next)) break;
                            i = !0;
                        }
                    } while (i || n !== t);
                    return t;
                }
                function Eu(e, t, i, n, r, s, a) {
                    if (!e) return;
                    !a &&
                        s &&
                        (function (e, t, i, n) {
                            let r = e;
                            do {
                                null === r.z && (r.z = Uu(r.x, r.y, t, i, n)),
                                    (r.prevZ = r.prev),
                                    (r.nextZ = r.next),
                                    (r = r.next);
                            } while (r !== e);
                            (r.prevZ.nextZ = null),
                                (r.prevZ = null),
                                (function (e) {
                                    let t,
                                        i,
                                        n,
                                        r,
                                        s,
                                        a,
                                        o,
                                        c,
                                        l = 1;
                                    do {
                                        for (
                                            i = e, e = null, s = null, a = 0;
                                            i;

                                        ) {
                                            for (
                                                a++, n = i, o = 0, t = 0;
                                                t < l &&
                                                (o++, (n = n.nextZ), n);
                                                t++
                                            );
                                            for (c = l; o > 0 || (c > 0 && n); )
                                                0 !== o &&
                                                (0 === c || !n || i.z <= n.z)
                                                    ? ((r = i),
                                                      (i = i.nextZ),
                                                      o--)
                                                    : ((r = n),
                                                      (n = n.nextZ),
                                                      c--),
                                                    s ? (s.nextZ = r) : (e = r),
                                                    (r.prevZ = s),
                                                    (s = r);
                                            i = n;
                                        }
                                        (s.nextZ = null), (l *= 2);
                                    } while (a > 1);
                                })(r);
                        })(e, n, r, s);
                    let o,
                        c,
                        l = e;
                    for (; e.prev !== e.next; )
                        if (
                            ((o = e.prev),
                            (c = e.next),
                            s ? zu(e, n, r, s) : Lu(e))
                        )
                            t.push(o.i / i),
                                t.push(e.i / i),
                                t.push(c.i / i),
                                Xu(e),
                                (e = c.next),
                                (l = c.next);
                        else if ((e = c) === l) {
                            a
                                ? 1 === a
                                    ? Eu(
                                          (e = ju(Au(e), t, i)),
                                          t,
                                          i,
                                          n,
                                          r,
                                          s,
                                          2
                                      )
                                    : 2 === a && Ou(e, t, i, n, r, s)
                                : Eu(Au(e), t, i, n, r, s, 1);
                            break;
                        }
                }
                function Lu(e) {
                    const t = e.prev,
                        i = e,
                        n = e.next;
                    if (Hu(t, i, n) >= 0) return !1;
                    let r = e.next.next;
                    for (; r !== e.prev; ) {
                        if (
                            Bu(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) &&
                            Hu(r.prev, r, r.next) >= 0
                        )
                            return !1;
                        r = r.next;
                    }
                    return !0;
                }
                function zu(e, t, i, n) {
                    const r = e.prev,
                        s = e,
                        a = e.next;
                    if (Hu(r, s, a) >= 0) return !1;
                    const o =
                            r.x < s.x
                                ? r.x < a.x
                                    ? r.x
                                    : a.x
                                : s.x < a.x
                                ? s.x
                                : a.x,
                        c =
                            r.y < s.y
                                ? r.y < a.y
                                    ? r.y
                                    : a.y
                                : s.y < a.y
                                ? s.y
                                : a.y,
                        l =
                            r.x > s.x
                                ? r.x > a.x
                                    ? r.x
                                    : a.x
                                : s.x > a.x
                                ? s.x
                                : a.x,
                        h =
                            r.y > s.y
                                ? r.y > a.y
                                    ? r.y
                                    : a.y
                                : s.y > a.y
                                ? s.y
                                : a.y,
                        u = Uu(o, c, t, i, n),
                        d = Uu(l, h, t, i, n);
                    let p = e.prevZ,
                        g = e.nextZ;
                    for (; p && p.z >= u && g && g.z <= d; ) {
                        if (
                            p !== e.prev &&
                            p !== e.next &&
                            Bu(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
                            Hu(p.prev, p, p.next) >= 0
                        )
                            return !1;
                        if (
                            ((p = p.prevZ),
                            g !== e.prev &&
                                g !== e.next &&
                                Bu(r.x, r.y, s.x, s.y, a.x, a.y, g.x, g.y) &&
                                Hu(g.prev, g, g.next) >= 0)
                        )
                            return !1;
                        g = g.nextZ;
                    }
                    for (; p && p.z >= u; ) {
                        if (
                            p !== e.prev &&
                            p !== e.next &&
                            Bu(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
                            Hu(p.prev, p, p.next) >= 0
                        )
                            return !1;
                        p = p.prevZ;
                    }
                    for (; g && g.z <= d; ) {
                        if (
                            g !== e.prev &&
                            g !== e.next &&
                            Bu(r.x, r.y, s.x, s.y, a.x, a.y, g.x, g.y) &&
                            Hu(g.prev, g, g.next) >= 0
                        )
                            return !1;
                        g = g.nextZ;
                    }
                    return !0;
                }
                function ju(e, t, i) {
                    let n = e;
                    do {
                        const r = n.prev,
                            s = n.next.next;
                        !Gu(r, s) &&
                            Vu(r, n, n.next, s) &&
                            Wu(r, s) &&
                            Wu(s, r) &&
                            (t.push(r.i / i),
                            t.push(n.i / i),
                            t.push(s.i / i),
                            Xu(n),
                            Xu(n.next),
                            (n = e = s)),
                            (n = n.next);
                    } while (n !== e);
                    return Au(n);
                }
                function Ou(e, t, i, n, r, s) {
                    let a = e;
                    do {
                        let e = a.next.next;
                        for (; e !== a.prev; ) {
                            if (a.i !== e.i && Fu(a, e)) {
                                let o = Qu(a, e);
                                return (
                                    (a = Au(a, a.next)),
                                    (o = Au(o, o.next)),
                                    Eu(a, t, i, n, r, s),
                                    void Eu(o, t, i, n, r, s)
                                );
                            }
                            e = e.next;
                        }
                        a = a.next;
                    } while (a !== e);
                }
                function ku(e, t) {
                    return e.x - t.x;
                }
                function Ru(e, t) {
                    if (
                        ((t = (function (e, t) {
                            let i = t;
                            const n = e.x,
                                r = e.y;
                            let s,
                                a = -1 / 0;
                            do {
                                if (
                                    r <= i.y &&
                                    r >= i.next.y &&
                                    i.next.y !== i.y
                                ) {
                                    const e =
                                        i.x +
                                        ((r - i.y) * (i.next.x - i.x)) /
                                            (i.next.y - i.y);
                                    if (e <= n && e > a) {
                                        if (((a = e), e === n)) {
                                            if (r === i.y) return i;
                                            if (r === i.next.y) return i.next;
                                        }
                                        s = i.x < i.next.x ? i : i.next;
                                    }
                                }
                                i = i.next;
                            } while (i !== t);
                            if (!s) return null;
                            if (n === a) return s;
                            const o = s,
                                c = s.x,
                                l = s.y;
                            let h,
                                u = 1 / 0;
                            i = s;
                            do {
                                n >= i.x &&
                                    i.x >= c &&
                                    n !== i.x &&
                                    Bu(
                                        r < l ? n : a,
                                        r,
                                        c,
                                        l,
                                        r < l ? a : n,
                                        r,
                                        i.x,
                                        i.y
                                    ) &&
                                    ((h = Math.abs(r - i.y) / (n - i.x)),
                                    Wu(i, e) &&
                                        (h < u ||
                                            (h === u &&
                                                (i.x > s.x ||
                                                    (i.x === s.x &&
                                                        Pu(s, i))))) &&
                                        ((s = i), (u = h))),
                                    (i = i.next);
                            } while (i !== o);
                            return s;
                        })(e, t)),
                        t)
                    ) {
                        const i = Qu(t, e);
                        Au(t, t.next), Au(i, i.next);
                    }
                }
                function Pu(e, t) {
                    return (
                        Hu(e.prev, e, t.prev) < 0 && Hu(t.next, e, e.next) < 0
                    );
                }
                function Uu(e, t, i, n, r) {
                    return (
                        (e =
                            1431655765 &
                            ((e =
                                858993459 &
                                ((e =
                                    252645135 &
                                    ((e =
                                        16711935 &
                                        ((e = 32767 * (e - i) * r) |
                                            (e << 8))) |
                                        (e << 4))) |
                                    (e << 2))) |
                                (e << 1))) |
                        ((t =
                            1431655765 &
                            ((t =
                                858993459 &
                                ((t =
                                    252645135 &
                                    ((t =
                                        16711935 &
                                        ((t = 32767 * (t - n) * r) |
                                            (t << 8))) |
                                        (t << 4))) |
                                    (t << 2))) |
                                (t << 1))) <<
                            1)
                    );
                }
                function $u(e) {
                    let t = e,
                        i = e;
                    do {
                        (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t),
                            (t = t.next);
                    } while (t !== e);
                    return i;
                }
                function Bu(e, t, i, n, r, s, a, o) {
                    return (
                        (r - a) * (t - o) - (e - a) * (s - o) >= 0 &&
                        (e - a) * (n - o) - (i - a) * (t - o) >= 0 &&
                        (i - a) * (s - o) - (r - a) * (n - o) >= 0
                    );
                }
                function Fu(e, t) {
                    return (
                        e.next.i !== t.i &&
                        e.prev.i !== t.i &&
                        !(function (e, t) {
                            let i = e;
                            do {
                                if (
                                    i.i !== e.i &&
                                    i.next.i !== e.i &&
                                    i.i !== t.i &&
                                    i.next.i !== t.i &&
                                    Vu(i, i.next, e, t)
                                )
                                    return !0;
                                i = i.next;
                            } while (i !== e);
                            return !1;
                        })(e, t) &&
                        ((Wu(e, t) &&
                            Wu(t, e) &&
                            (function (e, t) {
                                let i = e,
                                    n = !1;
                                const r = (e.x + t.x) / 2,
                                    s = (e.y + t.y) / 2;
                                do {
                                    i.y > s != i.next.y > s &&
                                        i.next.y !== i.y &&
                                        r <
                                            ((i.next.x - i.x) * (s - i.y)) /
                                                (i.next.y - i.y) +
                                                i.x &&
                                        (n = !n),
                                        (i = i.next);
                                } while (i !== e);
                                return n;
                            })(e, t) &&
                            (Hu(e.prev, e, t.prev) || Hu(e, t.prev, t))) ||
                            (Gu(e, t) &&
                                Hu(e.prev, e, e.next) > 0 &&
                                Hu(t.prev, t, t.next) > 0))
                    );
                }
                function Hu(e, t, i) {
                    return (
                        (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
                    );
                }
                function Gu(e, t) {
                    return e.x === t.x && e.y === t.y;
                }
                function Vu(e, t, i, n) {
                    const r = qu(Hu(e, t, i)),
                        s = qu(Hu(e, t, n)),
                        a = qu(Hu(i, n, e)),
                        o = qu(Hu(i, n, t));
                    return (
                        (r !== s && a !== o) ||
                        !(0 !== r || !Yu(e, i, t)) ||
                        !(0 !== s || !Yu(e, n, t)) ||
                        !(0 !== a || !Yu(i, e, n)) ||
                        !(0 !== o || !Yu(i, t, n))
                    );
                }
                function Yu(e, t, i) {
                    return (
                        t.x <= Math.max(e.x, i.x) &&
                        t.x >= Math.min(e.x, i.x) &&
                        t.y <= Math.max(e.y, i.y) &&
                        t.y >= Math.min(e.y, i.y)
                    );
                }
                function qu(e) {
                    return e > 0 ? 1 : e < 0 ? -1 : 0;
                }
                function Wu(e, t) {
                    return Hu(e.prev, e, e.next) < 0
                        ? Hu(e, t, e.next) >= 0 && Hu(e, e.prev, t) >= 0
                        : Hu(e, t, e.prev) < 0 || Hu(e, e.next, t) < 0;
                }
                function Qu(e, t) {
                    const i = new Ju(e.i, e.x, e.y),
                        n = new Ju(t.i, t.x, t.y),
                        r = e.next,
                        s = t.prev;
                    return (
                        (e.next = t),
                        (t.prev = e),
                        (i.next = r),
                        (r.prev = i),
                        (n.next = i),
                        (i.prev = n),
                        (s.next = n),
                        (n.prev = s),
                        n
                    );
                }
                function Zu(e, t, i, n) {
                    const r = new Ju(e, t, i);
                    return (
                        n
                            ? ((r.next = n.next),
                              (r.prev = n),
                              (n.next.prev = r),
                              (n.next = r))
                            : ((r.prev = r), (r.next = r)),
                        r
                    );
                }
                function Xu(e) {
                    (e.next.prev = e.prev),
                        (e.prev.next = e.next),
                        e.prevZ && (e.prevZ.nextZ = e.nextZ),
                        e.nextZ && (e.nextZ.prevZ = e.prevZ);
                }
                function Ju(e, t, i) {
                    (this.i = e),
                        (this.x = t),
                        (this.y = i),
                        (this.prev = null),
                        (this.next = null),
                        (this.z = null),
                        (this.prevZ = null),
                        (this.nextZ = null),
                        (this.steiner = !1);
                }
                class Ku {
                    static area(e) {
                        const t = e.length;
                        let i = 0;
                        for (let n = t - 1, r = 0; r < t; n = r++)
                            i += e[n].x * e[r].y - e[r].x * e[n].y;
                        return 0.5 * i;
                    }
                    static isClockWise(e) {
                        return Ku.area(e) < 0;
                    }
                    static triangulateShape(e, t) {
                        const i = [],
                            n = [],
                            r = [];
                        ed(e), td(i, e);
                        let s = e.length;
                        t.forEach(ed);
                        for (let e = 0; e < t.length; e++)
                            n.push(s), (s += t[e].length), td(i, t[e]);
                        const a = (function (e, t, i = 2) {
                            const n = t && t.length,
                                r = n ? t[0] * i : e.length;
                            let s = Cu(e, 0, r, i, !0);
                            const a = [];
                            if (!s || s.next === s.prev) return a;
                            let o, c, l, h, u, d, p;
                            if (
                                (n &&
                                    (s = (function (e, t, i, n) {
                                        const r = [];
                                        let s, a, o, c, l;
                                        for (s = 0, a = t.length; s < a; s++)
                                            (o = t[s] * n),
                                                (c =
                                                    s < a - 1
                                                        ? t[s + 1] * n
                                                        : e.length),
                                                (l = Cu(e, o, c, n, !1)),
                                                l === l.next &&
                                                    (l.steiner = !0),
                                                r.push($u(l));
                                        for (
                                            r.sort(ku), s = 0;
                                            s < r.length;
                                            s++
                                        )
                                            Ru(r[s], i), (i = Au(i, i.next));
                                        return i;
                                    })(e, t, s, i)),
                                e.length > 80 * i)
                            ) {
                                (o = l = e[0]), (c = h = e[1]);
                                for (let t = i; t < r; t += i)
                                    (u = e[t]),
                                        (d = e[t + 1]),
                                        u < o && (o = u),
                                        d < c && (c = d),
                                        u > l && (l = u),
                                        d > h && (h = d);
                                (p = Math.max(l - o, h - c)),
                                    (p = 0 !== p ? 1 / p : 0);
                            }
                            return Eu(s, a, i, o, c, p), a;
                        })(i, n);
                        for (let e = 0; e < a.length; e += 3)
                            r.push(a.slice(e, e + 3));
                        return r;
                    }
                }
                function ed(e) {
                    const t = e.length;
                    t > 2 && e[t - 1].equals(e[0]) && e.pop();
                }
                function td(e, t) {
                    for (let i = 0; i < t.length; i++)
                        e.push(t[i].x), e.push(t[i].y);
                }
                class id extends Ba {
                    constructor(
                        e = new Iu([
                            new Gr(0.5, 0.5),
                            new Gr(-0.5, 0.5),
                            new Gr(-0.5, -0.5),
                            new Gr(0.5, -0.5),
                        ]),
                        t = {}
                    ) {
                        super(),
                            (this.type = "ExtrudeGeometry"),
                            (this.parameters = { shapes: e, options: t }),
                            (e = Array.isArray(e) ? e : [e]);
                        const i = this,
                            n = [],
                            r = [];
                        for (let t = 0, i = e.length; t < i; t++) s(e[t]);
                        function s(e) {
                            const s = [],
                                a =
                                    void 0 !== t.curveSegments
                                        ? t.curveSegments
                                        : 12,
                                o = void 0 !== t.steps ? t.steps : 1;
                            let c = void 0 !== t.depth ? t.depth : 1,
                                l = void 0 === t.bevelEnabled || t.bevelEnabled,
                                h =
                                    void 0 !== t.bevelThickness
                                        ? t.bevelThickness
                                        : 0.2,
                                u =
                                    void 0 !== t.bevelSize
                                        ? t.bevelSize
                                        : h - 0.1,
                                d =
                                    void 0 !== t.bevelOffset
                                        ? t.bevelOffset
                                        : 0,
                                p =
                                    void 0 !== t.bevelSegments
                                        ? t.bevelSegments
                                        : 3;
                            const g = t.extrudePath,
                                m =
                                    void 0 !== t.UVGenerator
                                        ? t.UVGenerator
                                        : nd;
                            void 0 !== t.amount &&
                                (console.warn(
                                    "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
                                ),
                                (c = t.amount));
                            let f,
                                _,
                                M,
                                v,
                                y,
                                x = !1;
                            g &&
                                ((f = g.getSpacedPoints(o)),
                                (x = !0),
                                (l = !1),
                                (_ = g.computeFrenetFrames(o, !1)),
                                (M = new rs()),
                                (v = new rs()),
                                (y = new rs())),
                                l || ((p = 0), (h = 0), (u = 0), (d = 0));
                            const b = e.extractPoints(a);
                            let w = b.shape;
                            const T = b.holes;
                            if (!Ku.isClockWise(w)) {
                                w = w.reverse();
                                for (let e = 0, t = T.length; e < t; e++) {
                                    const t = T[e];
                                    Ku.isClockWise(t) && (T[e] = t.reverse());
                                }
                            }
                            const S = Ku.triangulateShape(w, T),
                                N = w;
                            for (let e = 0, t = T.length; e < t; e++) {
                                const t = T[e];
                                w = w.concat(t);
                            }
                            function D(e, t, i) {
                                return (
                                    t ||
                                        console.error(
                                            "THREE.ExtrudeGeometry: vec does not exist"
                                        ),
                                    t.clone().multiplyScalar(i).add(e)
                                );
                            }
                            const I = w.length,
                                C = S.length;
                            function A(e, t, i) {
                                let n, r, s;
                                const a = e.x - t.x,
                                    o = e.y - t.y,
                                    c = i.x - e.x,
                                    l = i.y - e.y,
                                    h = a * a + o * o,
                                    u = a * l - o * c;
                                if (Math.abs(u) > Number.EPSILON) {
                                    const u = Math.sqrt(h),
                                        d = Math.sqrt(c * c + l * l),
                                        p = t.x - o / u,
                                        g = t.y + a / u,
                                        m =
                                            ((i.x - l / d - p) * l -
                                                (i.y + c / d - g) * c) /
                                            (a * l - o * c);
                                    (n = p + a * m - e.x),
                                        (r = g + o * m - e.y);
                                    const f = n * n + r * r;
                                    if (f <= 2) return new Gr(n, r);
                                    s = Math.sqrt(f / 2);
                                } else {
                                    let e = !1;
                                    a > Number.EPSILON
                                        ? c > Number.EPSILON && (e = !0)
                                        : a < -Number.EPSILON
                                        ? c < -Number.EPSILON && (e = !0)
                                        : Math.sign(o) === Math.sign(l) &&
                                          (e = !0),
                                        e
                                            ? ((n = -o),
                                              (r = a),
                                              (s = Math.sqrt(h)))
                                            : ((n = a),
                                              (r = o),
                                              (s = Math.sqrt(h / 2)));
                                }
                                return new Gr(n / s, r / s);
                            }
                            const E = [];
                            for (
                                let e = 0, t = N.length, i = t - 1, n = e + 1;
                                e < t;
                                e++, i++, n++
                            )
                                i === t && (i = 0),
                                    n === t && (n = 0),
                                    (E[e] = A(N[e], N[i], N[n]));
                            const L = [];
                            let z,
                                j = E.concat();
                            for (let e = 0, t = T.length; e < t; e++) {
                                const t = T[e];
                                z = [];
                                for (
                                    let e = 0,
                                        i = t.length,
                                        n = i - 1,
                                        r = e + 1;
                                    e < i;
                                    e++, n++, r++
                                )
                                    n === i && (n = 0),
                                        r === i && (r = 0),
                                        (z[e] = A(t[e], t[n], t[r]));
                                L.push(z), (j = j.concat(z));
                            }
                            for (let e = 0; e < p; e++) {
                                const t = e / p,
                                    i = h * Math.cos((t * Math.PI) / 2),
                                    n = u * Math.sin((t * Math.PI) / 2) + d;
                                for (let e = 0, t = N.length; e < t; e++) {
                                    const t = D(N[e], E[e], n);
                                    R(t.x, t.y, -i);
                                }
                                for (let e = 0, t = T.length; e < t; e++) {
                                    const t = T[e];
                                    z = L[e];
                                    for (let e = 0, r = t.length; e < r; e++) {
                                        const r = D(t[e], z[e], n);
                                        R(r.x, r.y, -i);
                                    }
                                }
                            }
                            const O = u + d;
                            for (let e = 0; e < I; e++) {
                                const t = l ? D(w[e], j[e], O) : w[e];
                                x
                                    ? (v.copy(_.normals[0]).multiplyScalar(t.x),
                                      M.copy(_.binormals[0]).multiplyScalar(
                                          t.y
                                      ),
                                      y.copy(f[0]).add(v).add(M),
                                      R(y.x, y.y, y.z))
                                    : R(t.x, t.y, 0);
                            }
                            for (let e = 1; e <= o; e++)
                                for (let t = 0; t < I; t++) {
                                    const i = l ? D(w[t], j[t], O) : w[t];
                                    x
                                        ? (v
                                              .copy(_.normals[e])
                                              .multiplyScalar(i.x),
                                          M.copy(_.binormals[e]).multiplyScalar(
                                              i.y
                                          ),
                                          y.copy(f[e]).add(v).add(M),
                                          R(y.x, y.y, y.z))
                                        : R(i.x, i.y, (c / o) * e);
                                }
                            for (let e = p - 1; e >= 0; e--) {
                                const t = e / p,
                                    i = h * Math.cos((t * Math.PI) / 2),
                                    n = u * Math.sin((t * Math.PI) / 2) + d;
                                for (let e = 0, t = N.length; e < t; e++) {
                                    const t = D(N[e], E[e], n);
                                    R(t.x, t.y, c + i);
                                }
                                for (let e = 0, t = T.length; e < t; e++) {
                                    const t = T[e];
                                    z = L[e];
                                    for (let e = 0, r = t.length; e < r; e++) {
                                        const r = D(t[e], z[e], n);
                                        x
                                            ? R(
                                                  r.x,
                                                  r.y + f[o - 1].y,
                                                  f[o - 1].x + i
                                              )
                                            : R(r.x, r.y, c + i);
                                    }
                                }
                            }
                            function k(e, t) {
                                let i = e.length;
                                for (; --i >= 0; ) {
                                    const n = i;
                                    let r = i - 1;
                                    r < 0 && (r = e.length - 1);
                                    for (let e = 0, i = o + 2 * p; e < i; e++) {
                                        const i = I * e,
                                            s = I * (e + 1);
                                        U(
                                            t + n + i,
                                            t + r + i,
                                            t + r + s,
                                            t + n + s
                                        );
                                    }
                                }
                            }
                            function R(e, t, i) {
                                s.push(e), s.push(t), s.push(i);
                            }
                            function P(e, t, r) {
                                $(e), $(t), $(r);
                                const s = n.length / 3,
                                    a = m.generateTopUV(
                                        i,
                                        n,
                                        s - 3,
                                        s - 2,
                                        s - 1
                                    );
                                B(a[0]), B(a[1]), B(a[2]);
                            }
                            function U(e, t, r, s) {
                                $(e), $(t), $(s), $(t), $(r), $(s);
                                const a = n.length / 3,
                                    o = m.generateSideWallUV(
                                        i,
                                        n,
                                        a - 6,
                                        a - 3,
                                        a - 2,
                                        a - 1
                                    );
                                B(o[0]),
                                    B(o[1]),
                                    B(o[3]),
                                    B(o[1]),
                                    B(o[2]),
                                    B(o[3]);
                            }
                            function $(e) {
                                n.push(s[3 * e + 0]),
                                    n.push(s[3 * e + 1]),
                                    n.push(s[3 * e + 2]);
                            }
                            function B(e) {
                                r.push(e.x), r.push(e.y);
                            }
                            !(function () {
                                const e = n.length / 3;
                                if (l) {
                                    let e = 0,
                                        t = I * e;
                                    for (let e = 0; e < C; e++) {
                                        const i = S[e];
                                        P(i[2] + t, i[1] + t, i[0] + t);
                                    }
                                    (e = o + 2 * p), (t = I * e);
                                    for (let e = 0; e < C; e++) {
                                        const i = S[e];
                                        P(i[0] + t, i[1] + t, i[2] + t);
                                    }
                                } else {
                                    for (let e = 0; e < C; e++) {
                                        const t = S[e];
                                        P(t[2], t[1], t[0]);
                                    }
                                    for (let e = 0; e < C; e++) {
                                        const t = S[e];
                                        P(
                                            t[0] + I * o,
                                            t[1] + I * o,
                                            t[2] + I * o
                                        );
                                    }
                                }
                                i.addGroup(e, n.length / 3 - e, 0);
                            })(),
                                (function () {
                                    const e = n.length / 3;
                                    let t = 0;
                                    k(N, t), (t += N.length);
                                    for (let e = 0, i = T.length; e < i; e++) {
                                        const i = T[e];
                                        k(i, t), (t += i.length);
                                    }
                                    i.addGroup(e, n.length / 3 - e, 1);
                                })();
                        }
                        this.setAttribute("position", new za(n, 3)),
                            this.setAttribute("uv", new za(r, 2)),
                            this.computeVertexNormals();
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (function (e, t, i) {
                            if (((i.shapes = []), Array.isArray(e)))
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    i.shapes.push(n.uuid);
                                }
                            else i.shapes.push(e.uuid);
                            return (
                                void 0 !== t.extrudePath &&
                                    (i.options.extrudePath =
                                        t.extrudePath.toJSON()),
                                i
                            );
                        })(this.parameters.shapes, this.parameters.options, e);
                    }
                    static fromJSON(e, t) {
                        const i = [];
                        for (let n = 0, r = e.shapes.length; n < r; n++) {
                            const r = t[e.shapes[n]];
                            i.push(r);
                        }
                        const n = e.options.extrudePath;
                        return (
                            void 0 !== n &&
                                (e.options.extrudePath = new Su[
                                    n.type
                                ]().fromJSON(n)),
                            new id(i, e.options)
                        );
                    }
                }
                const nd = {
                    generateTopUV: function (e, t, i, n, r) {
                        const s = t[3 * i],
                            a = t[3 * i + 1],
                            o = t[3 * n],
                            c = t[3 * n + 1],
                            l = t[3 * r],
                            h = t[3 * r + 1];
                        return [new Gr(s, a), new Gr(o, c), new Gr(l, h)];
                    },
                    generateSideWallUV: function (e, t, i, n, r, s) {
                        const a = t[3 * i],
                            o = t[3 * i + 1],
                            c = t[3 * i + 2],
                            l = t[3 * n],
                            h = t[3 * n + 1],
                            u = t[3 * n + 2],
                            d = t[3 * r],
                            p = t[3 * r + 1],
                            g = t[3 * r + 2],
                            m = t[3 * s],
                            f = t[3 * s + 1],
                            _ = t[3 * s + 2];
                        return Math.abs(o - h) < Math.abs(a - l)
                            ? [
                                  new Gr(a, 1 - c),
                                  new Gr(l, 1 - u),
                                  new Gr(d, 1 - g),
                                  new Gr(m, 1 - _),
                              ]
                            : [
                                  new Gr(o, 1 - c),
                                  new Gr(h, 1 - u),
                                  new Gr(p, 1 - g),
                                  new Gr(f, 1 - _),
                              ];
                    },
                };
                class rd extends Ba {
                    constructor(
                        e = new Iu([
                            new Gr(0, 0.5),
                            new Gr(-0.5, -0.5),
                            new Gr(0.5, -0.5),
                        ]),
                        t = 12
                    ) {
                        super(),
                            (this.type = "ShapeGeometry"),
                            (this.parameters = { shapes: e, curveSegments: t });
                        const i = [],
                            n = [],
                            r = [],
                            s = [];
                        let a = 0,
                            o = 0;
                        if (!1 === Array.isArray(e)) c(e);
                        else
                            for (let t = 0; t < e.length; t++)
                                c(e[t]),
                                    this.addGroup(a, o, t),
                                    (a += o),
                                    (o = 0);
                        function c(e) {
                            const a = n.length / 3,
                                c = e.extractPoints(t);
                            let l = c.shape;
                            const h = c.holes;
                            !1 === Ku.isClockWise(l) && (l = l.reverse());
                            for (let e = 0, t = h.length; e < t; e++) {
                                const t = h[e];
                                !0 === Ku.isClockWise(t) &&
                                    (h[e] = t.reverse());
                            }
                            const u = Ku.triangulateShape(l, h);
                            for (let e = 0, t = h.length; e < t; e++) {
                                const t = h[e];
                                l = l.concat(t);
                            }
                            for (let e = 0, t = l.length; e < t; e++) {
                                const t = l[e];
                                n.push(t.x, t.y, 0),
                                    r.push(0, 0, 1),
                                    s.push(t.x, t.y);
                            }
                            for (let e = 0, t = u.length; e < t; e++) {
                                const t = u[e],
                                    n = t[0] + a,
                                    r = t[1] + a,
                                    s = t[2] + a;
                                i.push(n, r, s), (o += 3);
                            }
                        }
                        this.setIndex(i),
                            this.setAttribute("position", new za(n, 3)),
                            this.setAttribute("normal", new za(r, 3)),
                            this.setAttribute("uv", new za(s, 2));
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return (function (e, t) {
                            if (((t.shapes = []), Array.isArray(e)))
                                for (let i = 0, n = e.length; i < n; i++) {
                                    const n = e[i];
                                    t.shapes.push(n.uuid);
                                }
                            else t.shapes.push(e.uuid);
                            return t;
                        })(this.parameters.shapes, e);
                    }
                    static fromJSON(e, t) {
                        const i = [];
                        for (let n = 0, r = e.shapes.length; n < r; n++) {
                            const r = t[e.shapes[n]];
                            i.push(r);
                        }
                        return new rd(i, e.curveSegments);
                    }
                }
                class sd extends Ba {
                    constructor(
                        e = 1,
                        t = 32,
                        i = 16,
                        n = 0,
                        r = 2 * Math.PI,
                        s = 0,
                        a = Math.PI
                    ) {
                        super(),
                            (this.type = "SphereGeometry"),
                            (this.parameters = {
                                radius: e,
                                widthSegments: t,
                                heightSegments: i,
                                phiStart: n,
                                phiLength: r,
                                thetaStart: s,
                                thetaLength: a,
                            }),
                            (t = Math.max(3, Math.floor(t))),
                            (i = Math.max(2, Math.floor(i)));
                        const o = Math.min(s + a, Math.PI);
                        let c = 0;
                        const l = [],
                            h = new rs(),
                            u = new rs(),
                            d = [],
                            p = [],
                            g = [],
                            m = [];
                        for (let d = 0; d <= i; d++) {
                            const f = [],
                                _ = d / i;
                            let M = 0;
                            0 == d && 0 == s
                                ? (M = 0.5 / t)
                                : d == i && o == Math.PI && (M = -0.5 / t);
                            for (let i = 0; i <= t; i++) {
                                const o = i / t;
                                (h.x =
                                    -e *
                                    Math.cos(n + o * r) *
                                    Math.sin(s + _ * a)),
                                    (h.y = e * Math.cos(s + _ * a)),
                                    (h.z =
                                        e *
                                        Math.sin(n + o * r) *
                                        Math.sin(s + _ * a)),
                                    p.push(h.x, h.y, h.z),
                                    u.copy(h).normalize(),
                                    g.push(u.x, u.y, u.z),
                                    m.push(o + M, 1 - _),
                                    f.push(c++);
                            }
                            l.push(f);
                        }
                        for (let e = 0; e < i; e++)
                            for (let n = 0; n < t; n++) {
                                const t = l[e][n + 1],
                                    r = l[e][n],
                                    a = l[e + 1][n],
                                    c = l[e + 1][n + 1];
                                (0 !== e || s > 0) && d.push(t, r, c),
                                    (e !== i - 1 || o < Math.PI) &&
                                        d.push(r, a, c);
                            }
                        this.setIndex(d),
                            this.setAttribute("position", new za(p, 3)),
                            this.setAttribute("normal", new za(g, 3)),
                            this.setAttribute("uv", new za(m, 2));
                    }
                    static fromJSON(e) {
                        return new sd(
                            e.radius,
                            e.widthSegments,
                            e.heightSegments,
                            e.phiStart,
                            e.phiLength,
                            e.thetaStart,
                            e.thetaLength
                        );
                    }
                }
                (class extends va {
                    constructor(e) {
                        super(),
                            (this.type = "ShadowMaterial"),
                            (this.color = new Na(0)),
                            (this.transparent = !0),
                            this.setValues(e);
                    }
                    copy(e) {
                        return super.copy(e), this.color.copy(e.color), this;
                    }
                }).prototype.isShadowMaterial = !0;
                class ad extends va {
                    constructor(e) {
                        super(),
                            (this.defines = { STANDARD: "" }),
                            (this.type = "MeshStandardMaterial"),
                            (this.color = new Na(16777215)),
                            (this.roughness = 1),
                            (this.metalness = 0),
                            (this.map = null),
                            (this.lightMap = null),
                            (this.lightMapIntensity = 1),
                            (this.aoMap = null),
                            (this.aoMapIntensity = 1),
                            (this.emissive = new Na(0)),
                            (this.emissiveIntensity = 1),
                            (this.emissiveMap = null),
                            (this.bumpMap = null),
                            (this.bumpScale = 1),
                            (this.normalMap = null),
                            (this.normalMapType = Sr),
                            (this.normalScale = new Gr(1, 1)),
                            (this.displacementMap = null),
                            (this.displacementScale = 1),
                            (this.displacementBias = 0),
                            (this.roughnessMap = null),
                            (this.metalnessMap = null),
                            (this.alphaMap = null),
                            (this.envMap = null),
                            (this.envMapIntensity = 1),
                            (this.refractionRatio = 0.98),
                            (this.wireframe = !1),
                            (this.wireframeLinewidth = 1),
                            (this.wireframeLinecap = "round"),
                            (this.wireframeLinejoin = "round"),
                            (this.flatShading = !1),
                            this.setValues(e);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.defines = { STANDARD: "" }),
                            this.color.copy(e.color),
                            (this.roughness = e.roughness),
                            (this.metalness = e.metalness),
                            (this.map = e.map),
                            (this.lightMap = e.lightMap),
                            (this.lightMapIntensity = e.lightMapIntensity),
                            (this.aoMap = e.aoMap),
                            (this.aoMapIntensity = e.aoMapIntensity),
                            this.emissive.copy(e.emissive),
                            (this.emissiveMap = e.emissiveMap),
                            (this.emissiveIntensity = e.emissiveIntensity),
                            (this.bumpMap = e.bumpMap),
                            (this.bumpScale = e.bumpScale),
                            (this.normalMap = e.normalMap),
                            (this.normalMapType = e.normalMapType),
                            this.normalScale.copy(e.normalScale),
                            (this.displacementMap = e.displacementMap),
                            (this.displacementScale = e.displacementScale),
                            (this.displacementBias = e.displacementBias),
                            (this.roughnessMap = e.roughnessMap),
                            (this.metalnessMap = e.metalnessMap),
                            (this.alphaMap = e.alphaMap),
                            (this.envMap = e.envMap),
                            (this.envMapIntensity = e.envMapIntensity),
                            (this.refractionRatio = e.refractionRatio),
                            (this.wireframe = e.wireframe),
                            (this.wireframeLinewidth = e.wireframeLinewidth),
                            (this.wireframeLinecap = e.wireframeLinecap),
                            (this.wireframeLinejoin = e.wireframeLinejoin),
                            (this.flatShading = e.flatShading),
                            this
                        );
                    }
                }
                (ad.prototype.isMeshStandardMaterial = !0),
                    (class extends ad {
                        constructor(e) {
                            super(),
                                (this.defines = { STANDARD: "", PHYSICAL: "" }),
                                (this.type = "MeshPhysicalMaterial"),
                                (this.clearcoatMap = null),
                                (this.clearcoatRoughness = 0),
                                (this.clearcoatRoughnessMap = null),
                                (this.clearcoatNormalScale = new Gr(1, 1)),
                                (this.clearcoatNormalMap = null),
                                (this.ior = 1.5),
                                Object.defineProperty(this, "reflectivity", {
                                    get: function () {
                                        return Pr(
                                            (2.5 * (this.ior - 1)) /
                                                (this.ior + 1),
                                            0,
                                            1
                                        );
                                    },
                                    set: function (e) {
                                        this.ior =
                                            (1 + 0.4 * e) / (1 - 0.4 * e);
                                    },
                                }),
                                (this.sheenColor = new Na(0)),
                                (this.sheenColorMap = null),
                                (this.sheenRoughness = 1),
                                (this.sheenRoughnessMap = null),
                                (this.transmissionMap = null),
                                (this.thickness = 0.01),
                                (this.thicknessMap = null),
                                (this.attenuationDistance = 0),
                                (this.attenuationColor = new Na(1, 1, 1)),
                                (this.specularIntensity = 1),
                                (this.specularIntensityMap = null),
                                (this.specularColor = new Na(1, 1, 1)),
                                (this.specularColorMap = null),
                                (this._sheen = 0),
                                (this._clearcoat = 0),
                                (this._transmission = 0),
                                this.setValues(e);
                        }
                        get sheen() {
                            return this._sheen;
                        }
                        set sheen(e) {
                            this._sheen > 0 != e > 0 && this.version++,
                                (this._sheen = e);
                        }
                        get clearcoat() {
                            return this._clearcoat;
                        }
                        set clearcoat(e) {
                            this._clearcoat > 0 != e > 0 && this.version++,
                                (this._clearcoat = e);
                        }
                        get transmission() {
                            return this._transmission;
                        }
                        set transmission(e) {
                            this._transmission > 0 != e > 0 && this.version++,
                                (this._transmission = e);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.defines = { STANDARD: "", PHYSICAL: "" }),
                                (this.clearcoat = e.clearcoat),
                                (this.clearcoatMap = e.clearcoatMap),
                                (this.clearcoatRoughness =
                                    e.clearcoatRoughness),
                                (this.clearcoatRoughnessMap =
                                    e.clearcoatRoughnessMap),
                                (this.clearcoatNormalMap =
                                    e.clearcoatNormalMap),
                                this.clearcoatNormalScale.copy(
                                    e.clearcoatNormalScale
                                ),
                                (this.ior = e.ior),
                                (this.sheen = e.sheen),
                                this.sheenColor.copy(e.sheenColor),
                                (this.sheenColorMap = e.sheenColorMap),
                                (this.sheenRoughness = e.sheenRoughness),
                                (this.sheenRoughnessMap = e.sheenRoughnessMap),
                                (this.transmission = e.transmission),
                                (this.transmissionMap = e.transmissionMap),
                                (this.thickness = e.thickness),
                                (this.thicknessMap = e.thicknessMap),
                                (this.attenuationDistance =
                                    e.attenuationDistance),
                                this.attenuationColor.copy(e.attenuationColor),
                                (this.specularIntensity = e.specularIntensity),
                                (this.specularIntensityMap =
                                    e.specularIntensityMap),
                                this.specularColor.copy(e.specularColor),
                                (this.specularColorMap = e.specularColorMap),
                                this
                            );
                        }
                    }.prototype.isMeshPhysicalMaterial = !0),
                    (class extends va {
                        constructor(e) {
                            super(),
                                (this.type = "MeshPhongMaterial"),
                                (this.color = new Na(16777215)),
                                (this.specular = new Na(1118481)),
                                (this.shininess = 30),
                                (this.map = null),
                                (this.lightMap = null),
                                (this.lightMapIntensity = 1),
                                (this.aoMap = null),
                                (this.aoMapIntensity = 1),
                                (this.emissive = new Na(0)),
                                (this.emissiveIntensity = 1),
                                (this.emissiveMap = null),
                                (this.bumpMap = null),
                                (this.bumpScale = 1),
                                (this.normalMap = null),
                                (this.normalMapType = Sr),
                                (this.normalScale = new Gr(1, 1)),
                                (this.displacementMap = null),
                                (this.displacementScale = 1),
                                (this.displacementBias = 0),
                                (this.specularMap = null),
                                (this.alphaMap = null),
                                (this.envMap = null),
                                (this.combine = Di),
                                (this.reflectivity = 1),
                                (this.refractionRatio = 0.98),
                                (this.wireframe = !1),
                                (this.wireframeLinewidth = 1),
                                (this.wireframeLinecap = "round"),
                                (this.wireframeLinejoin = "round"),
                                (this.flatShading = !1),
                                this.setValues(e);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                this.color.copy(e.color),
                                this.specular.copy(e.specular),
                                (this.shininess = e.shininess),
                                (this.map = e.map),
                                (this.lightMap = e.lightMap),
                                (this.lightMapIntensity = e.lightMapIntensity),
                                (this.aoMap = e.aoMap),
                                (this.aoMapIntensity = e.aoMapIntensity),
                                this.emissive.copy(e.emissive),
                                (this.emissiveMap = e.emissiveMap),
                                (this.emissiveIntensity = e.emissiveIntensity),
                                (this.bumpMap = e.bumpMap),
                                (this.bumpScale = e.bumpScale),
                                (this.normalMap = e.normalMap),
                                (this.normalMapType = e.normalMapType),
                                this.normalScale.copy(e.normalScale),
                                (this.displacementMap = e.displacementMap),
                                (this.displacementScale = e.displacementScale),
                                (this.displacementBias = e.displacementBias),
                                (this.specularMap = e.specularMap),
                                (this.alphaMap = e.alphaMap),
                                (this.envMap = e.envMap),
                                (this.combine = e.combine),
                                (this.reflectivity = e.reflectivity),
                                (this.refractionRatio = e.refractionRatio),
                                (this.wireframe = e.wireframe),
                                (this.wireframeLinewidth =
                                    e.wireframeLinewidth),
                                (this.wireframeLinecap = e.wireframeLinecap),
                                (this.wireframeLinejoin = e.wireframeLinejoin),
                                (this.flatShading = e.flatShading),
                                this
                            );
                        }
                    }.prototype.isMeshPhongMaterial = !0),
                    (class extends va {
                        constructor(e) {
                            super(),
                                (this.defines = { TOON: "" }),
                                (this.type = "MeshToonMaterial"),
                                (this.color = new Na(16777215)),
                                (this.map = null),
                                (this.gradientMap = null),
                                (this.lightMap = null),
                                (this.lightMapIntensity = 1),
                                (this.aoMap = null),
                                (this.aoMapIntensity = 1),
                                (this.emissive = new Na(0)),
                                (this.emissiveIntensity = 1),
                                (this.emissiveMap = null),
                                (this.bumpMap = null),
                                (this.bumpScale = 1),
                                (this.normalMap = null),
                                (this.normalMapType = Sr),
                                (this.normalScale = new Gr(1, 1)),
                                (this.displacementMap = null),
                                (this.displacementScale = 1),
                                (this.displacementBias = 0),
                                (this.alphaMap = null),
                                (this.wireframe = !1),
                                (this.wireframeLinewidth = 1),
                                (this.wireframeLinecap = "round"),
                                (this.wireframeLinejoin = "round"),
                                this.setValues(e);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                this.color.copy(e.color),
                                (this.map = e.map),
                                (this.gradientMap = e.gradientMap),
                                (this.lightMap = e.lightMap),
                                (this.lightMapIntensity = e.lightMapIntensity),
                                (this.aoMap = e.aoMap),
                                (this.aoMapIntensity = e.aoMapIntensity),
                                this.emissive.copy(e.emissive),
                                (this.emissiveMap = e.emissiveMap),
                                (this.emissiveIntensity = e.emissiveIntensity),
                                (this.bumpMap = e.bumpMap),
                                (this.bumpScale = e.bumpScale),
                                (this.normalMap = e.normalMap),
                                (this.normalMapType = e.normalMapType),
                                this.normalScale.copy(e.normalScale),
                                (this.displacementMap = e.displacementMap),
                                (this.displacementScale = e.displacementScale),
                                (this.displacementBias = e.displacementBias),
                                (this.alphaMap = e.alphaMap),
                                (this.wireframe = e.wireframe),
                                (this.wireframeLinewidth =
                                    e.wireframeLinewidth),
                                (this.wireframeLinecap = e.wireframeLinecap),
                                (this.wireframeLinejoin = e.wireframeLinejoin),
                                this
                            );
                        }
                    }.prototype.isMeshToonMaterial = !0),
                    (class extends va {
                        constructor(e) {
                            super(),
                                (this.type = "MeshNormalMaterial"),
                                (this.bumpMap = null),
                                (this.bumpScale = 1),
                                (this.normalMap = null),
                                (this.normalMapType = Sr),
                                (this.normalScale = new Gr(1, 1)),
                                (this.displacementMap = null),
                                (this.displacementScale = 1),
                                (this.displacementBias = 0),
                                (this.wireframe = !1),
                                (this.wireframeLinewidth = 1),
                                (this.fog = !1),
                                (this.flatShading = !1),
                                this.setValues(e);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.bumpMap = e.bumpMap),
                                (this.bumpScale = e.bumpScale),
                                (this.normalMap = e.normalMap),
                                (this.normalMapType = e.normalMapType),
                                this.normalScale.copy(e.normalScale),
                                (this.displacementMap = e.displacementMap),
                                (this.displacementScale = e.displacementScale),
                                (this.displacementBias = e.displacementBias),
                                (this.wireframe = e.wireframe),
                                (this.wireframeLinewidth =
                                    e.wireframeLinewidth),
                                (this.flatShading = e.flatShading),
                                this
                            );
                        }
                    }.prototype.isMeshNormalMaterial = !0),
                    (class extends va {
                        constructor(e) {
                            super(),
                                (this.type = "MeshLambertMaterial"),
                                (this.color = new Na(16777215)),
                                (this.map = null),
                                (this.lightMap = null),
                                (this.lightMapIntensity = 1),
                                (this.aoMap = null),
                                (this.aoMapIntensity = 1),
                                (this.emissive = new Na(0)),
                                (this.emissiveIntensity = 1),
                                (this.emissiveMap = null),
                                (this.specularMap = null),
                                (this.alphaMap = null),
                                (this.envMap = null),
                                (this.combine = Di),
                                (this.reflectivity = 1),
                                (this.refractionRatio = 0.98),
                                (this.wireframe = !1),
                                (this.wireframeLinewidth = 1),
                                (this.wireframeLinecap = "round"),
                                (this.wireframeLinejoin = "round"),
                                this.setValues(e);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                this.color.copy(e.color),
                                (this.map = e.map),
                                (this.lightMap = e.lightMap),
                                (this.lightMapIntensity = e.lightMapIntensity),
                                (this.aoMap = e.aoMap),
                                (this.aoMapIntensity = e.aoMapIntensity),
                                this.emissive.copy(e.emissive),
                                (this.emissiveMap = e.emissiveMap),
                                (this.emissiveIntensity = e.emissiveIntensity),
                                (this.specularMap = e.specularMap),
                                (this.alphaMap = e.alphaMap),
                                (this.envMap = e.envMap),
                                (this.combine = e.combine),
                                (this.reflectivity = e.reflectivity),
                                (this.refractionRatio = e.refractionRatio),
                                (this.wireframe = e.wireframe),
                                (this.wireframeLinewidth =
                                    e.wireframeLinewidth),
                                (this.wireframeLinecap = e.wireframeLinecap),
                                (this.wireframeLinejoin = e.wireframeLinejoin),
                                this
                            );
                        }
                    }.prototype.isMeshLambertMaterial = !0),
                    (class extends va {
                        constructor(e) {
                            super(),
                                (this.defines = { MATCAP: "" }),
                                (this.type = "MeshMatcapMaterial"),
                                (this.color = new Na(16777215)),
                                (this.matcap = null),
                                (this.map = null),
                                (this.bumpMap = null),
                                (this.bumpScale = 1),
                                (this.normalMap = null),
                                (this.normalMapType = Sr),
                                (this.normalScale = new Gr(1, 1)),
                                (this.displacementMap = null),
                                (this.displacementScale = 1),
                                (this.displacementBias = 0),
                                (this.alphaMap = null),
                                (this.flatShading = !1),
                                this.setValues(e);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.defines = { MATCAP: "" }),
                                this.color.copy(e.color),
                                (this.matcap = e.matcap),
                                (this.map = e.map),
                                (this.bumpMap = e.bumpMap),
                                (this.bumpScale = e.bumpScale),
                                (this.normalMap = e.normalMap),
                                (this.normalMapType = e.normalMapType),
                                this.normalScale.copy(e.normalScale),
                                (this.displacementMap = e.displacementMap),
                                (this.displacementScale = e.displacementScale),
                                (this.displacementBias = e.displacementBias),
                                (this.alphaMap = e.alphaMap),
                                (this.flatShading = e.flatShading),
                                this
                            );
                        }
                    }.prototype.isMeshMatcapMaterial = !0),
                    (class extends Gh {
                        constructor(e) {
                            super(),
                                (this.type = "LineDashedMaterial"),
                                (this.scale = 1),
                                (this.dashSize = 3),
                                (this.gapSize = 1),
                                this.setValues(e);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.scale = e.scale),
                                (this.dashSize = e.dashSize),
                                (this.gapSize = e.gapSize),
                                this
                            );
                        }
                    }.prototype.isLineDashedMaterial = !0);
                const od = {
                    arraySlice: function (e, t, i) {
                        return od.isTypedArray(e)
                            ? new e.constructor(
                                  e.subarray(t, void 0 !== i ? i : e.length)
                              )
                            : e.slice(t, i);
                    },
                    convertArray: function (e, t, i) {
                        return !e || (!i && e.constructor === t)
                            ? e
                            : "number" == typeof t.BYTES_PER_ELEMENT
                            ? new t(e)
                            : Array.prototype.slice.call(e);
                    },
                    isTypedArray: function (e) {
                        return (
                            ArrayBuffer.isView(e) && !(e instanceof DataView)
                        );
                    },
                    getKeyframeOrder: function (e) {
                        const t = e.length,
                            i = new Array(t);
                        for (let e = 0; e !== t; ++e) i[e] = e;
                        return (
                            i.sort(function (t, i) {
                                return e[t] - e[i];
                            }),
                            i
                        );
                    },
                    sortedArray: function (e, t, i) {
                        const n = e.length,
                            r = new e.constructor(n);
                        for (let s = 0, a = 0; a !== n; ++s) {
                            const n = i[s] * t;
                            for (let i = 0; i !== t; ++i) r[a++] = e[n + i];
                        }
                        return r;
                    },
                    flattenJSON: function (e, t, i, n) {
                        let r = 1,
                            s = e[0];
                        for (; void 0 !== s && void 0 === s[n]; ) s = e[r++];
                        if (void 0 === s) return;
                        let a = s[n];
                        if (void 0 !== a)
                            if (Array.isArray(a))
                                do {
                                    (a = s[n]),
                                        void 0 !== a &&
                                            (t.push(s.time),
                                            i.push.apply(i, a)),
                                        (s = e[r++]);
                                } while (void 0 !== s);
                            else if (void 0 !== a.toArray)
                                do {
                                    (a = s[n]),
                                        void 0 !== a &&
                                            (t.push(s.time),
                                            a.toArray(i, i.length)),
                                        (s = e[r++]);
                                } while (void 0 !== s);
                            else
                                do {
                                    (a = s[n]),
                                        void 0 !== a &&
                                            (t.push(s.time), i.push(a)),
                                        (s = e[r++]);
                                } while (void 0 !== s);
                    },
                    subclip: function (e, t, i, n, r = 30) {
                        const s = e.clone();
                        s.name = t;
                        const a = [];
                        for (let e = 0; e < s.tracks.length; ++e) {
                            const t = s.tracks[e],
                                o = t.getValueSize(),
                                c = [],
                                l = [];
                            for (let e = 0; e < t.times.length; ++e) {
                                const s = t.times[e] * r;
                                if (!(s < i || s >= n)) {
                                    c.push(t.times[e]);
                                    for (let i = 0; i < o; ++i)
                                        l.push(t.values[e * o + i]);
                                }
                            }
                            0 !== c.length &&
                                ((t.times = od.convertArray(
                                    c,
                                    t.times.constructor
                                )),
                                (t.values = od.convertArray(
                                    l,
                                    t.values.constructor
                                )),
                                a.push(t));
                        }
                        s.tracks = a;
                        let o = 1 / 0;
                        for (let e = 0; e < s.tracks.length; ++e)
                            o > s.tracks[e].times[0] &&
                                (o = s.tracks[e].times[0]);
                        for (let e = 0; e < s.tracks.length; ++e)
                            s.tracks[e].shift(-1 * o);
                        return s.resetDuration(), s;
                    },
                    makeClipAdditive: function (e, t = 0, i = e, n = 30) {
                        n <= 0 && (n = 30);
                        const r = i.tracks.length,
                            s = t / n;
                        for (let t = 0; t < r; ++t) {
                            const n = i.tracks[t],
                                r = n.ValueTypeName;
                            if ("bool" === r || "string" === r) continue;
                            const a = e.tracks.find(function (e) {
                                return (
                                    e.name === n.name && e.ValueTypeName === r
                                );
                            });
                            if (void 0 === a) continue;
                            let o = 0;
                            const c = n.getValueSize();
                            n.createInterpolant
                                .isInterpolantFactoryMethodGLTFCubicSpline &&
                                (o = c / 3);
                            let l = 0;
                            const h = a.getValueSize();
                            a.createInterpolant
                                .isInterpolantFactoryMethodGLTFCubicSpline &&
                                (l = h / 3);
                            const u = n.times.length - 1;
                            let d;
                            if (s <= n.times[0]) {
                                const e = o,
                                    t = c - o;
                                d = od.arraySlice(n.values, e, t);
                            } else if (s >= n.times[u]) {
                                const e = u * c + o,
                                    t = e + c - o;
                                d = od.arraySlice(n.values, e, t);
                            } else {
                                const e = n.createInterpolant(),
                                    t = o,
                                    i = c - o;
                                e.evaluate(s),
                                    (d = od.arraySlice(e.resultBuffer, t, i));
                            }
                            "quaternion" === r &&
                                new ns()
                                    .fromArray(d)
                                    .normalize()
                                    .conjugate()
                                    .toArray(d);
                            const p = a.times.length;
                            for (let e = 0; e < p; ++e) {
                                const t = e * h + l;
                                if ("quaternion" === r)
                                    ns.multiplyQuaternionsFlat(
                                        a.values,
                                        t,
                                        d,
                                        0,
                                        a.values,
                                        t
                                    );
                                else {
                                    const e = h - 2 * l;
                                    for (let i = 0; i < e; ++i)
                                        a.values[t + i] -= d[i];
                                }
                            }
                        }
                        return (e.blendMode = 2501), e;
                    },
                };
                class cd {
                    constructor(e, t, i, n) {
                        (this.parameterPositions = e),
                            (this._cachedIndex = 0),
                            (this.resultBuffer =
                                void 0 !== n ? n : new t.constructor(i)),
                            (this.sampleValues = t),
                            (this.valueSize = i),
                            (this.settings = null),
                            (this.DefaultSettings_ = {});
                    }
                    evaluate(e) {
                        const t = this.parameterPositions;
                        let i = this._cachedIndex,
                            n = t[i],
                            r = t[i - 1];
                        e: {
                            t: {
                                let s;
                                i: {
                                    n: if (!(e < n)) {
                                        for (let s = i + 2; ; ) {
                                            if (void 0 === n) {
                                                if (e < r) break n;
                                                return (
                                                    (i = t.length),
                                                    (this._cachedIndex = i),
                                                    this.afterEnd_(i - 1, e, r)
                                                );
                                            }
                                            if (i === s) break;
                                            if (((r = n), (n = t[++i]), e < n))
                                                break t;
                                        }
                                        s = t.length;
                                        break i;
                                    }
                                    if (e >= r) break e;
                                    {
                                        const a = t[1];
                                        e < a && ((i = 2), (r = a));
                                        for (let s = i - 2; ; ) {
                                            if (void 0 === r)
                                                return (
                                                    (this._cachedIndex = 0),
                                                    this.beforeStart_(0, e, n)
                                                );
                                            if (i === s) break;
                                            if (
                                                ((n = r),
                                                (r = t[--i - 1]),
                                                e >= r)
                                            )
                                                break t;
                                        }
                                        (s = i), (i = 0);
                                    }
                                }
                                for (; i < s; ) {
                                    const n = (i + s) >>> 1;
                                    e < t[n] ? (s = n) : (i = n + 1);
                                }
                                if (((n = t[i]), (r = t[i - 1]), void 0 === r))
                                    return (
                                        (this._cachedIndex = 0),
                                        this.beforeStart_(0, e, n)
                                    );
                                if (void 0 === n)
                                    return (
                                        (i = t.length),
                                        (this._cachedIndex = i),
                                        this.afterEnd_(i - 1, r, e)
                                    );
                            }
                            (this._cachedIndex = i),
                                this.intervalChanged_(i, r, n);
                        }
                        return this.interpolate_(i, r, e, n);
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_;
                    }
                    copySampleValue_(e) {
                        const t = this.resultBuffer,
                            i = this.sampleValues,
                            n = this.valueSize,
                            r = e * n;
                        for (let e = 0; e !== n; ++e) t[e] = i[r + e];
                        return t;
                    }
                    interpolate_() {
                        throw new Error("call to abstract method");
                    }
                    intervalChanged_() {}
                }
                (cd.prototype.beforeStart_ = cd.prototype.copySampleValue_),
                    (cd.prototype.afterEnd_ = cd.prototype.copySampleValue_);
                class ld extends cd {
                    constructor(e, t, i, n) {
                        super(e, t, i, n),
                            (this._weightPrev = -0),
                            (this._offsetPrev = -0),
                            (this._weightNext = -0),
                            (this._offsetNext = -0),
                            (this.DefaultSettings_ = {
                                endingStart: pr,
                                endingEnd: pr,
                            });
                    }
                    intervalChanged_(e, t, i) {
                        const n = this.parameterPositions;
                        let r = e - 2,
                            s = e + 1,
                            a = n[r],
                            o = n[s];
                        if (void 0 === a)
                            switch (this.getSettings_().endingStart) {
                                case gr:
                                    (r = e), (a = 2 * t - i);
                                    break;
                                case mr:
                                    (r = n.length - 2),
                                        (a = t + n[r] - n[r + 1]);
                                    break;
                                default:
                                    (r = e), (a = i);
                            }
                        if (void 0 === o)
                            switch (this.getSettings_().endingEnd) {
                                case gr:
                                    (s = e), (o = 2 * i - t);
                                    break;
                                case mr:
                                    (s = 1), (o = i + n[1] - n[0]);
                                    break;
                                default:
                                    (s = e - 1), (o = t);
                            }
                        const c = 0.5 * (i - t),
                            l = this.valueSize;
                        (this._weightPrev = c / (t - a)),
                            (this._weightNext = c / (o - i)),
                            (this._offsetPrev = r * l),
                            (this._offsetNext = s * l);
                    }
                    interpolate_(e, t, i, n) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            a = this.valueSize,
                            o = e * a,
                            c = o - a,
                            l = this._offsetPrev,
                            h = this._offsetNext,
                            u = this._weightPrev,
                            d = this._weightNext,
                            p = (i - t) / (n - t),
                            g = p * p,
                            m = g * p,
                            f = -u * m + 2 * u * g - u * p,
                            _ =
                                (1 + u) * m +
                                (-1.5 - 2 * u) * g +
                                (-0.5 + u) * p +
                                1,
                            M = (-1 - d) * m + (1.5 + d) * g + 0.5 * p,
                            v = d * m - d * g;
                        for (let e = 0; e !== a; ++e)
                            r[e] =
                                f * s[l + e] +
                                _ * s[c + e] +
                                M * s[o + e] +
                                v * s[h + e];
                        return r;
                    }
                }
                class hd extends cd {
                    constructor(e, t, i, n) {
                        super(e, t, i, n);
                    }
                    interpolate_(e, t, i, n) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            a = this.valueSize,
                            o = e * a,
                            c = o - a,
                            l = (i - t) / (n - t),
                            h = 1 - l;
                        for (let e = 0; e !== a; ++e)
                            r[e] = s[c + e] * h + s[o + e] * l;
                        return r;
                    }
                }
                class ud extends cd {
                    constructor(e, t, i, n) {
                        super(e, t, i, n);
                    }
                    interpolate_(e) {
                        return this.copySampleValue_(e - 1);
                    }
                }
                class dd {
                    constructor(e, t, i, n) {
                        if (void 0 === e)
                            throw new Error(
                                "THREE.KeyframeTrack: track name is undefined"
                            );
                        if (void 0 === t || 0 === t.length)
                            throw new Error(
                                "THREE.KeyframeTrack: no keyframes in track named " +
                                    e
                            );
                        (this.name = e),
                            (this.times = od.convertArray(
                                t,
                                this.TimeBufferType
                            )),
                            (this.values = od.convertArray(
                                i,
                                this.ValueBufferType
                            )),
                            this.setInterpolation(
                                n || this.DefaultInterpolation
                            );
                    }
                    static toJSON(e) {
                        const t = e.constructor;
                        let i;
                        if (t.toJSON !== this.toJSON) i = t.toJSON(e);
                        else {
                            i = {
                                name: e.name,
                                times: od.convertArray(e.times, Array),
                                values: od.convertArray(e.values, Array),
                            };
                            const t = e.getInterpolation();
                            t !== e.DefaultInterpolation &&
                                (i.interpolation = t);
                        }
                        return (i.type = e.ValueTypeName), i;
                    }
                    InterpolantFactoryMethodDiscrete(e) {
                        return new ud(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            e
                        );
                    }
                    InterpolantFactoryMethodLinear(e) {
                        return new hd(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            e
                        );
                    }
                    InterpolantFactoryMethodSmooth(e) {
                        return new ld(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            e
                        );
                    }
                    setInterpolation(e) {
                        let t;
                        switch (e) {
                            case hr:
                                t = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case ur:
                                t = this.InterpolantFactoryMethodLinear;
                                break;
                            case dr:
                                t = this.InterpolantFactoryMethodSmooth;
                        }
                        if (void 0 === t) {
                            const t =
                                "unsupported interpolation for " +
                                this.ValueTypeName +
                                " keyframe track named " +
                                this.name;
                            if (void 0 === this.createInterpolant) {
                                if (e === this.DefaultInterpolation)
                                    throw new Error(t);
                                this.setInterpolation(
                                    this.DefaultInterpolation
                                );
                            }
                            return (
                                console.warn("THREE.KeyframeTrack:", t), this
                            );
                        }
                        return (this.createInterpolant = t), this;
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return hr;
                            case this.InterpolantFactoryMethodLinear:
                                return ur;
                            case this.InterpolantFactoryMethodSmooth:
                                return dr;
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length;
                    }
                    shift(e) {
                        if (0 !== e) {
                            const t = this.times;
                            for (let i = 0, n = t.length; i !== n; ++i)
                                t[i] += e;
                        }
                        return this;
                    }
                    scale(e) {
                        if (1 !== e) {
                            const t = this.times;
                            for (let i = 0, n = t.length; i !== n; ++i)
                                t[i] *= e;
                        }
                        return this;
                    }
                    trim(e, t) {
                        const i = this.times,
                            n = i.length;
                        let r = 0,
                            s = n - 1;
                        for (; r !== n && i[r] < e; ) ++r;
                        for (; -1 !== s && i[s] > t; ) --s;
                        if ((++s, 0 !== r || s !== n)) {
                            r >= s && ((s = Math.max(s, 1)), (r = s - 1));
                            const e = this.getValueSize();
                            (this.times = od.arraySlice(i, r, s)),
                                (this.values = od.arraySlice(
                                    this.values,
                                    r * e,
                                    s * e
                                ));
                        }
                        return this;
                    }
                    validate() {
                        let e = !0;
                        const t = this.getValueSize();
                        t - Math.floor(t) != 0 &&
                            (console.error(
                                "THREE.KeyframeTrack: Invalid value size in track.",
                                this
                            ),
                            (e = !1));
                        const i = this.times,
                            n = this.values,
                            r = i.length;
                        0 === r &&
                            (console.error(
                                "THREE.KeyframeTrack: Track is empty.",
                                this
                            ),
                            (e = !1));
                        let s = null;
                        for (let t = 0; t !== r; t++) {
                            const n = i[t];
                            if ("number" == typeof n && isNaN(n)) {
                                console.error(
                                    "THREE.KeyframeTrack: Time is not a valid number.",
                                    this,
                                    t,
                                    n
                                ),
                                    (e = !1);
                                break;
                            }
                            if (null !== s && s > n) {
                                console.error(
                                    "THREE.KeyframeTrack: Out of order keys.",
                                    this,
                                    t,
                                    n,
                                    s
                                ),
                                    (e = !1);
                                break;
                            }
                            s = n;
                        }
                        if (void 0 !== n && od.isTypedArray(n))
                            for (let t = 0, i = n.length; t !== i; ++t) {
                                const i = n[t];
                                if (isNaN(i)) {
                                    console.error(
                                        "THREE.KeyframeTrack: Value is not a valid number.",
                                        this,
                                        t,
                                        i
                                    ),
                                        (e = !1);
                                    break;
                                }
                            }
                        return e;
                    }
                    optimize() {
                        const e = od.arraySlice(this.times),
                            t = od.arraySlice(this.values),
                            i = this.getValueSize(),
                            n = this.getInterpolation() === dr,
                            r = e.length - 1;
                        let s = 1;
                        for (let a = 1; a < r; ++a) {
                            let r = !1;
                            const o = e[a];
                            if (o !== e[a + 1] && (1 !== a || o !== e[0]))
                                if (n) r = !0;
                                else {
                                    const e = a * i,
                                        n = e - i,
                                        s = e + i;
                                    for (let a = 0; a !== i; ++a) {
                                        const i = t[e + a];
                                        if (i !== t[n + a] || i !== t[s + a]) {
                                            r = !0;
                                            break;
                                        }
                                    }
                                }
                            if (r) {
                                if (a !== s) {
                                    e[s] = e[a];
                                    const n = a * i,
                                        r = s * i;
                                    for (let e = 0; e !== i; ++e)
                                        t[r + e] = t[n + e];
                                }
                                ++s;
                            }
                        }
                        if (r > 0) {
                            e[s] = e[r];
                            for (let e = r * i, n = s * i, a = 0; a !== i; ++a)
                                t[n + a] = t[e + a];
                            ++s;
                        }
                        return (
                            s !== e.length
                                ? ((this.times = od.arraySlice(e, 0, s)),
                                  (this.values = od.arraySlice(t, 0, s * i)))
                                : ((this.times = e), (this.values = t)),
                            this
                        );
                    }
                    clone() {
                        const e = od.arraySlice(this.times, 0),
                            t = od.arraySlice(this.values, 0),
                            i = new (0, this.constructor)(this.name, e, t);
                        return (
                            (i.createInterpolant = this.createInterpolant), i
                        );
                    }
                }
                (dd.prototype.TimeBufferType = Float32Array),
                    (dd.prototype.ValueBufferType = Float32Array),
                    (dd.prototype.DefaultInterpolation = ur);
                class pd extends dd {}
                (pd.prototype.ValueTypeName = "bool"),
                    (pd.prototype.ValueBufferType = Array),
                    (pd.prototype.DefaultInterpolation = hr),
                    (pd.prototype.InterpolantFactoryMethodLinear = void 0),
                    (pd.prototype.InterpolantFactoryMethodSmooth = void 0);
                class gd extends dd {}
                gd.prototype.ValueTypeName = "color";
                class md extends dd {}
                md.prototype.ValueTypeName = "number";
                class fd extends cd {
                    constructor(e, t, i, n) {
                        super(e, t, i, n);
                    }
                    interpolate_(e, t, i, n) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            a = this.valueSize,
                            o = (i - t) / (n - t);
                        let c = e * a;
                        for (let e = c + a; c !== e; c += 4)
                            ns.slerpFlat(r, 0, s, c - a, s, c, o);
                        return r;
                    }
                }
                class _d extends dd {
                    InterpolantFactoryMethodLinear(e) {
                        return new fd(
                            this.times,
                            this.values,
                            this.getValueSize(),
                            e
                        );
                    }
                }
                (_d.prototype.ValueTypeName = "quaternion"),
                    (_d.prototype.DefaultInterpolation = ur),
                    (_d.prototype.InterpolantFactoryMethodSmooth = void 0);
                class Md extends dd {}
                (Md.prototype.ValueTypeName = "string"),
                    (Md.prototype.ValueBufferType = Array),
                    (Md.prototype.DefaultInterpolation = hr),
                    (Md.prototype.InterpolantFactoryMethodLinear = void 0),
                    (Md.prototype.InterpolantFactoryMethodSmooth = void 0);
                class vd extends dd {}
                vd.prototype.ValueTypeName = "vector";
                class yd {
                    constructor(e, t = -1, i, n = 2500) {
                        (this.name = e),
                            (this.tracks = i),
                            (this.duration = t),
                            (this.blendMode = n),
                            (this.uuid = Rr()),
                            this.duration < 0 && this.resetDuration();
                    }
                    static parse(e) {
                        const t = [],
                            i = e.tracks,
                            n = 1 / (e.fps || 1);
                        for (let e = 0, r = i.length; e !== r; ++e)
                            t.push(xd(i[e]).scale(n));
                        const r = new this(e.name, e.duration, t, e.blendMode);
                        return (r.uuid = e.uuid), r;
                    }
                    static toJSON(e) {
                        const t = [],
                            i = e.tracks,
                            n = {
                                name: e.name,
                                duration: e.duration,
                                tracks: t,
                                uuid: e.uuid,
                                blendMode: e.blendMode,
                            };
                        for (let e = 0, n = i.length; e !== n; ++e)
                            t.push(dd.toJSON(i[e]));
                        return n;
                    }
                    static CreateFromMorphTargetSequence(e, t, i, n) {
                        const r = t.length,
                            s = [];
                        for (let e = 0; e < r; e++) {
                            let a = [],
                                o = [];
                            a.push((e + r - 1) % r, e, (e + 1) % r),
                                o.push(0, 1, 0);
                            const c = od.getKeyframeOrder(a);
                            (a = od.sortedArray(a, 1, c)),
                                (o = od.sortedArray(o, 1, c)),
                                n || 0 !== a[0] || (a.push(r), o.push(o[0])),
                                s.push(
                                    new md(
                                        ".morphTargetInfluences[" +
                                            t[e].name +
                                            "]",
                                        a,
                                        o
                                    ).scale(1 / i)
                                );
                        }
                        return new this(e, -1, s);
                    }
                    static findByName(e, t) {
                        let i = e;
                        if (!Array.isArray(e)) {
                            const t = e;
                            i =
                                (t.geometry && t.geometry.animations) ||
                                t.animations;
                        }
                        for (let e = 0; e < i.length; e++)
                            if (i[e].name === t) return i[e];
                        return null;
                    }
                    static CreateClipsFromMorphTargetSequences(e, t, i) {
                        const n = {},
                            r = /^([\w-]*?)([\d]+)$/;
                        for (let t = 0, i = e.length; t < i; t++) {
                            const i = e[t],
                                s = i.name.match(r);
                            if (s && s.length > 1) {
                                const e = s[1];
                                let t = n[e];
                                t || (n[e] = t = []), t.push(i);
                            }
                        }
                        const s = [];
                        for (const e in n)
                            s.push(
                                this.CreateFromMorphTargetSequence(
                                    e,
                                    n[e],
                                    t,
                                    i
                                )
                            );
                        return s;
                    }
                    static parseAnimation(e, t) {
                        if (!e)
                            return (
                                console.error(
                                    "THREE.AnimationClip: No animation in JSONLoader data."
                                ),
                                null
                            );
                        const i = function (e, t, i, n, r) {
                                if (0 !== i.length) {
                                    const s = [],
                                        a = [];
                                    od.flattenJSON(i, s, a, n),
                                        0 !== s.length &&
                                            r.push(new e(t, s, a));
                                }
                            },
                            n = [],
                            r = e.name || "default",
                            s = e.fps || 30,
                            a = e.blendMode;
                        let o = e.length || -1;
                        const c = e.hierarchy || [];
                        for (let e = 0; e < c.length; e++) {
                            const r = c[e].keys;
                            if (r && 0 !== r.length)
                                if (r[0].morphTargets) {
                                    const e = {};
                                    let t;
                                    for (t = 0; t < r.length; t++)
                                        if (r[t].morphTargets)
                                            for (
                                                let i = 0;
                                                i < r[t].morphTargets.length;
                                                i++
                                            )
                                                e[r[t].morphTargets[i]] = -1;
                                    for (const i in e) {
                                        const e = [],
                                            s = [];
                                        for (
                                            let n = 0;
                                            n !== r[t].morphTargets.length;
                                            ++n
                                        ) {
                                            const n = r[t];
                                            e.push(n.time),
                                                s.push(
                                                    n.morphTarget === i ? 1 : 0
                                                );
                                        }
                                        n.push(
                                            new md(
                                                ".morphTargetInfluence[" +
                                                    i +
                                                    "]",
                                                e,
                                                s
                                            )
                                        );
                                    }
                                    o = e.length * (s || 1);
                                } else {
                                    const s = ".bones[" + t[e].name + "]";
                                    i(vd, s + ".position", r, "pos", n),
                                        i(_d, s + ".quaternion", r, "rot", n),
                                        i(vd, s + ".scale", r, "scl", n);
                                }
                        }
                        return 0 === n.length ? null : new this(r, o, n, a);
                    }
                    resetDuration() {
                        let e = 0;
                        for (let t = 0, i = this.tracks.length; t !== i; ++t) {
                            const i = this.tracks[t];
                            e = Math.max(e, i.times[i.times.length - 1]);
                        }
                        return (this.duration = e), this;
                    }
                    trim() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].trim(0, this.duration);
                        return this;
                    }
                    validate() {
                        let e = !0;
                        for (let t = 0; t < this.tracks.length; t++)
                            e = e && this.tracks[t].validate();
                        return e;
                    }
                    optimize() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].optimize();
                        return this;
                    }
                    clone() {
                        const e = [];
                        for (let t = 0; t < this.tracks.length; t++)
                            e.push(this.tracks[t].clone());
                        return new this.constructor(
                            this.name,
                            this.duration,
                            e,
                            this.blendMode
                        );
                    }
                    toJSON() {
                        return this.constructor.toJSON(this);
                    }
                }
                function xd(e) {
                    if (void 0 === e.type)
                        throw new Error(
                            "THREE.KeyframeTrack: track type undefined, can not parse"
                        );
                    const t = (function (e) {
                        switch (e.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return md;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return vd;
                            case "color":
                                return gd;
                            case "quaternion":
                                return _d;
                            case "bool":
                            case "boolean":
                                return pd;
                            case "string":
                                return Md;
                        }
                        throw new Error(
                            "THREE.KeyframeTrack: Unsupported typeName: " + e
                        );
                    })(e.type);
                    if (void 0 === e.times) {
                        const t = [],
                            i = [];
                        od.flattenJSON(e.keys, t, i, "value"),
                            (e.times = t),
                            (e.values = i);
                    }
                    return void 0 !== t.parse
                        ? t.parse(e)
                        : new t(e.name, e.times, e.values, e.interpolation);
                }
                const bd = {
                        enabled: !1,
                        files: {},
                        add: function (e, t) {
                            !1 !== this.enabled && (this.files[e] = t);
                        },
                        get: function (e) {
                            if (!1 !== this.enabled) return this.files[e];
                        },
                        remove: function (e) {
                            delete this.files[e];
                        },
                        clear: function () {
                            this.files = {};
                        },
                    },
                    wd = new (class {
                        constructor(e, t, i) {
                            const n = this;
                            let r,
                                s = !1,
                                a = 0,
                                o = 0;
                            const c = [];
                            (this.onStart = void 0),
                                (this.onLoad = e),
                                (this.onProgress = t),
                                (this.onError = i),
                                (this.itemStart = function (e) {
                                    o++,
                                        !1 === s &&
                                            void 0 !== n.onStart &&
                                            n.onStart(e, a, o),
                                        (s = !0);
                                }),
                                (this.itemEnd = function (e) {
                                    a++,
                                        void 0 !== n.onProgress &&
                                            n.onProgress(e, a, o),
                                        a === o &&
                                            ((s = !1),
                                            void 0 !== n.onLoad && n.onLoad());
                                }),
                                (this.itemError = function (e) {
                                    void 0 !== n.onError && n.onError(e);
                                }),
                                (this.resolveURL = function (e) {
                                    return r ? r(e) : e;
                                }),
                                (this.setURLModifier = function (e) {
                                    return (r = e), this;
                                }),
                                (this.addHandler = function (e, t) {
                                    return c.push(e, t), this;
                                }),
                                (this.removeHandler = function (e) {
                                    const t = c.indexOf(e);
                                    return -1 !== t && c.splice(t, 2), this;
                                }),
                                (this.getHandler = function (e) {
                                    for (
                                        let t = 0, i = c.length;
                                        t < i;
                                        t += 2
                                    ) {
                                        const i = c[t],
                                            n = c[t + 1];
                                        if (
                                            (i.global && (i.lastIndex = 0),
                                            i.test(e))
                                        )
                                            return n;
                                    }
                                    return null;
                                });
                        }
                    })();
                class Td {
                    constructor(e) {
                        (this.manager = void 0 !== e ? e : wd),
                            (this.crossOrigin = "anonymous"),
                            (this.withCredentials = !1),
                            (this.path = ""),
                            (this.resourcePath = ""),
                            (this.requestHeader = {});
                    }
                    load() {}
                    loadAsync(e, t) {
                        const i = this;
                        return new Promise(function (n, r) {
                            i.load(e, n, t, r);
                        });
                    }
                    parse() {}
                    setCrossOrigin(e) {
                        return (this.crossOrigin = e), this;
                    }
                    setWithCredentials(e) {
                        return (this.withCredentials = e), this;
                    }
                    setPath(e) {
                        return (this.path = e), this;
                    }
                    setResourcePath(e) {
                        return (this.resourcePath = e), this;
                    }
                    setRequestHeader(e) {
                        return (this.requestHeader = e), this;
                    }
                }
                const Sd = {};
                class Nd extends Td {
                    constructor(e) {
                        super(e);
                    }
                    load(e, t, i, n) {
                        void 0 === e && (e = ""),
                            void 0 !== this.path && (e = this.path + e),
                            (e = this.manager.resolveURL(e));
                        const r = bd.get(e);
                        if (void 0 !== r)
                            return (
                                this.manager.itemStart(e),
                                setTimeout(() => {
                                    t && t(r), this.manager.itemEnd(e);
                                }, 0),
                                r
                            );
                        if (void 0 !== Sd[e])
                            return void Sd[e].push({
                                onLoad: t,
                                onProgress: i,
                                onError: n,
                            });
                        (Sd[e] = []),
                            Sd[e].push({
                                onLoad: t,
                                onProgress: i,
                                onError: n,
                            });
                        const s = new Request(e, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials
                                ? "include"
                                : "same-origin",
                        });
                        fetch(s)
                            .then((t) => {
                                if (200 === t.status || 0 === t.status) {
                                    0 === t.status &&
                                        console.warn(
                                            "THREE.FileLoader: HTTP Status 0 received."
                                        );
                                    const i = Sd[e],
                                        n = t.body.getReader(),
                                        r = t.headers.get("Content-Length"),
                                        s = r ? parseInt(r) : 0,
                                        a = 0 !== s;
                                    let o = 0;
                                    return new ReadableStream({
                                        start(e) {
                                            !(function t() {
                                                n.read().then(
                                                    ({ done: n, value: r }) => {
                                                        if (n) e.close();
                                                        else {
                                                            o += r.byteLength;
                                                            const n =
                                                                new ProgressEvent(
                                                                    "progress",
                                                                    {
                                                                        lengthComputable:
                                                                            a,
                                                                        loaded: o,
                                                                        total: s,
                                                                    }
                                                                );
                                                            for (
                                                                let e = 0,
                                                                    t =
                                                                        i.length;
                                                                e < t;
                                                                e++
                                                            ) {
                                                                const t = i[e];
                                                                t.onProgress &&
                                                                    t.onProgress(
                                                                        n
                                                                    );
                                                            }
                                                            e.enqueue(r), t();
                                                        }
                                                    }
                                                );
                                            })();
                                        },
                                    });
                                }
                                throw Error(
                                    `fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`
                                );
                            })
                            .then((e) => {
                                const t = new Response(e);
                                switch (this.responseType) {
                                    case "arraybuffer":
                                        return t.arrayBuffer();
                                    case "blob":
                                        return t.blob();
                                    case "document":
                                        return t
                                            .text()
                                            .then((e) =>
                                                new DOMParser().parseFromString(
                                                    e,
                                                    this.mimeType
                                                )
                                            );
                                    case "json":
                                        return t.json();
                                    default:
                                        return t.text();
                                }
                            })
                            .then((t) => {
                                bd.add(e, t);
                                const i = Sd[e];
                                delete Sd[e];
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    n.onLoad && n.onLoad(t);
                                }
                                this.manager.itemEnd(e);
                            })
                            .catch((t) => {
                                const i = Sd[e];
                                delete Sd[e];
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    n.onError && n.onError(t);
                                }
                                this.manager.itemError(e),
                                    this.manager.itemEnd(e);
                            }),
                            this.manager.itemStart(e);
                    }
                    setResponseType(e) {
                        return (this.responseType = e), this;
                    }
                    setMimeType(e) {
                        return (this.mimeType = e), this;
                    }
                }
                class Dd extends Td {
                    constructor(e) {
                        super(e);
                    }
                    load(e, t, i, n) {
                        void 0 !== this.path && (e = this.path + e),
                            (e = this.manager.resolveURL(e));
                        const r = this,
                            s = bd.get(e);
                        if (void 0 !== s)
                            return (
                                r.manager.itemStart(e),
                                setTimeout(function () {
                                    t && t(s), r.manager.itemEnd(e);
                                }, 0),
                                s
                            );
                        const a = qr("img");
                        function o() {
                            l(),
                                bd.add(e, this),
                                t && t(this),
                                r.manager.itemEnd(e);
                        }
                        function c(t) {
                            l(),
                                n && n(t),
                                r.manager.itemError(e),
                                r.manager.itemEnd(e);
                        }
                        function l() {
                            a.removeEventListener("load", o, !1),
                                a.removeEventListener("error", c, !1);
                        }
                        return (
                            a.addEventListener("load", o, !1),
                            a.addEventListener("error", c, !1),
                            "data:" !== e.substr(0, 5) &&
                                void 0 !== this.crossOrigin &&
                                (a.crossOrigin = this.crossOrigin),
                            r.manager.itemStart(e),
                            (a.src = e),
                            a
                        );
                    }
                }
                class Id extends Td {
                    constructor(e) {
                        super(e);
                    }
                    load(e, t, i, n) {
                        const r = new _o(),
                            s = new Dd(this.manager);
                        s.setCrossOrigin(this.crossOrigin),
                            s.setPath(this.path);
                        let a = 0;
                        function o(i) {
                            s.load(
                                e[i],
                                function (e) {
                                    (r.images[i] = e),
                                        a++,
                                        6 === a &&
                                            ((r.needsUpdate = !0), t && t(r));
                                },
                                void 0,
                                n
                            );
                        }
                        for (let t = 0; t < e.length; ++t) o(t);
                        return r;
                    }
                }
                class Cd extends Td {
                    constructor(e) {
                        super(e);
                    }
                    load(e, t, i, n) {
                        const r = new Jr(),
                            s = new Dd(this.manager);
                        return (
                            s.setCrossOrigin(this.crossOrigin),
                            s.setPath(this.path),
                            s.load(
                                e,
                                function (e) {
                                    (r.image = e),
                                        (r.needsUpdate = !0),
                                        void 0 !== t && t(r);
                                },
                                i,
                                n
                            ),
                            r
                        );
                    }
                }
                class Ad extends aa {
                    constructor(e, t = 1) {
                        super(),
                            (this.type = "Light"),
                            (this.color = new Na(e)),
                            (this.intensity = t);
                    }
                    dispose() {}
                    copy(e) {
                        return (
                            super.copy(e),
                            this.color.copy(e.color),
                            (this.intensity = e.intensity),
                            this
                        );
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return (
                            (t.object.color = this.color.getHex()),
                            (t.object.intensity = this.intensity),
                            void 0 !== this.groundColor &&
                                (t.object.groundColor =
                                    this.groundColor.getHex()),
                            void 0 !== this.distance &&
                                (t.object.distance = this.distance),
                            void 0 !== this.angle &&
                                (t.object.angle = this.angle),
                            void 0 !== this.decay &&
                                (t.object.decay = this.decay),
                            void 0 !== this.penumbra &&
                                (t.object.penumbra = this.penumbra),
                            void 0 !== this.shadow &&
                                (t.object.shadow = this.shadow.toJSON()),
                            t
                        );
                    }
                }
                (Ad.prototype.isLight = !0),
                    (class extends Ad {
                        constructor(e, t, i) {
                            super(e, i),
                                (this.type = "HemisphereLight"),
                                this.position.copy(aa.DefaultUp),
                                this.updateMatrix(),
                                (this.groundColor = new Na(t));
                        }
                        copy(e) {
                            return (
                                Ad.prototype.copy.call(this, e),
                                this.groundColor.copy(e.groundColor),
                                this
                            );
                        }
                    }.prototype.isHemisphereLight = !0);
                const Ed = new Os(),
                    Ld = new rs(),
                    zd = new rs();
                class jd {
                    constructor(e) {
                        (this.camera = e),
                            (this.bias = 0),
                            (this.normalBias = 0),
                            (this.radius = 1),
                            (this.blurSamples = 8),
                            (this.mapSize = new Gr(512, 512)),
                            (this.map = null),
                            (this.mapPass = null),
                            (this.matrix = new Os()),
                            (this.autoUpdate = !0),
                            (this.needsUpdate = !1),
                            (this._frustum = new So()),
                            (this._frameExtents = new Gr(1, 1)),
                            (this._viewportCount = 1),
                            (this._viewports = [new es(0, 0, 1, 1)]);
                    }
                    getViewportCount() {
                        return this._viewportCount;
                    }
                    getFrustum() {
                        return this._frustum;
                    }
                    updateMatrices(e) {
                        const t = this.camera,
                            i = this.matrix;
                        Ld.setFromMatrixPosition(e.matrixWorld),
                            t.position.copy(Ld),
                            zd.setFromMatrixPosition(e.target.matrixWorld),
                            t.lookAt(zd),
                            t.updateMatrixWorld(),
                            Ed.multiplyMatrices(
                                t.projectionMatrix,
                                t.matrixWorldInverse
                            ),
                            this._frustum.setFromProjectionMatrix(Ed),
                            i.set(
                                0.5,
                                0,
                                0,
                                0.5,
                                0,
                                0.5,
                                0,
                                0.5,
                                0,
                                0,
                                0.5,
                                0.5,
                                0,
                                0,
                                0,
                                1
                            ),
                            i.multiply(t.projectionMatrix),
                            i.multiply(t.matrixWorldInverse);
                    }
                    getViewport(e) {
                        return this._viewports[e];
                    }
                    getFrameExtents() {
                        return this._frameExtents;
                    }
                    dispose() {
                        this.map && this.map.dispose(),
                            this.mapPass && this.mapPass.dispose();
                    }
                    copy(e) {
                        return (
                            (this.camera = e.camera.clone()),
                            (this.bias = e.bias),
                            (this.radius = e.radius),
                            this.mapSize.copy(e.mapSize),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    toJSON() {
                        const e = {};
                        return (
                            0 !== this.bias && (e.bias = this.bias),
                            0 !== this.normalBias &&
                                (e.normalBias = this.normalBias),
                            1 !== this.radius && (e.radius = this.radius),
                            (512 === this.mapSize.x &&
                                512 === this.mapSize.y) ||
                                (e.mapSize = this.mapSize.toArray()),
                            (e.camera = this.camera.toJSON(!1).object),
                            delete e.camera.matrix,
                            e
                        );
                    }
                }
                class Od extends jd {
                    constructor() {
                        super(new go(50, 1, 0.5, 500)), (this.focus = 1);
                    }
                    updateMatrices(e) {
                        const t = this.camera,
                            i = 2 * jr * e.angle * this.focus,
                            n = this.mapSize.width / this.mapSize.height,
                            r = e.distance || t.far;
                        (i === t.fov && n === t.aspect && r === t.far) ||
                            ((t.fov = i),
                            (t.aspect = n),
                            (t.far = r),
                            t.updateProjectionMatrix()),
                            super.updateMatrices(e);
                    }
                    copy(e) {
                        return super.copy(e), (this.focus = e.focus), this;
                    }
                }
                (Od.prototype.isSpotLightShadow = !0),
                    (class extends Ad {
                        constructor(
                            e,
                            t,
                            i = 0,
                            n = Math.PI / 3,
                            r = 0,
                            s = 1
                        ) {
                            super(e, t),
                                (this.type = "SpotLight"),
                                this.position.copy(aa.DefaultUp),
                                this.updateMatrix(),
                                (this.target = new aa()),
                                (this.distance = i),
                                (this.angle = n),
                                (this.penumbra = r),
                                (this.decay = s),
                                (this.shadow = new Od());
                        }
                        get power() {
                            return this.intensity * Math.PI;
                        }
                        set power(e) {
                            this.intensity = e / Math.PI;
                        }
                        dispose() {
                            this.shadow.dispose();
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.distance = e.distance),
                                (this.angle = e.angle),
                                (this.penumbra = e.penumbra),
                                (this.decay = e.decay),
                                (this.target = e.target.clone()),
                                (this.shadow = e.shadow.clone()),
                                this
                            );
                        }
                    }.prototype.isSpotLight = !0);
                const kd = new Os(),
                    Rd = new rs(),
                    Pd = new rs();
                class Ud extends jd {
                    constructor() {
                        super(new go(90, 1, 0.5, 500)),
                            (this._frameExtents = new Gr(4, 2)),
                            (this._viewportCount = 6),
                            (this._viewports = [
                                new es(2, 1, 1, 1),
                                new es(0, 1, 1, 1),
                                new es(3, 1, 1, 1),
                                new es(1, 1, 1, 1),
                                new es(3, 0, 1, 1),
                                new es(1, 0, 1, 1),
                            ]),
                            (this._cubeDirections = [
                                new rs(1, 0, 0),
                                new rs(-1, 0, 0),
                                new rs(0, 0, 1),
                                new rs(0, 0, -1),
                                new rs(0, 1, 0),
                                new rs(0, -1, 0),
                            ]),
                            (this._cubeUps = [
                                new rs(0, 1, 0),
                                new rs(0, 1, 0),
                                new rs(0, 1, 0),
                                new rs(0, 1, 0),
                                new rs(0, 0, 1),
                                new rs(0, 0, -1),
                            ]);
                    }
                    updateMatrices(e, t = 0) {
                        const i = this.camera,
                            n = this.matrix,
                            r = e.distance || i.far;
                        r !== i.far &&
                            ((i.far = r), i.updateProjectionMatrix()),
                            Rd.setFromMatrixPosition(e.matrixWorld),
                            i.position.copy(Rd),
                            Pd.copy(i.position),
                            Pd.add(this._cubeDirections[t]),
                            i.up.copy(this._cubeUps[t]),
                            i.lookAt(Pd),
                            i.updateMatrixWorld(),
                            n.makeTranslation(-Rd.x, -Rd.y, -Rd.z),
                            kd.multiplyMatrices(
                                i.projectionMatrix,
                                i.matrixWorldInverse
                            ),
                            this._frustum.setFromProjectionMatrix(kd);
                    }
                }
                (Ud.prototype.isPointLightShadow = !0),
                    (class extends Ad {
                        constructor(e, t, i = 0, n = 1) {
                            super(e, t),
                                (this.type = "PointLight"),
                                (this.distance = i),
                                (this.decay = n),
                                (this.shadow = new Ud());
                        }
                        get power() {
                            return 4 * this.intensity * Math.PI;
                        }
                        set power(e) {
                            this.intensity = e / (4 * Math.PI);
                        }
                        dispose() {
                            this.shadow.dispose();
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.distance = e.distance),
                                (this.decay = e.decay),
                                (this.shadow = e.shadow.clone()),
                                this
                            );
                        }
                    }.prototype.isPointLight = !0);
                class $d extends jd {
                    constructor() {
                        super(new Po(-5, 5, 5, -5, 0.5, 500));
                    }
                }
                ($d.prototype.isDirectionalLightShadow = !0),
                    (class extends Ad {
                        constructor(e, t) {
                            super(e, t),
                                (this.type = "DirectionalLight"),
                                this.position.copy(aa.DefaultUp),
                                this.updateMatrix(),
                                (this.target = new aa()),
                                (this.shadow = new $d());
                        }
                        dispose() {
                            this.shadow.dispose();
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.target = e.target.clone()),
                                (this.shadow = e.shadow.clone()),
                                this
                            );
                        }
                    }.prototype.isDirectionalLight = !0),
                    (class extends Ad {
                        constructor(e, t) {
                            super(e, t), (this.type = "AmbientLight");
                        }
                    }.prototype.isAmbientLight = !0),
                    (class extends Ad {
                        constructor(e, t, i = 10, n = 10) {
                            super(e, t),
                                (this.type = "RectAreaLight"),
                                (this.width = i),
                                (this.height = n);
                        }
                        get power() {
                            return (
                                this.intensity *
                                this.width *
                                this.height *
                                Math.PI
                            );
                        }
                        set power(e) {
                            this.intensity =
                                e / (this.width * this.height * Math.PI);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.width = e.width),
                                (this.height = e.height),
                                this
                            );
                        }
                        toJSON(e) {
                            const t = super.toJSON(e);
                            return (
                                (t.object.width = this.width),
                                (t.object.height = this.height),
                                t
                            );
                        }
                    }.prototype.isRectAreaLight = !0);
                class Bd {
                    constructor() {
                        this.coefficients = [];
                        for (let e = 0; e < 9; e++)
                            this.coefficients.push(new rs());
                    }
                    set(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].copy(e[t]);
                        return this;
                    }
                    zero() {
                        for (let e = 0; e < 9; e++)
                            this.coefficients[e].set(0, 0, 0);
                        return this;
                    }
                    getAt(e, t) {
                        const i = e.x,
                            n = e.y,
                            r = e.z,
                            s = this.coefficients;
                        return (
                            t.copy(s[0]).multiplyScalar(0.282095),
                            t.addScaledVector(s[1], 0.488603 * n),
                            t.addScaledVector(s[2], 0.488603 * r),
                            t.addScaledVector(s[3], 0.488603 * i),
                            t.addScaledVector(s[4], i * n * 1.092548),
                            t.addScaledVector(s[5], n * r * 1.092548),
                            t.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
                            t.addScaledVector(s[7], i * r * 1.092548),
                            t.addScaledVector(s[8], 0.546274 * (i * i - n * n)),
                            t
                        );
                    }
                    getIrradianceAt(e, t) {
                        const i = e.x,
                            n = e.y,
                            r = e.z,
                            s = this.coefficients;
                        return (
                            t.copy(s[0]).multiplyScalar(0.886227),
                            t.addScaledVector(s[1], 1.023328 * n),
                            t.addScaledVector(s[2], 1.023328 * r),
                            t.addScaledVector(s[3], 1.023328 * i),
                            t.addScaledVector(s[4], 0.858086 * i * n),
                            t.addScaledVector(s[5], 0.858086 * n * r),
                            t.addScaledVector(
                                s[6],
                                0.743125 * r * r - 0.247708
                            ),
                            t.addScaledVector(s[7], 0.858086 * i * r),
                            t.addScaledVector(s[8], 0.429043 * (i * i - n * n)),
                            t
                        );
                    }
                    add(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].add(e.coefficients[t]);
                        return this;
                    }
                    addScaledSH(e, t) {
                        for (let i = 0; i < 9; i++)
                            this.coefficients[i].addScaledVector(
                                e.coefficients[i],
                                t
                            );
                        return this;
                    }
                    scale(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].multiplyScalar(e);
                        return this;
                    }
                    lerp(e, t) {
                        for (let i = 0; i < 9; i++)
                            this.coefficients[i].lerp(e.coefficients[i], t);
                        return this;
                    }
                    equals(e) {
                        for (let t = 0; t < 9; t++)
                            if (!this.coefficients[t].equals(e.coefficients[t]))
                                return !1;
                        return !0;
                    }
                    copy(e) {
                        return this.set(e.coefficients);
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    fromArray(e, t = 0) {
                        const i = this.coefficients;
                        for (let n = 0; n < 9; n++)
                            i[n].fromArray(e, t + 3 * n);
                        return this;
                    }
                    toArray(e = [], t = 0) {
                        const i = this.coefficients;
                        for (let n = 0; n < 9; n++) i[n].toArray(e, t + 3 * n);
                        return e;
                    }
                    static getBasisAt(e, t) {
                        const i = e.x,
                            n = e.y,
                            r = e.z;
                        (t[0] = 0.282095),
                            (t[1] = 0.488603 * n),
                            (t[2] = 0.488603 * r),
                            (t[3] = 0.488603 * i),
                            (t[4] = 1.092548 * i * n),
                            (t[5] = 1.092548 * n * r),
                            (t[6] = 0.315392 * (3 * r * r - 1)),
                            (t[7] = 1.092548 * i * r),
                            (t[8] = 0.546274 * (i * i - n * n));
                    }
                }
                Bd.prototype.isSphericalHarmonics3 = !0;
                class Fd extends Ad {
                    constructor(e = new Bd(), t = 1) {
                        super(void 0, t), (this.sh = e);
                    }
                    copy(e) {
                        return super.copy(e), this.sh.copy(e.sh), this;
                    }
                    fromJSON(e) {
                        return (
                            (this.intensity = e.intensity),
                            this.sh.fromArray(e.sh),
                            this
                        );
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return (t.object.sh = this.sh.toArray()), t;
                    }
                }
                Fd.prototype.isLightProbe = !0;
                class Hd {
                    static decodeText(e) {
                        if ("undefined" != typeof TextDecoder)
                            return new TextDecoder().decode(e);
                        let t = "";
                        for (let i = 0, n = e.length; i < n; i++)
                            t += String.fromCharCode(e[i]);
                        try {
                            return decodeURIComponent(escape(t));
                        } catch (e) {
                            return t;
                        }
                    }
                    static extractUrlBase(e) {
                        const t = e.lastIndexOf("/");
                        return -1 === t ? "./" : e.substr(0, t + 1);
                    }
                    static resolveURL(e, t) {
                        return "string" != typeof e || "" === e
                            ? ""
                            : (/^https?:\/\//i.test(t) &&
                                  /^\//.test(e) &&
                                  (t = t.replace(
                                      /(^https?:\/\/[^\/]+).*/i,
                                      "$1"
                                  )),
                              /^(https?:)?\/\//i.test(e) ||
                              /^data:.*,.*$/i.test(e) ||
                              /^blob:.*$/i.test(e)
                                  ? e
                                  : t + e);
                    }
                }
                let Gd;
                ((class extends Ba {
                    constructor() {
                        super(),
                            (this.type = "InstancedBufferGeometry"),
                            (this.instanceCount = 1 / 0);
                    }
                    copy(e) {
                        return (
                            super.copy(e),
                            (this.instanceCount = e.instanceCount),
                            this
                        );
                    }
                    clone() {
                        return new this.constructor().copy(this);
                    }
                    toJSON() {
                        const e = super.toJSON(this);
                        return (
                            (e.instanceCount = this.instanceCount),
                            (e.isInstancedBufferGeometry = !0),
                            e
                        );
                    }
                }).prototype.isInstancedBufferGeometry = !0),
                    (class extends Td {
                        constructor(e) {
                            super(e),
                                "undefined" == typeof createImageBitmap &&
                                    console.warn(
                                        "THREE.ImageBitmapLoader: createImageBitmap() not supported."
                                    ),
                                "undefined" == typeof fetch &&
                                    console.warn(
                                        "THREE.ImageBitmapLoader: fetch() not supported."
                                    ),
                                (this.options = { premultiplyAlpha: "none" });
                        }
                        setOptions(e) {
                            return (this.options = e), this;
                        }
                        load(e, t, i, n) {
                            void 0 === e && (e = ""),
                                void 0 !== this.path && (e = this.path + e),
                                (e = this.manager.resolveURL(e));
                            const r = this,
                                s = bd.get(e);
                            if (void 0 !== s)
                                return (
                                    r.manager.itemStart(e),
                                    setTimeout(function () {
                                        t && t(s), r.manager.itemEnd(e);
                                    }, 0),
                                    s
                                );
                            const a = {};
                            (a.credentials =
                                "anonymous" === this.crossOrigin
                                    ? "same-origin"
                                    : "include"),
                                (a.headers = this.requestHeader),
                                fetch(e, a)
                                    .then(function (e) {
                                        return e.blob();
                                    })
                                    .then(function (e) {
                                        return createImageBitmap(
                                            e,
                                            Object.assign(r.options, {
                                                colorSpaceConversion: "none",
                                            })
                                        );
                                    })
                                    .then(function (i) {
                                        bd.add(e, i),
                                            t && t(i),
                                            r.manager.itemEnd(e);
                                    })
                                    .catch(function (t) {
                                        n && n(t),
                                            r.manager.itemError(e),
                                            r.manager.itemEnd(e);
                                    }),
                                r.manager.itemStart(e);
                        }
                    }.prototype.isImageBitmapLoader = !0);
                class Vd extends Td {
                    constructor(e) {
                        super(e);
                    }
                    load(e, t, i, n) {
                        const r = this,
                            s = new Nd(this.manager);
                        s.setResponseType("arraybuffer"),
                            s.setPath(this.path),
                            s.setRequestHeader(this.requestHeader),
                            s.setWithCredentials(this.withCredentials),
                            s.load(
                                e,
                                function (i) {
                                    try {
                                        const e = i.slice(0);
                                        (void 0 === Gd &&
                                            (Gd = new (window.AudioContext ||
                                                window.webkitAudioContext)()),
                                        Gd).decodeAudioData(e, function (e) {
                                            t(e);
                                        });
                                    } catch (t) {
                                        n ? n(t) : console.error(t),
                                            r.manager.itemError(e);
                                    }
                                },
                                i,
                                n
                            );
                    }
                }
                ((class extends Fd {
                    constructor(e, t, i = 1) {
                        super(void 0, i);
                        const n = new Na().set(e),
                            r = new Na().set(t),
                            s = new rs(n.r, n.g, n.b),
                            a = new rs(r.r, r.g, r.b),
                            o = Math.sqrt(Math.PI),
                            c = o * Math.sqrt(0.75);
                        this.sh.coefficients[0]
                            .copy(s)
                            .add(a)
                            .multiplyScalar(o),
                            this.sh.coefficients[1]
                                .copy(s)
                                .sub(a)
                                .multiplyScalar(c);
                    }
                }).prototype.isHemisphereLightProbe = !0),
                    (class extends Fd {
                        constructor(e, t = 1) {
                            super(void 0, t);
                            const i = new Na().set(e);
                            this.sh.coefficients[0]
                                .set(i.r, i.g, i.b)
                                .multiplyScalar(2 * Math.sqrt(Math.PI));
                        }
                    }.prototype.isAmbientLightProbe = !0);
                class Yd {
                    constructor(e = !0) {
                        (this.autoStart = e),
                            (this.startTime = 0),
                            (this.oldTime = 0),
                            (this.elapsedTime = 0),
                            (this.running = !1);
                    }
                    start() {
                        (this.startTime = qd()),
                            (this.oldTime = this.startTime),
                            (this.elapsedTime = 0),
                            (this.running = !0);
                    }
                    stop() {
                        this.getElapsedTime(),
                            (this.running = !1),
                            (this.autoStart = !1);
                    }
                    getElapsedTime() {
                        return this.getDelta(), this.elapsedTime;
                    }
                    getDelta() {
                        let e = 0;
                        if (this.autoStart && !this.running)
                            return this.start(), 0;
                        if (this.running) {
                            const t = qd();
                            (e = (t - this.oldTime) / 1e3),
                                (this.oldTime = t),
                                (this.elapsedTime += e);
                        }
                        return e;
                    }
                }
                function qd() {
                    return (
                        "undefined" == typeof performance ? Date : performance
                    ).now();
                }
                class Wd {
                    constructor(e, t, i) {
                        let n, r, s;
                        switch (((this.binding = e), (this.valueSize = i), t)) {
                            case "quaternion":
                                (n = this._slerp),
                                    (r = this._slerpAdditive),
                                    (s = this._setAdditiveIdentityQuaternion),
                                    (this.buffer = new Float64Array(6 * i)),
                                    (this._workIndex = 5);
                                break;
                            case "string":
                            case "bool":
                                (n = this._select),
                                    (r = this._select),
                                    (s = this._setAdditiveIdentityOther),
                                    (this.buffer = new Array(5 * i));
                                break;
                            default:
                                (n = this._lerp),
                                    (r = this._lerpAdditive),
                                    (s = this._setAdditiveIdentityNumeric),
                                    (this.buffer = new Float64Array(5 * i));
                        }
                        (this._mixBufferRegion = n),
                            (this._mixBufferRegionAdditive = r),
                            (this._setIdentity = s),
                            (this._origIndex = 3),
                            (this._addIndex = 4),
                            (this.cumulativeWeight = 0),
                            (this.cumulativeWeightAdditive = 0),
                            (this.useCount = 0),
                            (this.referenceCount = 0);
                    }
                    accumulate(e, t) {
                        const i = this.buffer,
                            n = this.valueSize,
                            r = e * n + n;
                        let s = this.cumulativeWeight;
                        if (0 === s) {
                            for (let e = 0; e !== n; ++e) i[r + e] = i[e];
                            s = t;
                        } else {
                            s += t;
                            const e = t / s;
                            this._mixBufferRegion(i, r, 0, e, n);
                        }
                        this.cumulativeWeight = s;
                    }
                    accumulateAdditive(e) {
                        const t = this.buffer,
                            i = this.valueSize,
                            n = i * this._addIndex;
                        0 === this.cumulativeWeightAdditive &&
                            this._setIdentity(),
                            this._mixBufferRegionAdditive(t, n, 0, e, i),
                            (this.cumulativeWeightAdditive += e);
                    }
                    apply(e) {
                        const t = this.valueSize,
                            i = this.buffer,
                            n = e * t + t,
                            r = this.cumulativeWeight,
                            s = this.cumulativeWeightAdditive,
                            a = this.binding;
                        if (
                            ((this.cumulativeWeight = 0),
                            (this.cumulativeWeightAdditive = 0),
                            r < 1)
                        ) {
                            const e = t * this._origIndex;
                            this._mixBufferRegion(i, n, e, 1 - r, t);
                        }
                        s > 0 &&
                            this._mixBufferRegionAdditive(
                                i,
                                n,
                                this._addIndex * t,
                                1,
                                t
                            );
                        for (let e = t, r = t + t; e !== r; ++e)
                            if (i[e] !== i[e + t]) {
                                a.setValue(i, n);
                                break;
                            }
                    }
                    saveOriginalState() {
                        const e = this.binding,
                            t = this.buffer,
                            i = this.valueSize,
                            n = i * this._origIndex;
                        e.getValue(t, n);
                        for (let e = i, r = n; e !== r; ++e)
                            t[e] = t[n + (e % i)];
                        this._setIdentity(),
                            (this.cumulativeWeight = 0),
                            (this.cumulativeWeightAdditive = 0);
                    }
                    restoreOriginalState() {
                        const e = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, e);
                    }
                    _setAdditiveIdentityNumeric() {
                        const e = this._addIndex * this.valueSize,
                            t = e + this.valueSize;
                        for (let i = e; i < t; i++) this.buffer[i] = 0;
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(),
                            (this.buffer[
                                this._addIndex * this.valueSize + 3
                            ] = 1);
                    }
                    _setAdditiveIdentityOther() {
                        const e = this._origIndex * this.valueSize,
                            t = this._addIndex * this.valueSize;
                        for (let i = 0; i < this.valueSize; i++)
                            this.buffer[t + i] = this.buffer[e + i];
                    }
                    _select(e, t, i, n, r) {
                        if (n >= 0.5)
                            for (let n = 0; n !== r; ++n) e[t + n] = e[i + n];
                    }
                    _slerp(e, t, i, n) {
                        ns.slerpFlat(e, t, e, t, e, i, n);
                    }
                    _slerpAdditive(e, t, i, n, r) {
                        const s = this._workIndex * r;
                        ns.multiplyQuaternionsFlat(e, s, e, t, e, i),
                            ns.slerpFlat(e, t, e, t, e, s, n);
                    }
                    _lerp(e, t, i, n, r) {
                        const s = 1 - n;
                        for (let a = 0; a !== r; ++a) {
                            const r = t + a;
                            e[r] = e[r] * s + e[i + a] * n;
                        }
                    }
                    _lerpAdditive(e, t, i, n, r) {
                        for (let s = 0; s !== r; ++s) {
                            const r = t + s;
                            e[r] = e[r] + e[i + s] * n;
                        }
                    }
                }
                const Qd = "\\[\\]\\.:\\/",
                    Zd = new RegExp("[" + Qd + "]", "g"),
                    Xd = "[^" + Qd + "]",
                    Jd = "[^" + Qd.replace("\\.", "") + "]",
                    Kd = /((?:WC+[\/:])*)/.source.replace("WC", Xd),
                    ep = /(WCOD+)?/.source.replace("WCOD", Jd),
                    tp = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Xd),
                    ip = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Xd),
                    np = new RegExp("^" + Kd + ep + tp + ip + "$"),
                    rp = ["material", "materials", "bones"];
                class sp {
                    constructor(e, t, i) {
                        (this.path = t),
                            (this.parsedPath = i || sp.parseTrackName(t)),
                            (this.node =
                                sp.findNode(e, this.parsedPath.nodeName) || e),
                            (this.rootNode = e),
                            (this.getValue = this._getValue_unbound),
                            (this.setValue = this._setValue_unbound);
                    }
                    static create(e, t, i) {
                        return e && e.isAnimationObjectGroup
                            ? new sp.Composite(e, t, i)
                            : new sp(e, t, i);
                    }
                    static sanitizeNodeName(e) {
                        return e.replace(/\s/g, "_").replace(Zd, "");
                    }
                    static parseTrackName(e) {
                        const t = np.exec(e);
                        if (!t)
                            throw new Error(
                                "PropertyBinding: Cannot parse trackName: " + e
                            );
                        const i = {
                                nodeName: t[2],
                                objectName: t[3],
                                objectIndex: t[4],
                                propertyName: t[5],
                                propertyIndex: t[6],
                            },
                            n = i.nodeName && i.nodeName.lastIndexOf(".");
                        if (void 0 !== n && -1 !== n) {
                            const e = i.nodeName.substring(n + 1);
                            -1 !== rp.indexOf(e) &&
                                ((i.nodeName = i.nodeName.substring(0, n)),
                                (i.objectName = e));
                        }
                        if (
                            null === i.propertyName ||
                            0 === i.propertyName.length
                        )
                            throw new Error(
                                "PropertyBinding: can not parse propertyName from trackName: " +
                                    e
                            );
                        return i;
                    }
                    static findNode(e, t) {
                        if (
                            !t ||
                            "" === t ||
                            "." === t ||
                            -1 === t ||
                            t === e.name ||
                            t === e.uuid
                        )
                            return e;
                        if (e.skeleton) {
                            const i = e.skeleton.getBoneByName(t);
                            if (void 0 !== i) return i;
                        }
                        if (e.children) {
                            const i = function (e) {
                                    for (let n = 0; n < e.length; n++) {
                                        const r = e[n];
                                        if (r.name === t || r.uuid === t)
                                            return r;
                                        const s = i(r.children);
                                        if (s) return s;
                                    }
                                    return null;
                                },
                                n = i(e.children);
                            if (n) return n;
                        }
                        return null;
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(e, t) {
                        e[t] = this.targetObject[this.propertyName];
                    }
                    _getValue_array(e, t) {
                        const i = this.resolvedProperty;
                        for (let n = 0, r = i.length; n !== r; ++n)
                            e[t++] = i[n];
                    }
                    _getValue_arrayElement(e, t) {
                        e[t] = this.resolvedProperty[this.propertyIndex];
                    }
                    _getValue_toArray(e, t) {
                        this.resolvedProperty.toArray(e, t);
                    }
                    _setValue_direct(e, t) {
                        this.targetObject[this.propertyName] = e[t];
                    }
                    _setValue_direct_setNeedsUpdate(e, t) {
                        (this.targetObject[this.propertyName] = e[t]),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                        (this.targetObject[this.propertyName] = e[t]),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _setValue_array(e, t) {
                        const i = this.resolvedProperty;
                        for (let n = 0, r = i.length; n !== r; ++n)
                            i[n] = e[t++];
                    }
                    _setValue_array_setNeedsUpdate(e, t) {
                        const i = this.resolvedProperty;
                        for (let n = 0, r = i.length; n !== r; ++n)
                            i[n] = e[t++];
                        this.targetObject.needsUpdate = !0;
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                        const i = this.resolvedProperty;
                        for (let n = 0, r = i.length; n !== r; ++n)
                            i[n] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0;
                    }
                    _setValue_arrayElement(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t];
                    }
                    _setValue_arrayElement_setNeedsUpdate(e, t) {
                        (this.resolvedProperty[this.propertyIndex] = e[t]),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                        (this.resolvedProperty[this.propertyIndex] = e[t]),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _setValue_fromArray(e, t) {
                        this.resolvedProperty.fromArray(e, t);
                    }
                    _setValue_fromArray_setNeedsUpdate(e, t) {
                        this.resolvedProperty.fromArray(e, t),
                            (this.targetObject.needsUpdate = !0);
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                        this.resolvedProperty.fromArray(e, t),
                            (this.targetObject.matrixWorldNeedsUpdate = !0);
                    }
                    _getValue_unbound(e, t) {
                        this.bind(), this.getValue(e, t);
                    }
                    _setValue_unbound(e, t) {
                        this.bind(), this.setValue(e, t);
                    }
                    bind() {
                        let e = this.node;
                        const t = this.parsedPath,
                            i = t.objectName,
                            n = t.propertyName;
                        let r = t.propertyIndex;
                        if (
                            (e ||
                                ((e =
                                    sp.findNode(this.rootNode, t.nodeName) ||
                                    this.rootNode),
                                (this.node = e)),
                            (this.getValue = this._getValue_unavailable),
                            (this.setValue = this._setValue_unavailable),
                            !e)
                        )
                            return void console.error(
                                "THREE.PropertyBinding: Trying to update node for track: " +
                                    this.path +
                                    " but it wasn't found."
                            );
                        if (i) {
                            let n = t.objectIndex;
                            switch (i) {
                                case "materials":
                                    if (!e.material)
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                                            this
                                        );
                                    if (!e.material.materials)
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                                            this
                                        );
                                    e = e.material.materials;
                                    break;
                                case "bones":
                                    if (!e.skeleton)
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                                            this
                                        );
                                    e = e.skeleton.bones;
                                    for (let t = 0; t < e.length; t++)
                                        if (e[t].name === n) {
                                            n = t;
                                            break;
                                        }
                                    break;
                                default:
                                    if (void 0 === e[i])
                                        return void console.error(
                                            "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                                            this
                                        );
                                    e = e[i];
                            }
                            if (void 0 !== n) {
                                if (void 0 === e[n])
                                    return void console.error(
                                        "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                                        this,
                                        e
                                    );
                                e = e[n];
                            }
                        }
                        const s = e[n];
                        if (void 0 === s) {
                            const i = t.nodeName;
                            return void console.error(
                                "THREE.PropertyBinding: Trying to update property for track: " +
                                    i +
                                    "." +
                                    n +
                                    " but it wasn't found.",
                                e
                            );
                        }
                        let a = this.Versioning.None;
                        (this.targetObject = e),
                            void 0 !== e.needsUpdate
                                ? (a = this.Versioning.NeedsUpdate)
                                : void 0 !== e.matrixWorldNeedsUpdate &&
                                  (a = this.Versioning.MatrixWorldNeedsUpdate);
                        let o = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === n) {
                                if (!e.geometry)
                                    return void console.error(
                                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                                        this
                                    );
                                if (!e.geometry.isBufferGeometry)
                                    return void console.error(
                                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                                        this
                                    );
                                if (!e.geometry.morphAttributes)
                                    return void console.error(
                                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                                        this
                                    );
                                void 0 !== e.morphTargetDictionary[r] &&
                                    (r = e.morphTargetDictionary[r]);
                            }
                            (o = this.BindingType.ArrayElement),
                                (this.resolvedProperty = s),
                                (this.propertyIndex = r);
                        } else
                            void 0 !== s.fromArray && void 0 !== s.toArray
                                ? ((o = this.BindingType.HasFromToArray),
                                  (this.resolvedProperty = s))
                                : Array.isArray(s)
                                ? ((o = this.BindingType.EntireArray),
                                  (this.resolvedProperty = s))
                                : (this.propertyName = n);
                        (this.getValue = this.GetterByBindingType[o]),
                            (this.setValue =
                                this.SetterByBindingTypeAndVersioning[o][a]);
                    }
                    unbind() {
                        (this.node = null),
                            (this.getValue = this._getValue_unbound),
                            (this.setValue = this._setValue_unbound);
                    }
                }
                (sp.Composite = class {
                    constructor(e, t, i) {
                        const n = i || sp.parseTrackName(t);
                        (this._targetGroup = e),
                            (this._bindings = e.subscribe_(t, n));
                    }
                    getValue(e, t) {
                        this.bind();
                        const i = this._targetGroup.nCachedObjects_,
                            n = this._bindings[i];
                        void 0 !== n && n.getValue(e, t);
                    }
                    setValue(e, t) {
                        const i = this._bindings;
                        for (
                            let n = this._targetGroup.nCachedObjects_,
                                r = i.length;
                            n !== r;
                            ++n
                        )
                            i[n].setValue(e, t);
                    }
                    bind() {
                        const e = this._bindings;
                        for (
                            let t = this._targetGroup.nCachedObjects_,
                                i = e.length;
                            t !== i;
                            ++t
                        )
                            e[t].bind();
                    }
                    unbind() {
                        const e = this._bindings;
                        for (
                            let t = this._targetGroup.nCachedObjects_,
                                i = e.length;
                            t !== i;
                            ++t
                        )
                            e[t].unbind();
                    }
                }),
                    (sp.prototype.BindingType = {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3,
                    }),
                    (sp.prototype.Versioning = {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2,
                    }),
                    (sp.prototype.GetterByBindingType = [
                        sp.prototype._getValue_direct,
                        sp.prototype._getValue_array,
                        sp.prototype._getValue_arrayElement,
                        sp.prototype._getValue_toArray,
                    ]),
                    (sp.prototype.SetterByBindingTypeAndVersioning = [
                        [
                            sp.prototype._setValue_direct,
                            sp.prototype._setValue_direct_setNeedsUpdate,
                            sp.prototype
                                ._setValue_direct_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            sp.prototype._setValue_array,
                            sp.prototype._setValue_array_setNeedsUpdate,
                            sp.prototype
                                ._setValue_array_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            sp.prototype._setValue_arrayElement,
                            sp.prototype._setValue_arrayElement_setNeedsUpdate,
                            sp.prototype
                                ._setValue_arrayElement_setMatrixWorldNeedsUpdate,
                        ],
                        [
                            sp.prototype._setValue_fromArray,
                            sp.prototype._setValue_fromArray_setNeedsUpdate,
                            sp.prototype
                                ._setValue_fromArray_setMatrixWorldNeedsUpdate,
                        ],
                    ]);
                class ap {
                    constructor(e, t, i = null, n = t.blendMode) {
                        (this._mixer = e),
                            (this._clip = t),
                            (this._localRoot = i),
                            (this.blendMode = n);
                        const r = t.tracks,
                            s = r.length,
                            a = new Array(s),
                            o = { endingStart: pr, endingEnd: pr };
                        for (let e = 0; e !== s; ++e) {
                            const t = r[e].createInterpolant(null);
                            (a[e] = t), (t.settings = o);
                        }
                        (this._interpolantSettings = o),
                            (this._interpolants = a),
                            (this._propertyBindings = new Array(s)),
                            (this._cacheIndex = null),
                            (this._byClipCacheIndex = null),
                            (this._timeScaleInterpolant = null),
                            (this._weightInterpolant = null),
                            (this.loop = 2201),
                            (this._loopCount = -1),
                            (this._startTime = null),
                            (this.time = 0),
                            (this.timeScale = 1),
                            (this._effectiveTimeScale = 1),
                            (this.weight = 1),
                            (this._effectiveWeight = 1),
                            (this.repetitions = 1 / 0),
                            (this.paused = !1),
                            (this.enabled = !0),
                            (this.clampWhenFinished = !1),
                            (this.zeroSlopeAtStart = !0),
                            (this.zeroSlopeAtEnd = !0);
                    }
                    play() {
                        return this._mixer._activateAction(this), this;
                    }
                    stop() {
                        return (
                            this._mixer._deactivateAction(this), this.reset()
                        );
                    }
                    reset() {
                        return (
                            (this.paused = !1),
                            (this.enabled = !0),
                            (this.time = 0),
                            (this._loopCount = -1),
                            (this._startTime = null),
                            this.stopFading().stopWarping()
                        );
                    }
                    isRunning() {
                        return (
                            this.enabled &&
                            !this.paused &&
                            0 !== this.timeScale &&
                            null === this._startTime &&
                            this._mixer._isActiveAction(this)
                        );
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this);
                    }
                    startAt(e) {
                        return (this._startTime = e), this;
                    }
                    setLoop(e, t) {
                        return (this.loop = e), (this.repetitions = t), this;
                    }
                    setEffectiveWeight(e) {
                        return (
                            (this.weight = e),
                            (this._effectiveWeight = this.enabled ? e : 0),
                            this.stopFading()
                        );
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight;
                    }
                    fadeIn(e) {
                        return this._scheduleFading(e, 0, 1);
                    }
                    fadeOut(e) {
                        return this._scheduleFading(e, 1, 0);
                    }
                    crossFadeFrom(e, t, i) {
                        if ((e.fadeOut(t), this.fadeIn(t), i)) {
                            const i = this._clip.duration,
                                n = e._clip.duration,
                                r = n / i,
                                s = i / n;
                            e.warp(1, r, t), this.warp(s, 1, t);
                        }
                        return this;
                    }
                    crossFadeTo(e, t, i) {
                        return e.crossFadeFrom(this, t, i);
                    }
                    stopFading() {
                        const e = this._weightInterpolant;
                        return (
                            null !== e &&
                                ((this._weightInterpolant = null),
                                this._mixer._takeBackControlInterpolant(e)),
                            this
                        );
                    }
                    setEffectiveTimeScale(e) {
                        return (
                            (this.timeScale = e),
                            (this._effectiveTimeScale = this.paused ? 0 : e),
                            this.stopWarping()
                        );
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale;
                    }
                    setDuration(e) {
                        return (
                            (this.timeScale = this._clip.duration / e),
                            this.stopWarping()
                        );
                    }
                    syncWith(e) {
                        return (
                            (this.time = e.time),
                            (this.timeScale = e.timeScale),
                            this.stopWarping()
                        );
                    }
                    halt(e) {
                        return this.warp(this._effectiveTimeScale, 0, e);
                    }
                    warp(e, t, i) {
                        const n = this._mixer,
                            r = n.time,
                            s = this.timeScale;
                        let a = this._timeScaleInterpolant;
                        null === a &&
                            ((a = n._lendControlInterpolant()),
                            (this._timeScaleInterpolant = a));
                        const o = a.parameterPositions,
                            c = a.sampleValues;
                        return (
                            (o[0] = r),
                            (o[1] = r + i),
                            (c[0] = e / s),
                            (c[1] = t / s),
                            this
                        );
                    }
                    stopWarping() {
                        const e = this._timeScaleInterpolant;
                        return (
                            null !== e &&
                                ((this._timeScaleInterpolant = null),
                                this._mixer._takeBackControlInterpolant(e)),
                            this
                        );
                    }
                    getMixer() {
                        return this._mixer;
                    }
                    getClip() {
                        return this._clip;
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root;
                    }
                    _update(e, t, i, n) {
                        if (!this.enabled) return void this._updateWeight(e);
                        const r = this._startTime;
                        if (null !== r) {
                            const n = (e - r) * i;
                            if (n < 0 || 0 === i) return;
                            (this._startTime = null), (t = i * n);
                        }
                        t *= this._updateTimeScale(e);
                        const s = this._updateTime(t),
                            a = this._updateWeight(e);
                        if (a > 0) {
                            const e = this._interpolants,
                                t = this._propertyBindings;
                            if (2501 === this.blendMode)
                                for (let i = 0, n = e.length; i !== n; ++i)
                                    e[i].evaluate(s),
                                        t[i].accumulateAdditive(a);
                            else
                                for (let i = 0, r = e.length; i !== r; ++i)
                                    e[i].evaluate(s), t[i].accumulate(n, a);
                        }
                    }
                    _updateWeight(e) {
                        let t = 0;
                        if (this.enabled) {
                            t = this.weight;
                            const i = this._weightInterpolant;
                            if (null !== i) {
                                const n = i.evaluate(e)[0];
                                (t *= n),
                                    e > i.parameterPositions[1] &&
                                        (this.stopFading(),
                                        0 === n && (this.enabled = !1));
                            }
                        }
                        return (this._effectiveWeight = t), t;
                    }
                    _updateTimeScale(e) {
                        let t = 0;
                        if (!this.paused) {
                            t = this.timeScale;
                            const i = this._timeScaleInterpolant;
                            null !== i &&
                                ((t *= i.evaluate(e)[0]),
                                e > i.parameterPositions[1] &&
                                    (this.stopWarping(),
                                    0 === t
                                        ? (this.paused = !0)
                                        : (this.timeScale = t)));
                        }
                        return (this._effectiveTimeScale = t), t;
                    }
                    _updateTime(e) {
                        const t = this._clip.duration,
                            i = this.loop;
                        let n = this.time + e,
                            r = this._loopCount;
                        const s = 2202 === i;
                        if (0 === e)
                            return -1 === r || !s || 1 & ~r ? n : t - n;
                        if (2200 === i) {
                            -1 === r &&
                                ((this._loopCount = 0),
                                this._setEndings(!0, !0, !1));
                            e: {
                                if (n >= t) n = t;
                                else {
                                    if (!(n < 0)) {
                                        this.time = n;
                                        break e;
                                    }
                                    n = 0;
                                }
                                this.clampWhenFinished
                                    ? (this.paused = !0)
                                    : (this.enabled = !1),
                                    (this.time = n),
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e < 0 ? -1 : 1,
                                    });
                            }
                        } else {
                            if (
                                (-1 === r &&
                                    (e >= 0
                                        ? ((r = 0),
                                          this._setEndings(
                                              !0,
                                              0 === this.repetitions,
                                              s
                                          ))
                                        : this._setEndings(
                                              0 === this.repetitions,
                                              !0,
                                              s
                                          )),
                                n >= t || n < 0)
                            ) {
                                const i = Math.floor(n / t);
                                (n -= t * i), (r += Math.abs(i));
                                const a = this.repetitions - r;
                                if (a <= 0)
                                    this.clampWhenFinished
                                        ? (this.paused = !0)
                                        : (this.enabled = !1),
                                        (n = e > 0 ? t : 0),
                                        (this.time = n),
                                        this._mixer.dispatchEvent({
                                            type: "finished",
                                            action: this,
                                            direction: e > 0 ? 1 : -1,
                                        });
                                else {
                                    if (1 === a) {
                                        const t = e < 0;
                                        this._setEndings(t, !t, s);
                                    } else this._setEndings(!1, !1, s);
                                    (this._loopCount = r),
                                        (this.time = n),
                                        this._mixer.dispatchEvent({
                                            type: "loop",
                                            action: this,
                                            loopDelta: i,
                                        });
                                }
                            } else this.time = n;
                            if (s && !(1 & ~r)) return t - n;
                        }
                        return n;
                    }
                    _setEndings(e, t, i) {
                        const n = this._interpolantSettings;
                        i
                            ? ((n.endingStart = gr), (n.endingEnd = gr))
                            : ((n.endingStart = e
                                  ? this.zeroSlopeAtStart
                                      ? gr
                                      : pr
                                  : mr),
                              (n.endingEnd = t
                                  ? this.zeroSlopeAtEnd
                                      ? gr
                                      : pr
                                  : mr));
                    }
                    _scheduleFading(e, t, i) {
                        const n = this._mixer,
                            r = n.time;
                        let s = this._weightInterpolant;
                        null === s &&
                            ((s = n._lendControlInterpolant()),
                            (this._weightInterpolant = s));
                        const a = s.parameterPositions,
                            o = s.sampleValues;
                        return (
                            (a[0] = r),
                            (o[0] = t),
                            (a[1] = r + e),
                            (o[1] = i),
                            this
                        );
                    }
                }
                ((class extends Er {
                    constructor(e) {
                        super(),
                            (this._root = e),
                            this._initMemoryManager(),
                            (this._accuIndex = 0),
                            (this.time = 0),
                            (this.timeScale = 1);
                    }
                    _bindAction(e, t) {
                        const i = e._localRoot || this._root,
                            n = e._clip.tracks,
                            r = n.length,
                            s = e._propertyBindings,
                            a = e._interpolants,
                            o = i.uuid,
                            c = this._bindingsByRootAndName;
                        let l = c[o];
                        void 0 === l && ((l = {}), (c[o] = l));
                        for (let e = 0; e !== r; ++e) {
                            const r = n[e],
                                c = r.name;
                            let h = l[c];
                            if (void 0 !== h) s[e] = h;
                            else {
                                if (((h = s[e]), void 0 !== h)) {
                                    null === h._cacheIndex &&
                                        (++h.referenceCount,
                                        this._addInactiveBinding(h, o, c));
                                    continue;
                                }
                                const n =
                                    t &&
                                    t._propertyBindings[e].binding.parsedPath;
                                (h = new Wd(
                                    sp.create(i, c, n),
                                    r.ValueTypeName,
                                    r.getValueSize()
                                )),
                                    ++h.referenceCount,
                                    this._addInactiveBinding(h, o, c),
                                    (s[e] = h);
                            }
                            a[e].resultBuffer = h.buffer;
                        }
                    }
                    _activateAction(e) {
                        if (!this._isActiveAction(e)) {
                            if (null === e._cacheIndex) {
                                const t = (e._localRoot || this._root).uuid,
                                    i = e._clip.uuid,
                                    n = this._actionsByClip[i];
                                this._bindAction(e, n && n.knownActions[0]),
                                    this._addInactiveAction(e, i, t);
                            }
                            const t = e._propertyBindings;
                            for (let e = 0, i = t.length; e !== i; ++e) {
                                const i = t[e];
                                0 == i.useCount++ &&
                                    (this._lendBinding(i),
                                    i.saveOriginalState());
                            }
                            this._lendAction(e);
                        }
                    }
                    _deactivateAction(e) {
                        if (this._isActiveAction(e)) {
                            const t = e._propertyBindings;
                            for (let e = 0, i = t.length; e !== i; ++e) {
                                const i = t[e];
                                0 == --i.useCount &&
                                    (i.restoreOriginalState(),
                                    this._takeBackBinding(i));
                            }
                            this._takeBackAction(e);
                        }
                    }
                    _initMemoryManager() {
                        (this._actions = []),
                            (this._nActiveActions = 0),
                            (this._actionsByClip = {}),
                            (this._bindings = []),
                            (this._nActiveBindings = 0),
                            (this._bindingsByRootAndName = {}),
                            (this._controlInterpolants = []),
                            (this._nActiveControlInterpolants = 0);
                        const e = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return e._actions.length;
                                },
                                get inUse() {
                                    return e._nActiveActions;
                                },
                            },
                            bindings: {
                                get total() {
                                    return e._bindings.length;
                                },
                                get inUse() {
                                    return e._nActiveBindings;
                                },
                            },
                            controlInterpolants: {
                                get total() {
                                    return e._controlInterpolants.length;
                                },
                                get inUse() {
                                    return e._nActiveControlInterpolants;
                                },
                            },
                        };
                    }
                    _isActiveAction(e) {
                        const t = e._cacheIndex;
                        return null !== t && t < this._nActiveActions;
                    }
                    _addInactiveAction(e, t, i) {
                        const n = this._actions,
                            r = this._actionsByClip;
                        let s = r[t];
                        if (void 0 === s)
                            (s = { knownActions: [e], actionByRoot: {} }),
                                (e._byClipCacheIndex = 0),
                                (r[t] = s);
                        else {
                            const t = s.knownActions;
                            (e._byClipCacheIndex = t.length), t.push(e);
                        }
                        (e._cacheIndex = n.length),
                            n.push(e),
                            (s.actionByRoot[i] = e);
                    }
                    _removeInactiveAction(e) {
                        const t = this._actions,
                            i = t[t.length - 1],
                            n = e._cacheIndex;
                        (i._cacheIndex = n),
                            (t[n] = i),
                            t.pop(),
                            (e._cacheIndex = null);
                        const r = e._clip.uuid,
                            s = this._actionsByClip,
                            a = s[r],
                            o = a.knownActions,
                            c = o[o.length - 1],
                            l = e._byClipCacheIndex;
                        (c._byClipCacheIndex = l),
                            (o[l] = c),
                            o.pop(),
                            (e._byClipCacheIndex = null),
                            delete a.actionByRoot[
                                (e._localRoot || this._root).uuid
                            ],
                            0 === o.length && delete s[r],
                            this._removeInactiveBindingsForAction(e);
                    }
                    _removeInactiveBindingsForAction(e) {
                        const t = e._propertyBindings;
                        for (let e = 0, i = t.length; e !== i; ++e) {
                            const i = t[e];
                            0 == --i.referenceCount &&
                                this._removeInactiveBinding(i);
                        }
                    }
                    _lendAction(e) {
                        const t = this._actions,
                            i = e._cacheIndex,
                            n = this._nActiveActions++,
                            r = t[n];
                        (e._cacheIndex = n),
                            (t[n] = e),
                            (r._cacheIndex = i),
                            (t[i] = r);
                    }
                    _takeBackAction(e) {
                        const t = this._actions,
                            i = e._cacheIndex,
                            n = --this._nActiveActions,
                            r = t[n];
                        (e._cacheIndex = n),
                            (t[n] = e),
                            (r._cacheIndex = i),
                            (t[i] = r);
                    }
                    _addInactiveBinding(e, t, i) {
                        const n = this._bindingsByRootAndName,
                            r = this._bindings;
                        let s = n[t];
                        void 0 === s && ((s = {}), (n[t] = s)),
                            (s[i] = e),
                            (e._cacheIndex = r.length),
                            r.push(e);
                    }
                    _removeInactiveBinding(e) {
                        const t = this._bindings,
                            i = e.binding,
                            n = i.rootNode.uuid,
                            r = i.path,
                            s = this._bindingsByRootAndName,
                            a = s[n],
                            o = t[t.length - 1],
                            c = e._cacheIndex;
                        (o._cacheIndex = c),
                            (t[c] = o),
                            t.pop(),
                            delete a[r],
                            0 === Object.keys(a).length && delete s[n];
                    }
                    _lendBinding(e) {
                        const t = this._bindings,
                            i = e._cacheIndex,
                            n = this._nActiveBindings++,
                            r = t[n];
                        (e._cacheIndex = n),
                            (t[n] = e),
                            (r._cacheIndex = i),
                            (t[i] = r);
                    }
                    _takeBackBinding(e) {
                        const t = this._bindings,
                            i = e._cacheIndex,
                            n = --this._nActiveBindings,
                            r = t[n];
                        (e._cacheIndex = n),
                            (t[n] = e),
                            (r._cacheIndex = i),
                            (t[i] = r);
                    }
                    _lendControlInterpolant() {
                        const e = this._controlInterpolants,
                            t = this._nActiveControlInterpolants++;
                        let i = e[t];
                        return (
                            void 0 === i &&
                                ((i = new hd(
                                    new Float32Array(2),
                                    new Float32Array(2),
                                    1,
                                    this._controlInterpolantsResultBuffer
                                )),
                                (i.__cacheIndex = t),
                                (e[t] = i)),
                            i
                        );
                    }
                    _takeBackControlInterpolant(e) {
                        const t = this._controlInterpolants,
                            i = e.__cacheIndex,
                            n = --this._nActiveControlInterpolants,
                            r = t[n];
                        (e.__cacheIndex = n),
                            (t[n] = e),
                            (r.__cacheIndex = i),
                            (t[i] = r);
                    }
                    clipAction(e, t, i) {
                        const n = t || this._root,
                            r = n.uuid;
                        let s = "string" == typeof e ? yd.findByName(n, e) : e;
                        const a = null !== s ? s.uuid : e,
                            o = this._actionsByClip[a];
                        let c = null;
                        if (
                            (void 0 === i &&
                                (i = null !== s ? s.blendMode : 2500),
                            void 0 !== o)
                        ) {
                            const e = o.actionByRoot[r];
                            if (void 0 !== e && e.blendMode === i) return e;
                            (c = o.knownActions[0]),
                                null === s && (s = c._clip);
                        }
                        if (null === s) return null;
                        const l = new ap(this, s, t, i);
                        return (
                            this._bindAction(l, c),
                            this._addInactiveAction(l, a, r),
                            l
                        );
                    }
                    existingAction(e, t) {
                        const i = t || this._root,
                            n = i.uuid,
                            r = "string" == typeof e ? yd.findByName(i, e) : e,
                            s = r ? r.uuid : e,
                            a = this._actionsByClip[s];
                        return (void 0 !== a && a.actionByRoot[n]) || null;
                    }
                    stopAllAction() {
                        const e = this._actions;
                        for (let t = this._nActiveActions - 1; t >= 0; --t)
                            e[t].stop();
                        return this;
                    }
                    update(e) {
                        e *= this.timeScale;
                        const t = this._actions,
                            i = this._nActiveActions,
                            n = (this.time += e),
                            r = Math.sign(e),
                            s = (this._accuIndex ^= 1);
                        for (let a = 0; a !== i; ++a) t[a]._update(n, e, r, s);
                        const a = this._bindings,
                            o = this._nActiveBindings;
                        for (let e = 0; e !== o; ++e) a[e].apply(s);
                        return this;
                    }
                    setTime(e) {
                        this.time = 0;
                        for (let e = 0; e < this._actions.length; e++)
                            this._actions[e].time = 0;
                        return this.update(e);
                    }
                    getRoot() {
                        return this._root;
                    }
                    uncacheClip(e) {
                        const t = this._actions,
                            i = e.uuid,
                            n = this._actionsByClip,
                            r = n[i];
                        if (void 0 !== r) {
                            const e = r.knownActions;
                            for (let i = 0, n = e.length; i !== n; ++i) {
                                const n = e[i];
                                this._deactivateAction(n);
                                const r = n._cacheIndex,
                                    s = t[t.length - 1];
                                (n._cacheIndex = null),
                                    (n._byClipCacheIndex = null),
                                    (s._cacheIndex = r),
                                    (t[r] = s),
                                    t.pop(),
                                    this._removeInactiveBindingsForAction(n);
                            }
                            delete n[i];
                        }
                    }
                    uncacheRoot(e) {
                        const t = e.uuid,
                            i = this._actionsByClip;
                        for (const e in i) {
                            const n = i[e].actionByRoot[t];
                            void 0 !== n &&
                                (this._deactivateAction(n),
                                this._removeInactiveAction(n));
                        }
                        const n = this._bindingsByRootAndName[t];
                        if (void 0 !== n)
                            for (const e in n) {
                                const t = n[e];
                                t.restoreOriginalState(),
                                    this._removeInactiveBinding(t);
                            }
                    }
                    uncacheAction(e, t) {
                        const i = this.existingAction(e, t);
                        null !== i &&
                            (this._deactivateAction(i),
                            this._removeInactiveAction(i));
                    }
                }).prototype._controlInterpolantsResultBuffer =
                    new Float32Array(1)),
                    (class extends gh {
                        constructor(e, t, i = 1) {
                            super(e, t), (this.meshPerAttribute = i);
                        }
                        copy(e) {
                            return (
                                super.copy(e),
                                (this.meshPerAttribute = e.meshPerAttribute),
                                this
                            );
                        }
                        clone(e) {
                            const t = super.clone(e);
                            return (
                                (t.meshPerAttribute = this.meshPerAttribute), t
                            );
                        }
                        toJSON(e) {
                            const t = super.toJSON(e);
                            return (
                                (t.isInstancedInterleavedBuffer = !0),
                                (t.meshPerAttribute = this.meshPerAttribute),
                                t
                            );
                        }
                    }.prototype.isInstancedInterleavedBuffer = !0);
                class op {
                    constructor(e, t, i = 0, n = 1 / 0) {
                        (this.ray = new js(e, t)),
                            (this.near = i),
                            (this.far = n),
                            (this.camera = null),
                            (this.layers = new Ys()),
                            (this.params = {
                                Mesh: {},
                                Line: { threshold: 1 },
                                LOD: {},
                                Points: { threshold: 1 },
                                Sprite: {},
                            });
                    }
                    set(e, t) {
                        this.ray.set(e, t);
                    }
                    setFromCamera(e, t) {
                        t && t.isPerspectiveCamera
                            ? (this.ray.origin.setFromMatrixPosition(
                                  t.matrixWorld
                              ),
                              this.ray.direction
                                  .set(e.x, e.y, 0.5)
                                  .unproject(t)
                                  .sub(this.ray.origin)
                                  .normalize(),
                              (this.camera = t))
                            : t && t.isOrthographicCamera
                            ? (this.ray.origin
                                  .set(
                                      e.x,
                                      e.y,
                                      (t.near + t.far) / (t.near - t.far)
                                  )
                                  .unproject(t),
                              this.ray.direction
                                  .set(0, 0, -1)
                                  .transformDirection(t.matrixWorld),
                              (this.camera = t))
                            : console.error(
                                  "THREE.Raycaster: Unsupported camera type: " +
                                      t.type
                              );
                    }
                    intersectObject(e, t = !0, i = []) {
                        return lp(e, this, i, t), i.sort(cp), i;
                    }
                    intersectObjects(e, t = !0, i = []) {
                        for (let n = 0, r = e.length; n < r; n++)
                            lp(e[n], this, i, t);
                        return i.sort(cp), i;
                    }
                }
                function cp(e, t) {
                    return e.distance - t.distance;
                }
                function lp(e, t, i, n) {
                    if (
                        (e.layers.test(t.layers) && e.raycast(t, i), !0 === n)
                    ) {
                        const n = e.children;
                        for (let e = 0, r = n.length; e < r; e++)
                            lp(n[e], t, i, !0);
                    }
                }
                const hp = new rs(),
                    up = new Os(),
                    dp = new Os();
                function pp(e) {
                    const t = [];
                    e && e.isBone && t.push(e);
                    for (let i = 0; i < e.children.length; i++)
                        t.push.apply(t, pp(e.children[i]));
                    return t;
                }
                const gp = new Float32Array(1);
                new Int32Array(gp.buffer),
                    (ou.create = function (e, t) {
                        return (
                            console.log(
                                "THREE.Curve.create() has been deprecated"
                            ),
                            (e.prototype = Object.create(ou.prototype)),
                            (e.prototype.constructor = e),
                            (e.prototype.getPoint = t),
                            e
                        );
                    }),
                    (Du.prototype.fromPoints = function (e) {
                        return (
                            console.warn(
                                "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
                            ),
                            this.setFromPoints(e)
                        );
                    }),
                    (class extends Kh {
                        constructor(e = 10, t = 10, i = 4473924, n = 8947848) {
                            (i = new Na(i)), (n = new Na(n));
                            const r = t / 2,
                                s = e / t,
                                a = e / 2,
                                o = [],
                                c = [];
                            for (
                                let e = 0, l = 0, h = -a;
                                e <= t;
                                e++, h += s
                            ) {
                                o.push(-a, 0, h, a, 0, h),
                                    o.push(h, 0, -a, h, 0, a);
                                const t = e === r ? i : n;
                                t.toArray(c, l),
                                    (l += 3),
                                    t.toArray(c, l),
                                    (l += 3),
                                    t.toArray(c, l),
                                    (l += 3),
                                    t.toArray(c, l),
                                    (l += 3);
                            }
                            const l = new Ba();
                            l.setAttribute("position", new za(o, 3)),
                                l.setAttribute("color", new za(c, 3)),
                                super(
                                    l,
                                    new Gh({ vertexColors: !0, toneMapped: !1 })
                                ),
                                (this.type = "GridHelper");
                        }
                    }.prototype.setColors = function () {
                        console.error(
                            "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
                        );
                    }),
                    (class extends Kh {
                        constructor(e) {
                            const t = pp(e),
                                i = new Ba(),
                                n = [],
                                r = [],
                                s = new Na(0, 0, 1),
                                a = new Na(0, 1, 0);
                            for (let e = 0; e < t.length; e++) {
                                const i = t[e];
                                i.parent &&
                                    i.parent.isBone &&
                                    (n.push(0, 0, 0),
                                    n.push(0, 0, 0),
                                    r.push(s.r, s.g, s.b),
                                    r.push(a.r, a.g, a.b));
                            }
                            i.setAttribute("position", new za(n, 3)),
                                i.setAttribute("color", new za(r, 3)),
                                super(
                                    i,
                                    new Gh({
                                        vertexColors: !0,
                                        depthTest: !1,
                                        depthWrite: !1,
                                        toneMapped: !1,
                                        transparent: !0,
                                    })
                                ),
                                (this.type = "SkeletonHelper"),
                                (this.isSkeletonHelper = !0),
                                (this.root = e),
                                (this.bones = t),
                                (this.matrix = e.matrixWorld),
                                (this.matrixAutoUpdate = !1);
                        }
                        updateMatrixWorld(e) {
                            const t = this.bones,
                                i = this.geometry,
                                n = i.getAttribute("position");
                            dp.copy(this.root.matrixWorld).invert();
                            for (let e = 0, i = 0; e < t.length; e++) {
                                const r = t[e];
                                r.parent &&
                                    r.parent.isBone &&
                                    (up.multiplyMatrices(dp, r.matrixWorld),
                                    hp.setFromMatrixPosition(up),
                                    n.setXYZ(i, hp.x, hp.y, hp.z),
                                    up.multiplyMatrices(
                                        dp,
                                        r.parent.matrixWorld
                                    ),
                                    hp.setFromMatrixPosition(up),
                                    n.setXYZ(i + 1, hp.x, hp.y, hp.z),
                                    (i += 2));
                            }
                            (i.getAttribute("position").needsUpdate = !0),
                                super.updateMatrixWorld(e);
                        }
                    }.prototype.update = function () {
                        console.error(
                            "THREE.SkeletonHelper: update() no longer needs to be called."
                        );
                    }),
                    (Td.prototype.extractUrlBase = function (e) {
                        return (
                            console.warn(
                                "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
                            ),
                            Hd.extractUrlBase(e)
                        );
                    }),
                    (Td.Handlers = {
                        add: function () {
                            console.error(
                                "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
                            );
                        },
                        get: function () {
                            console.error(
                                "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
                            );
                        },
                    }),
                    (os.prototype.center = function (e) {
                        return (
                            console.warn(
                                "THREE.Box3: .center() has been renamed to .getCenter()."
                            ),
                            this.getCenter(e)
                        );
                    }),
                    (os.prototype.empty = function () {
                        return (
                            console.warn(
                                "THREE.Box3: .empty() has been renamed to .isEmpty()."
                            ),
                            this.isEmpty()
                        );
                    }),
                    (os.prototype.isIntersectionBox = function (e) {
                        return (
                            console.warn(
                                "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
                            ),
                            this.intersectsBox(e)
                        );
                    }),
                    (os.prototype.isIntersectionSphere = function (e) {
                        return (
                            console.warn(
                                "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
                            ),
                            this.intersectsSphere(e)
                        );
                    }),
                    (os.prototype.size = function (e) {
                        return (
                            console.warn(
                                "THREE.Box3: .size() has been renamed to .getSize()."
                            ),
                            this.getSize(e)
                        );
                    }),
                    (Ns.prototype.empty = function () {
                        return (
                            console.warn(
                                "THREE.Sphere: .empty() has been renamed to .isEmpty()."
                            ),
                            this.isEmpty()
                        );
                    }),
                    (So.prototype.setFromMatrix = function (e) {
                        return (
                            console.warn(
                                "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
                            ),
                            this.setFromProjectionMatrix(e)
                        );
                    }),
                    (Vr.prototype.flattenToArrayOffset = function (e, t) {
                        return (
                            console.warn(
                                "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
                            ),
                            this.toArray(e, t)
                        );
                    }),
                    (Vr.prototype.multiplyVector3 = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
                            ),
                            e.applyMatrix3(this)
                        );
                    }),
                    (Vr.prototype.multiplyVector3Array = function () {
                        console.error(
                            "THREE.Matrix3: .multiplyVector3Array() has been removed."
                        );
                    }),
                    (Vr.prototype.applyToBufferAttribute = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
                            ),
                            e.applyMatrix3(this)
                        );
                    }),
                    (Vr.prototype.applyToVector3Array = function () {
                        console.error(
                            "THREE.Matrix3: .applyToVector3Array() has been removed."
                        );
                    }),
                    (Vr.prototype.getInverse = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
                            ),
                            this.copy(e).invert()
                        );
                    }),
                    (Os.prototype.extractPosition = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
                            ),
                            this.copyPosition(e)
                        );
                    }),
                    (Os.prototype.flattenToArrayOffset = function (e, t) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
                            ),
                            this.toArray(e, t)
                        );
                    }),
                    (Os.prototype.getPosition = function () {
                        return (
                            console.warn(
                                "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
                            ),
                            new rs().setFromMatrixColumn(this, 3)
                        );
                    }),
                    (Os.prototype.setRotationFromQuaternion = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
                            ),
                            this.makeRotationFromQuaternion(e)
                        );
                    }),
                    (Os.prototype.multiplyToArray = function () {
                        console.warn(
                            "THREE.Matrix4: .multiplyToArray() has been removed."
                        );
                    }),
                    (Os.prototype.multiplyVector3 = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
                            ),
                            e.applyMatrix4(this)
                        );
                    }),
                    (Os.prototype.multiplyVector4 = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
                            ),
                            e.applyMatrix4(this)
                        );
                    }),
                    (Os.prototype.multiplyVector3Array = function () {
                        console.error(
                            "THREE.Matrix4: .multiplyVector3Array() has been removed."
                        );
                    }),
                    (Os.prototype.rotateAxis = function (e) {
                        console.warn(
                            "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
                        ),
                            e.transformDirection(this);
                    }),
                    (Os.prototype.crossVector = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
                            ),
                            e.applyMatrix4(this)
                        );
                    }),
                    (Os.prototype.translate = function () {
                        console.error(
                            "THREE.Matrix4: .translate() has been removed."
                        );
                    }),
                    (Os.prototype.rotateX = function () {
                        console.error(
                            "THREE.Matrix4: .rotateX() has been removed."
                        );
                    }),
                    (Os.prototype.rotateY = function () {
                        console.error(
                            "THREE.Matrix4: .rotateY() has been removed."
                        );
                    }),
                    (Os.prototype.rotateZ = function () {
                        console.error(
                            "THREE.Matrix4: .rotateZ() has been removed."
                        );
                    }),
                    (Os.prototype.rotateByAxis = function () {
                        console.error(
                            "THREE.Matrix4: .rotateByAxis() has been removed."
                        );
                    }),
                    (Os.prototype.applyToBufferAttribute = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
                            ),
                            e.applyMatrix4(this)
                        );
                    }),
                    (Os.prototype.applyToVector3Array = function () {
                        console.error(
                            "THREE.Matrix4: .applyToVector3Array() has been removed."
                        );
                    }),
                    (Os.prototype.makeFrustum = function (e, t, i, n, r, s) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
                            ),
                            this.makePerspective(e, t, n, i, r, s)
                        );
                    }),
                    (Os.prototype.getInverse = function (e) {
                        return (
                            console.warn(
                                "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
                            ),
                            this.copy(e).invert()
                        );
                    }),
                    (bo.prototype.isIntersectionLine = function (e) {
                        return (
                            console.warn(
                                "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
                            ),
                            this.intersectsLine(e)
                        );
                    }),
                    (ns.prototype.multiplyVector3 = function (e) {
                        return (
                            console.warn(
                                "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
                            ),
                            e.applyQuaternion(this)
                        );
                    }),
                    (ns.prototype.inverse = function () {
                        return (
                            console.warn(
                                "THREE.Quaternion: .inverse() has been renamed to invert()."
                            ),
                            this.invert()
                        );
                    }),
                    (js.prototype.isIntersectionBox = function (e) {
                        return (
                            console.warn(
                                "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
                            ),
                            this.intersectsBox(e)
                        );
                    }),
                    (js.prototype.isIntersectionPlane = function (e) {
                        return (
                            console.warn(
                                "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
                            ),
                            this.intersectsPlane(e)
                        );
                    }),
                    (js.prototype.isIntersectionSphere = function (e) {
                        return (
                            console.warn(
                                "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
                            ),
                            this.intersectsSphere(e)
                        );
                    }),
                    (_a.prototype.area = function () {
                        return (
                            console.warn(
                                "THREE.Triangle: .area() has been renamed to .getArea()."
                            ),
                            this.getArea()
                        );
                    }),
                    (_a.prototype.barycoordFromPoint = function (e, t) {
                        return (
                            console.warn(
                                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
                            ),
                            this.getBarycoord(e, t)
                        );
                    }),
                    (_a.prototype.midpoint = function (e) {
                        return (
                            console.warn(
                                "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
                            ),
                            this.getMidpoint(e)
                        );
                    }),
                    (_a.prototypenormal = function (e) {
                        return (
                            console.warn(
                                "THREE.Triangle: .normal() has been renamed to .getNormal()."
                            ),
                            this.getNormal(e)
                        );
                    }),
                    (_a.prototype.plane = function (e) {
                        return (
                            console.warn(
                                "THREE.Triangle: .plane() has been renamed to .getPlane()."
                            ),
                            this.getPlane(e)
                        );
                    }),
                    (_a.barycoordFromPoint = function (e, t, i, n, r) {
                        return (
                            console.warn(
                                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
                            ),
                            _a.getBarycoord(e, t, i, n, r)
                        );
                    }),
                    (_a.normal = function (e, t, i, n) {
                        return (
                            console.warn(
                                "THREE.Triangle: .normal() has been renamed to .getNormal()."
                            ),
                            _a.getNormal(e, t, i, n)
                        );
                    }),
                    (Iu.prototype.extractAllPoints = function (e) {
                        return (
                            console.warn(
                                "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
                            ),
                            this.extractPoints(e)
                        );
                    }),
                    (Iu.prototype.extrude = function (e) {
                        return (
                            console.warn(
                                "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
                            ),
                            new id(this, e)
                        );
                    }),
                    (Iu.prototype.makeGeometry = function (e) {
                        return (
                            console.warn(
                                "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
                            ),
                            new rd(this, e)
                        );
                    }),
                    (Gr.prototype.fromAttribute = function (e, t, i) {
                        return (
                            console.warn(
                                "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
                            ),
                            this.fromBufferAttribute(e, t, i)
                        );
                    }),
                    (Gr.prototype.distanceToManhattan = function (e) {
                        return (
                            console.warn(
                                "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
                            ),
                            this.manhattanDistanceTo(e)
                        );
                    }),
                    (Gr.prototype.lengthManhattan = function () {
                        return (
                            console.warn(
                                "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
                            ),
                            this.manhattanLength()
                        );
                    }),
                    (rs.prototype.setEulerFromRotationMatrix = function () {
                        console.error(
                            "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
                        );
                    }),
                    (rs.prototype.setEulerFromQuaternion = function () {
                        console.error(
                            "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
                        );
                    }),
                    (rs.prototype.getPositionFromMatrix = function (e) {
                        return (
                            console.warn(
                                "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
                            ),
                            this.setFromMatrixPosition(e)
                        );
                    }),
                    (rs.prototype.getScaleFromMatrix = function (e) {
                        return (
                            console.warn(
                                "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
                            ),
                            this.setFromMatrixScale(e)
                        );
                    }),
                    (rs.prototype.getColumnFromMatrix = function (e, t) {
                        return (
                            console.warn(
                                "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
                            ),
                            this.setFromMatrixColumn(t, e)
                        );
                    }),
                    (rs.prototype.applyProjection = function (e) {
                        return (
                            console.warn(
                                "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
                            ),
                            this.applyMatrix4(e)
                        );
                    }),
                    (rs.prototype.fromAttribute = function (e, t, i) {
                        return (
                            console.warn(
                                "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
                            ),
                            this.fromBufferAttribute(e, t, i)
                        );
                    }),
                    (rs.prototype.distanceToManhattan = function (e) {
                        return (
                            console.warn(
                                "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
                            ),
                            this.manhattanDistanceTo(e)
                        );
                    }),
                    (rs.prototype.lengthManhattan = function () {
                        return (
                            console.warn(
                                "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
                            ),
                            this.manhattanLength()
                        );
                    }),
                    (es.prototype.fromAttribute = function (e, t, i) {
                        return (
                            console.warn(
                                "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
                            ),
                            this.fromBufferAttribute(e, t, i)
                        );
                    }),
                    (es.prototype.lengthManhattan = function () {
                        return (
                            console.warn(
                                "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
                            ),
                            this.manhattanLength()
                        );
                    }),
                    (aa.prototype.getChildByName = function (e) {
                        return (
                            console.warn(
                                "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
                            ),
                            this.getObjectByName(e)
                        );
                    }),
                    (aa.prototype.renderDepth = function () {
                        console.warn(
                            "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
                        );
                    }),
                    (aa.prototype.translate = function (e, t) {
                        return (
                            console.warn(
                                "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
                            ),
                            this.translateOnAxis(t, e)
                        );
                    }),
                    (aa.prototype.getWorldRotation = function () {
                        console.error(
                            "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
                        );
                    }),
                    (aa.prototype.applyMatrix = function (e) {
                        return (
                            console.warn(
                                "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
                            ),
                            this.applyMatrix4(e)
                        );
                    }),
                    Object.defineProperties(aa.prototype, {
                        eulerOrder: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.Object3D: .eulerOrder is now .rotation.order."
                                    ),
                                    this.rotation.order
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.Object3D: .eulerOrder is now .rotation.order."
                                ),
                                    (this.rotation.order = e);
                            },
                        },
                        useQuaternion: {
                            get: function () {
                                console.warn(
                                    "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                                );
                            },
                        },
                    }),
                    (so.prototype.setDrawMode = function () {
                        console.error(
                            "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
                        );
                    }),
                    Object.defineProperties(so.prototype, {
                        drawMode: {
                            get: function () {
                                return (
                                    console.error(
                                        "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                                    ),
                                    0
                                );
                            },
                            set: function () {
                                console.error(
                                    "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
                                );
                            },
                        },
                    }),
                    (Ph.prototype.initBones = function () {
                        console.error(
                            "THREE.SkinnedMesh: initBones() has been removed."
                        );
                    }),
                    (go.prototype.setLens = function (e, t) {
                        console.warn(
                            "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
                        ),
                            void 0 !== t && (this.filmGauge = t),
                            this.setFocalLength(e);
                    }),
                    Object.defineProperties(Ad.prototype, {
                        onlyShadow: {
                            set: function () {
                                console.warn(
                                    "THREE.Light: .onlyShadow has been removed."
                                );
                            },
                        },
                        shadowCameraFov: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
                                ),
                                    (this.shadow.camera.fov = e);
                            },
                        },
                        shadowCameraLeft: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
                                ),
                                    (this.shadow.camera.left = e);
                            },
                        },
                        shadowCameraRight: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
                                ),
                                    (this.shadow.camera.right = e);
                            },
                        },
                        shadowCameraTop: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
                                ),
                                    (this.shadow.camera.top = e);
                            },
                        },
                        shadowCameraBottom: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
                                ),
                                    (this.shadow.camera.bottom = e);
                            },
                        },
                        shadowCameraNear: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
                                ),
                                    (this.shadow.camera.near = e);
                            },
                        },
                        shadowCameraFar: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
                                ),
                                    (this.shadow.camera.far = e);
                            },
                        },
                        shadowCameraVisible: {
                            set: function () {
                                console.warn(
                                    "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
                                );
                            },
                        },
                        shadowBias: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowBias is now .shadow.bias."
                                ),
                                    (this.shadow.bias = e);
                            },
                        },
                        shadowDarkness: {
                            set: function () {
                                console.warn(
                                    "THREE.Light: .shadowDarkness has been removed."
                                );
                            },
                        },
                        shadowMapWidth: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
                                ),
                                    (this.shadow.mapSize.width = e);
                            },
                        },
                        shadowMapHeight: {
                            set: function (e) {
                                console.warn(
                                    "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
                                ),
                                    (this.shadow.mapSize.height = e);
                            },
                        },
                    }),
                    Object.defineProperties(Aa.prototype, {
                        length: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                                    ),
                                    this.array.length
                                );
                            },
                        },
                        dynamic: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                                    ),
                                    this.usage === Cr
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                                ),
                                    this.setUsage(Cr);
                            },
                        },
                    }),
                    (Aa.prototype.setDynamic = function (e) {
                        return (
                            console.warn(
                                "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
                            ),
                            this.setUsage(!0 === e ? Cr : Ir),
                            this
                        );
                    }),
                    (Aa.prototype.copyIndicesArray = function () {
                        console.error(
                            "THREE.BufferAttribute: .copyIndicesArray() has been removed."
                        );
                    }),
                    (Aa.prototype.setArray = function () {
                        console.error(
                            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
                        );
                    }),
                    (Ba.prototype.addIndex = function (e) {
                        console.warn(
                            "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
                        ),
                            this.setIndex(e);
                    }),
                    (Ba.prototype.addAttribute = function (e, t) {
                        return (
                            console.warn(
                                "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
                            ),
                            (t && t.isBufferAttribute) ||
                            (t && t.isInterleavedBufferAttribute)
                                ? "index" === e
                                    ? (console.warn(
                                          "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                                      ),
                                      this.setIndex(t),
                                      this)
                                    : this.setAttribute(e, t)
                                : (console.warn(
                                      "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                                  ),
                                  this.setAttribute(
                                      e,
                                      new Aa(arguments[1], arguments[2])
                                  ))
                        );
                    }),
                    (Ba.prototype.addDrawCall = function (e, t, i) {
                        void 0 !== i &&
                            console.warn(
                                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
                            ),
                            console.warn(
                                "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
                            ),
                            this.addGroup(e, t);
                    }),
                    (Ba.prototype.clearDrawCalls = function () {
                        console.warn(
                            "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
                        ),
                            this.clearGroups();
                    }),
                    (Ba.prototype.computeOffsets = function () {
                        console.warn(
                            "THREE.BufferGeometry: .computeOffsets() has been removed."
                        );
                    }),
                    (Ba.prototype.removeAttribute = function (e) {
                        return (
                            console.warn(
                                "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
                            ),
                            this.deleteAttribute(e)
                        );
                    }),
                    (Ba.prototype.applyMatrix = function (e) {
                        return (
                            console.warn(
                                "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
                            ),
                            this.applyMatrix4(e)
                        );
                    }),
                    Object.defineProperties(Ba.prototype, {
                        drawcalls: {
                            get: function () {
                                return (
                                    console.error(
                                        "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                                    ),
                                    this.groups
                                );
                            },
                        },
                        offsets: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.BufferGeometry: .offsets has been renamed to .groups."
                                    ),
                                    this.groups
                                );
                            },
                        },
                    }),
                    (gh.prototype.setDynamic = function (e) {
                        return (
                            console.warn(
                                "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
                            ),
                            this.setUsage(!0 === e ? Cr : Ir),
                            this
                        );
                    }),
                    (gh.prototype.setArray = function () {
                        console.error(
                            "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
                        );
                    }),
                    (id.prototype.getArrays = function () {
                        console.error(
                            "THREE.ExtrudeGeometry: .getArrays() has been removed."
                        );
                    }),
                    (id.prototype.addShapeList = function () {
                        console.error(
                            "THREE.ExtrudeGeometry: .addShapeList() has been removed."
                        );
                    }),
                    (id.prototype.addShape = function () {
                        console.error(
                            "THREE.ExtrudeGeometry: .addShape() has been removed."
                        );
                    }),
                    (ph.prototype.dispose = function () {
                        console.error(
                            "THREE.Scene: .dispose() has been removed."
                        );
                    }),
                    Object.defineProperties(va.prototype, {
                        wrapAround: {
                            get: function () {
                                console.warn(
                                    "THREE.Material: .wrapAround has been removed."
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.Material: .wrapAround has been removed."
                                );
                            },
                        },
                        overdraw: {
                            get: function () {
                                console.warn(
                                    "THREE.Material: .overdraw has been removed."
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.Material: .overdraw has been removed."
                                );
                            },
                        },
                        wrapRGB: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.Material: .wrapRGB has been removed."
                                    ),
                                    new Na()
                                );
                            },
                        },
                        shading: {
                            get: function () {
                                console.error(
                                    "THREE." +
                                        this.type +
                                        ": .shading has been removed. Use the boolean .flatShading instead."
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE." +
                                        this.type +
                                        ": .shading has been removed. Use the boolean .flatShading instead."
                                ),
                                    (this.flatShading = 1 === e);
                            },
                        },
                        stencilMask: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE." +
                                            this.type +
                                            ": .stencilMask has been removed. Use .stencilFuncMask instead."
                                    ),
                                    this.stencilFuncMask
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE." +
                                        this.type +
                                        ": .stencilMask has been removed. Use .stencilFuncMask instead."
                                ),
                                    (this.stencilFuncMask = e);
                            },
                        },
                        vertexTangents: {
                            get: function () {
                                console.warn(
                                    "THREE." +
                                        this.type +
                                        ": .vertexTangents has been removed."
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE." +
                                        this.type +
                                        ": .vertexTangents has been removed."
                                );
                            },
                        },
                    }),
                    Object.defineProperties(uo.prototype, {
                        derivatives: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                                    ),
                                    this.extensions.derivatives
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                                ),
                                    (this.extensions.derivatives = e);
                            },
                        },
                    }),
                    (dh.prototype.clearTarget = function (e, t, i, n) {
                        console.warn(
                            "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
                        ),
                            this.setRenderTarget(e),
                            this.clear(t, i, n);
                    }),
                    (dh.prototype.animate = function (e) {
                        console.warn(
                            "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
                        ),
                            this.setAnimationLoop(e);
                    }),
                    (dh.prototype.getCurrentRenderTarget = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
                            ),
                            this.getRenderTarget()
                        );
                    }),
                    (dh.prototype.getMaxAnisotropy = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
                            ),
                            this.capabilities.getMaxAnisotropy()
                        );
                    }),
                    (dh.prototype.getPrecision = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
                            ),
                            this.capabilities.precision
                        );
                    }),
                    (dh.prototype.resetGLState = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
                            ),
                            this.state.reset()
                        );
                    }),
                    (dh.prototype.supportsFloatTextures = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
                            ),
                            this.extensions.get("OES_texture_float")
                        );
                    }),
                    (dh.prototype.supportsHalfFloatTextures = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
                            ),
                            this.extensions.get("OES_texture_half_float")
                        );
                    }),
                    (dh.prototype.supportsStandardDerivatives = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
                            ),
                            this.extensions.get("OES_standard_derivatives")
                        );
                    }),
                    (dh.prototype.supportsCompressedTextureS3TC = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
                            ),
                            this.extensions.get("WEBGL_compressed_texture_s3tc")
                        );
                    }),
                    (dh.prototype.supportsCompressedTexturePVRTC = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
                            ),
                            this.extensions.get(
                                "WEBGL_compressed_texture_pvrtc"
                            )
                        );
                    }),
                    (dh.prototype.supportsBlendMinMax = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
                            ),
                            this.extensions.get("EXT_blend_minmax")
                        );
                    }),
                    (dh.prototype.supportsVertexTextures = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
                            ),
                            this.capabilities.vertexTextures
                        );
                    }),
                    (dh.prototype.supportsInstancedArrays = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
                            ),
                            this.extensions.get("ANGLE_instanced_arrays")
                        );
                    }),
                    (dh.prototype.enableScissorTest = function (e) {
                        console.warn(
                            "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
                        ),
                            this.setScissorTest(e);
                    }),
                    (dh.prototype.initMaterial = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .initMaterial() has been removed."
                        );
                    }),
                    (dh.prototype.addPrePlugin = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .addPrePlugin() has been removed."
                        );
                    }),
                    (dh.prototype.addPostPlugin = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .addPostPlugin() has been removed."
                        );
                    }),
                    (dh.prototype.updateShadowMap = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .updateShadowMap() has been removed."
                        );
                    }),
                    (dh.prototype.setFaceCulling = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .setFaceCulling() has been removed."
                        );
                    }),
                    (dh.prototype.allocTextureUnit = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
                        );
                    }),
                    (dh.prototype.setTexture = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .setTexture() has been removed."
                        );
                    }),
                    (dh.prototype.setTexture2D = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .setTexture2D() has been removed."
                        );
                    }),
                    (dh.prototype.setTextureCube = function () {
                        console.warn(
                            "THREE.WebGLRenderer: .setTextureCube() has been removed."
                        );
                    }),
                    (dh.prototype.getActiveMipMapLevel = function () {
                        return (
                            console.warn(
                                "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
                            ),
                            this.getActiveMipmapLevel()
                        );
                    }),
                    Object.defineProperties(dh.prototype, {
                        shadowMapEnabled: {
                            get: function () {
                                return this.shadowMap.enabled;
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
                                ),
                                    (this.shadowMap.enabled = e);
                            },
                        },
                        shadowMapType: {
                            get: function () {
                                return this.shadowMap.type;
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
                                ),
                                    (this.shadowMap.type = e);
                            },
                        },
                        shadowMapCullFace: {
                            get: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                                );
                            },
                        },
                        context: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                                    ),
                                    this.getContext()
                                );
                            },
                        },
                        vr: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderer: .vr has been renamed to .xr"
                                    ),
                                    this.xr
                                );
                            },
                        },
                        gammaInput: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                                    ),
                                    !1
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                                );
                            },
                        },
                        gammaOutput: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                                    ),
                                    !1
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                                ),
                                    (this.outputEncoding = !0 === e ? _r : fr);
                            },
                        },
                        toneMappingWhitePoint: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                                    ),
                                    1
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                                );
                            },
                        },
                    }),
                    Object.defineProperties(ih.prototype, {
                        cullFace: {
                            get: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                                );
                            },
                        },
                        renderReverseSided: {
                            get: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                                );
                            },
                        },
                        renderSingleSided: {
                            get: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                                );
                            },
                            set: function () {
                                console.warn(
                                    "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                                );
                            },
                        },
                    }),
                    Object.defineProperties(ts.prototype, {
                        wrapS: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                                    ),
                                    this.texture.wrapS
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                                ),
                                    (this.texture.wrapS = e);
                            },
                        },
                        wrapT: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                                    ),
                                    this.texture.wrapT
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                                ),
                                    (this.texture.wrapT = e);
                            },
                        },
                        magFilter: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                                    ),
                                    this.texture.magFilter
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                                ),
                                    (this.texture.magFilter = e);
                            },
                        },
                        minFilter: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                                    ),
                                    this.texture.minFilter
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                                ),
                                    (this.texture.minFilter = e);
                            },
                        },
                        anisotropy: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                                    ),
                                    this.texture.anisotropy
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                                ),
                                    (this.texture.anisotropy = e);
                            },
                        },
                        offset: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                                    ),
                                    this.texture.offset
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                                ),
                                    (this.texture.offset = e);
                            },
                        },
                        repeat: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                                    ),
                                    this.texture.repeat
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                                ),
                                    (this.texture.repeat = e);
                            },
                        },
                        format: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .format is now .texture.format."
                                    ),
                                    this.texture.format
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .format is now .texture.format."
                                ),
                                    (this.texture.format = e);
                            },
                        },
                        type: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .type is now .texture.type."
                                    ),
                                    this.texture.type
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .type is now .texture.type."
                                ),
                                    (this.texture.type = e);
                            },
                        },
                        generateMipmaps: {
                            get: function () {
                                return (
                                    console.warn(
                                        "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                                    ),
                                    this.texture.generateMipmaps
                                );
                            },
                            set: function (e) {
                                console.warn(
                                    "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                                ),
                                    (this.texture.generateMipmaps = e);
                            },
                        },
                    }),
                    (class extends aa {
                        constructor(e) {
                            super(),
                                (this.type = "Audio"),
                                (this.listener = e),
                                (this.context = e.context),
                                (this.gain = this.context.createGain()),
                                this.gain.connect(e.getInput()),
                                (this.autoplay = !1),
                                (this.buffer = null),
                                (this.detune = 0),
                                (this.loop = !1),
                                (this.loopStart = 0),
                                (this.loopEnd = 0),
                                (this.offset = 0),
                                (this.duration = void 0),
                                (this.playbackRate = 1),
                                (this.isPlaying = !1),
                                (this.hasPlaybackControl = !0),
                                (this.source = null),
                                (this.sourceType = "empty"),
                                (this._startedAt = 0),
                                (this._progress = 0),
                                (this._connected = !1),
                                (this.filters = []);
                        }
                        getOutput() {
                            return this.gain;
                        }
                        setNodeSource(e) {
                            return (
                                (this.hasPlaybackControl = !1),
                                (this.sourceType = "audioNode"),
                                (this.source = e),
                                this.connect(),
                                this
                            );
                        }
                        setMediaElementSource(e) {
                            return (
                                (this.hasPlaybackControl = !1),
                                (this.sourceType = "mediaNode"),
                                (this.source =
                                    this.context.createMediaElementSource(e)),
                                this.connect(),
                                this
                            );
                        }
                        setMediaStreamSource(e) {
                            return (
                                (this.hasPlaybackControl = !1),
                                (this.sourceType = "mediaStreamNode"),
                                (this.source =
                                    this.context.createMediaStreamSource(e)),
                                this.connect(),
                                this
                            );
                        }
                        setBuffer(e) {
                            return (
                                (this.buffer = e),
                                (this.sourceType = "buffer"),
                                this.autoplay && this.play(),
                                this
                            );
                        }
                        play(e = 0) {
                            if (!0 === this.isPlaying)
                                return void console.warn(
                                    "THREE.Audio: Audio is already playing."
                                );
                            if (!1 === this.hasPlaybackControl)
                                return void console.warn(
                                    "THREE.Audio: this Audio has no playback control."
                                );
                            this._startedAt = this.context.currentTime + e;
                            const t = this.context.createBufferSource();
                            return (
                                (t.buffer = this.buffer),
                                (t.loop = this.loop),
                                (t.loopStart = this.loopStart),
                                (t.loopEnd = this.loopEnd),
                                (t.onended = this.onEnded.bind(this)),
                                t.start(
                                    this._startedAt,
                                    this._progress + this.offset,
                                    this.duration
                                ),
                                (this.isPlaying = !0),
                                (this.source = t),
                                this.setDetune(this.detune),
                                this.setPlaybackRate(this.playbackRate),
                                this.connect()
                            );
                        }
                        pause() {
                            if (!1 !== this.hasPlaybackControl)
                                return (
                                    !0 === this.isPlaying &&
                                        ((this._progress +=
                                            Math.max(
                                                this.context.currentTime -
                                                    this._startedAt,
                                                0
                                            ) * this.playbackRate),
                                        !0 === this.loop &&
                                            (this._progress =
                                                this._progress %
                                                (this.duration ||
                                                    this.buffer.duration)),
                                        this.source.stop(),
                                        (this.source.onended = null),
                                        (this.isPlaying = !1)),
                                    this
                                );
                            console.warn(
                                "THREE.Audio: this Audio has no playback control."
                            );
                        }
                        stop() {
                            if (!1 !== this.hasPlaybackControl)
                                return (
                                    (this._progress = 0),
                                    this.source.stop(),
                                    (this.source.onended = null),
                                    (this.isPlaying = !1),
                                    this
                                );
                            console.warn(
                                "THREE.Audio: this Audio has no playback control."
                            );
                        }
                        connect() {
                            if (this.filters.length > 0) {
                                this.source.connect(this.filters[0]);
                                for (
                                    let e = 1, t = this.filters.length;
                                    e < t;
                                    e++
                                )
                                    this.filters[e - 1].connect(
                                        this.filters[e]
                                    );
                                this.filters[this.filters.length - 1].connect(
                                    this.getOutput()
                                );
                            } else this.source.connect(this.getOutput());
                            return (this._connected = !0), this;
                        }
                        disconnect() {
                            if (this.filters.length > 0) {
                                this.source.disconnect(this.filters[0]);
                                for (
                                    let e = 1, t = this.filters.length;
                                    e < t;
                                    e++
                                )
                                    this.filters[e - 1].disconnect(
                                        this.filters[e]
                                    );
                                this.filters[
                                    this.filters.length - 1
                                ].disconnect(this.getOutput());
                            } else this.source.disconnect(this.getOutput());
                            return (this._connected = !1), this;
                        }
                        getFilters() {
                            return this.filters;
                        }
                        setFilters(e) {
                            return (
                                e || (e = []),
                                !0 === this._connected
                                    ? (this.disconnect(),
                                      (this.filters = e.slice()),
                                      this.connect())
                                    : (this.filters = e.slice()),
                                this
                            );
                        }
                        setDetune(e) {
                            if (
                                ((this.detune = e),
                                void 0 !== this.source.detune)
                            )
                                return (
                                    !0 === this.isPlaying &&
                                        this.source.detune.setTargetAtTime(
                                            this.detune,
                                            this.context.currentTime,
                                            0.01
                                        ),
                                    this
                                );
                        }
                        getDetune() {
                            return this.detune;
                        }
                        getFilter() {
                            return this.getFilters()[0];
                        }
                        setFilter(e) {
                            return this.setFilters(e ? [e] : []);
                        }
                        setPlaybackRate(e) {
                            if (!1 !== this.hasPlaybackControl)
                                return (
                                    (this.playbackRate = e),
                                    !0 === this.isPlaying &&
                                        this.source.playbackRate.setTargetAtTime(
                                            this.playbackRate,
                                            this.context.currentTime,
                                            0.01
                                        ),
                                    this
                                );
                            console.warn(
                                "THREE.Audio: this Audio has no playback control."
                            );
                        }
                        getPlaybackRate() {
                            return this.playbackRate;
                        }
                        onEnded() {
                            this.isPlaying = !1;
                        }
                        getLoop() {
                            return !1 === this.hasPlaybackControl
                                ? (console.warn(
                                      "THREE.Audio: this Audio has no playback control."
                                  ),
                                  !1)
                                : this.loop;
                        }
                        setLoop(e) {
                            if (!1 !== this.hasPlaybackControl)
                                return (
                                    (this.loop = e),
                                    !0 === this.isPlaying &&
                                        (this.source.loop = this.loop),
                                    this
                                );
                            console.warn(
                                "THREE.Audio: this Audio has no playback control."
                            );
                        }
                        setLoopStart(e) {
                            return (this.loopStart = e), this;
                        }
                        setLoopEnd(e) {
                            return (this.loopEnd = e), this;
                        }
                        getVolume() {
                            return this.gain.gain.value;
                        }
                        setVolume(e) {
                            return (
                                this.gain.gain.setTargetAtTime(
                                    e,
                                    this.context.currentTime,
                                    0.01
                                ),
                                this
                            );
                        }
                    }.prototype.load = function (e) {
                        console.warn(
                            "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
                        );
                        const t = this;
                        return (
                            new Vd().load(e, function (e) {
                                t.setBuffer(e);
                            }),
                            this
                        );
                    }),
                    (fo.prototype.updateCubeMap = function (e, t) {
                        return (
                            console.warn(
                                "THREE.CubeCamera: .updateCubeMap() is now .update()."
                            ),
                            this.update(e, t)
                        );
                    }),
                    (fo.prototype.clear = function (e, t, i, n) {
                        return (
                            console.warn(
                                "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
                            ),
                            this.renderTarget.clear(e, t, i, n)
                        );
                    }),
                    (Zr.crossOrigin = void 0),
                    (Zr.loadTexture = function (e, t, i, n) {
                        console.warn(
                            "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
                        );
                        const r = new Cd();
                        r.setCrossOrigin(this.crossOrigin);
                        const s = r.load(e, i, void 0, n);
                        return t && (s.mapping = t), s;
                    }),
                    (Zr.loadTextureCube = function (e, t, i, n) {
                        console.warn(
                            "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
                        );
                        const r = new Id();
                        r.setCrossOrigin(this.crossOrigin);
                        const s = r.load(e, i, void 0, n);
                        return t && (s.mapping = t), s;
                    }),
                    (Zr.loadCompressedTexture = function () {
                        console.error(
                            "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
                        );
                    }),
                    (Zr.loadCompressedTextureCube = function () {
                        console.error(
                            "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
                        );
                    }),
                    "undefined" != typeof __THREE_DEVTOOLS__ &&
                        __THREE_DEVTOOLS__.dispatchEvent(
                            new CustomEvent("register", {
                                detail: { revision: "134" },
                            })
                        ),
                    "undefined" != typeof window &&
                        (window.__THREE__
                            ? console.warn(
                                  "WARNING: Multiple instances of Three.js being imported."
                              )
                            : (window.__THREE__ = "134"));
                const mp = Math.PI / 180,
                    fp = 180 / Math.PI,
                    _p = 6378137,
                    Mp = 6356752.31424518;
                function vp(e, t, i, n, r, s) {
                    const a = xp(e, t, i);
                    return (function (e, t, i, n, r, s) {
                        const a = xp(n, r, s),
                            o = [e - a[0], t - a[1], i - a[2]];
                        (n *= mp), (r *= mp);
                        const c = Math.cos(n),
                            l = Math.sin(n),
                            h = Math.cos(r),
                            u = Math.sin(r);
                        return [
                            -l * o[0] + c * o[1],
                            -u * c * o[0] - u * l * o[1] + h * o[2],
                            h * c * o[0] + h * l * o[1] + u * o[2],
                        ];
                    })(a[0], a[1], a[2], n, r, s);
                }
                function yp(e, t, i, n, r, s) {
                    const a = (function (e, t, i, n, r, s) {
                        const a = xp(n, r, s);
                        (n *= mp), (r *= mp);
                        const o = Math.cos(n),
                            c = Math.sin(n),
                            l = Math.cos(r),
                            h = Math.sin(r);
                        return [
                            -c * e - h * o * t + l * o * i + a[0],
                            o * e - h * c * t + l * c * i + a[1],
                            l * t + h * i + a[2],
                        ];
                    })(e, t, i, n, r, s);
                    return (function (e, t, i) {
                        const n = _p,
                            r = Mp,
                            s = n * n,
                            a = r * r,
                            o = s - a,
                            c = Math.sqrt(o / s),
                            l = Math.sqrt(o / a),
                            h = Math.sqrt(e * e + t * t),
                            u = Math.atan2(i * n, h * r),
                            d = Math.sin(u),
                            p = Math.cos(u),
                            g = Math.atan2(t, e),
                            m = Math.atan2(
                                i + l * l * r * d * d * d,
                                h - c * c * n * p * p * p
                            ),
                            f = Math.sin(m),
                            _ = Math.cos(m),
                            M = n / Math.sqrt(1 - c * c * f * f);
                        return [g * fp, m * fp, h / _ - M];
                    })(a[0], a[1], a[2]);
                }
                function xp(e, t, i) {
                    const n = _p,
                        r = Mp;
                    (e *= mp), (t *= mp);
                    const s = Math.cos(e),
                        a = Math.sin(e),
                        o = Math.cos(t),
                        c = Math.sin(t),
                        l = n * n,
                        h = r * r,
                        u = 1 / Math.sqrt(l * o * o + h * c * c),
                        d = (l * u + i) * o;
                    return [d * s, d * a, (h * u + i) * c];
                }
                class bp {
                    boundingBoxCorners(e, t) {
                        const i = yp(-t, -t, 0, e.lng, e.lat, 0),
                            n = yp(t, t, 0, e.lng, e.lat, 0);
                        return [
                            { lat: i[1], lng: i[0] },
                            { lat: n[1], lng: n[0] },
                        ];
                    }
                    rotationFromCompass(e, t) {
                        let i = 0,
                            n = 0,
                            r = 0;
                        switch (t) {
                            case 1:
                                i = Math.PI / 2;
                                break;
                            case 3:
                                (i = -Math.PI / 2), (r = Math.PI);
                                break;
                            case 6:
                                (n = -Math.PI / 2), (r = -Math.PI / 2);
                                break;
                            case 8:
                                (n = Math.PI / 2), (r = Math.PI / 2);
                        }
                        const s = new Os().makeRotationZ(r),
                            a = new Vs(i, n, (e * Math.PI) / 180, "XYZ"),
                            o = new Os().makeRotationFromEuler(a),
                            c = new es().setAxisAngleFromRotationMatrix(
                                o.multiply(s)
                            );
                        return c.multiplyScalar(c.w).toArray().slice(0, 3);
                    }
                }
                class wp {
                    constructor(e) {
                        if (!e)
                            throw new Error(`Incorrect core image data ${e}`);
                        (this._cache = null),
                            (this._core = e),
                            (this._spatial = null);
                    }
                    get assetsCached() {
                        return (
                            null != this._core &&
                            null != this._spatial &&
                            null != this._cache &&
                            null != this._cache.image &&
                            null != this._cache.mesh
                        );
                    }
                    get cameraParameters() {
                        return this._spatial.camera_parameters;
                    }
                    get cameraType() {
                        return this._spatial.camera_type;
                    }
                    get capturedAt() {
                        return this._spatial.captured_at;
                    }
                    get clusterId() {
                        return this._spatial.cluster
                            ? this._spatial.cluster.id
                            : null;
                    }
                    get clusterUrl() {
                        return this._spatial.cluster
                            ? this._spatial.cluster.url
                            : null;
                    }
                    get compassAngle() {
                        return null != this._spatial.computed_compass_angle
                            ? this._spatial.computed_compass_angle
                            : this._spatial.compass_angle;
                    }
                    get complete() {
                        return null != this._spatial;
                    }
                    get computedAltitude() {
                        return this._spatial.computed_altitude;
                    }
                    get computedCompassAngle() {
                        return this._spatial.computed_compass_angle;
                    }
                    get computedLngLat() {
                        return this._core.computed_geometry;
                    }
                    get creatorId() {
                        return this._spatial.creator.id;
                    }
                    get creatorUsername() {
                        return this._spatial.creator.username;
                    }
                    get exifOrientation() {
                        return this._spatial.exif_orientation;
                    }
                    get height() {
                        return this._spatial.height;
                    }
                    get image() {
                        return this._cache.image;
                    }
                    get image$() {
                        return this._cache.image$;
                    }
                    get id() {
                        return this._core.id;
                    }
                    get lngLat() {
                        return null != this._core.computed_geometry
                            ? this._core.computed_geometry
                            : this._core.geometry;
                    }
                    get merged() {
                        return (
                            null != this._spatial &&
                            null != this._spatial.merge_id
                        );
                    }
                    get mergeId() {
                        return this._spatial.merge_id;
                    }
                    get mesh() {
                        return this._cache.mesh;
                    }
                    get originalAltitude() {
                        return this._spatial.altitude;
                    }
                    get originalCompassAngle() {
                        return this._spatial.compass_angle;
                    }
                    get originalLngLat() {
                        return this._core.geometry;
                    }
                    get ownerId() {
                        return this._spatial.owner
                            ? this._spatial.owner.id
                            : null;
                    }
                    get private() {
                        return this._spatial.private;
                    }
                    get qualityScore() {
                        return this._spatial.quality_score;
                    }
                    get rotation() {
                        return this._spatial.computed_rotation;
                    }
                    get scale() {
                        return this._spatial.atomic_scale;
                    }
                    get sequenceId() {
                        return this._core.sequence
                            ? this._core.sequence.id
                            : null;
                    }
                    get sequenceEdges() {
                        return this._cache.sequenceEdges;
                    }
                    get sequenceEdges$() {
                        return this._cache.sequenceEdges$;
                    }
                    get spatialEdges() {
                        return this._cache.spatialEdges;
                    }
                    get spatialEdges$() {
                        return this._cache.spatialEdges$;
                    }
                    get width() {
                        return this._spatial.width;
                    }
                    cacheAssets$() {
                        return this._cache
                            .cacheAssets$(this._spatial, this.merged)
                            .pipe(ke(() => this));
                    }
                    cacheImage$() {
                        return this._cache
                            .cacheImage$(this._spatial)
                            .pipe(ke(() => this));
                    }
                    cacheSequenceEdges(e) {
                        this._cache.cacheSequenceEdges(e);
                    }
                    cacheSpatialEdges(e) {
                        this._cache.cacheSpatialEdges(e);
                    }
                    dispose() {
                        null != this._cache &&
                            (this._cache.dispose(), (this._cache = null)),
                            (this._core = null),
                            (this._spatial = null);
                    }
                    initializeCache(e) {
                        if (null != this._cache)
                            throw new Error(
                                `Image cache already initialized (${this.id}).`
                            );
                        this._cache = e;
                    }
                    makeComplete(e) {
                        if (null == e) throw new Error("Fill can not be null.");
                        this._spatial = e;
                    }
                    resetSequenceEdges() {
                        this._cache.resetSequenceEdges();
                    }
                    resetSpatialEdges() {
                        this._cache.resetSpatialEdges();
                    }
                    uncache() {
                        null != this._cache &&
                            (this._cache.dispose(), (this._cache = null));
                    }
                }
                class Tp {
                    constructor(e) {
                        (this._disposed = !1),
                            (this._provider = e),
                            (this._image = null),
                            (this._mesh = null),
                            (this._sequenceEdges = { cached: !1, edges: [] }),
                            (this._spatialEdges = { cached: !1, edges: [] }),
                            (this._imageChanged$ = new W()),
                            (this._image$ = this._imageChanged$.pipe(
                                Ot(null),
                                It(1),
                                V()
                            )),
                            (this._iamgeSubscription =
                                this._image$.subscribe()),
                            (this._sequenceEdgesChanged$ = new W()),
                            (this._sequenceEdges$ =
                                this._sequenceEdgesChanged$.pipe(
                                    Ot(this._sequenceEdges),
                                    It(1),
                                    V()
                                )),
                            (this._sequenceEdgesSubscription =
                                this._sequenceEdges$.subscribe(() => {})),
                            (this._spatialEdgesChanged$ = new W()),
                            (this._spatialEdges$ =
                                this._spatialEdgesChanged$.pipe(
                                    Ot(this._spatialEdges),
                                    It(1),
                                    V()
                                )),
                            (this._spatialEdgesSubscription =
                                this._spatialEdges$.subscribe(() => {})),
                            (this._cachingAssets$ = null);
                    }
                    get image() {
                        return this._image;
                    }
                    get image$() {
                        return this._image$;
                    }
                    get mesh() {
                        return this._mesh;
                    }
                    get sequenceEdges() {
                        return this._sequenceEdges;
                    }
                    get sequenceEdges$() {
                        return this._sequenceEdges$;
                    }
                    get spatialEdges() {
                        return this._spatialEdges;
                    }
                    get spatialEdges$() {
                        return this._spatialEdges$;
                    }
                    cacheAssets$(e, t) {
                        return (
                            null != this._cachingAssets$ ||
                                ((this._cachingAssets$ = He(
                                    this._cacheImage$(e),
                                    this._cacheMesh$(e, t)
                                ).pipe(
                                    ke(
                                        ([e, t]) => (
                                            (this._image = e),
                                            (this._mesh = t),
                                            this
                                        )
                                    ),
                                    xt(() => {
                                        this._cachingAssets$ = null;
                                    }),
                                    It(1),
                                    V()
                                )),
                                this._cachingAssets$
                                    .pipe(bt((e) => !!e._image))
                                    .subscribe(
                                        () => {
                                            this._imageChanged$.next(
                                                this._image
                                            );
                                        },
                                        () => {}
                                    )),
                            this._cachingAssets$
                        );
                    }
                    cacheImage$(e) {
                        if (null != this._image) return Ce(this);
                        const t = this._cacheImage$(e).pipe(
                            bt((e) => !!e),
                            Ut((e) => {
                                this._disposeImage(), (this._image = e);
                            }),
                            ke(() => this),
                            It(1),
                            V()
                        );
                        return (
                            t.subscribe(
                                () => {
                                    this._imageChanged$.next(this._image);
                                },
                                () => {}
                            ),
                            t
                        );
                    }
                    cacheSequenceEdges(e) {
                        (this._sequenceEdges = { cached: !0, edges: e }),
                            this._sequenceEdgesChanged$.next(
                                this._sequenceEdges
                            );
                    }
                    cacheSpatialEdges(e) {
                        (this._spatialEdges = { cached: !0, edges: e }),
                            this._spatialEdgesChanged$.next(this._spatialEdges);
                    }
                    dispose() {
                        this._iamgeSubscription.unsubscribe(),
                            this._sequenceEdgesSubscription.unsubscribe(),
                            this._spatialEdgesSubscription.unsubscribe(),
                            this._disposeImage(),
                            (this._mesh = null),
                            (this._sequenceEdges = { cached: !1, edges: [] }),
                            (this._spatialEdges = { cached: !1, edges: [] }),
                            this._imageChanged$.next(null),
                            this._sequenceEdgesChanged$.next(
                                this._sequenceEdges
                            ),
                            this._spatialEdgesChanged$.next(this._spatialEdges),
                            (this._disposed = !0),
                            null != this._imageAborter &&
                                (this._imageAborter(),
                                (this._imageAborter = null)),
                            null != this._meshAborter &&
                                (this._meshAborter(),
                                (this._meshAborter = null));
                    }
                    resetSequenceEdges() {
                        (this._sequenceEdges = { cached: !1, edges: [] }),
                            this._sequenceEdgesChanged$.next(
                                this._sequenceEdges
                            );
                    }
                    resetSpatialEdges() {
                        (this._spatialEdges = { cached: !1, edges: [] }),
                            this._spatialEdgesChanged$.next(this._spatialEdges);
                    }
                    _cacheImage$(e) {
                        return $.create((t) => {
                            const i = new Promise((e, t) => {
                                    this._imageAborter = t;
                                }),
                                n = e.thumb.url;
                            if (n)
                                this._provider.getImageBuffer(n, i).then(
                                    (e) => {
                                        this._imageAborter = null;
                                        const i = new Image();
                                        (i.crossOrigin = "Anonymous"),
                                            (i.onload = () => {
                                                if (this._disposed) {
                                                    window.URL.revokeObjectURL(
                                                        i.src
                                                    );
                                                    const e = `Image load was aborted (${n})`;
                                                    t.error(new Error(e));
                                                } else t.next(i), t.complete();
                                            }),
                                            (i.onerror = () => {
                                                (this._imageAborter = null),
                                                    t.error(
                                                        new Error(
                                                            `Failed to load image (${n})`
                                                        )
                                                    );
                                            });
                                        const r = new Blob([e]);
                                        i.src = window.URL.createObjectURL(r);
                                    },
                                    (e) => {
                                        (this._imageAborter = null), t.error(e);
                                    }
                                );
                            else {
                                const i = e.thumb.id,
                                    r = `Incorrect thumb URL for ${e.id} (${i}, ${n})`;
                                t.error(new Error(r));
                            }
                        });
                    }
                    _cacheMesh$(e, t) {
                        return $.create((i) => {
                            if (!t)
                                return (
                                    i.next(this._createEmptyMesh()),
                                    void i.complete()
                                );
                            const n = e.mesh.url;
                            if (!n) {
                                const t = e.mesh.id,
                                    r = `Incorrect mesh URL for ${e.id} (${t}, ${n})`;
                                return (
                                    console.warn(r),
                                    i.next(this._createEmptyMesh()),
                                    void i.complete()
                                );
                            }
                            const r = new Promise((e, t) => {
                                this._meshAborter = t;
                            });
                            this._provider.getMesh(n, r).then(
                                (e) => {
                                    (this._meshAborter = null),
                                        this._disposed ||
                                            (i.next(e), i.complete());
                                },
                                (e) => {
                                    (this._meshAborter = null),
                                        console.error(e),
                                        i.next(this._createEmptyMesh()),
                                        i.complete();
                                }
                            );
                        });
                    }
                    _createEmptyMesh() {
                        return { faces: [], vertices: [] };
                    }
                    _disposeImage() {
                        null != this._image &&
                            window.URL.revokeObjectURL(this._image.src),
                            (this._image = null);
                    }
                }
                class Sp {
                    constructor(e) {
                        (this._id = e.id), (this._imageIds = e.image_ids);
                    }
                    get id() {
                        return this._id;
                    }
                    get imageIds() {
                        return this._imageIds;
                    }
                    dispose() {
                        (this._id = null), (this._imageIds = null);
                    }
                    findNext(e) {
                        let t = this._imageIds.indexOf(e);
                        return t + 1 >= this._imageIds.length || -1 === t
                            ? null
                            : this._imageIds[t + 1];
                    }
                    findPrev(e) {
                        let t = this._imageIds.indexOf(e);
                        return 0 === t || -1 === t
                            ? null
                            : this._imageIds[t - 1];
                    }
                }
                class Np {
                    constructor() {
                        (this.sphericalPreferredDistance = 2),
                            (this.sphericalMotion = 2),
                            (this.sphericalSequencePenalty = 1),
                            (this.sphericalMergeCCPenalty = 4),
                            (this.stepPreferredDistance = 4),
                            (this.stepMotion = 3),
                            (this.stepRotation = 4),
                            (this.stepSequencePenalty = 2),
                            (this.stepMergeCCPenalty = 6),
                            (this.similarDistance = 2),
                            (this.similarRotation = 3),
                            (this.turnDistance = 4),
                            (this.turnMotion = 2),
                            (this.turnSequencePenalty = 1),
                            (this.turnMergeCCPenalty = 4);
                    }
                }
                var Dp;
                !(function (e) {
                    (e[(e.Next = 0)] = "Next"),
                        (e[(e.Prev = 1)] = "Prev"),
                        (e[(e.StepLeft = 2)] = "StepLeft"),
                        (e[(e.StepRight = 3)] = "StepRight"),
                        (e[(e.StepForward = 4)] = "StepForward"),
                        (e[(e.StepBackward = 5)] = "StepBackward"),
                        (e[(e.TurnLeft = 6)] = "TurnLeft"),
                        (e[(e.TurnRight = 7)] = "TurnRight"),
                        (e[(e.TurnU = 8)] = "TurnU"),
                        (e[(e.Spherical = 9)] = "Spherical"),
                        (e[(e.Similar = 10)] = "Similar");
                })(Dp || (Dp = {}));
                class Ip {
                    constructor() {
                        (this.steps = {}),
                            (this.turns = {}),
                            (this.spherical = {}),
                            (this.steps[Dp.StepForward] = {
                                direction: Dp.StepForward,
                                motionChange: 0,
                                useFallback: !0,
                            }),
                            (this.steps[Dp.StepBackward] = {
                                direction: Dp.StepBackward,
                                motionChange: Math.PI,
                                useFallback: !0,
                            }),
                            (this.steps[Dp.StepLeft] = {
                                direction: Dp.StepLeft,
                                motionChange: Math.PI / 2,
                                useFallback: !1,
                            }),
                            (this.steps[Dp.StepRight] = {
                                direction: Dp.StepRight,
                                motionChange: -Math.PI / 2,
                                useFallback: !1,
                            }),
                            (this.turns[Dp.TurnLeft] = {
                                direction: Dp.TurnLeft,
                                directionChange: Math.PI / 2,
                                motionChange: Math.PI / 4,
                            }),
                            (this.turns[Dp.TurnRight] = {
                                direction: Dp.TurnRight,
                                directionChange: -Math.PI / 2,
                                motionChange: -Math.PI / 4,
                            }),
                            (this.turns[Dp.TurnU] = {
                                direction: Dp.TurnU,
                                directionChange: Math.PI,
                                motionChange: null,
                            }),
                            (this.spherical[Dp.StepForward] = {
                                direction: Dp.StepForward,
                                directionChange: 0,
                                next: Dp.StepLeft,
                                prev: Dp.StepRight,
                            }),
                            (this.spherical[Dp.StepBackward] = {
                                direction: Dp.StepBackward,
                                directionChange: Math.PI,
                                next: Dp.StepRight,
                                prev: Dp.StepLeft,
                            }),
                            (this.spherical[Dp.StepLeft] = {
                                direction: Dp.StepLeft,
                                directionChange: Math.PI / 2,
                                next: Dp.StepBackward,
                                prev: Dp.StepForward,
                            }),
                            (this.spherical[Dp.StepRight] = {
                                direction: Dp.StepRight,
                                directionChange: -Math.PI / 2,
                                next: Dp.StepForward,
                                prev: Dp.StepBackward,
                            });
                    }
                }
                class Cp {
                    constructor() {
                        (this.sphericalMinDistance = 0.1),
                            (this.sphericalMaxDistance = 20),
                            (this.sphericalPreferredDistance = 5),
                            (this.sphericalMaxItems = 4),
                            (this.sphericalMaxStepTurnChange = Math.PI / 8),
                            (this.rotationMaxDistance =
                                this.turnMaxRigDistance),
                            (this.rotationMaxDirectionChange = Math.PI / 6),
                            (this.rotationMaxVerticalDirectionChange =
                                Math.PI / 8),
                            (this.similarMaxDirectionChange = Math.PI / 8),
                            (this.similarMaxDistance = 12),
                            (this.similarMinTimeDifference = 432e5),
                            (this.stepMaxDistance = 20),
                            (this.stepMaxDirectionChange = Math.PI / 6),
                            (this.stepMaxDrift = Math.PI / 6),
                            (this.stepPreferredDistance = 4),
                            (this.turnMaxDistance = 15),
                            (this.turnMaxDirectionChange = (2 * Math.PI) / 9),
                            (this.turnMaxRigDistance = 0.65),
                            (this.turnMinRigDirectionChange = Math.PI / 6);
                    }
                    get maxDistance() {
                        return Math.max(
                            this.sphericalMaxDistance,
                            this.similarMaxDistance,
                            this.stepMaxDistance,
                            this.turnMaxDistance
                        );
                    }
                }
                class Ap extends Error {
                    constructor(e) {
                        super(e),
                            Object.setPrototypeOf(this, Ap.prototype),
                            (this.name = "MapillaryError");
                    }
                }
                class Ep extends Ap {
                    constructor(e) {
                        super(null != e ? e : "The argument is not valid."),
                            Object.setPrototypeOf(this, Ep.prototype),
                            (this.name = "ArgumentMapillaryError");
                    }
                }
                class Lp {
                    constructor() {
                        this._epsilon = 1e-9;
                    }
                    azimuthalToBearing(e) {
                        return -e + Math.PI / 2;
                    }
                    degToRad(e) {
                        return (Math.PI * e) / 180;
                    }
                    radToDeg(e) {
                        return (180 * e) / Math.PI;
                    }
                    rotationMatrix(e) {
                        let t = new rs(e[0], e[1], e[2]),
                            i = t.length();
                        return (
                            i > 0 && t.normalize(),
                            new Os().makeRotationAxis(t, i)
                        );
                    }
                    rotate(e, t) {
                        let i = new rs(e[0], e[1], e[2]),
                            n = this.rotationMatrix(t);
                        return i.applyMatrix4(n), i;
                    }
                    opticalCenter(e, t) {
                        let i = [-e[0], -e[1], -e[2]],
                            n = [-t[0], -t[1], -t[2]];
                        return this.rotate(n, i);
                    }
                    viewingDirection(e) {
                        let t = [-e[0], -e[1], -e[2]];
                        return this.rotate([0, 0, 1], t);
                    }
                    wrap(e, t, i) {
                        if (i < t)
                            throw new Error(
                                "Invalid arguments: max must be larger than min."
                            );
                        let n = i - t;
                        for (; e > i || e < t; )
                            e > i ? (e -= n) : e < t && (e += n);
                        return e;
                    }
                    wrapAngle(e) {
                        return this.wrap(e, -Math.PI, Math.PI);
                    }
                    clamp(e, t, i) {
                        return e < t ? t : e > i ? i : e;
                    }
                    angleBetweenVector2(e, t, i, n) {
                        let r = Math.atan2(n, i) - Math.atan2(t, e);
                        return this.wrapAngle(r);
                    }
                    angleDifference(e, t) {
                        let i = t - e;
                        return this.wrapAngle(i);
                    }
                    relativeRotationAngle(e, t) {
                        let i = this.rotationMatrix([-e[0], -e[1], -e[2]]),
                            n = this.rotationMatrix(t),
                            r = i.multiply(n).elements,
                            s = r[0] + r[5] + r[10];
                        return Math.acos(
                            Math.max(Math.min((s - 1) / 2, 1), -1)
                        );
                    }
                    angleToPlane(e, t) {
                        let i = new rs().fromArray(e),
                            n = i.length();
                        if (n < this._epsilon) return 0;
                        let r = i.dot(new rs().fromArray(t));
                        return Math.asin(r / n);
                    }
                    azimuthal(e, t) {
                        const i = new rs().fromArray(e),
                            n = new rs().fromArray(t),
                            r = i.clone().dot(n),
                            s = i.clone().sub(n.clone().multiplyScalar(r));
                        return Math.atan2(s.y, s.x);
                    }
                    distanceFromLngLat(e, t, i, n) {
                        let r = this.degToRad(n - t),
                            s = this.degToRad(i - e),
                            a =
                                Math.sin(r / 2) * Math.sin(r / 2) +
                                Math.cos(this.degToRad(t)) *
                                    Math.cos(this.degToRad(n)) *
                                    Math.sin(s / 2) *
                                    Math.sin(s / 2);
                        return (
                            12742e3 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
                        );
                    }
                }
                const zp = new Lp();
                function jp(e) {
                    return "spherical" === e;
                }
                function Op(e) {
                    return "fisheye" === e;
                }
                function kp(e, t, i) {
                    const n = vp(e.lng, e.lat, e.alt, i.lng, i.lat, i.alt),
                        r = zp.rotate(n, t);
                    return [-r.x, -r.y, -r.z];
                }
                function Rp(e, t, i, n, r) {
                    const s = [];
                    for (let e = 0; e < t.length; ++e) {
                        const r = t[e],
                            a = i[e];
                        for (let e = 0; e <= n; ++e)
                            s.push([
                                r[0] + (a[0] * e) / n,
                                r[1] + (a[1] * e) / n,
                            ]);
                    }
                    const a = new po();
                    return (
                        a.up.copy(e.upVector()),
                        a.position.copy(
                            new rs().fromArray(e.unprojectSfM([0, 0], 0))
                        ),
                        a.lookAt(
                            new rs().fromArray(e.unprojectSfM([0, 0], 10))
                        ),
                        a.updateMatrix(),
                        a.updateMatrixWorld(!0),
                        s.map((t) => {
                            const i = e.unprojectBasic(t, 1e4),
                                n = r.worldToCamera(i, a);
                            return [
                                Math.abs(n[0] / n[2]),
                                Math.abs(n[1] / n[2]),
                            ];
                        })
                    );
                }
                class Pp {
                    constructor(e, t, i) {
                        (this._spatial = new Lp()),
                            (this._settings = null != e ? e : new Cp()),
                            (this._directions = null != t ? t : new Ip()),
                            (this._coefficients = null != i ? i : new Np());
                    }
                    getPotentialEdges(e, t, i) {
                        if (!e.complete) throw new Ep("Image has to be full.");
                        if (!e.merged) return [];
                        let n = this._spatial.viewingDirection(e.rotation),
                            r = this._spatial.angleToPlane(
                                n.toArray(),
                                [0, 0, 1]
                            ),
                            s = [];
                        for (let a of t) {
                            if (!a.merged || a.id === e.id) continue;
                            let t = vp(
                                    a.lngLat.lng,
                                    a.lngLat.lat,
                                    a.computedAltitude,
                                    e.lngLat.lng,
                                    e.lngLat.lat,
                                    e.computedAltitude
                                ),
                                o = new rs(t[0], t[1], t[2]),
                                c = o.length();
                            if (
                                c > this._settings.maxDistance &&
                                i.indexOf(a.id) < 0
                            )
                                continue;
                            let l = this._spatial.angleBetweenVector2(
                                    n.x,
                                    n.y,
                                    o.x,
                                    o.y
                                ),
                                h = this._spatial.angleToPlane(
                                    o.toArray(),
                                    [0, 0, 1]
                                ),
                                u = this._spatial.viewingDirection(a.rotation),
                                d = this._spatial.angleBetweenVector2(
                                    n.x,
                                    n.y,
                                    u.x,
                                    u.y
                                ),
                                p =
                                    this._spatial.angleToPlane(
                                        u.toArray(),
                                        [0, 0, 1]
                                    ) - r,
                                g = this._spatial.relativeRotationAngle(
                                    e.rotation,
                                    a.rotation
                                ),
                                m = this._spatial.angleBetweenVector2(
                                    1,
                                    0,
                                    o.x,
                                    o.y
                                ),
                                f =
                                    null != a.sequenceId &&
                                    null != e.sequenceId &&
                                    a.sequenceId === e.sequenceId,
                                _ = a.mergeId === e.mergeId,
                                M = a.creatorId === e.creatorId,
                                v = {
                                    capturedAt: a.capturedAt,
                                    directionChange: d,
                                    distance: c,
                                    spherical: jp(a.cameraType),
                                    id: a.id,
                                    motionChange: l,
                                    rotation: g,
                                    sameMergeCC: _,
                                    sameSequence: f,
                                    sameUser: M,
                                    sequenceId: a.sequenceId,
                                    verticalDirectionChange: p,
                                    verticalMotion: h,
                                    worldMotionAzimuth: m,
                                };
                            s.push(v);
                        }
                        return s;
                    }
                    computeSequenceEdges(e, t) {
                        if (!e.complete) throw new Ep("Image has to be full.");
                        if (e.sequenceId !== t.id)
                            throw new Ep(
                                "Image and sequence does not correspond."
                            );
                        let i = [],
                            n = t.findNext(e.id);
                        null != n &&
                            i.push({
                                data: {
                                    direction: Dp.Next,
                                    worldMotionAzimuth: Number.NaN,
                                },
                                source: e.id,
                                target: n,
                            });
                        let r = t.findPrev(e.id);
                        return (
                            null != r &&
                                i.push({
                                    data: {
                                        direction: Dp.Prev,
                                        worldMotionAzimuth: Number.NaN,
                                    },
                                    source: e.id,
                                    target: r,
                                }),
                            i
                        );
                    }
                    computeSimilarEdges(e, t) {
                        if (!e.complete) throw new Ep("Image has to be full.");
                        let i = jp(e.cameraType),
                            n = {};
                        for (let r of t)
                            if (null != r.sequenceId && !r.sameSequence) {
                                if (i) {
                                    if (!r.spherical) continue;
                                } else if (
                                    !r.spherical &&
                                    Math.abs(r.directionChange) >
                                        this._settings.similarMaxDirectionChange
                                )
                                    continue;
                                r.distance >
                                    this._settings.similarMaxDistance ||
                                    (r.sameUser &&
                                        Math.abs(r.capturedAt - e.capturedAt) <
                                            this._settings
                                                .similarMinTimeDifference) ||
                                    (null == n[r.sequenceId] &&
                                        (n[r.sequenceId] = []),
                                    n[r.sequenceId].push(r));
                            }
                        let r = [],
                            s = jp(e.cameraType)
                                ? (e) => e.distance
                                : (e) =>
                                      this._coefficients.similarDistance *
                                          e.distance +
                                      this._coefficients.similarRotation *
                                          e.rotation;
                        for (let e in n) {
                            if (!n.hasOwnProperty(e)) continue;
                            let t = Number.MAX_VALUE,
                                i = null;
                            for (let r of n[e]) {
                                let e = s(r);
                                e < t && ((t = e), (i = r));
                            }
                            null != i && r.push(i);
                        }
                        return r.map((t) => ({
                            data: {
                                direction: Dp.Similar,
                                worldMotionAzimuth: t.worldMotionAzimuth,
                            },
                            source: e.id,
                            target: t.id,
                        }));
                    }
                    computeStepEdges(e, t, i, n) {
                        if (!e.complete) throw new Ep("Image has to be full.");
                        let r = [];
                        if (jp(e.cameraType)) return r;
                        for (let s in this._directions.steps) {
                            if (!this._directions.steps.hasOwnProperty(s))
                                continue;
                            let a = this._directions.steps[s],
                                o = Number.MAX_VALUE,
                                c = null,
                                l = null;
                            for (let e of t) {
                                if (e.spherical) continue;
                                if (
                                    Math.abs(e.directionChange) >
                                    this._settings.stepMaxDirectionChange
                                )
                                    continue;
                                let t = this._spatial.angleDifference(
                                        a.motionChange,
                                        e.motionChange
                                    ),
                                    r = this._spatial.angleDifference(
                                        e.directionChange,
                                        t
                                    ),
                                    s = Math.max(Math.abs(t), Math.abs(r));
                                if (Math.abs(s) > this._settings.stepMaxDrift)
                                    continue;
                                let h = e.id;
                                if (
                                    (!a.useFallback ||
                                        (h !== i && h !== n) ||
                                        (l = e),
                                    e.distance > this._settings.stepMaxDistance)
                                )
                                    continue;
                                t = Math.sqrt(
                                    t * t + e.verticalMotion * e.verticalMotion
                                );
                                let u =
                                    (this._coefficients.stepPreferredDistance *
                                        Math.abs(
                                            e.distance -
                                                this._settings
                                                    .stepPreferredDistance
                                        )) /
                                        this._settings.stepMaxDistance +
                                    (this._coefficients.stepMotion * t) /
                                        this._settings.stepMaxDrift +
                                    (this._coefficients.stepRotation *
                                        e.rotation) /
                                        this._settings.stepMaxDirectionChange +
                                    this._coefficients.stepSequencePenalty *
                                        (e.sameSequence ? 0 : 1) +
                                    this._coefficients.stepMergeCCPenalty *
                                        (e.sameMergeCC ? 0 : 1);
                                u < o && ((o = u), (c = e));
                            }
                            (c = null == c ? l : c),
                                null != c &&
                                    r.push({
                                        data: {
                                            direction: a.direction,
                                            worldMotionAzimuth:
                                                c.worldMotionAzimuth,
                                        },
                                        source: e.id,
                                        target: c.id,
                                    });
                        }
                        return r;
                    }
                    computeTurnEdges(e, t) {
                        if (!e.complete) throw new Ep("Image has to be full.");
                        let i = [];
                        if (jp(e.cameraType)) return i;
                        for (let n in this._directions.turns) {
                            if (!this._directions.turns.hasOwnProperty(n))
                                continue;
                            let r = this._directions.turns[n],
                                s = Number.MAX_VALUE,
                                a = null;
                            for (let e of t) {
                                if (e.spherical) continue;
                                if (e.distance > this._settings.turnMaxDistance)
                                    continue;
                                let t,
                                    i =
                                        r.direction !== Dp.TurnU &&
                                        e.distance <
                                            this._settings.turnMaxRigDistance &&
                                        Math.abs(e.directionChange) >
                                            this._settings
                                                .turnMinRigDirectionChange,
                                    n = this._spatial.angleDifference(
                                        r.directionChange,
                                        e.directionChange
                                    );
                                if (
                                    i &&
                                    e.directionChange * r.directionChange > 0 &&
                                    Math.abs(e.directionChange) <
                                        Math.abs(r.directionChange)
                                )
                                    t =
                                        -Math.PI / 2 +
                                        Math.abs(e.directionChange);
                                else {
                                    if (
                                        Math.abs(n) >
                                        this._settings.turnMaxDirectionChange
                                    )
                                        continue;
                                    let i = r.motionChange
                                        ? this._spatial.angleDifference(
                                              r.motionChange,
                                              e.motionChange
                                          )
                                        : 0;
                                    (i = Math.sqrt(
                                        i * i +
                                            e.verticalMotion * e.verticalMotion
                                    )),
                                        (t =
                                            (this._coefficients.turnDistance *
                                                e.distance) /
                                                this._settings.turnMaxDistance +
                                            (this._coefficients.turnMotion *
                                                i) /
                                                Math.PI +
                                            this._coefficients
                                                .turnSequencePenalty *
                                                (e.sameSequence ? 0 : 1) +
                                            this._coefficients
                                                .turnMergeCCPenalty *
                                                (e.sameMergeCC ? 0 : 1));
                                }
                                t < s && ((s = t), (a = e));
                            }
                            null != a &&
                                i.push({
                                    data: {
                                        direction: r.direction,
                                        worldMotionAzimuth:
                                            a.worldMotionAzimuth,
                                    },
                                    source: e.id,
                                    target: a.id,
                                });
                        }
                        return i;
                    }
                    computePerspectiveToSphericalEdges(e, t) {
                        if (!e.complete) throw new Ep("Image has to be full.");
                        if (jp(e.cameraType)) return [];
                        let i = Number.MAX_VALUE,
                            n = null;
                        for (let e of t) {
                            if (!e.spherical) continue;
                            let t =
                                (this._coefficients.sphericalPreferredDistance *
                                    Math.abs(
                                        e.distance -
                                            this._settings
                                                .sphericalPreferredDistance
                                    )) /
                                    this._settings.sphericalMaxDistance +
                                (this._coefficients.sphericalMotion *
                                    Math.abs(e.motionChange)) /
                                    Math.PI +
                                this._coefficients.sphericalMergeCCPenalty *
                                    (e.sameMergeCC ? 0 : 1);
                            t < i && ((i = t), (n = e));
                        }
                        return null == n
                            ? []
                            : [
                                  {
                                      data: {
                                          direction: Dp.Spherical,
                                          worldMotionAzimuth:
                                              n.worldMotionAzimuth,
                                      },
                                      source: e.id,
                                      target: n.id,
                                  },
                              ];
                    }
                    computeSphericalEdges(e, t) {
                        if (!e.complete) throw new Ep("Image has to be full.");
                        if (!jp(e.cameraType)) return [];
                        let i = [],
                            n = [],
                            r = [];
                        for (let e of t)
                            if (
                                !(
                                    e.distance >
                                    this._settings.sphericalMaxDistance
                                )
                            )
                                if (e.spherical) {
                                    if (
                                        e.distance <
                                        this._settings.sphericalMinDistance
                                    )
                                        continue;
                                    n.push(e);
                                } else
                                    for (let t in this._directions.spherical) {
                                        if (
                                            !this._directions.spherical.hasOwnProperty(
                                                t
                                            )
                                        )
                                            continue;
                                        let i = this._directions.spherical[t],
                                            n = this._spatial.angleDifference(
                                                e.directionChange,
                                                e.motionChange
                                            ),
                                            s = this._spatial.angleDifference(
                                                i.directionChange,
                                                n
                                            );
                                        if (
                                            !(
                                                Math.abs(s) >
                                                this._settings
                                                    .sphericalMaxStepTurnChange
                                            )
                                        ) {
                                            r.push([i.direction, e]);
                                            break;
                                        }
                                    }
                        let s = Math.PI / this._settings.sphericalMaxItems,
                            a = [],
                            o = [];
                        for (
                            let t = 0;
                            t < this._settings.sphericalMaxItems;
                            t++
                        ) {
                            let r =
                                    (t / this._settings.sphericalMaxItems) *
                                    2 *
                                    Math.PI,
                                c = Number.MAX_VALUE,
                                l = null;
                            for (let e of n) {
                                let t = this._spatial.angleDifference(
                                    r,
                                    e.motionChange
                                );
                                if (Math.abs(t) > s) continue;
                                let i = Number.MAX_VALUE;
                                for (let t of a) {
                                    let n = Math.abs(
                                        this._spatial.angleDifference(
                                            t,
                                            e.motionChange
                                        )
                                    );
                                    n < i && (i = n);
                                }
                                if (i <= s) continue;
                                let n =
                                    (this._coefficients
                                        .sphericalPreferredDistance *
                                        Math.abs(
                                            e.distance -
                                                this._settings
                                                    .sphericalPreferredDistance
                                        )) /
                                        this._settings.sphericalMaxDistance +
                                    (this._coefficients.sphericalMotion *
                                        Math.abs(t)) /
                                        s +
                                    this._coefficients
                                        .sphericalSequencePenalty *
                                        (e.sameSequence ? 0 : 1) +
                                    this._coefficients.sphericalMergeCCPenalty *
                                        (e.sameMergeCC ? 0 : 1);
                                n < c && ((c = n), (l = e));
                            }
                            null != l
                                ? (a.push(l.motionChange),
                                  i.push({
                                      data: {
                                          direction: Dp.Spherical,
                                          worldMotionAzimuth:
                                              l.worldMotionAzimuth,
                                      },
                                      source: e.id,
                                      target: l.id,
                                  }))
                                : o.push(r);
                        }
                        let c = {};
                        (c[Dp.Spherical] = a),
                            (c[Dp.StepForward] = []),
                            (c[Dp.StepLeft] = []),
                            (c[Dp.StepBackward] = []),
                            (c[Dp.StepRight] = []);
                        for (let t of o) {
                            let n = [];
                            for (let a in this._directions.spherical) {
                                if (
                                    !this._directions.spherical.hasOwnProperty(
                                        a
                                    )
                                )
                                    continue;
                                let o = this._directions.spherical[a],
                                    l = c[Dp.Spherical]
                                        .concat(c[o.direction])
                                        .concat(c[o.prev])
                                        .concat(c[o.next]),
                                    h = Number.MAX_VALUE,
                                    u = null;
                                for (let e of r) {
                                    if (e[0] !== o.direction) continue;
                                    let i = this._spatial.angleDifference(
                                        t,
                                        e[1].motionChange
                                    );
                                    if (Math.abs(i) > s) continue;
                                    let n = Number.MAX_VALUE;
                                    for (let t of l) {
                                        let i = Math.abs(
                                            this._spatial.angleDifference(
                                                t,
                                                e[1].motionChange
                                            )
                                        );
                                        i < n && (n = i);
                                    }
                                    if (n <= s) continue;
                                    let r =
                                        (this._coefficients
                                            .sphericalPreferredDistance *
                                            Math.abs(
                                                e[1].distance -
                                                    this._settings
                                                        .sphericalPreferredDistance
                                            )) /
                                            this._settings
                                                .sphericalMaxDistance +
                                        (this._coefficients.sphericalMotion *
                                            Math.abs(i)) /
                                            s +
                                        this._coefficients
                                            .sphericalMergeCCPenalty *
                                            (e[1].sameMergeCC ? 0 : 1);
                                    r < h && ((h = r), (u = e));
                                }
                                null != u &&
                                    (n.push(u),
                                    i.push({
                                        data: {
                                            direction: u[0],
                                            worldMotionAzimuth:
                                                u[1].worldMotionAzimuth,
                                        },
                                        source: e.id,
                                        target: u[1].id,
                                    }));
                            }
                            for (let e of n) c[e[0]].push(e[1].motionChange);
                        }
                        return i;
                    }
                }
                class Up extends Ap {
                    constructor(e) {
                        super(e),
                            Object.setPrototypeOf(this, Up.prototype),
                            (this.name = "GraphMapillaryError");
                    }
                }
                class $p {
                    constructor(e, t, i, n, r, s) {
                        (this._api = e),
                            (this._cachedNodes = {}),
                            (this._cachedNodeTiles = {}),
                            (this._cachedSequenceNodes = {}),
                            (this._cachedSpatialEdges = {}),
                            (this._cachedTiles = {}),
                            (this._cachingFill$ = {}),
                            (this._cachingFull$ = {}),
                            (this._cachingSequenceNodes$ = {}),
                            (this._cachingSequences$ = {}),
                            (this._cachingSpatialArea$ = {}),
                            (this._cachingTiles$ = {}),
                            (this._changed$ = new W()),
                            (this._filterCreator = null != r ? r : new Bt()),
                            (this._filter = this._filterCreator.createFilter(
                                void 0
                            )),
                            (this._filterSubject$ = new W()),
                            (this._filter$ = We(
                                Ce(this._filter),
                                this._filterSubject$
                            ).pipe(It(1), V())),
                            (this._filterSubscription = this._filter$.subscribe(
                                () => {}
                            )),
                            (this._defaultAlt = 2),
                            (this._edgeCalculator = null != n ? n : new Pp()),
                            (this._graphCalculator = null != i ? i : new bp()),
                            (this._configuration =
                                null != s
                                    ? s
                                    : {
                                          maxSequences: 50,
                                          maxUnusedImages: 100,
                                          maxUnusedPreStoredImages: 30,
                                          maxUnusedTiles: 20,
                                      }),
                            (this._nodes = {}),
                            (this._nodeIndex =
                                null != t ? t : new $p._spatialIndex(16)),
                            (this._nodeIndexTiles = {}),
                            (this._nodeToTile = {}),
                            (this._preStored = {}),
                            (this._requiredNodeTiles = {}),
                            (this._requiredSpatialArea = {}),
                            (this._sequences = {}),
                            (this._tileThreshold = 20);
                    }
                    static register(e) {
                        $p._spatialIndex = e;
                    }
                    get api() {
                        return this._api;
                    }
                    get changed$() {
                        return this._changed$;
                    }
                    get filter$() {
                        return this._filter$;
                    }
                    cacheBoundingBox$(e, t) {
                        const i = this._api.data.geometry
                            .bboxToCellIds(e, t)
                            .filter((e) => !(e in this._cachedTiles))
                            .map((e) =>
                                e in this._cachingTiles$
                                    ? this._cachingTiles$[e]
                                    : this._cacheTile$(e)
                            );
                        return (
                            0 === i.length && i.push(Ce(this)),
                            ye(i).pipe(
                                qe(),
                                Tt(),
                                Ye(() => {
                                    const i = this._nodeIndex
                                            .search({
                                                maxX: t.lng,
                                                maxY: t.lat,
                                                minX: e.lng,
                                                minY: e.lat,
                                            })
                                            .map((e) => e.node),
                                        n = [],
                                        r = [];
                                    for (const e of i)
                                        e.complete ? n.push(e) : r.push(e.id);
                                    const s = [];
                                    for (; r.length > 0; )
                                        s.push(r.splice(0, 200));
                                    return tt(
                                        Ce(n),
                                        ye(
                                            s.map((e) =>
                                                this._api
                                                    .getSpatialImages$(e)
                                                    .pipe(
                                                        ke((e) => {
                                                            const t = [];
                                                            for (const i of e) {
                                                                if (
                                                                    !this.hasNode(
                                                                        i.node_id
                                                                    )
                                                                )
                                                                    continue;
                                                                const e =
                                                                    this.getNode(
                                                                        i.node_id
                                                                    );
                                                                e.complete ||
                                                                    this._makeFull(
                                                                        e,
                                                                        i.node
                                                                    ),
                                                                    t.push(e);
                                                            }
                                                            return t;
                                                        })
                                                    )
                                            )
                                        ).pipe(qe())
                                    );
                                }),
                                lt((e, t) => e.concat(t))
                            )
                        );
                    }
                    cacheCell$(e) {
                        return (
                            e in this._cachedTiles
                                ? Ce(this)
                                : e in this._cachingTiles$
                                ? this._cachingTiles$[e]
                                : this._cacheTile$(e)
                        ).pipe(
                            Ye(() => {
                                const t = this._cachedTiles[e];
                                t.accessed = new Date().getTime();
                                const i = t.nodes,
                                    n = [],
                                    r = [];
                                for (const e of i)
                                    e.complete ? n.push(e) : r.push(e.id);
                                const s = [];
                                for (; r.length > 0; ) s.push(r.splice(0, 200));
                                return tt(
                                    Ce(n),
                                    ye(
                                        s.map((e) =>
                                            this._api.getSpatialImages$(e).pipe(
                                                ke((e) => {
                                                    const t = [];
                                                    for (const i of e) {
                                                        if (!i.node) {
                                                            console.warn(
                                                                `Image is empty (${i.node})`
                                                            );
                                                            continue;
                                                        }
                                                        const e = i.node_id;
                                                        if (!this.hasNode(e))
                                                            continue;
                                                        const n =
                                                            this.getNode(e);
                                                        n.complete ||
                                                            this._makeFull(
                                                                n,
                                                                i.node
                                                            ),
                                                            t.push(n);
                                                    }
                                                    return t;
                                                })
                                            )
                                        )
                                    ).pipe(qe())
                                );
                            }),
                            lt((e, t) => e.concat(t))
                        );
                    }
                    cacheFill$(e) {
                        if (e in this._cachingFull$)
                            throw new Up(
                                `Cannot fill node while caching full (${e}).`
                            );
                        if (!this.hasNode(e))
                            throw new Up(
                                `Cannot fill node that does not exist in graph (${e}).`
                            );
                        if (e in this._cachingFill$)
                            return this._cachingFill$[e];
                        const t = this.getNode(e);
                        if (t.complete)
                            throw new Up(
                                `Cannot fill node that is already full (${e}).`
                            );
                        return (
                            (this._cachingFill$[e] = this._api
                                .getSpatialImages$([e])
                                .pipe(
                                    Ut((e) => {
                                        for (const i of e)
                                            i.node ||
                                                console.warn(
                                                    `Image is empty ${i.node_id}`
                                                ),
                                                t.complete ||
                                                    this._makeFull(t, i.node),
                                                delete this._cachingFill$[
                                                    i.node_id
                                                ];
                                    }),
                                    ke(() => this),
                                    xt(() => {
                                        e in this._cachingFill$ &&
                                            delete this._cachingFill$[e],
                                            this._changed$.next(this);
                                    }),
                                    Dt(),
                                    V()
                                )),
                            this._cachingFill$[e]
                        );
                    }
                    cacheFull$(e) {
                        if (e in this._cachingFull$)
                            return this._cachingFull$[e];
                        if (this.hasNode(e))
                            throw new Up(
                                `Cannot cache full node that already exist in graph (${e}).`
                            );
                        return (
                            (this._cachingFull$[e] = this._api
                                .getImages$([e])
                                .pipe(
                                    Ut((t) => {
                                        for (const i of t) {
                                            if (!i.node)
                                                throw new Up(
                                                    `Image does not exist (${e}, ${i.node}).`
                                                );
                                            const t = i.node_id;
                                            if (this.hasNode(t)) {
                                                const t = this.getNode(e);
                                                t.complete ||
                                                    this._makeFull(t, i.node);
                                            } else {
                                                if (null == i.node.sequence.id)
                                                    throw new Up(
                                                        `Image has no sequence key (${e}).`
                                                    );
                                                const n = new wp(i.node);
                                                this._makeFull(n, i.node);
                                                const r =
                                                    this._api.data.geometry.lngLatToCellId(
                                                        n.originalLngLat
                                                    );
                                                this._preStore(r, n),
                                                    this._setNode(n),
                                                    delete this._cachingFull$[
                                                        t
                                                    ];
                                            }
                                        }
                                    }),
                                    ke(() => this),
                                    xt(() => {
                                        e in this._cachingFull$ &&
                                            delete this._cachingFull$[e],
                                            this._changed$.next(this);
                                    }),
                                    Dt(),
                                    V()
                                )),
                            this._cachingFull$[e]
                        );
                    }
                    cacheNodeSequence$(e) {
                        if (!this.hasNode(e))
                            throw new Up(
                                `Cannot cache sequence edges of node that does not exist in graph (${e}).`
                            );
                        let t = this.getNode(e);
                        if (t.sequenceId in this._sequences)
                            throw new Up(
                                `Sequence already cached (${e}), (${t.sequenceId}).`
                            );
                        return this._cacheSequence$(t.sequenceId);
                    }
                    cacheSequence$(e) {
                        if (e in this._sequences)
                            throw new Up(`Sequence already cached (${e})`);
                        return this._cacheSequence$(e);
                    }
                    cacheSequenceEdges(e) {
                        let t = this.getNode(e);
                        if (!(t.sequenceId in this._sequences))
                            throw new Up(
                                `Sequence is not cached (${e}), (${t.sequenceId})`
                            );
                        let i = this._sequences[t.sequenceId].sequence,
                            n = this._edgeCalculator.computeSequenceEdges(t, i);
                        t.cacheSequenceEdges(n);
                    }
                    cacheSequenceNodes$(e, t) {
                        if (!this.hasSequence(e))
                            throw new Up(
                                `Cannot cache sequence nodes of sequence that does not exist in graph (${e}).`
                            );
                        if (this.hasSequenceNodes(e))
                            throw new Up(
                                `Sequence nodes already cached (${e}).`
                            );
                        const i = this.getSequence(e);
                        if (i.id in this._cachingSequenceNodes$)
                            return this._cachingSequenceNodes$[i.id];
                        const n = [],
                            r = i.imageIds.slice();
                        if (t && r.length > 50) {
                            const e = r.indexOf(t),
                                i = Math.max(
                                    0,
                                    Math.min(e - 25, r.length - 50)
                                );
                            n.push(r.splice(i, 50));
                        }
                        for (; r.length > 0; ) n.push(r.splice(0, 200));
                        let s = n.length;
                        const a = ye(n).pipe(
                            Ye(
                                (e) =>
                                    this._api.getImages$(e).pipe(
                                        Ut((e) => {
                                            for (const t of e) {
                                                if (!t.node) {
                                                    console.warn(
                                                        `Image empty (${t.node_id})`
                                                    );
                                                    continue;
                                                }
                                                const e = t.node_id;
                                                if (this.hasNode(e)) {
                                                    const i = this.getNode(e);
                                                    i.complete ||
                                                        this._makeFull(
                                                            i,
                                                            t.node
                                                        );
                                                } else {
                                                    null ==
                                                        t.node.sequence.id &&
                                                        console.warn(
                                                            `Sequence missing, discarding node (${t.node_id})`
                                                        );
                                                    const e = new wp(t.node);
                                                    this._makeFull(e, t.node);
                                                    const i =
                                                        this._api.data.geometry.lngLatToCellId(
                                                            e.originalLngLat
                                                        );
                                                    this._preStore(i, e),
                                                        this._setNode(e);
                                                }
                                            }
                                            s--;
                                        }),
                                        ke(() => this)
                                    ),
                                6
                            ),
                            Tt(),
                            xt(() => {
                                delete this._cachingSequenceNodes$[i.id],
                                    0 === s &&
                                        (this._cachedSequenceNodes[i.id] = !0);
                            }),
                            Dt(),
                            V()
                        );
                        return (this._cachingSequenceNodes$[i.id] = a), a;
                    }
                    cacheSpatialArea$(e) {
                        if (!this.hasNode(e))
                            throw new Up(
                                `Cannot cache spatial area of node that does not exist in graph (${e}).`
                            );
                        if (e in this._cachedSpatialEdges)
                            throw new Up(
                                `Image already spatially cached (${e}).`
                            );
                        if (!(e in this._requiredSpatialArea))
                            throw new Up(`Spatial area not determined (${e}).`);
                        let t = this._requiredSpatialArea[e];
                        if (0 === Object.keys(t.cacheNodes).length)
                            throw new Up(
                                `Spatial nodes already cached (${e}).`
                            );
                        if (e in this._cachingSpatialArea$)
                            return this._cachingSpatialArea$[e];
                        let i = [];
                        for (; t.cacheKeys.length > 0; )
                            i.push(t.cacheKeys.splice(0, 200));
                        let n = i.length,
                            r = [];
                        for (let s of i) {
                            let i = this._api.getSpatialImages$(s).pipe(
                                Ut((i) => {
                                    for (const e of i) {
                                        if (!e.node) {
                                            console.warn(
                                                `Image is empty (${e.node_id})`
                                            );
                                            continue;
                                        }
                                        const i = e.node_id,
                                            n = t.cacheNodes[i];
                                        n.complete || this._makeFull(n, e.node),
                                            delete t.cacheNodes[i];
                                    }
                                    0 == --n &&
                                        delete this._cachingSpatialArea$[e];
                                }),
                                ke(() => this),
                                ot((i) => {
                                    for (let e of s)
                                        e in t.all && delete t.all[e],
                                            e in t.cacheNodes &&
                                                delete t.cacheNodes[e];
                                    throw (
                                        (0 == --n &&
                                            delete this._cachingSpatialArea$[e],
                                        i)
                                    );
                                }),
                                xt(() => {
                                    0 === Object.keys(t.cacheNodes).length &&
                                        this._changed$.next(this);
                                }),
                                Dt(),
                                V()
                            );
                            r.push(i);
                        }
                        return (this._cachingSpatialArea$[e] = r), r;
                    }
                    cacheSpatialEdges(e) {
                        if (e in this._cachedSpatialEdges)
                            throw new Up(
                                `Spatial edges already cached (${e}).`
                            );
                        let t = this.getNode(e),
                            i = this._sequences[t.sequenceId].sequence,
                            n = [],
                            r = i.findPrev(t.id);
                        null != r && n.push(r);
                        let s = i.findNext(t.id);
                        null != s && n.push(s);
                        let a = this._requiredSpatialArea[e].all,
                            o = [],
                            c = this._filter;
                        for (let e in a) {
                            if (!a.hasOwnProperty(e)) continue;
                            let t = a[e];
                            c(t) && o.push(t);
                        }
                        let l = this._edgeCalculator.getPotentialEdges(t, o, n),
                            h = this._edgeCalculator.computeStepEdges(
                                t,
                                l,
                                r,
                                s
                            );
                        (h = h.concat(
                            this._edgeCalculator.computeTurnEdges(t, l)
                        )),
                            (h = h.concat(
                                this._edgeCalculator.computeSphericalEdges(t, l)
                            )),
                            (h = h.concat(
                                this._edgeCalculator.computePerspectiveToSphericalEdges(
                                    t,
                                    l
                                )
                            )),
                            (h = h.concat(
                                this._edgeCalculator.computeSimilarEdges(t, l)
                            )),
                            t.cacheSpatialEdges(h),
                            (this._cachedSpatialEdges[e] = t),
                            delete this._requiredSpatialArea[e],
                            delete this._cachedNodeTiles[e];
                    }
                    cacheTiles$(e) {
                        if (e in this._cachedNodeTiles)
                            throw new Up(`Tiles already cached (${e}).`);
                        if (e in this._cachedSpatialEdges)
                            throw new Up(
                                `Spatial edges already cached so tiles considered cached (${e}).`
                            );
                        if (!(e in this._requiredNodeTiles))
                            throw new Up(
                                `Tiles have not been determined (${e}).`
                            );
                        let t = this._requiredNodeTiles[e];
                        if (0 === t.cache.length && 0 === t.caching.length)
                            throw new Up(`Tiles already cached (${e}).`);
                        if (!this.hasNode(e))
                            throw new Up(
                                `Cannot cache tiles of node that does not exist in graph (${e}).`
                            );
                        let i = t.cache.slice();
                        (t.caching =
                            this._requiredNodeTiles[e].caching.concat(i)),
                            (t.cache = []);
                        let n = [];
                        for (let i of t.caching) {
                            const r =
                                i in this._cachingTiles$
                                    ? this._cachingTiles$[i]
                                    : this._cacheTile$(i);
                            n.push(
                                r.pipe(
                                    Ut((n) => {
                                        let r = t.caching.indexOf(i);
                                        r > -1 && t.caching.splice(r, 1),
                                            0 === t.caching.length &&
                                                0 === t.cache.length &&
                                                (delete this._requiredNodeTiles[
                                                    e
                                                ],
                                                (this._cachedNodeTiles[e] =
                                                    !0));
                                    }),
                                    ot((n) => {
                                        let r = t.caching.indexOf(i);
                                        throw (
                                            (r > -1 && t.caching.splice(r, 1),
                                            0 === t.caching.length &&
                                                0 === t.cache.length &&
                                                (delete this._requiredNodeTiles[
                                                    e
                                                ],
                                                (this._cachedNodeTiles[e] =
                                                    !0)),
                                            n)
                                        );
                                    }),
                                    xt(() => {
                                        this._changed$.next(this);
                                    }),
                                    Dt(),
                                    V()
                                )
                            );
                        }
                        return n;
                    }
                    initializeCache(e) {
                        if (e in this._cachedNodes)
                            throw new Up(`Image already in cache (${e}).`);
                        const t = this.getNode(e),
                            i = this._api.data;
                        t.initializeCache(new Tp(i));
                        const n = new Date().getTime();
                        (this._cachedNodes[e] = { accessed: n, node: t }),
                            this._updateCachedTileAccess(e, n);
                    }
                    isCachingFill(e) {
                        return e in this._cachingFill$;
                    }
                    isCachingFull(e) {
                        return e in this._cachingFull$;
                    }
                    isCachingNodeSequence(e) {
                        return (
                            this.getNode(e).sequenceId in
                            this._cachingSequences$
                        );
                    }
                    isCachingSequence(e) {
                        return e in this._cachingSequences$;
                    }
                    isCachingSequenceNodes(e) {
                        return e in this._cachingSequenceNodes$;
                    }
                    isCachingTiles(e) {
                        return (
                            e in this._requiredNodeTiles &&
                            0 === this._requiredNodeTiles[e].cache.length &&
                            this._requiredNodeTiles[e].caching.length > 0
                        );
                    }
                    hasInitializedCache(e) {
                        return e in this._cachedNodes;
                    }
                    hasNode(e) {
                        let t = new Date().getTime();
                        return (
                            this._updateCachedNodeAccess(e, t),
                            this._updateCachedTileAccess(e, t),
                            e in this._nodes
                        );
                    }
                    hasNodeSequence(e) {
                        let t = this.getNode(e).sequenceId,
                            i = t in this._sequences;
                        return (
                            i &&
                                (this._sequences[t].accessed =
                                    new Date().getTime()),
                            i
                        );
                    }
                    hasSequence(e) {
                        let t = e in this._sequences;
                        return (
                            t &&
                                (this._sequences[e].accessed =
                                    new Date().getTime()),
                            t
                        );
                    }
                    hasSequenceNodes(e) {
                        return e in this._cachedSequenceNodes;
                    }
                    hasSpatialArea(e) {
                        if (!this.hasNode(e))
                            throw new Up(
                                `Spatial area nodes cannot be determined if node not in graph (${e}).`
                            );
                        if (e in this._cachedSpatialEdges) return !0;
                        if (e in this._requiredSpatialArea)
                            return (
                                0 ===
                                Object.keys(
                                    this._requiredSpatialArea[e].cacheNodes
                                ).length
                            );
                        let t = this.getNode(e),
                            i = this._graphCalculator.boundingBoxCorners(
                                t.lngLat,
                                this._tileThreshold
                            ),
                            n = this._nodeIndex.search({
                                maxX: i[1].lng,
                                maxY: i[1].lat,
                                minX: i[0].lng,
                                minY: i[0].lat,
                            }),
                            r = { all: {}, cacheKeys: [], cacheNodes: {} };
                        for (let e of n)
                            (r.all[e.node.id] = e.node),
                                e.node.complete ||
                                    (r.cacheKeys.push(e.node.id),
                                    (r.cacheNodes[e.node.id] = e.node));
                        return (
                            (this._requiredSpatialArea[e] = r),
                            0 === r.cacheKeys.length
                        );
                    }
                    hasTiles(e) {
                        if (e in this._cachedNodeTiles) return !0;
                        if (e in this._cachedSpatialEdges) return !0;
                        if (!this.hasNode(e))
                            throw new Up(
                                `Image does not exist in graph (${e}).`
                            );
                        let t = { cache: [], caching: [] };
                        if (e in this._requiredNodeTiles)
                            t = this._requiredNodeTiles[e];
                        else {
                            const i = this.getNode(e),
                                [n, r] =
                                    this._graphCalculator.boundingBoxCorners(
                                        i.lngLat,
                                        this._tileThreshold
                                    );
                            (t.cache = this._api.data.geometry
                                .bboxToCellIds(n, r)
                                .filter((e) => !(e in this._cachedTiles))),
                                t.cache.length > 0 &&
                                    (this._requiredNodeTiles[e] = t);
                        }
                        return 0 === t.cache.length && 0 === t.caching.length;
                    }
                    getNode(e) {
                        let t = new Date().getTime();
                        return (
                            this._updateCachedNodeAccess(e, t),
                            this._updateCachedTileAccess(e, t),
                            this._nodes[e]
                        );
                    }
                    getSequence(e) {
                        let t = this._sequences[e];
                        return (t.accessed = new Date().getTime()), t.sequence;
                    }
                    resetSpatialEdges() {
                        let e = Object.keys(this._cachedSpatialEdges);
                        for (let t of e)
                            this._cachedSpatialEdges[t].resetSpatialEdges(),
                                delete this._cachedSpatialEdges[t];
                    }
                    reset(e) {
                        const t = [];
                        for (const i of e) {
                            if (!this.hasNode(i))
                                throw new Error(`Image does not exist ${i}`);
                            const e = this.getNode(i);
                            e.resetSequenceEdges(),
                                e.resetSpatialEdges(),
                                t.push(e);
                        }
                        for (let t of Object.keys(this._cachedNodes))
                            -1 === e.indexOf(t) &&
                                (this._cachedNodes[t].node.dispose(),
                                delete this._cachedNodes[t]);
                        (this._cachedNodeTiles = {}),
                            (this._cachedSpatialEdges = {}),
                            (this._cachedTiles = {}),
                            (this._cachingFill$ = {}),
                            (this._cachingFull$ = {}),
                            (this._cachingSequences$ = {}),
                            (this._cachingSpatialArea$ = {}),
                            (this._cachingTiles$ = {}),
                            (this._nodes = {}),
                            (this._nodeToTile = {}),
                            (this._preStored = {});
                        for (const e of t) {
                            this._nodes[e.id] = e;
                            const t = this._api.data.geometry.lngLatToCellId(
                                e.originalLngLat
                            );
                            this._preStore(t, e);
                        }
                        (this._requiredNodeTiles = {}),
                            (this._requiredSpatialArea = {}),
                            (this._sequences = {}),
                            (this._nodeIndexTiles = {}),
                            this._nodeIndex.clear();
                    }
                    setFilter(e) {
                        (this._filter = this._filterCreator.createFilter(e)),
                            this._filterSubject$.next(this._filter);
                    }
                    uncache(e, t, i) {
                        const n = {};
                        this._addNewKeys(n, this._cachingFull$),
                            this._addNewKeys(n, this._cachingFill$),
                            this._addNewKeys(n, this._cachingSpatialArea$),
                            this._addNewKeys(n, this._requiredNodeTiles),
                            this._addNewKeys(n, this._requiredSpatialArea);
                        for (const t of e) t in n || (n[t] = !0);
                        const r = this._tileThreshold,
                            s = this._graphCalculator,
                            a = this._api.data.geometry,
                            o = new Set(t);
                        for (let e in n) {
                            if (!n.hasOwnProperty(e)) continue;
                            const t = this._nodes[e],
                                [i, c] = s.boundingBoxCorners(t.lngLat, r),
                                l = a.bboxToCellIds(i, c);
                            for (const e of l) o.has(e) || o.add(e);
                        }
                        const c = [];
                        for (let e in this._cachedTiles)
                            this._cachedTiles.hasOwnProperty(e) &&
                                !o.has(e) &&
                                c.push([e, this._cachedTiles[e]]);
                        const l = c
                            .sort((e, t) => t[1].accessed - e[1].accessed)
                            .slice(this._configuration.maxUnusedTiles)
                            .map((e) => e[0]);
                        for (let e of l) this._uncacheTile(e, i);
                        const h = [],
                            u = [];
                        for (let e in this._preStored) {
                            if (
                                !this._preStored.hasOwnProperty(e) ||
                                e in this._cachingTiles$
                            )
                                continue;
                            const t = this._preStored[e];
                            for (let r in t)
                                t.hasOwnProperty(r) &&
                                    !(r in n) &&
                                    t[r].sequenceId !== i &&
                                    (r in this._cachedNodes
                                        ? h.push([this._cachedNodes[r], e])
                                        : u.push([r, e]));
                        }
                        const d = h
                            .sort(([e], [t]) => t.accessed - e.accessed)
                            .slice(this._configuration.maxUnusedPreStoredImages)
                            .map(([e, t]) => [e.node.id, t]);
                        this._uncachePreStored(u), this._uncachePreStored(d);
                        const p = [];
                        for (let e in this._cachedNodes)
                            this._cachedNodes.hasOwnProperty(e) &&
                                !(e in n) &&
                                p.push(this._cachedNodes[e]);
                        const g = p
                            .sort((e, t) => t.accessed - e.accessed)
                            .slice(this._configuration.maxUnusedImages);
                        for (const e of g) {
                            e.node.uncache();
                            const t = e.node.id;
                            delete this._cachedNodes[t],
                                t in this._cachedNodeTiles &&
                                    delete this._cachedNodeTiles[t],
                                t in this._cachedSpatialEdges &&
                                    delete this._cachedSpatialEdges[t];
                        }
                        const m = [];
                        for (let e in this._sequences)
                            this._sequences.hasOwnProperty(e) &&
                                !(e in this._cachingSequences$) &&
                                e !== i &&
                                m.push(this._sequences[e]);
                        const f = m
                            .sort((e, t) => t.accessed - e.accessed)
                            .slice(this._configuration.maxSequences);
                        for (const e of f) {
                            const t = e.sequence.id;
                            delete this._sequences[t],
                                t in this._cachedSequenceNodes &&
                                    delete this._cachedSequenceNodes[t],
                                e.sequence.dispose();
                        }
                    }
                    updateCells$(e) {
                        const t = this._cachedTiles,
                            i = this._cachingTiles$;
                        return ye(e).pipe(
                            Ye((e) =>
                                e in t
                                    ? this._updateCell$(e)
                                    : e in i
                                    ? i[e].pipe(
                                          ot(() => Ce(this)),
                                          Ye(() => this._updateCell$(e))
                                      )
                                    : oe()
                            )
                        );
                    }
                    unsubscribe() {
                        this._filterSubscription.unsubscribe();
                    }
                    _addNewKeys(e, t) {
                        for (let i in t)
                            t.hasOwnProperty(i) &&
                                this.hasNode(i) &&
                                (i in e || (e[i] = !0));
                    }
                    _cacheSequence$(e) {
                        return (
                            e in this._cachingSequences$ ||
                                (this._cachingSequences$[e] = this._api
                                    .getSequence$(e)
                                    .pipe(
                                        Ut((t) => {
                                            t
                                                ? (t.id in this._sequences ||
                                                      (this._sequences[t.id] = {
                                                          accessed:
                                                              new Date().getTime(),
                                                          sequence: new Sp(t),
                                                      }),
                                                  delete this
                                                      ._cachingSequences$[e])
                                                : console.warn(
                                                      `Sequence does not exist (${e})`
                                                  );
                                        }),
                                        ke(() => this),
                                        xt(() => {
                                            e in this._cachingSequences$ &&
                                                delete this._cachingSequences$[
                                                    e
                                                ],
                                                this._changed$.next(this);
                                        }),
                                        Dt(),
                                        V()
                                    )),
                            this._cachingSequences$[e]
                        );
                    }
                    _cacheTile$(e) {
                        return (
                            (this._cachingTiles$[e] = this._api
                                .getCoreImages$(e)
                                .pipe(
                                    Ut((t) => {
                                        if (e in this._cachedTiles) return;
                                        const i = t.images;
                                        (this._nodeIndexTiles[e] = []),
                                            (this._cachedTiles[e] = {
                                                accessed: new Date().getTime(),
                                                nodes: [],
                                            });
                                        const n = this._cachedTiles[e].nodes,
                                            r = this._removeFromPreStore(e);
                                        for (const t of i) {
                                            if (!t) break;
                                            if (null == t.sequence.id) {
                                                console.warn(
                                                    `Sequence missing, discarding node (${t.id})`
                                                );
                                                continue;
                                            }
                                            if (null != r && t.id in r) {
                                                const i = r[t.id];
                                                delete r[t.id], n.push(i);
                                                const s = {
                                                    lat: i.lngLat.lat,
                                                    lng: i.lngLat.lng,
                                                    node: i,
                                                };
                                                this._nodeIndex.insert(s),
                                                    this._nodeIndexTiles[
                                                        e
                                                    ].push(s),
                                                    (this._nodeToTile[i.id] =
                                                        e);
                                                continue;
                                            }
                                            const i = new wp(t);
                                            n.push(i);
                                            const s = {
                                                lat: i.lngLat.lat,
                                                lng: i.lngLat.lng,
                                                node: i,
                                            };
                                            this._nodeIndex.insert(s),
                                                this._nodeIndexTiles[e].push(s),
                                                (this._nodeToTile[i.id] = e),
                                                this._setNode(i);
                                        }
                                        delete this._cachingTiles$[e];
                                    }),
                                    ke(() => this),
                                    ot((t) => {
                                        throw (
                                            (delete this._cachingTiles$[e], t)
                                        );
                                    }),
                                    Dt(),
                                    V()
                                )),
                            this._cachingTiles$[e]
                        );
                    }
                    _makeFull(e, t) {
                        null == t.computed_altitude &&
                            (t.computed_altitude = this._defaultAlt),
                            null == t.computed_rotation &&
                                (t.computed_rotation =
                                    this._graphCalculator.rotationFromCompass(
                                        t.compass_angle,
                                        t.exif_orientation
                                    )),
                            e.makeComplete(t);
                    }
                    _preStore(e, t) {
                        e in this._preStored || (this._preStored[e] = {}),
                            (this._preStored[e][t.id] = t);
                    }
                    _removeFromPreStore(e) {
                        let t = null;
                        return (
                            e in this._preStored &&
                                ((t = this._preStored[e]),
                                delete this._preStored[e]),
                            t
                        );
                    }
                    _setNode(e) {
                        let t = e.id;
                        if (this.hasNode(t))
                            throw new Up(`Image already exist (${t}).`);
                        this._nodes[t] = e;
                    }
                    _uncacheTile(e, t) {
                        for (let i of this._cachedTiles[e].nodes) {
                            let n = i.id;
                            delete this._nodeToTile[n],
                                n in this._cachedNodes &&
                                    delete this._cachedNodes[n],
                                n in this._cachedNodeTiles &&
                                    delete this._cachedNodeTiles[n],
                                n in this._cachedSpatialEdges &&
                                    delete this._cachedSpatialEdges[n],
                                i.sequenceId === t
                                    ? (this._preStore(e, i), i.uncache())
                                    : (delete this._nodes[n],
                                      i.sequenceId in
                                          this._cachedSequenceNodes &&
                                          delete this._cachedSequenceNodes[
                                              i.sequenceId
                                          ],
                                      i.dispose());
                        }
                        for (let t of this._nodeIndexTiles[e])
                            this._nodeIndex.remove(t);
                        delete this._nodeIndexTiles[e],
                            delete this._cachedTiles[e];
                    }
                    _uncachePreStored(e) {
                        let t = {};
                        for (let [i, n] of e) {
                            i in this._nodes && delete this._nodes[i],
                                i in this._cachedNodes &&
                                    delete this._cachedNodes[i];
                            let e = this._preStored[n][i];
                            e.sequenceId in this._cachedSequenceNodes &&
                                delete this._cachedSequenceNodes[e.sequenceId],
                                delete this._preStored[n][i],
                                e.dispose(),
                                (t[n] = !0);
                        }
                        for (let e in t)
                            t.hasOwnProperty(e) &&
                                0 === Object.keys(this._preStored[e]).length &&
                                delete this._preStored[e];
                    }
                    _updateCachedTileAccess(e, t) {
                        e in this._nodeToTile &&
                            (this._cachedTiles[this._nodeToTile[e]].accessed =
                                t);
                    }
                    _updateCachedNodeAccess(e, t) {
                        e in this._cachedNodes &&
                            (this._cachedNodes[e].accessed = t);
                    }
                    _updateCell$(e) {
                        return this._api.getCoreImages$(e).pipe(
                            Ye((t) => {
                                if (!(e in this._cachedTiles)) return oe();
                                const i = this._nodeIndex,
                                    n = this._nodeIndexTiles[e],
                                    r = this._nodeToTile,
                                    s = this._cachedTiles[e];
                                s.accessed = new Date().getTime();
                                const a = s.nodes,
                                    o = t.images;
                                for (const t of o) {
                                    if (null == t) break;
                                    if (this.hasNode(t.id)) continue;
                                    if (null == t.sequence.id) {
                                        console.warn(
                                            `Sequence missing, discarding node (${t.id})`
                                        );
                                        continue;
                                    }
                                    const s = new wp(t);
                                    a.push(s);
                                    const o = {
                                        lat: s.lngLat.lat,
                                        lng: s.lngLat.lng,
                                        node: s,
                                    };
                                    i.insert(o),
                                        n.push(o),
                                        (r[s.id] = e),
                                        this._setNode(s);
                                }
                                return Ce(e);
                            }),
                            ot((e) => (console.error(e), oe()))
                        );
                    }
                }
                class Bp {
                    constructor() {
                        (this._hash = {}),
                            (this._index = new Bp._spatialIndex(16)),
                            (this._indexChanged$ = new W()),
                            (this._updated$ = new W());
                    }
                    static register(e) {
                        Bp._spatialIndex = e;
                    }
                    get changed$() {
                        return this._indexChanged$;
                    }
                    get updated$() {
                        return this._updated$;
                    }
                    add(e) {
                        const t = [],
                            i = this._hash,
                            n = this._index;
                        for (const r of e) {
                            const e = r.id;
                            e in i && (n.remove(i[e]), t.push(r));
                            const s = {
                                lat: r.lngLat.lat,
                                lng: r.lngLat.lng,
                                marker: r,
                            };
                            (i[e] = s), n.insert(s);
                        }
                        t.length > 0 && this._updated$.next(t),
                            e.length > t.length &&
                                this._indexChanged$.next(this);
                    }
                    has(e) {
                        return e in this._hash;
                    }
                    get(e) {
                        return this.has(e) ? this._hash[e].marker : void 0;
                    }
                    getAll() {
                        return this._index.all().map((e) => e.marker);
                    }
                    remove(e) {
                        const t = this._hash,
                            i = this._index;
                        let n = !1;
                        for (const r of e) {
                            if (!(r in t)) continue;
                            const e = t[r];
                            i.remove(e), delete t[r], (n = !0);
                        }
                        n && this._indexChanged$.next(this);
                    }
                    removeAll() {
                        (this._hash = {}),
                            this._index.clear(),
                            this._indexChanged$.next(this);
                    }
                    search([e, t]) {
                        return this._index
                            .search({
                                maxX: t.lng,
                                maxY: t.lat,
                                minX: e.lng,
                                minY: e.lat,
                            })
                            .map((e) => e.marker);
                    }
                    update(e) {
                        const t = this._hash,
                            i = this._index,
                            n = e.id;
                        if (!(n in t)) return;
                        i.remove(t[n]);
                        const r = {
                            lat: e.lngLat.lat,
                            lng: e.lngLat.lng,
                            marker: e,
                        };
                        (t[n] = r), i.insert(r);
                    }
                }
                function Fp(e, t, i, n, r) {
                    Hp(e, t, i || 0, n || e.length - 1, r || Vp);
                }
                function Hp(e, t, i, n, r) {
                    for (; n > i; ) {
                        if (n - i > 600) {
                            var s = n - i + 1,
                                a = t - i + 1,
                                o = Math.log(s),
                                c = 0.5 * Math.exp((2 * o) / 3),
                                l =
                                    0.5 *
                                    Math.sqrt((o * c * (s - c)) / s) *
                                    (a - s / 2 < 0 ? -1 : 1);
                            Hp(
                                e,
                                t,
                                Math.max(i, Math.floor(t - (a * c) / s + l)),
                                Math.min(
                                    n,
                                    Math.floor(t + ((s - a) * c) / s + l)
                                ),
                                r
                            );
                        }
                        var h = e[t],
                            u = i,
                            d = n;
                        for (
                            Gp(e, i, t), r(e[n], h) > 0 && Gp(e, i, n);
                            u < d;

                        ) {
                            for (Gp(e, u, d), u++, d--; r(e[u], h) < 0; ) u++;
                            for (; r(e[d], h) > 0; ) d--;
                        }
                        0 === r(e[i], h) ? Gp(e, i, d) : Gp(e, ++d, n),
                            d <= t && (i = d + 1),
                            t <= d && (n = d - 1);
                    }
                }
                function Gp(e, t, i) {
                    var n = e[t];
                    (e[t] = e[i]), (e[i] = n);
                }
                function Vp(e, t) {
                    return e < t ? -1 : e > t ? 1 : 0;
                }
                class Yp {
                    constructor(e = 9) {
                        (this._maxEntries = Math.max(4, e)),
                            (this._minEntries = Math.max(
                                2,
                                Math.ceil(0.4 * this._maxEntries)
                            )),
                            this.clear();
                    }
                    all() {
                        return this._all(this.data, []);
                    }
                    search(e) {
                        let t = this.data;
                        const i = [];
                        if (!ng(e, t)) return i;
                        const n = this.toBBox,
                            r = [];
                        for (; t; ) {
                            for (let s = 0; s < t.children.length; s++) {
                                const a = t.children[s],
                                    o = t.leaf ? n(a) : a;
                                ng(e, o) &&
                                    (t.leaf
                                        ? i.push(a)
                                        : ig(e, o)
                                        ? this._all(a, i)
                                        : r.push(a));
                            }
                            t = r.pop();
                        }
                        return i;
                    }
                    collides(e) {
                        let t = this.data;
                        if (!ng(e, t)) return !1;
                        const i = [];
                        for (; t; ) {
                            for (let n = 0; n < t.children.length; n++) {
                                const r = t.children[n],
                                    s = t.leaf ? this.toBBox(r) : r;
                                if (ng(e, s)) {
                                    if (t.leaf || ig(e, s)) return !0;
                                    i.push(r);
                                }
                            }
                            t = i.pop();
                        }
                        return !1;
                    }
                    load(e) {
                        if (!e || !e.length) return this;
                        if (e.length < this._minEntries) {
                            for (let t = 0; t < e.length; t++)
                                this.insert(e[t]);
                            return this;
                        }
                        let t = this._build(e.slice(), 0, e.length - 1, 0);
                        if (this.data.children.length)
                            if (this.data.height === t.height)
                                this._splitRoot(this.data, t);
                            else {
                                if (this.data.height < t.height) {
                                    const e = this.data;
                                    (this.data = t), (t = e);
                                }
                                this._insert(
                                    t,
                                    this.data.height - t.height - 1,
                                    !0
                                );
                            }
                        else this.data = t;
                        return this;
                    }
                    insert(e) {
                        return e && this._insert(e, this.data.height - 1), this;
                    }
                    clear() {
                        return (this.data = rg([])), this;
                    }
                    remove(e, t) {
                        if (!e) return this;
                        let i = this.data;
                        const n = this.toBBox(e),
                            r = [],
                            s = [];
                        let a, o, c;
                        for (; i || r.length; ) {
                            if (
                                (i ||
                                    ((i = r.pop()),
                                    (o = r[r.length - 1]),
                                    (a = s.pop()),
                                    (c = !0)),
                                i.leaf)
                            ) {
                                const n = qp(e, i.children, t);
                                if (-1 !== n)
                                    return (
                                        i.children.splice(n, 1),
                                        r.push(i),
                                        this._condense(r),
                                        this
                                    );
                            }
                            c || i.leaf || !ig(i, n)
                                ? o
                                    ? (a++, (i = o.children[a]), (c = !1))
                                    : (i = null)
                                : (r.push(i),
                                  s.push(a),
                                  (a = 0),
                                  (o = i),
                                  (i = i.children[0]));
                        }
                        return this;
                    }
                    toBBox(e) {
                        return e;
                    }
                    compareMinX(e, t) {
                        return e.minX - t.minX;
                    }
                    compareMinY(e, t) {
                        return e.minY - t.minY;
                    }
                    toJSON() {
                        return this.data;
                    }
                    fromJSON(e) {
                        return (this.data = e), this;
                    }
                    _all(e, t) {
                        const i = [];
                        for (; e; )
                            e.leaf
                                ? t.push(...e.children)
                                : i.push(...e.children),
                                (e = i.pop());
                        return t;
                    }
                    _build(e, t, i, n) {
                        const r = i - t + 1;
                        let s,
                            a = this._maxEntries;
                        if (r <= a)
                            return (
                                (s = rg(e.slice(t, i + 1))),
                                Wp(s, this.toBBox),
                                s
                            );
                        n ||
                            ((n = Math.ceil(Math.log(r) / Math.log(a))),
                            (a = Math.ceil(r / Math.pow(a, n - 1)))),
                            (s = rg([])),
                            (s.leaf = !1),
                            (s.height = n);
                        const o = Math.ceil(r / a),
                            c = o * Math.ceil(Math.sqrt(a));
                        sg(e, t, i, c, this.compareMinX);
                        for (let r = t; r <= i; r += c) {
                            const t = Math.min(r + c - 1, i);
                            sg(e, r, t, o, this.compareMinY);
                            for (let i = r; i <= t; i += o) {
                                const r = Math.min(i + o - 1, t);
                                s.children.push(this._build(e, i, r, n - 1));
                            }
                        }
                        return Wp(s, this.toBBox), s;
                    }
                    _chooseSubtree(e, t, i, n) {
                        for (; n.push(t), !t.leaf && n.length - 1 !== i; ) {
                            let i,
                                n = 1 / 0,
                                a = 1 / 0;
                            for (let o = 0; o < t.children.length; o++) {
                                const c = t.children[o],
                                    l = Kp(c),
                                    h =
                                        ((r = e),
                                        (s = c),
                                        (Math.max(s.maxX, r.maxX) -
                                            Math.min(s.minX, r.minX)) *
                                            (Math.max(s.maxY, r.maxY) -
                                                Math.min(s.minY, r.minY)) -
                                            l);
                                h < a
                                    ? ((a = h), (n = l < n ? l : n), (i = c))
                                    : h === a && l < n && ((n = l), (i = c));
                            }
                            t = i || t.children[0];
                        }
                        var r, s;
                        return t;
                    }
                    _insert(e, t, i) {
                        const n = i ? e : this.toBBox(e),
                            r = [],
                            s = this._chooseSubtree(n, this.data, t, r);
                        for (
                            s.children.push(e), Zp(s, n);
                            t >= 0 && r[t].children.length > this._maxEntries;

                        )
                            this._split(r, t), t--;
                        this._adjustParentBBoxes(n, r, t);
                    }
                    _split(e, t) {
                        const i = e[t],
                            n = i.children.length,
                            r = this._minEntries;
                        this._chooseSplitAxis(i, r, n);
                        const s = this._chooseSplitIndex(i, r, n),
                            a = rg(i.children.splice(s, i.children.length - s));
                        (a.height = i.height),
                            (a.leaf = i.leaf),
                            Wp(i, this.toBBox),
                            Wp(a, this.toBBox),
                            t
                                ? e[t - 1].children.push(a)
                                : this._splitRoot(i, a);
                    }
                    _splitRoot(e, t) {
                        (this.data = rg([e, t])),
                            (this.data.height = e.height + 1),
                            (this.data.leaf = !1),
                            Wp(this.data, this.toBBox);
                    }
                    _chooseSplitIndex(e, t, i) {
                        let n,
                            r = 1 / 0,
                            s = 1 / 0;
                        for (let a = t; a <= i - t; a++) {
                            const t = Qp(e, 0, a, this.toBBox),
                                o = Qp(e, a, i, this.toBBox),
                                c = tg(t, o),
                                l = Kp(t) + Kp(o);
                            c < r
                                ? ((r = c), (n = a), (s = l < s ? l : s))
                                : c === r && l < s && ((s = l), (n = a));
                        }
                        return n || i - t;
                    }
                    _chooseSplitAxis(e, t, i) {
                        const n = e.leaf ? this.compareMinX : Xp,
                            r = e.leaf ? this.compareMinY : Jp;
                        this._allDistMargin(e, t, i, n) <
                            this._allDistMargin(e, t, i, r) &&
                            e.children.sort(n);
                    }
                    _allDistMargin(e, t, i, n) {
                        e.children.sort(n);
                        const r = this.toBBox,
                            s = Qp(e, 0, t, r),
                            a = Qp(e, i - t, i, r);
                        let o = eg(s) + eg(a);
                        for (let n = t; n < i - t; n++) {
                            const t = e.children[n];
                            Zp(s, e.leaf ? r(t) : t), (o += eg(s));
                        }
                        for (let n = i - t - 1; n >= t; n--) {
                            const t = e.children[n];
                            Zp(a, e.leaf ? r(t) : t), (o += eg(a));
                        }
                        return o;
                    }
                    _adjustParentBBoxes(e, t, i) {
                        for (let n = i; n >= 0; n--) Zp(t[n], e);
                    }
                    _condense(e) {
                        for (let t, i = e.length - 1; i >= 0; i--)
                            0 === e[i].children.length
                                ? i > 0
                                    ? ((t = e[i - 1].children),
                                      t.splice(t.indexOf(e[i]), 1))
                                    : this.clear()
                                : Wp(e[i], this.toBBox);
                    }
                }
                function qp(e, t, i) {
                    if (!i) return t.indexOf(e);
                    for (let n = 0; n < t.length; n++) if (i(e, t[n])) return n;
                    return -1;
                }
                function Wp(e, t) {
                    Qp(e, 0, e.children.length, t, e);
                }
                function Qp(e, t, i, n, r) {
                    r || (r = rg(null)),
                        (r.minX = 1 / 0),
                        (r.minY = 1 / 0),
                        (r.maxX = -1 / 0),
                        (r.maxY = -1 / 0);
                    for (let s = t; s < i; s++) {
                        const t = e.children[s];
                        Zp(r, e.leaf ? n(t) : t);
                    }
                    return r;
                }
                function Zp(e, t) {
                    return (
                        (e.minX = Math.min(e.minX, t.minX)),
                        (e.minY = Math.min(e.minY, t.minY)),
                        (e.maxX = Math.max(e.maxX, t.maxX)),
                        (e.maxY = Math.max(e.maxY, t.maxY)),
                        e
                    );
                }
                function Xp(e, t) {
                    return e.minX - t.minX;
                }
                function Jp(e, t) {
                    return e.minY - t.minY;
                }
                function Kp(e) {
                    return (e.maxX - e.minX) * (e.maxY - e.minY);
                }
                function eg(e) {
                    return e.maxX - e.minX + (e.maxY - e.minY);
                }
                function tg(e, t) {
                    const i = Math.max(e.minX, t.minX),
                        n = Math.max(e.minY, t.minY),
                        r = Math.min(e.maxX, t.maxX),
                        s = Math.min(e.maxY, t.maxY);
                    return Math.max(0, r - i) * Math.max(0, s - n);
                }
                function ig(e, t) {
                    return (
                        e.minX <= t.minX &&
                        e.minY <= t.minY &&
                        t.maxX <= e.maxX &&
                        t.maxY <= e.maxY
                    );
                }
                function ng(e, t) {
                    return (
                        t.minX <= e.maxX &&
                        t.minY <= e.maxY &&
                        t.maxX >= e.minX &&
                        t.maxY >= e.minY
                    );
                }
                function rg(e) {
                    return {
                        children: e,
                        height: 1,
                        leaf: !0,
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -1 / 0,
                        maxY: -1 / 0,
                    };
                }
                function sg(e, t, i, n, r) {
                    const s = [t, i];
                    for (; s.length; ) {
                        if ((i = s.pop()) - (t = s.pop()) <= n) continue;
                        const a = t + Math.ceil((i - t) / n / 2) * n;
                        Fp(e, a, t, i, r), s.push(t, a, a, i);
                    }
                }
                class ag extends Yp {
                    compareMinX(e, t) {
                        return e.lng - t.lng;
                    }
                    compareMinY(e, t) {
                        return e.lat - t.lat;
                    }
                    toBBox(e) {
                        return {
                            minX: e.lng,
                            minY: e.lat,
                            maxX: e.lng,
                            maxY: e.lat,
                        };
                    }
                }
                class og {
                    constructor(e, t) {
                        this._components = {};
                        for (const i in og.registeredComponents) {
                            if (!og.registeredComponents.hasOwnProperty(i))
                                continue;
                            const n = og.registeredComponents[i];
                            this._components[i] = {
                                active: !1,
                                component: new n(i, e, t),
                            };
                        }
                        (this._coverComponent = new og.registeredCoverComponent(
                            "cover",
                            e,
                            t
                        )),
                            this._coverComponent.activate(),
                            (this._coverActivated = !0);
                    }
                    static register(e) {
                        void 0 === og.registeredComponents[e.componentName] &&
                            (og.registeredComponents[e.componentName] = e);
                    }
                    static registerCover(e) {
                        og.registeredCoverComponent = e;
                    }
                    get coverActivated() {
                        return this._coverActivated;
                    }
                    activateCover() {
                        if (!this._coverActivated) {
                            this._coverActivated = !0;
                            for (const e in this._components) {
                                if (!this._components.hasOwnProperty(e))
                                    continue;
                                const t = this._components[e];
                                t.active && t.component.deactivate();
                            }
                        }
                    }
                    deactivateCover() {
                        if (this._coverActivated) {
                            this._coverActivated = !1;
                            for (const e in this._components) {
                                if (!this._components.hasOwnProperty(e))
                                    continue;
                                const t = this._components[e];
                                t.active && t.component.activate();
                            }
                        }
                    }
                    activate(e) {
                        this._checkName(e),
                            (this._components[e].active = !0),
                            this._coverActivated || this.get(e).activate();
                    }
                    configure(e, t) {
                        this._checkName(e), this.get(e).configure(t);
                    }
                    deactivate(e) {
                        this._checkName(e),
                            (this._components[e].active = !1),
                            this._coverActivated || this.get(e).deactivate();
                    }
                    get(e) {
                        return this._components[e].component;
                    }
                    getCover() {
                        return this._coverComponent;
                    }
                    remove() {
                        this._coverComponent.deactivate();
                        for (const e in this._components)
                            this._components.hasOwnProperty(e) &&
                                this._components[e].component.deactivate();
                    }
                    _checkName(e) {
                        if (!(e in this._components))
                            throw new Ep(`Component does not exist: ${e}`);
                    }
                }
                og.registeredComponents = {};
                var cg =
                    "undefined" != typeof globalThis
                        ? globalThis
                        : "undefined" != typeof window
                        ? window
                        : "undefined" != typeof global
                        ? global
                        : "undefined" != typeof self
                        ? self
                        : {};
                function lg(e) {
                    if (e.__esModule) return e;
                    var t = Object.defineProperty({}, "__esModule", {
                        value: !0,
                    });
                    return (
                        Object.keys(e).forEach(function (i) {
                            var n = Object.getOwnPropertyDescriptor(e, i);
                            Object.defineProperty(
                                t,
                                i,
                                n.get
                                    ? n
                                    : {
                                          enumerable: !0,
                                          get: function () {
                                              return e[i];
                                          },
                                      }
                            );
                        }),
                        t
                    );
                }
                var hg = Array.isArray,
                    ug = Object.prototype.toString,
                    dg =
                        hg ||
                        function (e) {
                            return "[object Array]" === ug.call(e);
                        },
                    pg = "2",
                    gg = pg;
                (fg.NONE = 0),
                    (fg.VTEXT = 1),
                    (fg.VNODE = 2),
                    (fg.WIDGET = 3),
                    (fg.PROPS = 4),
                    (fg.ORDER = 5),
                    (fg.INSERT = 6),
                    (fg.REMOVE = 7),
                    (fg.THUNK = 8);
                var mg = fg;
                function fg(e, t, i) {
                    (this.type = Number(e)), (this.vNode = t), (this.patch = i);
                }
                (fg.prototype.version = gg),
                    (fg.prototype.type = "VirtualPatch");
                var _g = pg,
                    Mg = function (e) {
                        return (
                            e && "VirtualNode" === e.type && e.version === _g
                        );
                    },
                    vg = pg,
                    yg = function (e) {
                        return (
                            e && "VirtualText" === e.type && e.version === vg
                        );
                    },
                    xg = function (e) {
                        return e && "Widget" === e.type;
                    },
                    bg = function (e) {
                        return e && "Thunk" === e.type;
                    },
                    wg = Mg,
                    Tg = yg,
                    Sg = xg,
                    Ng = bg,
                    Dg = function (e, t) {
                        var i = e,
                            n = t;
                        return (
                            Ng(t) && (n = Ig(t, e)),
                            Ng(e) && (i = Ig(e, null)),
                            { a: i, b: n }
                        );
                    };
                function Ig(e, t) {
                    var i = e.vnode;
                    if (
                        (i || (i = e.vnode = e.render(t)),
                        !(wg(i) || Tg(i) || Sg(i)))
                    )
                        throw new Error("thunk did not return a valid node");
                    return i;
                }
                var Cg = function (e) {
                        return "object" == typeof e && null !== e;
                    },
                    Ag = function (e) {
                        return (
                            e &&
                            (("function" == typeof e.hook &&
                                !e.hasOwnProperty("hook")) ||
                                ("function" == typeof e.unhook &&
                                    !e.hasOwnProperty("unhook")))
                        );
                    },
                    Eg = Cg,
                    Lg = Ag;
                function zg(e) {
                    return Object.getPrototypeOf
                        ? Object.getPrototypeOf(e)
                        : e.__proto__
                        ? e.__proto__
                        : e.constructor
                        ? e.constructor.prototype
                        : void 0;
                }
                var jg = dg,
                    Og = mg,
                    kg = Mg,
                    Rg = yg,
                    Pg = xg,
                    Ug = bg,
                    $g = Dg,
                    Bg = function e(t, i) {
                        var n;
                        for (var r in t) {
                            r in i || ((n = n || {})[r] = void 0);
                            var s = t[r],
                                a = i[r];
                            if (s !== a)
                                if (Eg(s) && Eg(a))
                                    if (zg(a) !== zg(s)) (n = n || {})[r] = a;
                                    else if (Lg(a)) (n = n || {})[r] = a;
                                    else {
                                        var o = e(s, a);
                                        o && ((n = n || {})[r] = o);
                                    }
                                else (n = n || {})[r] = a;
                        }
                        for (var c in i) c in t || ((n = n || {})[c] = i[c]);
                        return n;
                    };
                function Fg(e, t) {
                    var i = { a: e };
                    return Hg(e, t, i, 0), i;
                }
                function Hg(e, t, i, n) {
                    if (e !== t) {
                        var r = i[n],
                            s = !1;
                        if (Ug(e) || Ug(t)) Yg(e, t, i, n);
                        else if (null == t)
                            Pg(e) || (Gg(e, i, n), (r = i[n])),
                                (r = Zg(r, new Og(Og.REMOVE, e, t)));
                        else if (kg(t))
                            if (kg(e))
                                if (
                                    e.tagName === t.tagName &&
                                    e.namespace === t.namespace &&
                                    e.key === t.key
                                ) {
                                    var a = Bg(e.properties, t.properties);
                                    a && (r = Zg(r, new Og(Og.PROPS, e, a))),
                                        (r = (function (e, t, i, n, r) {
                                            for (
                                                var s = e.children,
                                                    a = (function (e, t) {
                                                        var i = Qg(t),
                                                            n = i.keys,
                                                            r = i.free;
                                                        if (
                                                            r.length ===
                                                            t.length
                                                        )
                                                            return {
                                                                children: t,
                                                                moves: null,
                                                            };
                                                        var s = Qg(e),
                                                            a = s.keys;
                                                        if (
                                                            s.free.length ===
                                                            e.length
                                                        )
                                                            return {
                                                                children: t,
                                                                moves: null,
                                                            };
                                                        for (
                                                            var o = [],
                                                                c = 0,
                                                                l = r.length,
                                                                h = 0,
                                                                u = 0;
                                                            u < e.length;
                                                            u++
                                                        ) {
                                                            var d,
                                                                p = e[u];
                                                            p.key
                                                                ? n.hasOwnProperty(
                                                                      p.key
                                                                  )
                                                                    ? ((d =
                                                                          n[
                                                                              p
                                                                                  .key
                                                                          ]),
                                                                      o.push(
                                                                          t[d]
                                                                      ))
                                                                    : ((d =
                                                                          u -
                                                                          h++),
                                                                      o.push(
                                                                          null
                                                                      ))
                                                                : c < l
                                                                ? ((d = r[c++]),
                                                                  o.push(t[d]))
                                                                : ((d =
                                                                      u - h++),
                                                                  o.push(null));
                                                        }
                                                        for (
                                                            var g =
                                                                    c >=
                                                                    r.length
                                                                        ? t.length
                                                                        : r[c],
                                                                m = 0;
                                                            m < t.length;
                                                            m++
                                                        ) {
                                                            var f = t[m];
                                                            f.key
                                                                ? a.hasOwnProperty(
                                                                      f.key
                                                                  ) || o.push(f)
                                                                : m >= g &&
                                                                  o.push(f);
                                                        }
                                                        for (
                                                            var _,
                                                                M = o.slice(),
                                                                v = 0,
                                                                y = [],
                                                                x = [],
                                                                b = 0;
                                                            b < t.length;

                                                        ) {
                                                            var w = t[b];
                                                            for (
                                                                _ = M[v];
                                                                null === _ &&
                                                                M.length;

                                                            )
                                                                y.push(
                                                                    Wg(
                                                                        M,
                                                                        v,
                                                                        null
                                                                    )
                                                                ),
                                                                    (_ = M[v]);
                                                            _ && _.key === w.key
                                                                ? (v++, b++)
                                                                : w.key
                                                                ? (_ &&
                                                                  _.key &&
                                                                  n[_.key] !==
                                                                      b + 1
                                                                      ? (y.push(
                                                                            Wg(
                                                                                M,
                                                                                v,
                                                                                _.key
                                                                            )
                                                                        ),
                                                                        (_ =
                                                                            M[
                                                                                v
                                                                            ]) &&
                                                                        _.key ===
                                                                            w.key
                                                                            ? v++
                                                                            : x.push(
                                                                                  {
                                                                                      key: w.key,
                                                                                      to: b,
                                                                                  }
                                                                              ))
                                                                      : x.push({
                                                                            key: w.key,
                                                                            to: b,
                                                                        }),
                                                                  b++)
                                                                : _ &&
                                                                  _.key &&
                                                                  y.push(
                                                                      Wg(
                                                                          M,
                                                                          v,
                                                                          _.key
                                                                      )
                                                                  );
                                                        }
                                                        for (; v < M.length; )
                                                            (_ = M[v]),
                                                                y.push(
                                                                    Wg(
                                                                        M,
                                                                        v,
                                                                        _ &&
                                                                            _.key
                                                                    )
                                                                );
                                                        return y.length !== h ||
                                                            x.length
                                                            ? {
                                                                  children: o,
                                                                  moves: {
                                                                      removes:
                                                                          y,
                                                                      inserts:
                                                                          x,
                                                                  },
                                                              }
                                                            : {
                                                                  children: o,
                                                                  moves: null,
                                                              };
                                                    })(s, t.children),
                                                    o = a.children,
                                                    c = s.length,
                                                    l = o.length,
                                                    h = c > l ? c : l,
                                                    u = 0;
                                                u < h;
                                                u++
                                            ) {
                                                var d = s[u],
                                                    p = o[u];
                                                (r += 1),
                                                    d
                                                        ? Hg(d, p, i, r)
                                                        : p &&
                                                          (n = Zg(
                                                              n,
                                                              new Og(
                                                                  Og.INSERT,
                                                                  null,
                                                                  p
                                                              )
                                                          )),
                                                    kg(d) &&
                                                        d.count &&
                                                        (r += d.count);
                                            }
                                            return (
                                                a.moves &&
                                                    (n = Zg(
                                                        n,
                                                        new Og(
                                                            Og.ORDER,
                                                            e,
                                                            a.moves
                                                        )
                                                    )),
                                                n
                                            );
                                        })(e, t, i, r, n));
                                } else
                                    (r = Zg(r, new Og(Og.VNODE, e, t))),
                                        (s = !0);
                            else (r = Zg(r, new Og(Og.VNODE, e, t))), (s = !0);
                        else
                            Rg(t)
                                ? Rg(e)
                                    ? e.text !== t.text &&
                                      (r = Zg(r, new Og(Og.VTEXT, e, t)))
                                    : ((r = Zg(r, new Og(Og.VTEXT, e, t))),
                                      (s = !0))
                                : Pg(t) &&
                                  (Pg(e) || (s = !0),
                                  (r = Zg(r, new Og(Og.WIDGET, e, t))));
                        r && (i[n] = r), s && Gg(e, i, n);
                    }
                }
                function Gg(e, t, i) {
                    qg(e, t, i), Vg(e, t, i);
                }
                function Vg(e, t, i) {
                    if (Pg(e))
                        "function" == typeof e.destroy &&
                            (t[i] = Zg(t[i], new Og(Og.REMOVE, e, null)));
                    else if (kg(e) && (e.hasWidgets || e.hasThunks))
                        for (
                            var n = e.children, r = n.length, s = 0;
                            s < r;
                            s++
                        ) {
                            var a = n[s];
                            Vg(a, t, (i += 1)),
                                kg(a) && a.count && (i += a.count);
                        }
                    else Ug(e) && Yg(e, null, t, i);
                }
                function Yg(e, t, i, n) {
                    var r = $g(e, t),
                        s = Fg(r.a, r.b);
                    (function (e) {
                        for (var t in e) if ("a" !== t) return !0;
                        return !1;
                    })(s) && (i[n] = new Og(Og.THUNK, null, s));
                }
                function qg(e, t, i) {
                    if (kg(e)) {
                        if (
                            (e.hooks &&
                                (t[i] = Zg(
                                    t[i],
                                    new Og(
                                        Og.PROPS,
                                        e,
                                        (function (e) {
                                            var t = {};
                                            for (var i in e) t[i] = void 0;
                                            return t;
                                        })(e.hooks)
                                    )
                                )),
                            e.descendantHooks || e.hasThunks)
                        )
                            for (
                                var n = e.children, r = n.length, s = 0;
                                s < r;
                                s++
                            ) {
                                var a = n[s];
                                qg(a, t, (i += 1)),
                                    kg(a) && a.count && (i += a.count);
                            }
                    } else Ug(e) && Yg(e, null, t, i);
                }
                function Wg(e, t, i) {
                    return e.splice(t, 1), { from: t, key: i };
                }
                function Qg(e) {
                    for (var t = {}, i = [], n = e.length, r = 0; r < n; r++) {
                        var s = e[r];
                        s.key ? (t[s.key] = r) : i.push(r);
                    }
                    return { keys: t, free: i };
                }
                function Zg(e, t) {
                    return e ? (jg(e) ? e.push(t) : (e = [e, t]), e) : t;
                }
                var Xg = Fg,
                    Jg = Array.prototype.slice,
                    Kg = function (e, t) {
                        "length" in e || (e = [e]), (e = Jg.call(e));
                        for (; e.length; ) {
                            var i = e.shift(),
                                n = t(i);
                            if (n) return n;
                            i.childNodes &&
                                i.childNodes.length &&
                                (e = Jg.call(i.childNodes).concat(e));
                        }
                    },
                    em = tm;
                function tm(e, t) {
                    if (!(this instanceof tm)) return new tm(e, t);
                    (this.data = e),
                        (this.nodeValue = e),
                        (this.length = e.length),
                        (this.ownerDocument = t || null);
                }
                (tm.prototype.nodeType = 8),
                    (tm.prototype.nodeName = "#comment"),
                    (tm.prototype.toString = function () {
                        return "[object Comment]";
                    });
                var im = nm;
                function nm(e, t) {
                    if (!(this instanceof nm)) return new nm(e);
                    (this.data = e || ""),
                        (this.length = this.data.length),
                        (this.ownerDocument = t || null);
                }
                (nm.prototype.type = "DOMTextNode"),
                    (nm.prototype.nodeType = 3),
                    (nm.prototype.nodeName = "#text"),
                    (nm.prototype.toString = function () {
                        return this.data;
                    }),
                    (nm.prototype.replaceData = function (e, t, i) {
                        var n = this.data,
                            r = n.substring(0, e),
                            s = n.substring(e + t, n.length);
                        (this.data = r + i + s),
                            (this.length = this.data.length);
                    });
                var rm = function (e) {
                        var t = this,
                            i = e.type;
                        e.target || (e.target = t),
                            t.listeners || (t.listeners = {});
                        var n = t.listeners[i];
                        if (n)
                            return n.forEach(function (i) {
                                (e.currentTarget = t),
                                    "function" == typeof i
                                        ? i(e)
                                        : i.handleEvent(e);
                            });
                        t.parentNode && t.parentNode.dispatchEvent(e);
                    },
                    sm = function (e, t) {
                        var i = this;
                        i.listeners || (i.listeners = {}),
                            i.listeners[e] || (i.listeners[e] = []),
                            -1 === i.listeners[e].indexOf(t) &&
                                i.listeners[e].push(t);
                    },
                    am = function (e, t) {
                        var i = this;
                        if (i.listeners && i.listeners[e]) {
                            var n = i.listeners[e],
                                r = n.indexOf(t);
                            -1 !== r && n.splice(r, 1);
                        }
                    },
                    om = [
                        "area",
                        "base",
                        "br",
                        "col",
                        "embed",
                        "hr",
                        "img",
                        "input",
                        "keygen",
                        "link",
                        "menuitem",
                        "meta",
                        "param",
                        "source",
                        "track",
                        "wbr",
                    ];
                function cm(e, t) {
                    var i = typeof e[t];
                    return (
                        ("style" === t && Object.keys(e.style).length > 0) ||
                        (e.hasOwnProperty(t) &&
                            ("string" === i ||
                                "boolean" === i ||
                                "number" === i) &&
                            "nodeName" !== t &&
                            "className" !== t &&
                            "tagName" !== t &&
                            "textContent" !== t &&
                            "innerText" !== t &&
                            "namespaceURI" !== t &&
                            "innerHTML" !== t)
                    );
                }
                function lm(e) {
                    var t = [];
                    return (
                        e.forEach(function (e) {
                            var i = e.name,
                                n = e.value;
                            "style" === i &&
                                (n = (function (e) {
                                    if ("string" == typeof e) return e;
                                    var t = "";
                                    return (
                                        Object.keys(e).forEach(function (i) {
                                            var n = e[i];
                                            (i = i.replace(
                                                /[A-Z]/g,
                                                function (e) {
                                                    return (
                                                        "-" + e.toLowerCase()
                                                    );
                                                }
                                            )),
                                                (t += i + ":" + n + ";");
                                        }),
                                        t
                                    );
                                })(n)),
                                t.push(
                                    i +
                                        '="' +
                                        hm(n).replace(/"/g, "&quot;") +
                                        '"'
                                );
                        }),
                        t.length ? " " + t.join(" ") : ""
                    );
                }
                function hm(e) {
                    var t = "";
                    return (
                        "string" == typeof e
                            ? (t = e)
                            : e && (t = e.toString()),
                        t
                            .replace(/&/g, "&amp;")
                            .replace(/</g, "&lt;")
                            .replace(/>/g, "&gt;")
                    );
                }
                var um = Kg,
                    dm = rm,
                    pm = sm,
                    gm = am,
                    mm = function e(t) {
                        switch (t.nodeType) {
                            case 3:
                                return hm(t.data);
                            case 8:
                                return "\x3c!--" + t.data + "--\x3e";
                            default:
                                return (function (t) {
                                    var i = [],
                                        n = t.tagName;
                                    return (
                                        "http://www.w3.org/1999/xhtml" ===
                                            t.namespaceURI &&
                                            (n = n.toLowerCase()),
                                        i.push(
                                            "<" +
                                                n +
                                                (function (e) {
                                                    var t = [];
                                                    for (var i in e)
                                                        cm(e, i) &&
                                                            t.push({
                                                                name: i,
                                                                value: e[i],
                                                            });
                                                    for (var n in e._attributes)
                                                        for (var r in e
                                                            ._attributes[n]) {
                                                            var s =
                                                                    e
                                                                        ._attributes[
                                                                        n
                                                                    ][r],
                                                                a =
                                                                    (s.prefix
                                                                        ? s.prefix +
                                                                          ":"
                                                                        : "") +
                                                                    r;
                                                            t.push({
                                                                name: a,
                                                                value: s.value,
                                                            });
                                                        }
                                                    return (
                                                        e.className &&
                                                            t.push({
                                                                name: "class",
                                                                value: e.className,
                                                            }),
                                                        t.length ? lm(t) : ""
                                                    );
                                                })(t) +
                                                (function (e) {
                                                    var t = e.dataset,
                                                        i = [];
                                                    for (var n in t)
                                                        i.push({
                                                            name: "data-" + n,
                                                            value: t[n],
                                                        });
                                                    return i.length
                                                        ? lm(i)
                                                        : "";
                                                })(t)
                                        ),
                                        om.indexOf(n) > -1
                                            ? i.push(" />")
                                            : (i.push(">"),
                                              t.childNodes.length
                                                  ? i.push.apply(
                                                        i,
                                                        t.childNodes.map(e)
                                                    )
                                                  : t.textContent || t.innerText
                                                  ? i.push(
                                                        hm(
                                                            t.textContent ||
                                                                t.innerText
                                                        )
                                                    )
                                                  : t.innerHTML &&
                                                    i.push(t.innerHTML),
                                              i.push("</" + n + ">")),
                                        i.join("")
                                    );
                                })(t);
                        }
                    },
                    fm = "http://www.w3.org/1999/xhtml",
                    _m = Mm;
                function Mm(e, t, i) {
                    if (!(this instanceof Mm)) return new Mm(e);
                    var n = void 0 === i ? fm : i || null;
                    (this.tagName = n === fm ? String(e).toUpperCase() : e),
                        (this.nodeName = this.tagName),
                        (this.className = ""),
                        (this.dataset = {}),
                        (this.childNodes = []),
                        (this.parentNode = null),
                        (this.style = {}),
                        (this.ownerDocument = t || null),
                        (this.namespaceURI = n),
                        (this._attributes = {}),
                        "INPUT" === this.tagName && (this.type = "text");
                }
                (Mm.prototype.type = "DOMElement"),
                    (Mm.prototype.nodeType = 1),
                    (Mm.prototype.appendChild = function (e) {
                        return (
                            e.parentNode && e.parentNode.removeChild(e),
                            this.childNodes.push(e),
                            (e.parentNode = this),
                            e
                        );
                    }),
                    (Mm.prototype.replaceChild = function (e, t) {
                        e.parentNode && e.parentNode.removeChild(e);
                        var i = this.childNodes.indexOf(t);
                        return (
                            (t.parentNode = null),
                            (this.childNodes[i] = e),
                            (e.parentNode = this),
                            t
                        );
                    }),
                    (Mm.prototype.removeChild = function (e) {
                        var t = this.childNodes.indexOf(e);
                        return (
                            this.childNodes.splice(t, 1),
                            (e.parentNode = null),
                            e
                        );
                    }),
                    (Mm.prototype.insertBefore = function (e, t) {
                        e.parentNode && e.parentNode.removeChild(e);
                        var i = null == t ? -1 : this.childNodes.indexOf(t);
                        return (
                            i > -1
                                ? this.childNodes.splice(i, 0, e)
                                : this.childNodes.push(e),
                            (e.parentNode = this),
                            e
                        );
                    }),
                    (Mm.prototype.setAttributeNS = function (e, t, i) {
                        var n = null,
                            r = t,
                            s = t.indexOf(":");
                        s > -1 && ((n = t.substr(0, s)), (r = t.substr(s + 1))),
                            "INPUT" === this.tagName && "type" === t
                                ? (this.type = i)
                                : ((this._attributes[e] ||
                                      (this._attributes[e] = {}))[r] = {
                                      value: i,
                                      prefix: n,
                                  });
                    }),
                    (Mm.prototype.getAttributeNS = function (e, t) {
                        var i = this._attributes[e],
                            n = i && i[t] && i[t].value;
                        return "INPUT" === this.tagName && "type" === t
                            ? this.type
                            : "string" != typeof n
                            ? null
                            : n;
                    }),
                    (Mm.prototype.removeAttributeNS = function (e, t) {
                        var i = this._attributes[e];
                        i && delete i[t];
                    }),
                    (Mm.prototype.hasAttributeNS = function (e, t) {
                        var i = this._attributes[e];
                        return !!i && t in i;
                    }),
                    (Mm.prototype.setAttribute = function (e, t) {
                        return this.setAttributeNS(null, e, t);
                    }),
                    (Mm.prototype.getAttribute = function (e) {
                        return this.getAttributeNS(null, e);
                    }),
                    (Mm.prototype.removeAttribute = function (e) {
                        return this.removeAttributeNS(null, e);
                    }),
                    (Mm.prototype.hasAttribute = function (e) {
                        return this.hasAttributeNS(null, e);
                    }),
                    (Mm.prototype.removeEventListener = gm),
                    (Mm.prototype.addEventListener = pm),
                    (Mm.prototype.dispatchEvent = dm),
                    (Mm.prototype.focus = function () {}),
                    (Mm.prototype.toString = function () {
                        return mm(this);
                    }),
                    (Mm.prototype.getElementsByClassName = function (e) {
                        var t = e.split(" "),
                            i = [];
                        return (
                            um(this, function (e) {
                                if (1 === e.nodeType) {
                                    var n = (e.className || "").split(" ");
                                    t.every(function (e) {
                                        return -1 !== n.indexOf(e);
                                    }) && i.push(e);
                                }
                            }),
                            i
                        );
                    }),
                    (Mm.prototype.getElementsByTagName = function (e) {
                        e = e.toLowerCase();
                        var t = [];
                        return (
                            um(this.childNodes, function (i) {
                                1 !== i.nodeType ||
                                    ("*" !== e &&
                                        i.tagName.toLowerCase() !== e) ||
                                    t.push(i);
                            }),
                            t
                        );
                    }),
                    (Mm.prototype.contains = function (e) {
                        return (
                            um(this, function (t) {
                                return e === t;
                            }) || !1
                        );
                    });
                var vm = _m,
                    ym = xm;
                function xm(e) {
                    if (!(this instanceof xm)) return new xm();
                    (this.childNodes = []),
                        (this.parentNode = null),
                        (this.ownerDocument = e || null);
                }
                (xm.prototype.type = "DocumentFragment"),
                    (xm.prototype.nodeType = 11),
                    (xm.prototype.nodeName = "#document-fragment"),
                    (xm.prototype.appendChild = vm.prototype.appendChild),
                    (xm.prototype.replaceChild = vm.prototype.replaceChild),
                    (xm.prototype.removeChild = vm.prototype.removeChild),
                    (xm.prototype.toString = function () {
                        return this.childNodes
                            .map(function (e) {
                                return String(e);
                            })
                            .join("");
                    });
                var bm = wm;
                function wm(e) {}
                (wm.prototype.initEvent = function (e, t, i) {
                    (this.type = e), (this.bubbles = t), (this.cancelable = i);
                }),
                    (wm.prototype.preventDefault = function () {});
                var Tm = Kg,
                    Sm = em,
                    Nm = im,
                    Dm = _m,
                    Im = ym,
                    Cm = bm,
                    Am = rm,
                    Em = sm,
                    Lm = am,
                    zm = jm;
                function jm() {
                    if (!(this instanceof jm)) return new jm();
                    (this.head = this.createElement("head")),
                        (this.body = this.createElement("body")),
                        (this.documentElement = this.createElement("html")),
                        this.documentElement.appendChild(this.head),
                        this.documentElement.appendChild(this.body),
                        (this.childNodes = [this.documentElement]),
                        (this.nodeType = 9);
                }
                var Om = jm.prototype;
                (Om.createTextNode = function (e) {
                    return new Nm(e, this);
                }),
                    (Om.createElementNS = function (e, t) {
                        var i = null === e ? null : String(e);
                        return new Dm(t, this, i);
                    }),
                    (Om.createElement = function (e) {
                        return new Dm(e, this);
                    }),
                    (Om.createDocumentFragment = function () {
                        return new Im(this);
                    }),
                    (Om.createEvent = function (e) {
                        return new Cm(e);
                    }),
                    (Om.createComment = function (e) {
                        return new Sm(e, this);
                    }),
                    (Om.getElementById = function (e) {
                        return (
                            (e = String(e)),
                            Tm(this.childNodes, function (t) {
                                if (String(t.id) === e) return t;
                            }) || null
                        );
                    }),
                    (Om.getElementsByClassName =
                        Dm.prototype.getElementsByClassName),
                    (Om.getElementsByTagName =
                        Dm.prototype.getElementsByTagName),
                    (Om.contains = Dm.prototype.contains),
                    (Om.removeEventListener = Lm),
                    (Om.addEventListener = Em),
                    (Om.dispatchEvent = Am);
                var km,
                    Rm = new zm(),
                    Pm =
                        void 0 !== cg
                            ? cg
                            : "undefined" != typeof window
                            ? window
                            : {},
                    Um = Rm;
                "undefined" != typeof document
                    ? (km = document)
                    : (km = Pm["__GLOBAL_DOCUMENT_CACHE@4"]) ||
                      (km = Pm["__GLOBAL_DOCUMENT_CACHE@4"] = Um);
                var $m = Cg,
                    Bm = Ag,
                    Fm = function (e, t, i) {
                        for (var n in t) {
                            var r = t[n];
                            void 0 === r
                                ? Hm(e, n, r, i)
                                : Bm(r)
                                ? (Hm(e, n, r, i),
                                  r.hook && r.hook(e, n, i ? i[n] : void 0))
                                : $m(r)
                                ? Gm(e, 0, i, n, r)
                                : (e[n] = r);
                        }
                    };
                function Hm(e, t, i, n) {
                    if (n) {
                        var r = n[t];
                        if (Bm(r)) r.unhook && r.unhook(e, t, i);
                        else if ("attributes" === t)
                            for (var s in r) e.removeAttribute(s);
                        else if ("style" === t)
                            for (var a in r) e.style[a] = "";
                        else e[t] = "string" == typeof r ? "" : null;
                    }
                }
                function Gm(e, t, i, n, r) {
                    var s = i ? i[n] : void 0;
                    if ("attributes" !== n)
                        if (s && $m(s) && Vm(s) !== Vm(r)) e[n] = r;
                        else {
                            $m(e[n]) || (e[n] = {});
                            var a = "style" === n ? "" : void 0;
                            for (var o in r) {
                                var c = r[o];
                                e[n][o] = void 0 === c ? a : c;
                            }
                        }
                    else
                        for (var l in r) {
                            var h = r[l];
                            void 0 === h
                                ? e.removeAttribute(l)
                                : e.setAttribute(l, h);
                        }
                }
                function Vm(e) {
                    return Object.getPrototypeOf
                        ? Object.getPrototypeOf(e)
                        : e.__proto__
                        ? e.__proto__
                        : e.constructor
                        ? e.constructor.prototype
                        : void 0;
                }
                var Ym = km,
                    qm = Fm,
                    Wm = Mg,
                    Qm = yg,
                    Zm = xg,
                    Xm = Dg,
                    Jm = function e(t, i) {
                        var n = (i && i.document) || Ym,
                            r = i ? i.warn : null;
                        if (((t = Xm(t).a), Zm(t))) return t.init();
                        if (Qm(t)) return n.createTextNode(t.text);
                        if (!Wm(t))
                            return (
                                r &&
                                    r(
                                        "Item is not a valid virtual dom node",
                                        t
                                    ),
                                null
                            );
                        var s =
                                null === t.namespace
                                    ? n.createElement(t.tagName)
                                    : n.createElementNS(t.namespace, t.tagName),
                            a = t.properties;
                        qm(s, a);
                        for (var o = t.children, c = 0; c < o.length; c++) {
                            var l = e(o[c], i);
                            l && s.appendChild(l);
                        }
                        return s;
                    },
                    Km = {};
                function ef(e, t, i, n, r) {
                    if (((n = n || {}), e)) {
                        tf(i, r, r) && (n[r] = e);
                        var s = t.children;
                        if (s)
                            for (
                                var a = e.childNodes, o = 0;
                                o < t.children.length;
                                o++
                            ) {
                                r += 1;
                                var c = s[o] || Km,
                                    l = r + (c.count || 0);
                                tf(i, r, l) && ef(a[o], c, i, n, r), (r = l);
                            }
                    }
                    return n;
                }
                function tf(e, t, i) {
                    if (0 === e.length) return !1;
                    for (var n, r, s = 0, a = e.length - 1; s <= a; ) {
                        if (((r = e[(n = ((a + s) / 2) | 0)]), s === a))
                            return r >= t && r <= i;
                        if (r < t) s = n + 1;
                        else {
                            if (!(r > i)) return !0;
                            a = n - 1;
                        }
                    }
                    return !1;
                }
                function nf(e, t) {
                    return e > t ? 1 : -1;
                }
                var rf = xg,
                    sf = Fm,
                    af = xg,
                    of = mg;
                function cf(e, t) {
                    "function" == typeof t.destroy && af(t) && t.destroy(e);
                }
                var lf = km,
                    hf = dg,
                    uf = Jm,
                    df = function (e, t, i, n) {
                        return i && 0 !== i.length
                            ? (i.sort(nf), ef(e, t, i, n, 0))
                            : {};
                    },
                    pf = function (e, t, i) {
                        var n,
                            r,
                            s = e.type,
                            a = e.vNode,
                            o = e.patch;
                        switch (s) {
                            case of.REMOVE:
                                return (function (e, t) {
                                    var i = e.parentNode;
                                    return (
                                        i && i.removeChild(e), cf(e, t), null
                                    );
                                })(t, a);
                            case of.INSERT:
                                return (function (e, t, i) {
                                    var n = i.render(t, i);
                                    return e && e.appendChild(n), e;
                                })(t, o, i);
                            case of.VTEXT:
                                return (function (e, t, i, n) {
                                    var r;
                                    if (3 === e.nodeType)
                                        e.replaceData(0, e.length, i.text),
                                            (r = e);
                                    else {
                                        var s = e.parentNode;
                                        (r = n.render(i, n)),
                                            s &&
                                                r !== e &&
                                                s.replaceChild(r, e);
                                    }
                                    return r;
                                })(t, 0, o, i);
                            case of.WIDGET:
                                return (function (e, t, i, n) {
                                    var r,
                                        s,
                                        a,
                                        o =
                                            ((a = i),
                                            !(!rf((s = t)) || !rf(a)) &&
                                                ("name" in s && "name" in a
                                                    ? s.id === a.id
                                                    : s.init === a.init));
                                    r = o
                                        ? i.update(t, e) || e
                                        : n.render(i, n);
                                    var c = e.parentNode;
                                    return (
                                        c && r !== e && c.replaceChild(r, e),
                                        o || cf(e, t),
                                        r
                                    );
                                })(t, a, o, i);
                            case of.VNODE:
                                return (function (e, t, i, n) {
                                    var r = e.parentNode,
                                        s = n.render(i, n);
                                    return (
                                        r && s !== e && r.replaceChild(s, e), s
                                    );
                                })(t, 0, o, i);
                            case of.ORDER:
                                return (
                                    (function (e, t) {
                                        for (
                                            var i,
                                                n,
                                                r,
                                                s = e.childNodes,
                                                a = {},
                                                o = 0;
                                            o < t.removes.length;
                                            o++
                                        )
                                            (i = s[(n = t.removes[o]).from]),
                                                n.key && (a[n.key] = i),
                                                e.removeChild(i);
                                        for (
                                            var c = s.length, l = 0;
                                            l < t.inserts.length;
                                            l++
                                        )
                                            (i = a[(r = t.inserts[l]).key]),
                                                e.insertBefore(
                                                    i,
                                                    r.to >= c++ ? null : s[r.to]
                                                );
                                    })(t, o),
                                    t
                                );
                            case of.PROPS:
                                return sf(t, o, a.properties), t;
                            case of.THUNK:
                                return (
                                    (n = t),
                                    (r = i.patch(t, o, i)),
                                    n &&
                                        r &&
                                        n !== r &&
                                        n.parentNode &&
                                        n.parentNode.replaceChild(r, n),
                                    r
                                );
                            default:
                                return t;
                        }
                    };
                function gf(e, t, i) {
                    var n = (function (e) {
                        var t = [];
                        for (var i in e) "a" !== i && t.push(Number(i));
                        return t;
                    })(t);
                    if (0 === n.length) return e;
                    var r = df(e, t.a, n),
                        s = e.ownerDocument;
                    i.document || s === lf || (i.document = s);
                    for (var a = 0; a < n.length; a++) {
                        var o = n[a];
                        e = mf(e, r[o], t[o], i);
                    }
                    return e;
                }
                function mf(e, t, i, n) {
                    if (!t) return e;
                    var r;
                    if (hf(i))
                        for (var s = 0; s < i.length; s++)
                            (r = pf(i[s], t, n)), t === e && (e = r);
                    else (r = pf(i, t, n)), t === e && (e = r);
                    return e;
                }
                var ff = function e(t, i, n) {
                        return (
                            ((n = n || {}).patch =
                                n.patch && n.patch !== e ? n.patch : gf),
                            (n.render = n.render || uf),
                            n.patch(t, i, n)
                        );
                    },
                    _f = pg,
                    Mf = Mg,
                    vf = xg,
                    yf = bg,
                    xf = Ag,
                    bf = Sf,
                    wf = {},
                    Tf = [];
                function Sf(e, t, i, n, r) {
                    (this.tagName = e),
                        (this.properties = t || wf),
                        (this.children = i || Tf),
                        (this.key = null != n ? String(n) : void 0),
                        (this.namespace = "string" == typeof r ? r : null);
                    var s,
                        a = (i && i.length) || 0,
                        o = 0,
                        c = !1,
                        l = !1,
                        h = !1;
                    for (var u in t)
                        if (t.hasOwnProperty(u)) {
                            var d = t[u];
                            xf(d) && d.unhook && (s || (s = {}), (s[u] = d));
                        }
                    for (var p = 0; p < a; p++) {
                        var g = i[p];
                        Mf(g)
                            ? ((o += g.count || 0),
                              !c && g.hasWidgets && (c = !0),
                              !l && g.hasThunks && (l = !0),
                              h || (!g.hooks && !g.descendantHooks) || (h = !0))
                            : !c && vf(g)
                            ? "function" == typeof g.destroy && (c = !0)
                            : !l && yf(g) && (l = !0);
                    }
                    (this.count = a + o),
                        (this.hasWidgets = c),
                        (this.hasThunks = l),
                        (this.hooks = s),
                        (this.descendantHooks = h);
                }
                (Sf.prototype.version = _f),
                    (Sf.prototype.type = "VirtualNode");
                var Nf = pg,
                    Df = If;
                function If(e) {
                    this.text = String(e);
                }
                (If.prototype.version = Nf),
                    (If.prototype.type = "VirtualText");
                var Cf = (function (e) {
                        var t,
                            i = String.prototype.split,
                            n = /()??/.exec("")[1] === e;
                        return (
                            (t = function (t, r, s) {
                                if (
                                    "[object RegExp]" !==
                                    Object.prototype.toString.call(r)
                                )
                                    return i.call(t, r, s);
                                var a,
                                    o,
                                    c,
                                    l,
                                    h = [],
                                    u =
                                        (r.ignoreCase ? "i" : "") +
                                        (r.multiline ? "m" : "") +
                                        (r.extended ? "x" : "") +
                                        (r.sticky ? "y" : ""),
                                    d = 0;
                                for (
                                    r = new RegExp(r.source, u + "g"),
                                        t += "",
                                        n ||
                                            (a = new RegExp(
                                                "^" + r.source + "$(?!\\s)",
                                                u
                                            )),
                                        s = s === e ? -1 >>> 0 : s >>> 0;
                                    (o = r.exec(t)) &&
                                    !(
                                        (c = o.index + o[0].length) > d &&
                                        (h.push(t.slice(d, o.index)),
                                        !n &&
                                            o.length > 1 &&
                                            o[0].replace(a, function () {
                                                for (
                                                    var t = 1;
                                                    t < arguments.length - 2;
                                                    t++
                                                )
                                                    arguments[t] === e &&
                                                        (o[t] = e);
                                            }),
                                        o.length > 1 &&
                                            o.index < t.length &&
                                            Array.prototype.push.apply(
                                                h,
                                                o.slice(1)
                                            ),
                                        (l = o[0].length),
                                        (d = c),
                                        h.length >= s)
                                    );

                                )
                                    r.lastIndex === o.index && r.lastIndex++;
                                return (
                                    d === t.length
                                        ? (!l && r.test("")) || h.push("")
                                        : h.push(t.slice(d)),
                                    h.length > s ? h.slice(0, s) : h
                                );
                            }),
                            t
                        );
                    })(),
                    Af = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/,
                    Ef = /^\.|#/,
                    Lf = zf;
                function zf(e) {
                    if (!(this instanceof zf)) return new zf(e);
                    this.value = e;
                }
                zf.prototype.hook = function (e, t) {
                    e[t] !== this.value && (e[t] = this.value);
                };
                var jf =
                        "undefined" != typeof window
                            ? window
                            : void 0 !== cg
                            ? cg
                            : {},
                    Of = function (e, t) {
                        return e in jf ? jf[e] : ((jf[e] = t), t);
                    };
                !(function (e, t, i) {
                    var n = "__INDIVIDUAL_ONE_VERSION_" + e,
                        r = Of(n + "_ENFORCE_SINGLETON", t);
                    if (r !== t)
                        throw new Error(
                            "Can only have one copy of " +
                                e +
                                ".\nYou already have version " +
                                r +
                                " installed.\nThis means you cannot install version " +
                                t
                        );
                    Of(n, i);
                })("ev-store", "7");
                var kf = "__EV_STORE_KEY@7",
                    Rf = function (e) {
                        var t = e[kf];
                        return t || (t = e[kf] = {}), t;
                    },
                    Pf = Uf;
                function Uf(e) {
                    if (!(this instanceof Uf)) return new Uf(e);
                    this.value = e;
                }
                (Uf.prototype.hook = function (e, t) {
                    Rf(e)[t.substr(3)] = this.value;
                }),
                    (Uf.prototype.unhook = function (e, t) {
                        Rf(e)[t.substr(3)] = void 0;
                    });
                var $f = dg,
                    Bf = bf,
                    Ff = Df,
                    Hf = Mg,
                    Gf = yg,
                    Vf = xg,
                    Yf = Ag,
                    qf = bg,
                    Wf = function (e, t) {
                        if (!e) return "DIV";
                        var i,
                            n,
                            r,
                            s,
                            a = !t.hasOwnProperty("id"),
                            o = Cf(e, Af),
                            c = null;
                        for (
                            Ef.test(o[1]) && (c = "DIV"), s = 0;
                            s < o.length;
                            s++
                        )
                            (n = o[s]) &&
                                ((r = n.charAt(0)),
                                c
                                    ? "." === r
                                        ? (i = i || []).push(
                                              n.substring(1, n.length)
                                          )
                                        : "#" === r &&
                                          a &&
                                          (t.id = n.substring(1, n.length))
                                    : (c = n));
                        return (
                            i &&
                                (t.className && i.push(t.className),
                                (t.className = i.join(" "))),
                            t.namespace ? c : c.toUpperCase()
                        );
                    },
                    Qf = Lf,
                    Zf = Pf;
                function Xf(e, t, i, n) {
                    if ("string" == typeof e) t.push(new Ff(e));
                    else if ("number" == typeof e) t.push(new Ff(String(e)));
                    else if (Jf(e)) t.push(e);
                    else {
                        if (!$f(e)) {
                            if (null == e) return;
                            throw (function (e) {
                                var t = new Error();
                                return (
                                    (t.type =
                                        "virtual-hyperscript.unexpected.virtual-element"),
                                    (t.message =
                                        "Unexpected virtual child passed to h().\nExpected a VNode / Vthunk / VWidget / string but:\ngot:\n" +
                                        Kf(e.foreignObject) +
                                        ".\nThe parent vnode is:\n" +
                                        Kf(e.parentVnode)),
                                    (t.foreignObject = e.foreignObject),
                                    (t.parentVnode = e.parentVnode),
                                    t
                                );
                            })({
                                foreignObject: e,
                                parentVnode: { tagName: i, properties: n },
                            });
                        }
                        for (var r = 0; r < e.length; r++) Xf(e[r], t, i, n);
                    }
                }
                function Jf(e) {
                    return Hf(e) || Gf(e) || Vf(e) || qf(e);
                }
                function Kf(e) {
                    try {
                        return JSON.stringify(e, null, "    ");
                    } catch (t) {
                        return String(e);
                    }
                }
                var e_,
                    t_,
                    i_,
                    n_ = {
                        diff: Xg,
                        patch: ff,
                        h: function (e, t, i) {
                            var n,
                                r,
                                s,
                                a,
                                o,
                                c = [];
                            return (
                                !i &&
                                    ("string" == typeof (o = t) ||
                                        $f(o) ||
                                        Jf(o)) &&
                                    ((i = t), (r = {})),
                                (n = Wf(e, (r = r || t || {}))),
                                r.hasOwnProperty("key") &&
                                    ((s = r.key), (r.key = void 0)),
                                r.hasOwnProperty("namespace") &&
                                    ((a = r.namespace), (r.namespace = void 0)),
                                "INPUT" !== n ||
                                    a ||
                                    !r.hasOwnProperty("value") ||
                                    void 0 === r.value ||
                                    Yf(r.value) ||
                                    (r.value = Qf(r.value)),
                                (function (e) {
                                    for (var t in e)
                                        if (e.hasOwnProperty(t)) {
                                            var i = e[t];
                                            if (Yf(i)) continue;
                                            "ev-" === t.substr(0, 3) &&
                                                (e[t] = Zf(i));
                                        }
                                })(r),
                                null != i && Xf(i, c, n, r),
                                new Bf(n, r, c, s, a)
                            );
                        },
                        create: Jm,
                        VNode: bf,
                        VText: Df,
                    };
                class r_ {
                    constructor() {
                        this._events = {};
                    }
                    fire(e, t) {
                        if (this._listens(e))
                            for (const i of this._events[e]) i(t);
                    }
                    off(e, t) {
                        if (e) {
                            if (this._listens(e)) {
                                const i = this._events[e].indexOf(t);
                                i >= 0 && this._events[e].splice(i, 1),
                                    this._events[e].length ||
                                        delete this._events[e];
                            }
                        } else this._events = {};
                    }
                    on(e, t) {
                        (this._events[e] = this._events[e] || []),
                            this._events[e].push(t);
                    }
                    _listens(e) {
                        return e in this._events;
                    }
                }
                class s_ {
                    constructor() {
                        this._subscriptions = [];
                    }
                    push(e) {
                        this._subscriptions.push(e);
                    }
                    unsubscribe() {
                        for (const e of this._subscriptions) e.unsubscribe();
                        this._subscriptions = [];
                    }
                }
                class a_ extends r_ {
                    constructor(e, t, i) {
                        super(),
                            (this._activated$ = new Z(!1)),
                            (this._configurationSubject$ = new W()),
                            (this._activated = !1),
                            (this._container = t),
                            (this._name = e),
                            (this._navigator = i),
                            (this._subscriptions = new s_()),
                            (this._configuration$ =
                                this._configurationSubject$.pipe(
                                    Ot(this.defaultConfiguration),
                                    At((e, t) => {
                                        for (let i in t)
                                            t.hasOwnProperty(i) &&
                                                (e[i] = t[i]);
                                        return e;
                                    }),
                                    It(1),
                                    V()
                                )),
                            this._configuration$.subscribe(() => {});
                    }
                    get activated() {
                        return this._activated;
                    }
                    get activated$() {
                        return this._activated$;
                    }
                    get defaultConfiguration() {
                        return this._getDefaultConfiguration();
                    }
                    get configuration$() {
                        return this._configuration$;
                    }
                    get name() {
                        return this._name;
                    }
                    activate(e) {
                        this._activated ||
                            (void 0 !== e &&
                                this._configurationSubject$.next(e),
                            (this._activated = !0),
                            this._activate(),
                            this._activated$.next(!0));
                    }
                    configure(e) {
                        this._configurationSubject$.next(e);
                    }
                    deactivate() {
                        this._activated &&
                            ((this._activated = !1),
                            this._deactivate(),
                            this._container.domRenderer.clear(this._name),
                            this._container.glRenderer.clear(this._name),
                            this._activated$.next(!1));
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                    resize() {}
                }
                !(function (e) {
                    (e[(e.Hidden = 0)] = "Hidden"),
                        (e[(e.Loading = 1)] = "Loading"),
                        (e[(e.Visible = 2)] = "Visible");
                })(e_ || (e_ = {}));
                class o_ extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i);
                    }
                    _activate() {
                        const e = this.configuration$.pipe(
                                bt((e) => !!e.id),
                                nt((e) => !e.src),
                                kt((e) =>
                                    this._getImageSrc$(e.id).pipe(
                                        ot((e) => (console.error(e), oe()))
                                    )
                                ),
                                It(1),
                                V()
                            ),
                            t = this._subscriptions;
                        t.push(
                            e.pipe(ke((e) => ({ src: e }))).subscribe((e) => {
                                this._configurationSubject$.next(e);
                            })
                        ),
                            t.push(
                                He(this.configuration$, e)
                                    .pipe(
                                        nt(([e, t]) => !!e.src && e.src !== t),
                                        bt()
                                    )
                                    .subscribe(([, e]) => {
                                        window.URL.revokeObjectURL(e);
                                    })
                            ),
                            t.push(
                                this._configuration$
                                    .pipe(
                                        ft(void 0, (e) => e.state),
                                        kt((e) =>
                                            He(
                                                Ce(e.state),
                                                this._navigator.stateService
                                                    .currentImage$
                                            )
                                        ),
                                        kt(([e, t]) => {
                                            const i = He(
                                                Ce(t.id),
                                                t.image$.pipe(
                                                    nt((e) => !!e),
                                                    ke((e) => e.src)
                                                )
                                            );
                                            return e === e_.Visible
                                                ? i.pipe(bt())
                                                : i;
                                        }),
                                        ft(
                                            ([e, t], [i, n]) =>
                                                e === i && t === n
                                        ),
                                        ke(([e, t]) => ({ id: e, src: t }))
                                    )
                                    .subscribe(this._configurationSubject$)
                            ),
                            t.push(
                                He(
                                    this._configuration$,
                                    this._container.configurationService
                                        .exploreUrl$,
                                    this._container.renderService.size$
                                )
                                    .pipe(
                                        ke(([e, t, i]) => {
                                            if (!e.src)
                                                return {
                                                    name: this._name,
                                                    vNode: n_.h("div", []),
                                                };
                                            const n =
                                                i.width <= 640 ||
                                                i.height <= 480
                                                    ? ".mapillary-cover-compact"
                                                    : "";
                                            if (e.state === e_.Hidden) {
                                                const t = n_.h(
                                                    "div.mapillary-cover-container.mapillary-cover-done" +
                                                        n,
                                                    [
                                                        this._getCoverBackgroundVNode(
                                                            e
                                                        ),
                                                    ]
                                                );
                                                return {
                                                    name: this._name,
                                                    vNode: t,
                                                };
                                            }
                                            const r = n_.h(
                                                "div.mapillary-cover-container" +
                                                    n,
                                                [
                                                    this._getCoverButtonVNode(
                                                        e,
                                                        t
                                                    ),
                                                ]
                                            );
                                            return {
                                                name: this._name,
                                                vNode: r,
                                            };
                                        })
                                    )
                                    .subscribe(
                                        this._container.domRenderer.render$
                                    )
                            );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return { state: e_.Visible };
                    }
                    _getCoverButtonVNode(e, t) {
                        const i =
                                e.state === e_.Loading
                                    ? "div.mapillary-cover.mapillary-cover-loading"
                                    : "div.mapillary-cover",
                            n = n_.h("div.mapillary-cover-button", [
                                n_.h("div.mapillary-cover-button-icon", []),
                            ]),
                            r = n_.h(
                                "a.mapillary-cover-logo",
                                { href: t, target: "_blank" },
                                []
                            ),
                            s = n_.h(
                                "div.mapillary-cover-indicator",
                                {
                                    onclick: () => {
                                        this.configure({ state: e_.Loading });
                                    },
                                },
                                []
                            );
                        return n_.h(i, [
                            this._getCoverBackgroundVNode(e),
                            s,
                            n,
                            r,
                        ]);
                    }
                    _getCoverBackgroundVNode(e) {
                        const t = {
                                style: { backgroundImage: `url(${e.src})` },
                            },
                            i = [];
                        return (
                            e.state === e_.Loading &&
                                i.push(
                                    n_.h("div.mapillary-cover-spinner", {}, [])
                                ),
                            n_.h("div.mapillary-cover-background", t, i)
                        );
                    }
                    _getImageSrc$(e) {
                        return $.create((t) => {
                            this._navigator.api.getImages$([e]).subscribe(
                                (i) => {
                                    for (const n of i) {
                                        const i =
                                            "number" == typeof e
                                                ? e.toString()
                                                : e;
                                        if (n.node_id === i)
                                            return void this._navigator.api.data
                                                .getImageBuffer(
                                                    n.node.thumb.url
                                                )
                                                .then(
                                                    (i) => {
                                                        const n = new Image();
                                                        (n.crossOrigin =
                                                            "Anonymous"),
                                                            (n.onload = () => {
                                                                t.next(n.src),
                                                                    t.complete();
                                                            }),
                                                            (n.onerror = () => {
                                                                t.error(
                                                                    new Error(
                                                                        `Failed to load cover image (${e})`
                                                                    )
                                                                );
                                                            });
                                                        const r = new Blob([i]);
                                                        n.src =
                                                            window.URL.createObjectURL(
                                                                r
                                                            );
                                                    },
                                                    (e) => {
                                                        t.error(e);
                                                    }
                                                );
                                    }
                                    t.error(
                                        new Ap(`Non existent cover key: ${e}`)
                                    );
                                },
                                (e) => {
                                    t.error(e);
                                }
                            );
                        });
                    }
                }
                o_.componentName = "cover";
                class c_ extends a_ {
                    _activate() {
                        this._subscriptions.push(
                            He(
                                this._container.configurationService
                                    .exploreUrl$,
                                this._navigator.stateService.currentImage$,
                                this._container.renderService.size$
                            )
                                .pipe(
                                    ke(([e, t, i]) => {
                                        const n = this._makeAttribution(
                                            t.creatorUsername,
                                            e,
                                            t.id,
                                            t.capturedAt,
                                            i.width
                                        );
                                        return { name: this._name, vNode: n };
                                    })
                                )
                                .subscribe(this._container.domRenderer.render$)
                        );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return {};
                    }
                    makeImageUrl(e, t) {
                        return `${e}/app/?pKey=${t}&focus=photo`;
                    }
                    _makeAttribution(e, t, i, n, r) {
                        const s = r <= 640,
                            a = this._makeDate(n, s),
                            o = this._makeBy(e, t, i, s),
                            c = s ? ".mapillary-attribution-compact" : "";
                        return n_.h(
                            "div.mapillary-attribution-container" + c,
                            {},
                            [...o, a]
                        );
                    }
                    _makeBy(e, t, i, n) {
                        const r = n_.h("div.mapillary-attribution-logo", []);
                        return e
                            ? this._makeCreatorBy(r, e, t, i, n)
                            : this._makeGeneralBy(r, t, i, n);
                    }
                    _makeCreatorBy(e, t, i, n, r) {
                        const s = n_.h(
                                "a.mapillary-attribution-icon-container",
                                {
                                    href: i,
                                    rel: "noreferrer",
                                    target: "_blank",
                                },
                                [e]
                            ),
                            a = r ? `${t}` : `image by ${t}`,
                            o = n_.h(
                                "div.mapillary-attribution-username",
                                { textContent: a },
                                []
                            );
                        return [
                            s,
                            n_.h(
                                "a.mapillary-attribution-image-container",
                                {
                                    href: this.makeImageUrl(i, n),
                                    rel: "noreferrer",
                                    target: "_blank",
                                },
                                [o]
                            ),
                        ];
                    }
                    _makeGeneralBy(e, t, i, n) {
                        const r = n_.h(
                                "div.mapillary-attribution-username",
                                { textContent: "images by" },
                                []
                            ),
                            s = [
                                n_.h(
                                    "div.mapillary-attribution-icon-container",
                                    {},
                                    [e]
                                ),
                                n_.h(
                                    "div.mapillary-attribution-username",
                                    { textContent: "contributors" },
                                    []
                                ),
                            ];
                        return (
                            n || s.unshift(r),
                            [
                                n_.h(
                                    "a.mapillary-attribution-image-container",
                                    {
                                        href: this.makeImageUrl(t, i),
                                        rel: "noreferrer",
                                        target: "_blank",
                                    },
                                    s
                                ),
                            ]
                        );
                    }
                    _makeDate(e, t) {
                        const i = new Date(e).toDateString().split(" "),
                            n = (
                                i.length > 3
                                    ? t
                                        ? [i[3]]
                                        : [i[1], i[2] + ",", i[3]]
                                    : i
                            ).join(" ");
                        return n_.h(
                            "div.mapillary-attribution-date",
                            { textContent: n },
                            []
                        );
                    }
                }
                c_.componentName = "attribution";
                class l_ {
                    constructor() {
                        this._unprojectDepth = 200;
                    }
                    basicToCanvas(e, t, i, n, r) {
                        const s = n.unprojectBasic(
                            [e, t],
                            this._unprojectDepth
                        );
                        return this.projectToCanvas(s, i, r);
                    }
                    basicToCanvasSafe(e, t, i, n, r) {
                        const s = this.basicToViewportSafe(e, t, n, r);
                        return null === s
                            ? null
                            : this.viewportToCanvas(s[0], s[1], i);
                    }
                    basicToViewport(e, t, i, n) {
                        const r = i.unprojectBasic(
                            [e, t],
                            this._unprojectDepth
                        );
                        return this.projectToViewport(r, n);
                    }
                    basicToViewportSafe(e, t, i, n) {
                        const r = i.unprojectBasic(
                            [e, t],
                            this._unprojectDepth
                        );
                        return this.worldToCamera(r, n)[2] > 0
                            ? null
                            : this.projectToViewport(r, n);
                    }
                    cameraToViewport(e, t) {
                        const i = new rs()
                            .fromArray(e)
                            .applyMatrix4(t.projectionMatrix);
                        return [i.x, i.y];
                    }
                    canvasPosition(e, t) {
                        const i = t.getBoundingClientRect();
                        return [
                            e.clientX - i.left - t.clientLeft,
                            e.clientY - i.top - t.clientTop,
                        ];
                    }
                    canvasToBasic(e, t, i, n, r) {
                        const s = this.unprojectFromCanvas(
                            e,
                            t,
                            i,
                            r
                        ).toArray();
                        return n.projectBasic(s);
                    }
                    canvasToViewport(e, t, i) {
                        const [n, r] = this.containerToCanvas(i);
                        return [(2 * e) / n - 1, 1 - (2 * t) / r];
                    }
                    containerToCanvas(e) {
                        return [e.offsetWidth, e.offsetHeight];
                    }
                    getBasicDistances(e, t) {
                        const i = this.viewportToBasic(-1, 1, e, t),
                            n = this.viewportToBasic(1, 1, e, t),
                            r = this.viewportToBasic(1, -1, e, t),
                            s = this.viewportToBasic(-1, -1, e, t);
                        let a = 0,
                            o = 0,
                            c = 0,
                            l = 0;
                        return (
                            i[1] < 0 &&
                                n[1] < 0 &&
                                (a = i[1] > n[1] ? -i[1] : -n[1]),
                            n[0] > 1 &&
                                r[0] > 1 &&
                                (o = n[0] < r[0] ? n[0] - 1 : r[0] - 1),
                            r[1] > 1 &&
                                s[1] > 1 &&
                                (c = r[1] < s[1] ? r[1] - 1 : s[1] - 1),
                            s[0] < 0 &&
                                i[0] < 0 &&
                                (l = s[0] > i[0] ? -s[0] : -i[0]),
                            [a, o, c, l]
                        );
                    }
                    getPixelDistances(e, t, i) {
                        const n = this.viewportToBasic(-1, 1, t, i),
                            r = this.viewportToBasic(1, 1, t, i),
                            s = this.viewportToBasic(1, -1, t, i),
                            a = this.viewportToBasic(-1, -1, t, i);
                        let o = 0,
                            c = 0,
                            l = 0,
                            h = 0;
                        const [u, d] = this.containerToCanvas(e);
                        if (n[1] < 0 && r[1] < 0) {
                            const s = n[1] > r[1] ? n[0] : r[0],
                                a = this.basicToCanvas(s, 0, e, t, i);
                            o = a[1] > 0 ? a[1] : 0;
                        }
                        if (r[0] > 1 && s[0] > 1) {
                            const n = r[0] < s[0] ? r[1] : s[1],
                                a = this.basicToCanvas(1, n, e, t, i);
                            c = a[0] < u ? u - a[0] : 0;
                        }
                        if (s[1] > 1 && a[1] > 1) {
                            const n = s[1] < a[1] ? s[0] : a[0],
                                r = this.basicToCanvas(n, 1, e, t, i);
                            l = r[1] < d ? d - r[1] : 0;
                        }
                        if (a[0] < 0 && n[0] < 0) {
                            const r = a[0] > n[0] ? a[1] : n[1],
                                s = this.basicToCanvas(0, r, e, t, i);
                            h = s[0] > 0 ? s[0] : 0;
                        }
                        return [o, c, l, h];
                    }
                    insideElement(e, t) {
                        const i = t.getBoundingClientRect(),
                            n = i.left + t.clientLeft,
                            r = n + t.clientWidth,
                            s = i.top + t.clientTop,
                            a = s + t.clientHeight;
                        return (
                            e.clientX > n &&
                            e.clientX < r &&
                            e.clientY > s &&
                            e.clientY < a
                        );
                    }
                    projectToCanvas(e, t, i) {
                        const n = this.projectToViewport(e, i);
                        return this.viewportToCanvas(n[0], n[1], t);
                    }
                    projectToCanvasSafe(e, t, i) {
                        if (this.worldToCamera(e, i)[2] > 0) return null;
                        const n = this.projectToViewport(e, i);
                        return this.viewportToCanvas(n[0], n[1], t);
                    }
                    projectToViewport(e, t) {
                        const i = new rs(e[0], e[1], e[2]).project(t);
                        return [i.x, i.y];
                    }
                    unprojectFromCanvas(e, t, i, n) {
                        const r = this.canvasToViewport(e, t, i);
                        return this.unprojectFromViewport(r[0], r[1], n);
                    }
                    unprojectFromViewport(e, t, i) {
                        return new rs(e, t, 1).unproject(i);
                    }
                    viewportToBasic(e, t, i, n) {
                        const r = new rs(e, t, 1).unproject(n).toArray();
                        return i.projectBasic(r);
                    }
                    viewportToCanvas(e, t, i) {
                        const [n, r] = this.containerToCanvas(i);
                        return [(n * (e + 1)) / 2, (-r * (t - 1)) / 2];
                    }
                    worldToCamera(e, t) {
                        return new rs(e[0], e[1], e[2])
                            .applyMatrix4(t.matrixWorldInverse)
                            .toArray();
                    }
                }
                !(function (e) {
                    (e[(e.Automatic = 0)] = "Automatic"),
                        (e[(e.Large = 1)] = "Large"),
                        (e[(e.Small = 2)] = "Small");
                })(t_ || (t_ = {}));
                class h_ extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i),
                            (this._spatial = new Lp()),
                            (this._viewportCoords = new l_()),
                            (this._svgNamespace = "http://www.w3.org/2000/svg"),
                            (this._distinctThreshold = Math.PI / 360),
                            (this._animationSpeed = 0.075);
                    }
                    _activate() {
                        const e = this._subscriptions,
                            t =
                                this._container.renderService.renderCamera$.pipe(
                                    ke((e) => {
                                        let t = this._spatial.degToRad(
                                                e.perspective.fov
                                            ),
                                            i =
                                                e.perspective.aspect ===
                                                Number.POSITIVE_INFINITY
                                                    ? Math.PI
                                                    : 2 *
                                                      Math.atan(
                                                          e.perspective.aspect *
                                                              Math.tan(0.5 * t)
                                                      );
                                        return [
                                            this._spatial.azimuthalToBearing(
                                                e.rotation.phi
                                            ),
                                            i,
                                        ];
                                    }),
                                    ft(
                                        (e, t) =>
                                            Math.abs(t[0] - e[0]) <
                                                this._distinctThreshold &&
                                            Math.abs(t[1] - e[1]) <
                                                this._distinctThreshold
                                    )
                                ),
                            i = He(
                                this._navigator.stateService.currentState$.pipe(
                                    ft(void 0, (e) => e.state.currentImage.id)
                                ),
                                this._navigator.panService.panImages$
                            ).pipe(
                                ke(([e, t]) => {
                                    const i = e.state.currentImage,
                                        n = e.state.currentTransform;
                                    if (jp(i.cameraType))
                                        return [Math.PI, Math.PI];
                                    const r = this._computeProjectedPoints(n),
                                        s = this._spatial.degToRad(
                                            this._computeHorizontalFov(r)
                                        );
                                    let a = s / 2,
                                        o = s / 2;
                                    for (const [e, , n] of t) {
                                        const t = this._spatial.wrap(
                                            e.compassAngle - i.compassAngle,
                                            -180,
                                            180
                                        );
                                        t < 0
                                            ? (a =
                                                  this._spatial.degToRad(
                                                      Math.abs(t)
                                                  ) +
                                                  n / 2)
                                            : (o =
                                                  this._spatial.degToRad(
                                                      Math.abs(t)
                                                  ) +
                                                  n / 2);
                                    }
                                    return [a, o];
                                }),
                                ft(
                                    ([e, t], [i, n]) =>
                                        Math.abs(i - e) <
                                            this._distinctThreshold &&
                                        Math.abs(n - t) <
                                            this._distinctThreshold
                                )
                            ),
                            n = He(
                                this._navigator.stateService.currentState$.pipe(
                                    ft(void 0, (e) => e.state.currentImage.id)
                                ),
                                this._container.renderService.bearing$
                            ).pipe(
                                ke(([e, t]) =>
                                    this._spatial.degToRad(
                                        e.state.currentImage.compassAngle - t
                                    )
                                )
                            ),
                            r = new W(),
                            s = r.pipe(
                                At((e, t) => t(e), {
                                    alpha: 0,
                                    curr: [0, 0, 0],
                                    prev: [0, 0, 0],
                                }),
                                ke((e) => {
                                    const t = Hr.smootherstep(e.alpha, 0, 1),
                                        i = e.curr,
                                        n = e.prev;
                                    return [
                                        this._interpolate(n[0], i[0], t),
                                        this._interpolate(n[1], i[1], t),
                                    ];
                                })
                            );
                        e.push(
                            i
                                .pipe(
                                    ke((e) => (t) => {
                                        const i = Hr.smootherstep(
                                                t.alpha,
                                                0,
                                                1
                                            ),
                                            n = t.curr,
                                            r = t.prev,
                                            s = [
                                                this._interpolate(
                                                    r[0],
                                                    n[0],
                                                    i
                                                ),
                                                this._interpolate(
                                                    r[1],
                                                    n[1],
                                                    i
                                                ),
                                            ];
                                        return {
                                            alpha: 0,
                                            curr: e.slice(),
                                            prev: s,
                                        };
                                    })
                                )
                                .subscribe(r)
                        ),
                            e.push(
                                i
                                    .pipe(
                                        kt(() =>
                                            this._container.renderService.renderCameraFrame$.pipe(
                                                zt(1),
                                                At(
                                                    (e) =>
                                                        e +
                                                        this._animationSpeed,
                                                    0
                                                ),
                                                Pt(
                                                    (e) =>
                                                        e <=
                                                        1 + this._animationSpeed
                                                ),
                                                ke((e) => Math.min(e, 1))
                                            )
                                        ),
                                        ke((e) => (t) => ({
                                            alpha: e,
                                            curr: t.curr.slice(),
                                            prev: t.prev.slice(),
                                        }))
                                    )
                                    .subscribe(r)
                            );
                        const a = He(n, s).pipe(
                            ke(([e, t]) => [e, t[0], t[1]])
                        );
                        e.push(
                            He(
                                t,
                                a,
                                this._configuration$,
                                this._container.renderService.size$
                            )
                                .pipe(
                                    ke(([[e, t], [i, n, r], s, a]) => {
                                        const o = this._createBackground(e),
                                            c = this._createFovIndicator(
                                                n,
                                                r,
                                                i
                                            ),
                                            l = this._createNorth(e),
                                            h = this._createCircleSectorCompass(
                                                this._createCircleSector(
                                                    Math.max(Math.PI / 20, t),
                                                    "#FFF"
                                                )
                                            ),
                                            u =
                                                s.size === t_.Small ||
                                                (s.size === t_.Automatic &&
                                                    a.width < 640)
                                                    ? ".mapillary-bearing-compact"
                                                    : "";
                                        return {
                                            name: this._name,
                                            vNode: n_.h(
                                                "div.mapillary-bearing-indicator-container" +
                                                    u,
                                                {
                                                    oncontextmenu: (e) => {
                                                        e.preventDefault();
                                                    },
                                                },
                                                [o, c, l, h]
                                            ),
                                        };
                                    })
                                )
                                .subscribe(this._container.domRenderer.render$)
                        );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return { size: t_.Automatic };
                    }
                    _createFovIndicator(e, t, i) {
                        const n = this._createFovArc(e, t),
                            r = n_.h(
                                "g",
                                {
                                    attributes: {
                                        transform: "translate(18,18)",
                                    },
                                    namespace: this._svgNamespace,
                                },
                                [n]
                            );
                        return n_.h(
                            "svg",
                            {
                                attributes: { viewBox: "0 0 36 36" },
                                namespace: this._svgNamespace,
                                style: {
                                    height: "36px",
                                    left: "2px",
                                    position: "absolute",
                                    top: "2px",
                                    transform: `rotateZ(${this._spatial.radToDeg(
                                        i
                                    )}deg)`,
                                    width: "36px",
                                },
                            },
                            [r]
                        );
                    }
                    _createFovArc(e, t) {
                        const i = 16.75,
                            n = e + t;
                        if (n > 2 * Math.PI - Math.PI / 90)
                            return n_.h(
                                "circle",
                                {
                                    attributes: {
                                        cx: "0",
                                        cy: "0",
                                        "fill-opacity": "0",
                                        r: "16.75",
                                        stroke: "#FFF",
                                        "stroke-width": "2.5",
                                    },
                                    namespace: this._svgNamespace,
                                },
                                []
                            );
                        let r = -Math.PI / 2 - e,
                            s = r + n,
                            a = i * Math.cos(r),
                            o = i * Math.sin(r),
                            c = i * Math.cos(s),
                            l = i * Math.sin(s),
                            h = `M ${a} ${o} A 16.75 16.75 0 ${
                                n >= Math.PI ? 1 : 0
                            } 1 ${c} ${l}`;
                        return n_.h(
                            "path",
                            {
                                attributes: {
                                    d: h,
                                    "fill-opacity": "0",
                                    stroke: "#FFF",
                                    "stroke-width": "2.5",
                                },
                                namespace: this._svgNamespace,
                            },
                            []
                        );
                    }
                    _createCircleSectorCompass(e) {
                        let t = n_.h(
                            "g",
                            {
                                attributes: { transform: "translate(1,1)" },
                                namespace: this._svgNamespace,
                            },
                            [e]
                        );
                        return n_.h(
                            "svg",
                            {
                                attributes: { viewBox: "0 0 2 2" },
                                namespace: this._svgNamespace,
                                style: {
                                    height: "26px",
                                    left: "7px",
                                    position: "absolute",
                                    top: "7px",
                                    width: "26px",
                                },
                            },
                            [t]
                        );
                    }
                    _createCircleSector(e, t) {
                        if (e > 2 * Math.PI - Math.PI / 90)
                            return n_.h(
                                "circle",
                                {
                                    attributes: {
                                        cx: "0",
                                        cy: "0",
                                        fill: t,
                                        r: "1",
                                    },
                                    namespace: this._svgNamespace,
                                },
                                []
                            );
                        let i = -Math.PI / 2 - e / 2,
                            n = i + e,
                            r = Math.cos(i),
                            s = Math.sin(i),
                            a = Math.cos(n),
                            o = Math.sin(n),
                            c = `M 0 0 ${r} ${s} A 1 1 0 ${
                                e >= Math.PI ? 1 : 0
                            } 1 ${a} ${o}`;
                        return n_.h(
                            "path",
                            {
                                attributes: { d: c, fill: t },
                                namespace: this._svgNamespace,
                            },
                            []
                        );
                    }
                    _createNorth(e) {
                        const t = n_.h("div.mapillary-bearing-north", []);
                        return n_.h(
                            "div.mapillary-bearing-north-container",
                            {
                                style: {
                                    transform: `rotateZ(${this._spatial.radToDeg(
                                        -e
                                    )}deg)`,
                                },
                            },
                            [t]
                        );
                    }
                    _createBackground(e) {
                        return n_.h(
                            "div.mapillary-bearing-indicator-background",
                            {
                                style: {
                                    transform: `rotateZ(${this._spatial.radToDeg(
                                        -e
                                    )}deg)`,
                                },
                            },
                            [
                                n_.h(
                                    "div.mapillary-bearing-indicator-background-circle",
                                    []
                                ),
                                n_.h(
                                    "div.mapillary-bearing-indicator-background-arrow-container",
                                    [
                                        n_.h(
                                            "div.mapillary-bearing-indicator-background-arrow",
                                            []
                                        ),
                                    ]
                                ),
                            ]
                        );
                    }
                    _computeProjectedPoints(e) {
                        return Rp(
                            e,
                            [[1, 0]],
                            [[0, 0.5]],
                            12,
                            this._viewportCoords
                        );
                    }
                    _computeHorizontalFov(e) {
                        const t = e.map((e) => this._coordToFov(e[0]));
                        return Math.min(...t);
                    }
                    _coordToFov(e) {
                        return this._spatial.radToDeg(2 * Math.atan(e));
                    }
                    _interpolate(e, t, i) {
                        return (1 - i) * e + i * t;
                    }
                }
                h_.componentName = "bearing";
                class u_ extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i);
                    }
                    _activate() {
                        const e = this._subscriptions;
                        e.push(
                            He(
                                this._navigator.stateService.currentImage$.pipe(
                                    kt((e) => e.sequenceEdges$),
                                    nt((e) => e.cached)
                                ),
                                this._configuration$
                            )
                                .pipe(
                                    kt((e) => {
                                        let t = e[0],
                                            i = e[1],
                                            n = Math.max(
                                                0,
                                                Math.min(4, i.depth.sequence)
                                            );
                                        return tt(
                                            this._cache$(t.edges, Dp.Next, n),
                                            this._cache$(t.edges, Dp.Prev, n)
                                        ).pipe(
                                            ot(
                                                (e) => (
                                                    console.error(
                                                        "Failed to cache sequence edges.",
                                                        e
                                                    ),
                                                    oe()
                                                )
                                            )
                                        );
                                    })
                                )
                                .subscribe(() => {})
                        ),
                            e.push(
                                He(
                                    this._navigator.stateService.currentImage$.pipe(
                                        kt((e) =>
                                            He(
                                                Ce(e),
                                                e.spatialEdges$.pipe(
                                                    nt((e) => e.cached)
                                                )
                                            )
                                        )
                                    ),
                                    this._configuration$
                                )
                                    .pipe(
                                        kt(([[e, t], i]) => {
                                            let n = t.edges,
                                                r = i.depth,
                                                s = Math.max(
                                                    0,
                                                    Math.min(2, r.spherical)
                                                ),
                                                a = jp(e.cameraType)
                                                    ? 0
                                                    : Math.max(
                                                          0,
                                                          Math.min(3, r.step)
                                                      ),
                                                o = jp(e.cameraType)
                                                    ? 0
                                                    : Math.max(
                                                          0,
                                                          Math.min(1, r.turn)
                                                      ),
                                                c = this._cache$(
                                                    n,
                                                    Dp.Spherical,
                                                    s
                                                );
                                            return tt(
                                                this._cache$(
                                                    n,
                                                    Dp.StepForward,
                                                    a
                                                ),
                                                this._cache$(
                                                    n,
                                                    Dp.StepBackward,
                                                    a
                                                ),
                                                this._cache$(n, Dp.StepLeft, a),
                                                this._cache$(
                                                    n,
                                                    Dp.StepRight,
                                                    a
                                                ),
                                                c,
                                                this._cache$(n, Dp.TurnLeft, o),
                                                this._cache$(
                                                    n,
                                                    Dp.TurnRight,
                                                    o
                                                ),
                                                this._cache$(n, Dp.TurnU, o)
                                            ).pipe(
                                                ot(
                                                    (e) => (
                                                        console.error(
                                                            "Failed to cache spatial edges.",
                                                            e
                                                        ),
                                                        oe()
                                                    )
                                                )
                                            );
                                        })
                                    )
                                    .subscribe(() => {})
                            );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return {
                            depth: {
                                spherical: 1,
                                sequence: 2,
                                step: 1,
                                turn: 0,
                            },
                        };
                    }
                    _cache$(e, t, i) {
                        return rt(Ce(e), Ce(i)).pipe(
                            yt((e) => {
                                let i = e[0],
                                    n = e[1],
                                    r = [];
                                if (n > 0)
                                    for (let e of i)
                                        e.data.direction === t &&
                                            r.push(
                                                rt(
                                                    this._navigator.graphService
                                                        .cacheImage$(e.target)
                                                        .pipe(
                                                            Ye((e) =>
                                                                this._imageToEdges$(
                                                                    e,
                                                                    t
                                                                )
                                                            )
                                                        ),
                                                    Ce(n - 1)
                                                )
                                            );
                                return ye(r).pipe(qe());
                            }),
                            zt(1)
                        );
                    }
                    _imageToEdges$(e, t) {
                        return (
                            [Dp.Next, Dp.Prev].indexOf(t) > -1
                                ? e.sequenceEdges$
                                : e.spatialEdges$
                        ).pipe(
                            bt((e) => e.cached),
                            ke((e) => e.edges)
                        );
                    }
                }
                u_.componentName = "cache";
                class d_ extends Ap {
                    constructor(e) {
                        super(null != e ? e : "The request was cancelled."),
                            Object.setPrototypeOf(this, d_.prototype),
                            (this.name = "CancelMapillaryError");
                    }
                }
                class p_ {
                    constructor(e, t) {
                        (this._spatial = new Lp()),
                            (this._minThresholdWidth = 320),
                            (this._maxThresholdWidth = 1480),
                            (this._minThresholdHeight = 240),
                            (this._maxThresholdHeight = 820),
                            this._configure(e),
                            this._resize(t),
                            this._reset();
                    }
                    get minWidth() {
                        return this._minWidth;
                    }
                    get maxWidth() {
                        return this._maxWidth;
                    }
                    get containerWidth() {
                        return this._containerWidth;
                    }
                    get containerWidthCss() {
                        return this._containerWidthCss;
                    }
                    get containerMarginCss() {
                        return this._containerMarginCss;
                    }
                    get containerLeftCss() {
                        return this._containerLeftCss;
                    }
                    get containerHeight() {
                        return this._containerHeight;
                    }
                    get containerHeightCss() {
                        return this._containerHeightCss;
                    }
                    get containerBottomCss() {
                        return this._containerBottomCss;
                    }
                    get stepCircleSize() {
                        return this._stepCircleSize;
                    }
                    get stepCircleSizeCss() {
                        return this._stepCircleSizeCss;
                    }
                    get stepCircleMarginCss() {
                        return this._stepCircleMarginCss;
                    }
                    get turnCircleSize() {
                        return this._turnCircleSize;
                    }
                    get turnCircleSizeCss() {
                        return this._turnCircleSizeCss;
                    }
                    get outerRadius() {
                        return this._outerRadius;
                    }
                    get innerRadius() {
                        return this._innerRadius;
                    }
                    get shadowOffset() {
                        return this._shadowOffset;
                    }
                    configure(e) {
                        this._configure(e), this._reset();
                    }
                    resize(e) {
                        this._resize(e), this._reset();
                    }
                    angleToCoordinates(e) {
                        return [Math.cos(e), Math.sin(e)];
                    }
                    relativeAngleToCoordiantes(e, t) {
                        let i = this._spatial.wrapAngle(e - t);
                        return this.angleToCoordinates(i);
                    }
                    _configure(e) {
                        (this._minWidth = e.minWidth),
                            (this._maxWidth = this._getMaxWidth(
                                e.minWidth,
                                e.maxWidth
                            ));
                    }
                    _resize(e) {
                        (this._elementWidth = e.width),
                            (this._elementHeight = e.height);
                    }
                    _reset() {
                        (this._containerWidth = this._getContainerWidth(
                            this._elementWidth,
                            this._elementHeight
                        )),
                            (this._containerHeight = this._getContainerHeight(
                                this.containerWidth
                            )),
                            (this._stepCircleSize = this._getStepCircleDiameter(
                                this._containerHeight
                            )),
                            (this._turnCircleSize = this._getTurnCircleDiameter(
                                this.containerHeight
                            )),
                            (this._outerRadius = this._getOuterRadius(
                                this._containerHeight
                            )),
                            (this._innerRadius = this._getInnerRadius(
                                this._containerHeight
                            )),
                            (this._shadowOffset = 3),
                            (this._containerWidthCss = this._numberToCssPixels(
                                this._containerWidth
                            )),
                            (this._containerMarginCss = this._numberToCssPixels(
                                -0.5 * this._containerWidth
                            )),
                            (this._containerLeftCss = this._numberToCssPixels(
                                Math.floor(0.5 * this._elementWidth)
                            )),
                            (this._containerHeightCss = this._numberToCssPixels(
                                this._containerHeight
                            )),
                            (this._containerBottomCss = this._numberToCssPixels(
                                Math.floor(-0.08 * this._containerHeight)
                            )),
                            (this._stepCircleSizeCss = this._numberToCssPixels(
                                this._stepCircleSize
                            )),
                            (this._stepCircleMarginCss =
                                this._numberToCssPixels(
                                    -0.5 * this._stepCircleSize
                                )),
                            (this._turnCircleSizeCss = this._numberToCssPixels(
                                this._turnCircleSize
                            ));
                    }
                    _getContainerWidth(e, t) {
                        let i =
                                (e - this._minThresholdWidth) /
                                (this._maxThresholdWidth -
                                    this._minThresholdWidth),
                            n =
                                (t - this._minThresholdHeight) /
                                (this._maxThresholdHeight -
                                    this._minThresholdHeight),
                            r = Math.max(0, Math.min(1, Math.min(i, n)));
                        return (
                            (r = 0.04 * Math.round(25 * r)),
                            this._minWidth +
                                r * (this._maxWidth - this._minWidth)
                        );
                    }
                    _getContainerHeight(e) {
                        return 0.77 * e;
                    }
                    _getStepCircleDiameter(e) {
                        return 0.34 * e;
                    }
                    _getTurnCircleDiameter(e) {
                        return 0.3 * e;
                    }
                    _getOuterRadius(e) {
                        return 0.31 * e;
                    }
                    _getInnerRadius(e) {
                        return 0.125 * e;
                    }
                    _numberToCssPixels(e) {
                        return e + "px";
                    }
                    _getMaxWidth(e, t) {
                        return e > t ? e : t;
                    }
                }
                class g_ {
                    constructor(e, t) {
                        (this._isEdge = !1),
                            (this._spatial = new Lp()),
                            (this._calculator = new p_(e, t)),
                            (this._image = null),
                            (this._rotation = { phi: 0, theta: 0 }),
                            (this._epsilon = (0.5 * Math.PI) / 180),
                            (this._highlightKey = null),
                            (this._distinguishSequence = !1),
                            (this._needsRender = !1),
                            (this._stepEdges = []),
                            (this._turnEdges = []),
                            (this._sphericalEdges = []),
                            (this._sequenceEdgeKeys = []),
                            (this._stepDirections = [
                                Dp.StepForward,
                                Dp.StepBackward,
                                Dp.StepLeft,
                                Dp.StepRight,
                            ]),
                            (this._turnDirections = [
                                Dp.TurnLeft,
                                Dp.TurnRight,
                                Dp.TurnU,
                            ]),
                            (this._turnNames = {}),
                            (this._turnNames[Dp.TurnLeft] =
                                "mapillary-direction-turn-left"),
                            (this._turnNames[Dp.TurnRight] =
                                "mapillary-direction-turn-right"),
                            (this._turnNames[Dp.TurnU] =
                                "mapillary-direction-turn-around");
                        let i = !!document.documentMode;
                        this._isEdge = !i && !!window.StyleMedia;
                    }
                    get needsRender() {
                        return this._needsRender;
                    }
                    render(e) {
                        this._needsRender = !1;
                        let t = this._rotation,
                            i = [],
                            n = [];
                        return (
                            jp(this._image.cameraType)
                                ? (i = i.concat(
                                      this._createSphericalArrows(e, t)
                                  ))
                                : ((i = i.concat(
                                      this._createPerspectiveToSphericalArrows(
                                          e,
                                          t
                                      )
                                  )),
                                  (i = i.concat(this._createStepArrows(e, t))),
                                  (n = n.concat(this._createTurnArrows(e)))),
                            this._getContainer(i, n, t)
                        );
                    }
                    setEdges(e, t) {
                        this._setEdges(e, t), this._setNeedsRender();
                    }
                    setImage(e) {
                        (this._image = e),
                            this._clearEdges(),
                            this._setNeedsRender();
                    }
                    setRenderCamera(e) {
                        let t = e.rotation;
                        Math.abs(t.phi - this._rotation.phi) < this._epsilon ||
                            ((this._rotation = t), this._setNeedsRender());
                    }
                    setConfiguration(e) {
                        let t = !1;
                        (this._highlightKey === e.highlightId &&
                            this._distinguishSequence ===
                                e.distinguishSequence) ||
                            ((this._highlightKey = e.highlightId),
                            (this._distinguishSequence = e.distinguishSequence),
                            (t = !0)),
                            (this._calculator.minWidth === e.minWidth &&
                                this._calculator.maxWidth === e.maxWidth) ||
                                (this._calculator.configure(e), (t = !0)),
                            t && this._setNeedsRender();
                    }
                    resize(e) {
                        this._calculator.resize(e), this._setNeedsRender();
                    }
                    _setNeedsRender() {
                        null != this._image && (this._needsRender = !0);
                    }
                    _clearEdges() {
                        (this._stepEdges = []),
                            (this._turnEdges = []),
                            (this._sphericalEdges = []),
                            (this._sequenceEdgeKeys = []);
                    }
                    _setEdges(e, t) {
                        (this._stepEdges = []),
                            (this._turnEdges = []),
                            (this._sphericalEdges = []),
                            (this._sequenceEdgeKeys = []);
                        for (let t of e.edges) {
                            let e = t.data.direction;
                            this._stepDirections.indexOf(e) > -1
                                ? this._stepEdges.push(t)
                                : this._turnDirections.indexOf(e) > -1
                                ? this._turnEdges.push(t)
                                : t.data.direction === Dp.Spherical &&
                                  this._sphericalEdges.push(t);
                        }
                        if (this._distinguishSequence && null != t) {
                            let e = this._sphericalEdges
                                .concat(this._stepEdges)
                                .concat(this._turnEdges);
                            for (let i of e) {
                                let e = i.target;
                                for (let i of t.imageIds)
                                    if (i === e) {
                                        this._sequenceEdgeKeys.push(e);
                                        break;
                                    }
                            }
                        }
                    }
                    _createSphericalArrows(e, t) {
                        let i = [];
                        for (let n of this._sphericalEdges)
                            i.push(
                                this._createVNodeByKey(
                                    e,
                                    n.target,
                                    n.data.worldMotionAzimuth,
                                    t,
                                    this._calculator.outerRadius,
                                    "mapillary-direction-arrow-spherical"
                                )
                            );
                        for (let n of this._stepEdges)
                            i.push(
                                this._createSphericalToPerspectiveArrow(
                                    e,
                                    n.target,
                                    n.data.worldMotionAzimuth,
                                    t,
                                    n.data.direction
                                )
                            );
                        return i;
                    }
                    _createSphericalToPerspectiveArrow(e, t, i, n, r) {
                        let s = Math.PI / 8,
                            a = n.phi;
                        switch (r) {
                            case Dp.StepBackward:
                                a = n.phi - Math.PI;
                                break;
                            case Dp.StepLeft:
                                a = n.phi + Math.PI / 2;
                                break;
                            case Dp.StepRight:
                                a = n.phi - Math.PI / 2;
                        }
                        return Math.abs(this._spatial.wrapAngle(i - a)) < s
                            ? this._createVNodeByKey(
                                  e,
                                  t,
                                  i,
                                  n,
                                  this._calculator.outerRadius,
                                  "mapillary-direction-arrow-step"
                              )
                            : this._createVNodeInactive(t, i, n);
                    }
                    _createPerspectiveToSphericalArrows(e, t) {
                        let i = [];
                        for (let n of this._sphericalEdges)
                            i.push(
                                this._createVNodeByKey(
                                    e,
                                    n.target,
                                    n.data.worldMotionAzimuth,
                                    t,
                                    this._calculator.innerRadius,
                                    "mapillary-direction-arrow-spherical",
                                    !0
                                )
                            );
                        return i;
                    }
                    _createStepArrows(e, t) {
                        let i = [];
                        for (let n of this._stepEdges)
                            i.push(
                                this._createVNodeByDirection(
                                    e,
                                    n.target,
                                    n.data.worldMotionAzimuth,
                                    t,
                                    n.data.direction
                                )
                            );
                        return i;
                    }
                    _createTurnArrows(e) {
                        let t = [];
                        for (let i of this._turnEdges) {
                            let n = i.data.direction,
                                r = this._turnNames[n];
                            t.push(this._createVNodeByTurn(e, i.target, r, n));
                        }
                        return t;
                    }
                    _createVNodeByKey(e, t, i, n, r, s, a) {
                        return this._createVNode(
                            t,
                            i,
                            n,
                            r,
                            s,
                            "mapillary-direction-circle",
                            (i) => {
                                e.moveTo$(t).subscribe(void 0, (e) => {
                                    e instanceof d_ || console.error(e);
                                });
                            },
                            a
                        );
                    }
                    _createVNodeByDirection(e, t, i, n, r) {
                        return this._createVNode(
                            t,
                            i,
                            n,
                            this._calculator.outerRadius,
                            "mapillary-direction-arrow-step",
                            "mapillary-direction-circle",
                            (t) => {
                                e.moveDir$(r).subscribe(void 0, (e) => {
                                    e instanceof d_ || console.error(e);
                                });
                            }
                        );
                    }
                    _createVNodeByTurn(e, t, i, n) {
                        let r = {
                            height: this._calculator.turnCircleSizeCss,
                            transform: "rotate(0)",
                            width: this._calculator.turnCircleSizeCss,
                        };
                        switch (n) {
                            case Dp.TurnLeft:
                                (r.left = "5px"), (r.top = "5px");
                                break;
                            case Dp.TurnRight:
                                (r.right = "5px"), (r.top = "5px");
                                break;
                            case Dp.TurnU:
                                (r.left = "5px"), (r.bottom = "5px");
                        }
                        let s = {
                                attributes: { "data-id": t },
                                onclick: (t) => {
                                    e.moveDir$(n).subscribe(void 0, (e) => {
                                        e instanceof d_ || console.error(e);
                                    });
                                },
                                style: r,
                            },
                            a = "mapillary-direction-turn-circle";
                        this._sequenceEdgeKeys.indexOf(t) > -1 &&
                            (a += "-sequence"),
                            this._highlightKey === t && (a += "-highlight");
                        let o = n_.h(`div.${i}`, {}, []);
                        return n_.h("div." + a, s, [o]);
                    }
                    _createVNodeInactive(e, t, i) {
                        return this._createVNode(
                            e,
                            t,
                            i,
                            this._calculator.outerRadius,
                            "mapillary-direction-arrow-inactive",
                            "mapillary-direction-circle-inactive"
                        );
                    }
                    _createVNode(e, t, i, n, r, s, a, o) {
                        let c = this._calculator.angleToCoordinates(t - i.phi),
                            l = Math.round(
                                -n * c[1] +
                                    0.5 * this._calculator.containerWidth
                            ),
                            h = Math.round(
                                -n * c[0] +
                                    0.5 * this._calculator.containerHeight
                            ),
                            u = this._calculator.relativeAngleToCoordiantes(
                                t,
                                i.phi
                            ),
                            d = this._calculator.shadowOffset,
                            p = `drop-shadow(${-d * u[1]}px ${
                                d * u[0]
                            }px 1px rgba(0,0,0,0.8))`,
                            g = { style: { "-webkit-filter": p, filter: p } },
                            m = n_.h("div." + r, g, []),
                            f = -this._spatial.radToDeg(t - i.phi),
                            _ = o
                                ? `translate(${l}px, ${h}px) rotate(${f}deg) translateZ(-0.01px)`
                                : `translate(${l}px, ${h}px) rotate(${f}deg)`,
                            M = {
                                attributes: { "data-id": e },
                                onclick: a,
                                style: {
                                    height: this._calculator.stepCircleSizeCss,
                                    marginLeft:
                                        this._calculator.stepCircleMarginCss,
                                    marginTop:
                                        this._calculator.stepCircleMarginCss,
                                    transform: _,
                                    width: this._calculator.stepCircleSizeCss,
                                },
                            };
                        return (
                            this._sequenceEdgeKeys.indexOf(e) > -1 &&
                                (s += "-sequence"),
                            this._highlightKey === e && (s += "-highlight"),
                            n_.h("div." + s, M, [m])
                        );
                    }
                    _getContainer(e, t, i) {
                        let n = this._isEdge
                                ? "rotateX(60deg)"
                                : `perspective(${this._calculator.containerWidthCss}) rotateX(60deg)`,
                            r = {
                                oncontextmenu: (e) => {
                                    e.preventDefault();
                                },
                                style: {
                                    bottom: this._calculator.containerBottomCss,
                                    height: this._calculator.containerHeightCss,
                                    left: this._calculator.containerLeftCss,
                                    marginLeft:
                                        this._calculator.containerMarginCss,
                                    transform: n,
                                    width: this._calculator.containerWidthCss,
                                },
                            };
                        return n_.h(
                            "div.mapillary-direction-perspective",
                            r,
                            t.concat(e)
                        );
                    }
                }
                class m_ extends a_ {
                    constructor(e, t, i, n) {
                        super(e, t, i),
                            (this._renderer =
                                n ||
                                new g_(this.defaultConfiguration, {
                                    height: t.container.offsetHeight,
                                    width: t.container.offsetWidth,
                                })),
                            (this._hoveredIdSubject$ = new W()),
                            (this._hoveredId$ = this._hoveredIdSubject$.pipe(
                                Et()
                            ));
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                    _activate() {
                        const e = this._subscriptions;
                        e.push(
                            this._configuration$.subscribe((e) => {
                                this._renderer.setConfiguration(e);
                            })
                        ),
                            e.push(
                                this._container.renderService.size$.subscribe(
                                    (e) => {
                                        this._renderer.resize(e);
                                    }
                                )
                            ),
                            e.push(
                                this._navigator.stateService.currentImage$
                                    .pipe(
                                        Ut((e) => {
                                            this._container.domRenderer.render$.next(
                                                {
                                                    name: this._name,
                                                    vNode: n_.h("div", {}, []),
                                                }
                                            ),
                                                this._renderer.setImage(e);
                                        }),
                                        $t(this._configuration$),
                                        kt(([e, t]) =>
                                            He(
                                                e.spatialEdges$,
                                                t.distinguishSequence
                                                    ? this._navigator.graphService
                                                          .cacheSequence$(
                                                              e.sequenceId
                                                          )
                                                          .pipe(
                                                              ot(
                                                                  (t) => (
                                                                      console.error(
                                                                          `Failed to cache sequence (${e.sequenceId})`,
                                                                          t
                                                                      ),
                                                                      Ce(null)
                                                                  )
                                                              )
                                                          )
                                                    : Ce(null)
                                            )
                                        )
                                    )
                                    .subscribe(([e, t]) => {
                                        this._renderer.setEdges(e, t);
                                    })
                            ),
                            e.push(
                                this._container.renderService.renderCameraFrame$
                                    .pipe(
                                        Ut((e) => {
                                            this._renderer.setRenderCamera(e);
                                        }),
                                        ke(() => this._renderer),
                                        nt((e) => e.needsRender),
                                        ke((e) => ({
                                            name: this._name,
                                            vNode: e.render(this._navigator),
                                        }))
                                    )
                                    .subscribe(
                                        this._container.domRenderer.render$
                                    )
                            ),
                            e.push(
                                He(
                                    this._container.domRenderer.element$,
                                    this._container.renderService.renderCamera$,
                                    this._container.mouseService.mouseMove$.pipe(
                                        Ot(null)
                                    ),
                                    this._container.mouseService.mouseUp$.pipe(
                                        Ot(null)
                                    )
                                )
                                    .pipe(
                                        ke(([e]) => {
                                            let t = e.getElementsByClassName(
                                                "mapillary-direction-perspective"
                                            );
                                            for (let e = 0; e < t.length; e++) {
                                                let i = t
                                                    .item(e)
                                                    .querySelector(":hover");
                                                if (
                                                    null != i &&
                                                    i.hasAttribute("data-id")
                                                )
                                                    return i.getAttribute(
                                                        "data-id"
                                                    );
                                            }
                                            return null;
                                        }),
                                        ft()
                                    )
                                    .subscribe(this._hoveredIdSubject$)
                            ),
                            e.push(
                                this._hoveredId$.subscribe((e) => {
                                    const t = "hover",
                                        i = { id: e, target: this, type: t };
                                    this.fire(t, i);
                                })
                            );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return {
                            distinguishSequence: !1,
                            maxWidth: 460,
                            minWidth: 260,
                        };
                    }
                }
                m_.componentName = "direction";
                class f_ {}
                (f_.fisheye = {
                    fragment:
                        "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D projectorTex;\nuniform float opacity;\nuniform float focal;\nuniform float k1;\nuniform float k2;\nuniform float scale_x;\nuniform float scale_y;\nuniform float radial_peak;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    float x = vRstq.x;\n    float y = vRstq.y;\n    float z = vRstq.z;\n\n    float r = sqrt(x * x + y * y);\n    float theta = atan(r, z);\n\n    if (radial_peak > 0. && theta > radial_peak) {\n        theta = radial_peak;\n    }\n\n    float theta2 = theta * theta;\n    float theta_d = theta * (1.0 + theta2 * (k1 + theta2 * k2));\n    float s = focal * theta_d / r;\n\n    float u = scale_x * s * x + 0.5;\n    float v = -scale_y * s * y + 0.5;\n\n    vec4 baseColor;\n    if (u >= 0. && u <= 1. && v >= 0. && v <= 1.) {\n        baseColor = texture2D(projectorTex, vec2(u, v));\n        baseColor.a = opacity;\n    } else {\n        baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    gl_FragColor = baseColor;\n}\n",
                    vertex: "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                }),
                    (f_.fisheyeCurtain = {
                        fragment:
                            "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D projectorTex;\nuniform float opacity;\nuniform float focal;\nuniform float k1;\nuniform float k2;\nuniform float scale_x;\nuniform float scale_y;\nuniform float radial_peak;\nuniform float curtain;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    float x = vRstq.x;\n    float y = vRstq.y;\n    float z = vRstq.z;\n\n    float r2 = sqrt(x * x + y * y);\n    float theta = atan(r2, z);\n\n    if (radial_peak > 0. && theta > radial_peak) {\n        theta = radial_peak;\n    }\n\n    float theta2 = theta * theta;\n    float theta_d = theta * (1.0 + theta2 * (k1 + theta2 * k2));\n    float s = focal * theta_d / r2;\n\n    float u = scale_x * s * x + 0.5;\n    float v = -scale_y * s * y + 0.5;\n\n    vec4 baseColor;\n    if ((u < curtain || curtain >= 1.0) && u >= 0. && u <= 1. && v >= 0. && v <= 1.) {\n        baseColor = texture2D(projectorTex, vec2(u, v));\n        baseColor.a = opacity;\n    } else {\n        baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    gl_FragColor = baseColor;\n}\n",
                        vertex: "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                    }),
                    (f_.perspective = {
                        fragment:
                            "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D projectorTex;\nuniform float opacity;\nuniform float focal;\nuniform float k1;\nuniform float k2;\nuniform float scale_x;\nuniform float scale_y;\nuniform float radial_peak;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    float x = vRstq.x / vRstq.z;\n    float y = vRstq.y / vRstq.z;\n    float r2 = x * x + y * y;\n\n    if (radial_peak > 0. && r2 > radial_peak * sqrt(r2)) {\n        r2 = radial_peak * radial_peak;\n    }\n\n    float d = 1.0 + k1 * r2 + k2 * r2 * r2;\n    float u = scale_x * focal * d * x + 0.5;\n    float v = - scale_y * focal * d * y + 0.5;\n\n    vec4 baseColor;\n    if (u >= 0. && u <= 1. && v >= 0. && v <= 1.) {\n        baseColor = texture2D(projectorTex, vec2(u, v));\n        baseColor.a = opacity;\n    } else {\n        baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    gl_FragColor = baseColor;\n}\n",
                        vertex: "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                    }),
                    (f_.perspectiveCurtain = {
                        fragment:
                            "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D projectorTex;\nuniform float opacity;\nuniform float focal;\nuniform float k1;\nuniform float k2;\nuniform float scale_x;\nuniform float scale_y;\nuniform float radial_peak;\nuniform float curtain;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    float x = vRstq.x / vRstq.z;\n    float y = vRstq.y / vRstq.z;\n    float r2 = x * x + y * y;\n\n    if (radial_peak > 0. && r2 > radial_peak * sqrt(r2)) {\n        r2 = radial_peak * radial_peak;\n    }\n\n    float d = 1.0 + k1 * r2 + k2 * r2 * r2;\n    float u = scale_x * focal * d * x + 0.5;\n    float v = - scale_y * focal * d * y + 0.5;\n\n    vec4 baseColor;\n    if ((u < curtain || curtain >= 1.0) && u >= 0. && u <= 1. && v >= 0. && v <= 1.) {\n        baseColor = texture2D(projectorTex, vec2(u, v));\n        baseColor.a = opacity;\n    } else {\n        baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    gl_FragColor = baseColor;\n}\n",
                        vertex: "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                    }),
                    (f_.perspectiveDistorted = {
                        fragment:
                            "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D projectorTex;\nuniform float opacity;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    float u = vRstq.x / vRstq.w;\n    float v = vRstq.y / vRstq.w;\n\n    vec4 baseColor;\n    if (u >= 0. && u <= 1. && v >= 0. && v <= 1.) {\n        baseColor = texture2D(projectorTex, vec2(u, v));\n        baseColor.a = opacity;\n    } else {\n        baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    gl_FragColor = baseColor;\n}\n",
                        vertex: "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                    }),
                    (f_.perspectiveDistortedCurtain = {
                        fragment:
                            "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D projectorTex;\nuniform float opacity;\nuniform float curtain;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    float u = vRstq.x / vRstq.w;\n    float v = vRstq.y / vRstq.w;\n\n    vec4 baseColor;\n    if ((u < curtain || curtain >= 1.0) && u >= 0. && u <= 1. && v >= 0. && v <= 1.) {\n        baseColor = texture2D(projectorTex, vec2(u, v));\n        baseColor.a = opacity;\n    } else {\n        baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    gl_FragColor = baseColor;\n}\n",
                        vertex: "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                    }),
                    (f_.spherical = {
                        fragment:
                            "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define tau 6.28318530718\n\nuniform sampler2D projectorTex;\nuniform float opacity;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vec3 b = normalize(vRstq.xyz);\n    float lat = -asin(b.y);\n    float lng = atan(b.x, b.z);\n    float x = lng / tau + 0.5;\n    float y = lat / tau * 2.0 + 0.5;\n    vec4 baseColor = texture2D(projectorTex, vec2(x, y));\n    baseColor.a = opacity;\n    gl_FragColor = baseColor;\n}\n",
                        vertex: "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                    }),
                    (f_.sphericalCurtain = {
                        fragment:
                            "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define tau 6.28318530718\n\nuniform sampler2D projectorTex;\nuniform float curtain;\nuniform float opacity;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vec3 b = normalize(vRstq.xyz);\n    float lat = -asin(b.y);\n    float lng = atan(b.x, b.z);\n    float x = lng / tau + 0.5;\n    float y = lat / tau * 2.0 + 0.5;\n\n    bool inverted = curtain < 0.5;\n\n    float curtainMin = inverted ? curtain + 0.5 : curtain - 0.5;\n    float curtainMax = curtain;\n\n    bool insideCurtain = inverted ?\n        x > curtainMin || x < curtainMax :\n        x > curtainMin && x < curtainMax;\n\n    vec4 baseColor;\n    if (insideCurtain) {\n        baseColor = texture2D(projectorTex, vec2(x, y));\n        baseColor.a = opacity;\n    } else {\n        baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    gl_FragColor = baseColor;\n}\n",
                        vertex: "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                    });
                class __ {
                    constructor(e, t) {
                        (this._imagePlaneDepth = null != e ? e : 200),
                            (this._imageSphereRadius = null != t ? t : 200);
                    }
                    createMesh(e, t) {
                        return jp(t.cameraType)
                            ? this._createImageSphere(e, t)
                            : Op(t.cameraType)
                            ? this._createImagePlaneFisheye(e, t)
                            : this._createImagePlane(e, t);
                    }
                    createFlatMesh(e, t, i, n, r, s) {
                        let a = this._createTexture(e.image),
                            o = this._createDistortedPlaneMaterialParameters(
                                t,
                                a
                            ),
                            c = new uo(o),
                            l = this._getFlatImagePlaneGeoFromBasic(
                                t,
                                i,
                                n,
                                r,
                                s
                            );
                        return new so(l, c);
                    }
                    createCurtainMesh(e, t) {
                        return jp(t.cameraType)
                            ? this._createSphereCurtainMesh(e, t)
                            : Op(t.cameraType)
                            ? this._createCurtainMeshFisheye(e, t)
                            : this._createCurtainMesh(e, t);
                    }
                    createDistortedCurtainMesh(e, t) {
                        return this._createDistortedCurtainMesh(e, t);
                    }
                    _createCurtainMesh(e, t) {
                        let i = this._createTexture(e.image),
                            n = this._createCurtainPlaneMaterialParameters(
                                t,
                                i
                            ),
                            r = new uo(n),
                            s = this._useMesh(t, e)
                                ? this._getImagePlaneGeo(t, e)
                                : this._getRegularFlatImagePlaneGeo(t);
                        return new so(s, r);
                    }
                    _createCurtainMeshFisheye(e, t) {
                        let i = this._createTexture(e.image),
                            n =
                                this._createCurtainPlaneMaterialParametersFisheye(
                                    t,
                                    i
                                ),
                            r = new uo(n),
                            s = this._useMesh(t, e)
                                ? this._getImagePlaneGeoFisheye(t, e)
                                : this._getRegularFlatImagePlaneGeo(t);
                        return new so(s, r);
                    }
                    _createDistortedCurtainMesh(e, t) {
                        let i = this._createTexture(e.image),
                            n =
                                this._createDistortedCurtainPlaneMaterialParameters(
                                    t,
                                    i
                                ),
                            r = new uo(n),
                            s = this._getRegularFlatImagePlaneGeo(t);
                        return new so(s, r);
                    }
                    _createSphereCurtainMesh(e, t) {
                        let i = this._createTexture(e.image),
                            n = this._createCurtainSphereMaterialParameters(
                                t,
                                i
                            ),
                            r = new uo(n);
                        return this._useMesh(t, e)
                            ? new so(this._getImageSphereGeo(t, e), r)
                            : new so(this._getFlatImageSphereGeo(t), r);
                    }
                    _createImageSphere(e, t) {
                        let i = this._createTexture(e.image),
                            n = this._createSphereMaterialParameters(t, i),
                            r = new uo(n);
                        return this._useMesh(t, e)
                            ? new so(this._getImageSphereGeo(t, e), r)
                            : new so(this._getFlatImageSphereGeo(t), r);
                    }
                    _createImagePlane(e, t) {
                        let i = this._createTexture(e.image),
                            n = this._createPlaneMaterialParameters(t, i),
                            r = new uo(n),
                            s = this._useMesh(t, e)
                                ? this._getImagePlaneGeo(t, e)
                                : this._getRegularFlatImagePlaneGeo(t);
                        return new so(s, r);
                    }
                    _createImagePlaneFisheye(e, t) {
                        let i = this._createTexture(e.image),
                            n = this._createPlaneMaterialParametersFisheye(
                                t,
                                i
                            ),
                            r = new uo(n),
                            s = this._useMesh(t, e)
                                ? this._getImagePlaneGeoFisheye(t, e)
                                : this._getRegularFlatImagePlaneGeoFisheye(t);
                        return new so(s, r);
                    }
                    _createSphereMaterialParameters(e, t) {
                        return {
                            depthWrite: !1,
                            fragmentShader: f_.spherical.fragment,
                            side: Zt,
                            transparent: !0,
                            uniforms: {
                                opacity: { value: 1 },
                                projectorMat: { value: e.rt },
                                projectorTex: { value: t },
                            },
                            vertexShader: f_.spherical.vertex,
                        };
                    }
                    _createCurtainSphereMaterialParameters(e, t) {
                        return {
                            depthWrite: !1,
                            fragmentShader: f_.sphericalCurtain.fragment,
                            side: Zt,
                            transparent: !0,
                            uniforms: {
                                curtain: { value: 1 },
                                opacity: { value: 1 },
                                projectorMat: { value: e.rt },
                                projectorTex: { value: t },
                            },
                            vertexShader: f_.sphericalCurtain.vertex,
                        };
                    }
                    _createPlaneMaterialParameters(e, t) {
                        return {
                            depthWrite: !1,
                            fragmentShader: f_.perspective.fragment,
                            side: Zt,
                            transparent: !0,
                            uniforms: {
                                focal: { value: e.focal },
                                k1: { value: e.ck1 },
                                k2: { value: e.ck2 },
                                opacity: { value: 1 },
                                projectorMat: { value: e.basicRt },
                                projectorTex: { value: t },
                                radial_peak: {
                                    value: e.radialPeak ? e.radialPeak : 0,
                                },
                                scale_x: {
                                    value:
                                        Math.max(e.basicHeight, e.basicWidth) /
                                        e.basicWidth,
                                },
                                scale_y: {
                                    value:
                                        Math.max(e.basicWidth, e.basicHeight) /
                                        e.basicHeight,
                                },
                            },
                            vertexShader: f_.perspective.vertex,
                        };
                    }
                    _createPlaneMaterialParametersFisheye(e, t) {
                        return {
                            depthWrite: !1,
                            fragmentShader: f_.fisheye.fragment,
                            side: Zt,
                            transparent: !0,
                            uniforms: {
                                focal: { value: e.focal },
                                k1: { value: e.ck1 },
                                k2: { value: e.ck2 },
                                opacity: { value: 1 },
                                projectorMat: { value: e.basicRt },
                                projectorTex: { value: t },
                                radial_peak: {
                                    value: e.radialPeak ? e.radialPeak : 0,
                                },
                                scale_x: {
                                    value:
                                        Math.max(e.basicHeight, e.basicWidth) /
                                        e.basicWidth,
                                },
                                scale_y: {
                                    value:
                                        Math.max(e.basicWidth, e.basicHeight) /
                                        e.basicHeight,
                                },
                            },
                            vertexShader: f_.fisheye.vertex,
                        };
                    }
                    _createCurtainPlaneMaterialParametersFisheye(e, t) {
                        return {
                            depthWrite: !1,
                            fragmentShader: f_.fisheyeCurtain.fragment,
                            side: Zt,
                            transparent: !0,
                            uniforms: {
                                curtain: { value: 1 },
                                focal: { value: e.focal },
                                k1: { value: e.ck1 },
                                k2: { value: e.ck2 },
                                opacity: { value: 1 },
                                projectorMat: { value: e.basicRt },
                                projectorTex: { value: t },
                                radial_peak: {
                                    value: e.radialPeak ? e.radialPeak : 0,
                                },
                                scale_x: {
                                    value:
                                        Math.max(e.basicHeight, e.basicWidth) /
                                        e.basicWidth,
                                },
                                scale_y: {
                                    value:
                                        Math.max(e.basicWidth, e.basicHeight) /
                                        e.basicHeight,
                                },
                            },
                            vertexShader: f_.fisheyeCurtain.vertex,
                        };
                    }
                    _createCurtainPlaneMaterialParameters(e, t) {
                        return {
                            depthWrite: !1,
                            fragmentShader: f_.perspectiveCurtain.fragment,
                            side: Zt,
                            transparent: !0,
                            uniforms: {
                                curtain: { value: 1 },
                                focal: { value: e.focal },
                                k1: { value: e.ck1 },
                                k2: { value: e.ck2 },
                                opacity: { value: 1 },
                                projectorMat: { value: e.basicRt },
                                projectorTex: { value: t },
                                radial_peak: {
                                    value: e.radialPeak ? e.radialPeak : 0,
                                },
                                scale_x: {
                                    value:
                                        Math.max(e.basicHeight, e.basicWidth) /
                                        e.basicWidth,
                                },
                                scale_y: {
                                    value:
                                        Math.max(e.basicWidth, e.basicHeight) /
                                        e.basicHeight,
                                },
                            },
                            vertexShader: f_.perspectiveCurtain.vertex,
                        };
                    }
                    _createDistortedCurtainPlaneMaterialParameters(e, t) {
                        return {
                            depthWrite: !1,
                            fragmentShader:
                                f_.perspectiveDistortedCurtain.fragment,
                            side: Zt,
                            transparent: !0,
                            uniforms: {
                                curtain: { value: 1 },
                                opacity: { value: 1 },
                                projectorMat: { value: e.projectorMatrix() },
                                projectorTex: { value: t },
                            },
                            vertexShader: f_.perspectiveDistortedCurtain.vertex,
                        };
                    }
                    _createDistortedPlaneMaterialParameters(e, t) {
                        return {
                            depthWrite: !1,
                            fragmentShader: f_.perspectiveDistorted.fragment,
                            side: Zt,
                            transparent: !0,
                            uniforms: {
                                opacity: { value: 1 },
                                projectorMat: { value: e.projectorMatrix() },
                                projectorTex: { value: t },
                            },
                            vertexShader: f_.perspectiveDistorted.vertex,
                        };
                    }
                    _createTexture(e) {
                        let t = new Jr(e);
                        return (t.minFilter = Wi), (t.needsUpdate = !0), t;
                    }
                    _useMesh(e, t) {
                        return t.mesh.vertices.length && e.hasValidScale;
                    }
                    _getImageSphereGeo(e, t) {
                        const i = e.srtInverse;
                        let n = 5 * e.scale,
                            r = this._imageSphereRadius * e.scale,
                            s = t.mesh.vertices,
                            a = s.length / 3,
                            o = new Float32Array(s.length);
                        for (let e = 0; e < a; ++e) {
                            let t = 3 * e,
                                a = s[t + 0],
                                c = s[t + 1],
                                l = s[t + 2],
                                h = Math.sqrt(a * a + c * c + l * l),
                                u = Math.max(n, Math.min(h, r)) / h,
                                d = new rs(a * u, c * u, l * u);
                            d.applyMatrix4(i),
                                (o[t + 0] = d.x),
                                (o[t + 1] = d.y),
                                (o[t + 2] = d.z);
                        }
                        let c = t.mesh.faces,
                            l = new Uint16Array(c.length);
                        for (let e = 0; e < c.length; ++e) l[e] = c[e];
                        let h = new Ba();
                        return (
                            h.setAttribute("position", new Aa(o, 3)),
                            h.setIndex(new Aa(l, 1)),
                            h
                        );
                    }
                    _getImagePlaneGeo(e, t) {
                        const i = e.srtInverse;
                        let n = 5 * e.scale,
                            r = this._imagePlaneDepth * e.scale,
                            s = t.mesh.vertices,
                            a = s.length / 3,
                            o = new Float32Array(s.length);
                        for (let e = 0; e < a; ++e) {
                            let t = 3 * e,
                                a = s[t + 0],
                                c = s[t + 1],
                                l = s[t + 2];
                            e < 4 && ((a *= 3), (c *= 3));
                            let h = Math.max(n, Math.min(l, r)),
                                u = h / l,
                                d = new rs(a * u, c * u, h);
                            d.applyMatrix4(i),
                                (o[t + 0] = d.x),
                                (o[t + 1] = d.y),
                                (o[t + 2] = d.z);
                        }
                        let c = t.mesh.faces,
                            l = new Uint16Array(c.length);
                        for (let e = 0; e < c.length; ++e) l[e] = c[e];
                        let h = new Ba();
                        return (
                            h.setAttribute("position", new Aa(o, 3)),
                            h.setIndex(new Aa(l, 1)),
                            h
                        );
                    }
                    _getImagePlaneGeoFisheye(e, t) {
                        const i = e.srtInverse;
                        let n = 5 * e.scale,
                            r = this._imagePlaneDepth * e.scale,
                            s = t.mesh.vertices,
                            a = s.length / 3,
                            o = new Float32Array(s.length);
                        for (let e = 0; e < a; ++e) {
                            let t = 3 * e,
                                a = s[t + 0],
                                c = s[t + 1],
                                l = s[t + 2],
                                h = Math.sqrt(a * a + c * c + l * l),
                                u = Math.max(n, Math.min(h, r)) / h,
                                d = new rs(a * u, c * u, l * u);
                            d.applyMatrix4(i),
                                (o[t + 0] = d.x),
                                (o[t + 1] = d.y),
                                (o[t + 2] = d.z);
                        }
                        let c = t.mesh.faces,
                            l = new Uint16Array(c.length);
                        for (let e = 0; e < c.length; ++e) l[e] = c[e];
                        let h = new Ba();
                        return (
                            h.setAttribute("position", new Aa(o, 3)),
                            h.setIndex(new Aa(l, 1)),
                            h
                        );
                    }
                    _getFlatImageSphereGeo(e) {
                        const t = new sd(this._imageSphereRadius, 20, 40),
                            i = e.rt.clone().invert();
                        return t.applyMatrix4(i), t;
                    }
                    _getRegularFlatImagePlaneGeo(e) {
                        let t = e.width,
                            i = e.height,
                            n = Math.max(t, i),
                            r = t / 2 / n,
                            s = i / 2 / n;
                        return this._getFlatImagePlaneGeo(e, r, s);
                    }
                    _getFlatImagePlaneGeo(e, t, i) {
                        let n = [];
                        return (
                            n.push(
                                e.unprojectSfM([-t, -i], this._imagePlaneDepth)
                            ),
                            n.push(
                                e.unprojectSfM([t, -i], this._imagePlaneDepth)
                            ),
                            n.push(
                                e.unprojectSfM([t, i], this._imagePlaneDepth)
                            ),
                            n.push(
                                e.unprojectSfM([-t, i], this._imagePlaneDepth)
                            ),
                            this._createFlatGeometry(n)
                        );
                    }
                    _getRegularFlatImagePlaneGeoFisheye(e) {
                        let t = e.width,
                            i = e.height,
                            n = Math.max(t, i),
                            r = t / 2 / n,
                            s = i / 2 / n;
                        return this._getFlatImagePlaneGeoFisheye(e, r, s);
                    }
                    _getFlatImagePlaneGeoFisheye(e, t, i) {
                        let n = [];
                        return (
                            n.push(
                                e.unprojectSfM([-t, -i], this._imagePlaneDepth)
                            ),
                            n.push(
                                e.unprojectSfM([t, -i], this._imagePlaneDepth)
                            ),
                            n.push(
                                e.unprojectSfM([t, i], this._imagePlaneDepth)
                            ),
                            n.push(
                                e.unprojectSfM([-t, i], this._imagePlaneDepth)
                            ),
                            this._createFlatGeometry(n)
                        );
                    }
                    _getFlatImagePlaneGeoFromBasic(e, t, i, n, r) {
                        let s = [];
                        return (
                            s.push(
                                e.unprojectBasic([t, n], this._imagePlaneDepth)
                            ),
                            s.push(
                                e.unprojectBasic([i, n], this._imagePlaneDepth)
                            ),
                            s.push(
                                e.unprojectBasic([i, r], this._imagePlaneDepth)
                            ),
                            s.push(
                                e.unprojectBasic([t, r], this._imagePlaneDepth)
                            ),
                            this._createFlatGeometry(s)
                        );
                    }
                    _createFlatGeometry(e) {
                        let t = new Float32Array(12);
                        for (let i = 0; i < e.length; i++) {
                            let n = 3 * i;
                            (t[n + 0] = e[i][0]),
                                (t[n + 1] = e[i][1]),
                                (t[n + 2] = e[i][2]);
                        }
                        let i = new Uint16Array(6);
                        (i[0] = 0),
                            (i[1] = 1),
                            (i[2] = 3),
                            (i[3] = 1),
                            (i[4] = 2),
                            (i[5] = 3);
                        let n = new Ba();
                        return (
                            n.setAttribute("position", new Aa(t, 3)),
                            n.setIndex(new Aa(i, 1)),
                            n
                        );
                    }
                }
                class M_ {
                    constructor() {
                        (this._planes = {}),
                            (this._planesOld = {}),
                            (this._planesPeriphery = {}),
                            (this._scene = new ph()),
                            (this._sceneOld = new ph()),
                            (this._scenePeriphery = new ph());
                    }
                    get planes() {
                        return this._planes;
                    }
                    get planesOld() {
                        return this._planesOld;
                    }
                    get planesPeriphery() {
                        return this._planesPeriphery;
                    }
                    get scene() {
                        return this._scene;
                    }
                    get sceneOld() {
                        return this._sceneOld;
                    }
                    get scenePeriphery() {
                        return this._scenePeriphery;
                    }
                    updateImagePlanes(e) {
                        this._dispose(this._planesOld, this.sceneOld);
                        for (const e in this._planes) {
                            if (!this._planes.hasOwnProperty(e)) continue;
                            const t = this._planes[e];
                            this._scene.remove(t), this._sceneOld.add(t);
                        }
                        for (const t in e)
                            e.hasOwnProperty(t) && this._scene.add(e[t]);
                        (this._planesOld = this._planes), (this._planes = e);
                    }
                    addImagePlanes(e) {
                        for (const t in e) {
                            if (!e.hasOwnProperty(t)) continue;
                            const i = e[t];
                            this._scene.add(i), (this._planes[t] = i);
                        }
                    }
                    addImagePlanesOld(e) {
                        for (const t in e) {
                            if (!e.hasOwnProperty(t)) continue;
                            const i = e[t];
                            this._sceneOld.add(i), (this._planesOld[t] = i);
                        }
                    }
                    setImagePlanes(e) {
                        this._clear(), this.addImagePlanes(e);
                    }
                    addPeripheryPlanes(e) {
                        for (const t in e) {
                            if (!e.hasOwnProperty(t)) continue;
                            const i = e[t];
                            this._scenePeriphery.add(i),
                                (this._planesPeriphery[t] = i);
                        }
                    }
                    setPeripheryPlanes(e) {
                        this._clearPeriphery(), this.addPeripheryPlanes(e);
                    }
                    setImagePlanesOld(e) {
                        this._clearOld(), this.addImagePlanesOld(e);
                    }
                    clear() {
                        this._clear(), this._clearOld();
                    }
                    _clear() {
                        this._dispose(this._planes, this._scene),
                            (this._planes = {});
                    }
                    _clearOld() {
                        this._dispose(this._planesOld, this._sceneOld),
                            (this._planesOld = {});
                    }
                    _clearPeriphery() {
                        this._dispose(
                            this._planesPeriphery,
                            this._scenePeriphery
                        ),
                            (this._planesPeriphery = {});
                    }
                    _dispose(e, t) {
                        for (const i in e) {
                            if (!e.hasOwnProperty(i)) continue;
                            const n = e[i];
                            t.remove(n),
                                n.geometry.dispose(),
                                n.material.dispose();
                            let r = n.material.uniforms.projectorTex.value;
                            null != r && r.dispose();
                        }
                    }
                }
                class v_ {
                    constructor() {
                        (this._factory = new __()),
                            (this._scene = new M_()),
                            (this._alpha = 0),
                            (this._alphaOld = 0),
                            (this._fadeOutSpeed = 0.05),
                            (this._currentKey = null),
                            (this._previousKey = null),
                            (this._providerDisposers = {}),
                            (this._frameId = 0),
                            (this._needsRender = !1);
                    }
                    get frameId() {
                        return this._frameId;
                    }
                    get needsRender() {
                        return this._needsRender;
                    }
                    indicateNeedsRender() {
                        this._needsRender = !0;
                    }
                    addPeripheryPlane(e, t) {
                        const i = this._factory.createMesh(e, t),
                            n = {};
                        (n[e.id] = i),
                            this._scene.addPeripheryPlanes(n),
                            (this._needsRender = !0);
                    }
                    clearPeripheryPlanes() {
                        this._scene.setPeripheryPlanes({}),
                            (this._needsRender = !0);
                    }
                    updateFrame(e) {
                        this._updateFrameId(e.id),
                            (this._needsRender =
                                this._updateAlpha(e.state.alpha) ||
                                this._needsRender),
                            (this._needsRender =
                                this._updateAlphaOld(e.state.alpha) ||
                                this._needsRender),
                            (this._needsRender =
                                this._updateImagePlanes(e.state) ||
                                this._needsRender);
                    }
                    setTextureProvider(e, t) {
                        if (e !== this._currentKey) return;
                        let i = t.textureCreated$.subscribe((e) => {
                                this._updateTexture(e);
                            }),
                            n = t.textureUpdated$.subscribe((e) => {
                                this._needsRender = !0;
                            });
                        e in this._providerDisposers &&
                            ((0, this._providerDisposers[e])(),
                            delete this._providerDisposers[e]),
                            (this._providerDisposers[e] = () => {
                                i.unsubscribe(), n.unsubscribe(), t.dispose();
                            });
                    }
                    updateTextureImage(e, t) {
                        this._needsRender = !0;
                        const i = this._extend(
                            {},
                            this._scene.planes,
                            this._scene.planesOld,
                            this._scene.planesPeriphery
                        );
                        for (const n in i) {
                            if (!i.hasOwnProperty(n)) continue;
                            if (n !== t.id) continue;
                            let r = i[n].material.uniforms.projectorTex.value;
                            (r.image = e), (r.needsUpdate = !0);
                        }
                    }
                    render(e, t) {
                        const i = this._scene.planes,
                            n = this._scene.planesOld,
                            r = this._scene.planesPeriphery,
                            s = Object.keys(n).length ? 1 : this._alpha,
                            a = Object.keys(n).length
                                ? 1
                                : Math.floor(this._alpha);
                        for (const e in i)
                            i.hasOwnProperty(e) &&
                                (i[e].material.uniforms.opacity.value = s);
                        for (const e in n)
                            n.hasOwnProperty(e) &&
                                (n[e].material.uniforms.opacity.value =
                                    this._alphaOld);
                        for (const e in r)
                            r.hasOwnProperty(e) &&
                                (r[e].material.uniforms.opacity.value = a);
                        t.render(this._scene.scenePeriphery, e),
                            t.render(this._scene.scene, e),
                            t.render(this._scene.sceneOld, e);
                        for (const e in i)
                            i.hasOwnProperty(e) &&
                                (i[e].material.uniforms.opacity.value =
                                    this._alpha);
                        t.render(this._scene.scene, e);
                    }
                    clearNeedsRender() {
                        this._needsRender = !1;
                    }
                    dispose() {
                        this._scene.clear();
                    }
                    _updateFrameId(e) {
                        this._frameId = e;
                    }
                    _updateAlpha(e) {
                        return e !== this._alpha && ((this._alpha = e), !0);
                    }
                    _updateAlphaOld(e) {
                        return !(
                            e < 1 ||
                            0 === this._alphaOld ||
                            ((this._alphaOld = Math.max(
                                0,
                                this._alphaOld - this._fadeOutSpeed
                            )),
                            0)
                        );
                    }
                    _updateImagePlanes(e) {
                        if (
                            null == e.currentImage ||
                            e.currentImage.id === this._currentKey
                        )
                            return !1;
                        let t =
                                null != e.previousImage
                                    ? e.previousImage.id
                                    : null,
                            i = e.currentImage.id;
                        if (
                            (this._previousKey !== t &&
                                this._previousKey !== i &&
                                this._previousKey in this._providerDisposers &&
                                ((0,
                                this._providerDisposers[this._previousKey])(),
                                delete this._providerDisposers[
                                    this._previousKey
                                ]),
                            null != t)
                        ) {
                            if (
                                t !== this._currentKey &&
                                t !== this._previousKey
                            ) {
                                let i = this._factory.createMesh(
                                    e.previousImage,
                                    e.previousTransform
                                );
                                const n = {};
                                (n[t] = i), this._scene.updateImagePlanes(n);
                            }
                            this._previousKey = t;
                        }
                        this._currentKey = i;
                        let n = this._factory.createMesh(
                            e.currentImage,
                            e.currentTransform
                        );
                        const r = {};
                        return (
                            (r[i] = n),
                            this._scene.updateImagePlanes(r),
                            (this._alphaOld = 1),
                            !0
                        );
                    }
                    _updateTexture(e) {
                        this._needsRender = !0;
                        const t = this._scene.planes;
                        for (const i in t) {
                            if (!t.hasOwnProperty(i)) continue;
                            let n = t[i].material,
                                r = n.uniforms.projectorTex.value;
                            (n.uniforms.projectorTex.value = null),
                                r.dispose(),
                                (n.uniforms.projectorTex.value = e);
                        }
                    }
                    _extend(e, ...t) {
                        for (const i of t)
                            for (const t in i)
                                i.hasOwnProperty(t) && (e[t] = i[t]);
                        return e;
                    }
                }
                !(function (e) {
                    (e[(e.Background = 0)] = "Background"),
                        (e[(e.Opaque = 1)] = "Opaque");
                })(i_ || (i_ = {}));
                class y_ {
                    constructor(e) {
                        (this._api = e), (this._urls$ = new Map());
                    }
                    getImage$(e) {
                        let t;
                        const i = new Promise((e, i) => {
                            t = i;
                        });
                        return [
                            $.create((n) => {
                                this._api.data.getImageBuffer(e, i).then(
                                    (e) => {
                                        t = null;
                                        const i = new Image();
                                        (i.crossOrigin = "Anonymous"),
                                            (i.onload = () => {
                                                window.URL.revokeObjectURL(
                                                    i.src
                                                ),
                                                    n.next(i),
                                                    n.complete();
                                            }),
                                            (i.onerror = () => {
                                                (t = null),
                                                    window.URL.revokeObjectURL(
                                                        i.src
                                                    ),
                                                    n.error(
                                                        new Error(
                                                            "Failed to load image tile"
                                                        )
                                                    );
                                            });
                                        const r = new Blob([e]);
                                        i.src = window.URL.createObjectURL(r);
                                    },
                                    (e) => {
                                        (t = null), n.error(e);
                                    }
                                );
                            }),
                            () => {
                                t && t();
                            },
                        ];
                    }
                    getURLs$(e, t) {
                        const i = this._inventId(e, t);
                        if (this._urls$.has(i)) return this._urls$.get(i);
                        const n = { imageId: e, z: t },
                            r = this._api.getImageTiles$(n).pipe(
                                ke((e) => e.node),
                                xt(() => {
                                    this._urls$.delete(i);
                                }),
                                Dt(),
                                V()
                            );
                        return this._urls$.set(i, r), r;
                    }
                    _inventId(e, t) {
                        return `${e}-${t}`;
                    }
                }
                class x_ {
                    constructor() {
                        (this._tiles = new Map()),
                            (this._urlLevels = new Set()),
                            (this._urls = new Map());
                    }
                    add(e, t) {
                        if (this._tiles.has(e))
                            throw new Error(`Image tile already stored (${e})`);
                        this._tiles.set(e, t);
                    }
                    addURLs(e, t) {
                        const i = this._urls;
                        for (const e of t) {
                            const t = this.inventId(e);
                            if (this._urls.has(t))
                                throw new Error(`URL already stored (${t})`);
                            i.set(t, e.url);
                        }
                        this._urlLevels.add(e);
                    }
                    dispose() {
                        this._tiles.forEach((e) =>
                            window.URL.revokeObjectURL(e.src)
                        ),
                            this._tiles.clear(),
                            this._urls.clear(),
                            this._urlLevels.clear();
                    }
                    get(e) {
                        return this._tiles.get(e);
                    }
                    getURL(e) {
                        return this._urls.get(e);
                    }
                    has(e) {
                        return this._tiles.has(e);
                    }
                    hasURL(e) {
                        return this._urls.has(e);
                    }
                    hasURLLevel(e) {
                        return this._urlLevels.has(e);
                    }
                    inventId(e) {
                        return `${e.z}-${e.x}-${e.y}`;
                    }
                }
                class b_ {
                    constructor() {
                        this._viewportCoords = new l_();
                    }
                    computeRegionOfInterest(e, t, i) {
                        const n = this._viewportBoundaryPoints(4),
                            r = this._viewportPointsBoundingBox(n, e, i);
                        this._clipBoundingBox(r);
                        const s = 2 / t.width,
                            a = 2 / t.height,
                            o = [
                                [-0.5 * s, 0.5 * a],
                                [0.5 * s, 0.5 * a],
                                [0.5 * s, -0.5 * a],
                                [-0.5 * s, -0.5 * a],
                            ],
                            c = this._viewportPointsBoundingBox(o, e, i),
                            l = c.minX < c.maxX;
                        return {
                            bbox: r,
                            pixelHeight: c.maxY - c.minY,
                            pixelWidth: c.maxX - c.minX + (l ? 0 : 1),
                        };
                    }
                    _viewportBoundaryPoints(e) {
                        const t = [],
                            i = [
                                [-1, 1],
                                [1, 1],
                                [1, -1],
                                [-1, -1],
                            ],
                            n = [
                                [2, 0],
                                [0, -2],
                                [-2, 0],
                                [0, 2],
                            ];
                        for (let r = 0; r < 4; ++r) {
                            const s = i[r],
                                a = n[r];
                            for (let i = 0; i < e; ++i)
                                t.push([
                                    s[0] + (a[0] * i) / e,
                                    s[1] + (a[1] * i) / e,
                                ]);
                        }
                        return t;
                    }
                    _viewportPointsBoundingBox(e, t, i) {
                        const n = e.map((e) =>
                            this._viewportCoords.viewportToBasic(
                                e[0],
                                e[1],
                                i,
                                t.perspective
                            )
                        );
                        return jp(i.cameraType)
                            ? this._boundingBoxSpherical(n)
                            : this._boundingBox(n);
                    }
                    _boundingBox(e) {
                        const t = {
                            maxX: Number.NEGATIVE_INFINITY,
                            maxY: Number.NEGATIVE_INFINITY,
                            minX: Number.POSITIVE_INFINITY,
                            minY: Number.POSITIVE_INFINITY,
                        };
                        for (let i = 0; i < e.length; ++i)
                            (t.minX = Math.min(t.minX, e[i][0])),
                                (t.maxX = Math.max(t.maxX, e[i][0])),
                                (t.minY = Math.min(t.minY, e[i][1])),
                                (t.maxY = Math.max(t.maxY, e[i][1]));
                        return t;
                    }
                    _boundingBoxSpherical(e) {
                        const t = [],
                            i = [];
                        for (let n = 0; n < e.length; ++n)
                            t.push(e[n][0]), i.push(e[n][1]);
                        t.sort((e, t) => this._sign(e - t)),
                            i.sort((e, t) => this._sign(e - t));
                        const n = this._intervalSpherical(t);
                        return {
                            maxX: n[1],
                            maxY: i[i.length - 1],
                            minX: n[0],
                            minY: i[0],
                        };
                    }
                    _intervalSpherical(e) {
                        let t = 0,
                            i = -1;
                        for (let n = 0; n < e.length - 1; ++n) {
                            const r = e[n + 1] - e[n];
                            r > t && ((t = r), (i = n));
                        }
                        return e[0] + 1 - e[e.length - 1] > t
                            ? [e[0], e[e.length - 1]]
                            : [e[i + 1], e[i]];
                    }
                    _clipBoundingBox(e) {
                        (e.minX = Math.max(0, Math.min(1, e.minX))),
                            (e.maxX = Math.max(0, Math.min(1, e.maxX))),
                            (e.minY = Math.max(0, Math.min(1, e.minY))),
                            (e.maxY = Math.max(0, Math.min(1, e.maxY)));
                    }
                    _sign(e) {
                        return e > 0 ? 1 : e < 0 ? -1 : 0;
                    }
                }
                const w_ = 1024;
                function T_(e, t, i) {
                    return Math.max(t, Math.min(i, e));
                }
                function S_(e) {
                    return w_ / N_(e);
                }
                function N_(e) {
                    return Math.pow(2, e.z - e.max);
                }
                function D_(e) {
                    return Math.ceil(
                        (function (e) {
                            const t = Math.max(e.w, e.h);
                            return Math.log(t) / Math.log(2);
                        })(e)
                    );
                }
                function I_(e, t, i) {
                    const n = S_(i),
                        r = t.w,
                        s = t.h,
                        a = Math.ceil(r / n) - 1,
                        o = Math.ceil(s / n) - 1;
                    return {
                        x: T_(Math.floor((r * e[0]) / n), 0, a),
                        y: T_(Math.floor((s * e[1]) / n), 0, o),
                    };
                }
                function C_(e, t, i) {
                    const n = (1 / N_(i)) * w_,
                        r = n * e.x,
                        s = n * e.y,
                        a = Math.min(n, t.w - r);
                    return { h: Math.min(n, t.h - s), x: r, y: s, w: a };
                }
                function A_(e, t, i) {
                    return i * e <= t && t < i * (e + 1);
                }
                function E_(e, t) {
                    if (e.z === t.z) return e.x === t.x && e.y === t.y;
                    const i = e.z < t.z ? e : t,
                        n = e.z < t.z ? t : e,
                        r = 1 / N_({ max: n.z, z: i.z }),
                        s = A_(i.x, n.x, r),
                        a = A_(i.y, n.y, r);
                    return s && a;
                }
                function L_(e) {
                    return e.w > 0 && e.h > 0;
                }
                class z_ {
                    constructor(e, t, i, n, r, s, a) {
                        const o = { h: i, w: t };
                        L_(o) ||
                            console.warn(
                                `Original image size (${t}, ${i}) is invalid (${e}). Tiles will not be loaded.`
                            ),
                            (this._imageId = e),
                            (this._size = o),
                            (this._level = { max: D_(this._size), z: -1 }),
                            (this._holder = new s_()),
                            (this._updated$ = new W()),
                            (this._createdSubject$ = new W()),
                            (this._created$ = this._createdSubject$.pipe(
                                It(1),
                                V()
                            )),
                            this._holder.push(
                                this._created$.subscribe(() => {})
                            ),
                            (this._hasSubject$ = new W()),
                            (this._has$ = this._hasSubject$.pipe(
                                Ot(!1),
                                It(1),
                                V()
                            )),
                            this._holder.push(this._has$.subscribe(() => {})),
                            (this._renderedLevel = new Set()),
                            (this._rendered = new Map()),
                            (this._subscriptions = new Map()),
                            (this._urlSubscriptions = new Map()),
                            (this._loader = r),
                            (this._store = s),
                            (this._background = n),
                            (this._renderer = a),
                            (this._aborts = []),
                            (this._render = null),
                            (this._disposed = !1);
                    }
                    get disposed() {
                        return this._disposed;
                    }
                    get hasTexture$() {
                        return this._has$;
                    }
                    get id() {
                        return this._imageId;
                    }
                    get textureUpdated$() {
                        return this._updated$;
                    }
                    get textureCreated$() {
                        return this._created$;
                    }
                    abort() {
                        this._subscriptions.forEach((e) => e.unsubscribe()),
                            this._subscriptions.clear();
                        for (const e of this._aborts) e();
                        this._aborts = [];
                    }
                    dispose() {
                        this._disposed
                            ? console.warn(
                                  `Texture already disposed (${this._imageId})`
                              )
                            : (this._urlSubscriptions.forEach((e) =>
                                  e.unsubscribe()
                              ),
                              this._urlSubscriptions.clear(),
                              this.abort(),
                              null != this._render &&
                                  (this._render.target.dispose(),
                                  (this._render.target = null),
                                  (this._render.camera = null),
                                  (this._render = null)),
                              this._store.dispose(),
                              this._holder.unsubscribe(),
                              this._renderedLevel.clear(),
                              (this._background = null),
                              (this._renderer = null),
                              (this._disposed = !0));
                    }
                    setRegionOfInterest(e) {
                        if (!L_(this._size)) return;
                        const t = 1 / e.pixelWidth,
                            i = (function (e, t, i) {
                                return Math.max(11, Math.min(i, D_(e)));
                            })(
                                { h: 1 / e.pixelHeight, w: t },
                                0,
                                this._level.max
                            );
                        i !== this._level.z &&
                            (this.abort(),
                            (this._level.z = i),
                            this._renderedLevel.clear(),
                            this._rendered.forEach((e, t) => {
                                e.z === i && this._renderedLevel.add(t);
                            })),
                            null == this._render && this._initRender();
                        const n = (function (e, t, i, n) {
                            const r = [];
                            if (e.x > t.x) {
                                const s = S_(n),
                                    a = Math.ceil(i.w / s) - 1;
                                for (let t = e.x; t <= a; t++) r.push(t);
                                for (let e = 0; e <= t.x; e++) r.push(e);
                            } else for (let i = e.x; i <= t.x; i++) r.push(i);
                            const s = [];
                            for (const i of r)
                                for (let n = e.y; n <= t.y; n++)
                                    s.push({ x: i, y: n });
                            return s;
                        })(
                            I_(
                                [e.bbox.minX, e.bbox.minY],
                                this._size,
                                this._level
                            ),
                            I_(
                                [e.bbox.maxX, e.bbox.maxY],
                                this._size,
                                this._level
                            ),
                            this._size,
                            this._level
                        );
                        this._fetchTiles(i, n);
                    }
                    _fetchTile(e) {
                        const t = this._loader.getImage$(e.url),
                            i = t[0],
                            n = t[1];
                        this._aborts.push(n);
                        const r = this._store.inventId(e),
                            s = i.subscribe(
                                (t) => {
                                    const i = C_(e, this._size, this._level);
                                    this._renderToTarget(i, t),
                                        this._subscriptions.delete(r),
                                        this._removeFromArray(n, this._aborts),
                                        this._markRendered(e),
                                        this._store.add(r, t),
                                        this._updated$.next(!0);
                                },
                                (e) => {
                                    this._subscriptions.delete(r),
                                        this._removeFromArray(n, this._aborts),
                                        console.error(e);
                                }
                            );
                        s.closed || this._subscriptions.set(r, s);
                    }
                    _fetchTiles(e, t) {
                        const i = (
                            this._store.hasURLLevel(e)
                                ? Ce(void 0)
                                : this._loader.getURLs$(this._imageId, e).pipe(
                                      Ut((t) => {
                                          this._store.hasURLLevel(e) ||
                                              this._store.addURLs(e, t);
                                      })
                                  )
                        ).subscribe(
                            () => {
                                if (e === this._level.z) {
                                    for (const i of t) {
                                        const t = {
                                                x: i.x,
                                                y: i.y,
                                                z: e,
                                                url: null,
                                            },
                                            n = this._store.inventId(t);
                                        if (
                                            !this._renderedLevel.has(n) &&
                                            !this._subscriptions.has(n)
                                        )
                                            if (this._store.has(n)) {
                                                const e = C_(
                                                    i,
                                                    this._size,
                                                    this._level
                                                );
                                                this._renderToTarget(
                                                    e,
                                                    this._store.get(n)
                                                ),
                                                    this._markRendered(t),
                                                    this._updated$.next(!0);
                                            } else
                                                (t.url = this._store.getURL(n)),
                                                    this._fetchTile(t);
                                    }
                                    this._urlSubscriptions.delete(e);
                                }
                            },
                            (t) => {
                                this._urlSubscriptions.delete(e),
                                    console.error(t);
                            }
                        );
                        i.closed || this._urlSubscriptions.set(e, i);
                    }
                    _initRender() {
                        const e = this._size.w / 2,
                            t = this._size.h / 2,
                            i = new Po(-e, e, t, -t, -1, 1);
                        i.position.z = 1;
                        const n = this._renderer.getContext(),
                            r = n.getParameter(n.MAX_TEXTURE_SIZE),
                            s = Math.max(this._size.w, this._size.h),
                            a = r > s ? 1 : r / s,
                            o = Math.floor(a * this._size.w),
                            c = Math.floor(a * this._size.h),
                            l = new ts(o, c, {
                                depthBuffer: !1,
                                format: un,
                                magFilter: Wi,
                                minFilter: Wi,
                                stencilBuffer: !1,
                            });
                        this._render = { camera: i, target: l };
                        const h = C_({ x: 0, y: 0 }, this._size, {
                            max: this._level.max,
                            z: 0,
                        });
                        this._renderToTarget(h, this._background),
                            this._createdSubject$.next(l.texture),
                            this._hasSubject$.next(!0);
                    }
                    _markRendered(e) {
                        const t = Array.from(this._rendered.entries()).filter(
                            ([t, i]) => i.z !== e.z
                        );
                        for (const [i, n] of t)
                            E_(e, n) && this._rendered.delete(i);
                        const i = this._store.inventId(e);
                        this._rendered.set(i, e), this._renderedLevel.add(i);
                    }
                    _removeFromArray(e, t) {
                        const i = t.indexOf(e);
                        -1 !== i && t.splice(i, 1);
                    }
                    _renderToTarget(e, t) {
                        const i = new Jr(t);
                        (i.minFilter = Wi), (i.needsUpdate = !0);
                        const n = new Io(e.w, e.h),
                            r = new Da({ map: i, side: Wt }),
                            s = new so(n, r);
                        (s.position.x = -this._size.w / 2 + e.x + e.w / 2),
                            (s.position.y = this._size.h / 2 - e.y - e.h / 2);
                        const a = new ph();
                        a.add(s);
                        const o = this._renderer.getRenderTarget();
                        this._renderer.resetState(),
                            this._renderer.setRenderTarget(this._render.target),
                            this._renderer.render(a, this._render.camera),
                            this._renderer.setRenderTarget(o),
                            a.remove(s),
                            n.dispose(),
                            r.dispose(),
                            i.dispose();
                    }
                }
                var j_, O_, k_, R_, P_, U_, $_;
                !(function (e) {
                    (e[(e.Custom = 0)] = "Custom"),
                        (e[(e.Earth = 1)] = "Earth"),
                        (e[(e.Traversing = 2)] = "Traversing"),
                        (e[(e.Waiting = 3)] = "Waiting"),
                        (e[(e.WaitingInteractively = 4)] =
                            "WaitingInteractively");
                })(j_ || (j_ = {}));
                class B_ extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i),
                            (this._imageTileLoader = new y_(i.api)),
                            (this._roiCalculator = new b_()),
                            (this._rendererOperation$ = new W()),
                            (this._rendererCreator$ = new W()),
                            (this._rendererDisposer$ = new W()),
                            (this._renderer$ = this._rendererOperation$.pipe(
                                At((e, t) => t(e), null),
                                nt((e) => null != e),
                                ft(void 0, (e) => e.frameId)
                            )),
                            this._rendererCreator$
                                .pipe(
                                    ke(() => (e) => {
                                        if (null != e)
                                            throw new Error(
                                                "Multiple image plane states can not be created at the same time"
                                            );
                                        return new v_();
                                    })
                                )
                                .subscribe(this._rendererOperation$),
                            this._rendererDisposer$
                                .pipe(ke(() => (e) => (e.dispose(), null)))
                                .subscribe(this._rendererOperation$);
                    }
                    _activate() {
                        const e = this._subscriptions;
                        e.push(
                            this._renderer$
                                .pipe(
                                    ke((e) => {
                                        const t = {
                                            name: this._name,
                                            renderer: {
                                                frameId: e.frameId,
                                                needsRender: e.needsRender,
                                                render: e.render.bind(e),
                                                pass: i_.Background,
                                            },
                                        };
                                        return e.clearNeedsRender(), t;
                                    })
                                )
                                .subscribe(this._container.glRenderer.render$)
                        ),
                            this._rendererCreator$.next(null),
                            e.push(
                                this._navigator.stateService.currentState$
                                    .pipe(
                                        ke((e) => (t) => (t.updateFrame(e), t))
                                    )
                                    .subscribe(this._rendererOperation$)
                            );
                        const t =
                            this._container.configurationService.imageTiling$.pipe(
                                kt((e) =>
                                    e
                                        ? this._navigator.stateService
                                              .currentState$
                                        : new W()
                                ),
                                ft(void 0, (e) => e.state.currentImage.id),
                                $t(this._container.glRenderer.webGLRenderer$),
                                ke(([e, t]) => {
                                    const i = e.state,
                                        n = i.currentImage,
                                        r = i.currentTransform;
                                    return new z_(
                                        n.id,
                                        r.basicWidth,
                                        r.basicHeight,
                                        n.image,
                                        this._imageTileLoader,
                                        new x_(),
                                        t
                                    );
                                }),
                                It(1),
                                V()
                            );
                        e.push(t.subscribe(() => {})),
                            e.push(
                                t
                                    .pipe(
                                        ke(
                                            (e) => (t) => (
                                                t.setTextureProvider(e.id, e), t
                                            )
                                        )
                                    )
                                    .subscribe(this._rendererOperation$)
                            ),
                            e.push(
                                t.pipe(Nt()).subscribe((e) => {
                                    e[0].abort();
                                })
                            );
                        const i =
                            this._container.configurationService.imageTiling$.pipe(
                                kt((e) =>
                                    e
                                        ? He(
                                              this._navigator.stateService
                                                  .state$,
                                              this._navigator.stateService
                                                  .inTranslation$
                                          )
                                        : new W()
                                ),
                                kt(([e, t]) =>
                                    (e !== j_.Traversing &&
                                        e !== j_.Waiting &&
                                        e !== j_.WaitingInteractively) ||
                                    t
                                        ? oe()
                                        : this._container.renderService
                                              .renderCameraFrame$
                                ),
                                ke((e) => ({
                                    camera: e,
                                    height: e.size.height.valueOf(),
                                    lookat: e.camera.lookat.clone(),
                                    width: e.size.width.valueOf(),
                                    zoom: e.zoom.valueOf(),
                                })),
                                Nt(),
                                ke(([e, t]) => {
                                    const i =
                                        e.width === t.width &&
                                        e.height === t.height &&
                                        e.zoom === t.zoom &&
                                        e.lookat.equals(t.lookat);
                                    return { camera: t.camera, stalled: i };
                                }),
                                ft((e, t) => e.stalled === t.stalled),
                                nt((e) => e.stalled),
                                $t(
                                    this._container.renderService.size$,
                                    this._navigator.stateService
                                        .currentTransform$
                                )
                            );
                        e.push(
                            t
                                .pipe(
                                    kt((e) =>
                                        i.pipe(
                                            ke(([t, i, n]) => {
                                                const r = t.camera,
                                                    s =
                                                        new l_().viewportToBasic(
                                                            0,
                                                            0,
                                                            n,
                                                            r.perspective
                                                        );
                                                if (
                                                    !(
                                                        s[0] < 0 ||
                                                        s[1] < 0 ||
                                                        s[0] > 1 ||
                                                        s[1] > 1
                                                    )
                                                )
                                                    return [
                                                        this._roiCalculator.computeRegionOfInterest(
                                                            r,
                                                            i,
                                                            n
                                                        ),
                                                        e,
                                                    ];
                                            }),
                                            nt((e) => !!e)
                                        )
                                    ),
                                    nt((e) => !e[1].disposed)
                                )
                                .subscribe(([e, t]) => {
                                    t.setRegionOfInterest(e);
                                })
                        );
                        const n = t.pipe(
                            kt((e) => e.hasTexture$),
                            Ot(!1),
                            It(1),
                            V()
                        );
                        e.push(n.subscribe(() => {})),
                            e.push(
                                this._navigator.panService.panImages$
                                    .pipe(
                                        nt((e) => 0 === e.length),
                                        ke(
                                            () => (e) => (
                                                e.clearPeripheryPlanes(), e
                                            )
                                        )
                                    )
                                    .subscribe(this._rendererOperation$)
                            );
                        const r = this._navigator.panService.panImages$.pipe(
                            kt((e) =>
                                ye(e).pipe(
                                    Ye(([e, t]) =>
                                        He(
                                            this._navigator.graphService
                                                .cacheImage$(e.id)
                                                .pipe(
                                                    ot(
                                                        (t) => (
                                                            console.error(
                                                                `Failed to cache periphery image (${e.id})`,
                                                                t
                                                            ),
                                                            oe()
                                                        )
                                                    )
                                                ),
                                            Ce(t)
                                        )
                                    )
                                )
                            ),
                            Et()
                        );
                        e.push(
                            r
                                .pipe(
                                    ke(
                                        ([e, t]) =>
                                            (i) => (
                                                i.addPeripheryPlane(e, t), i
                                            )
                                    )
                                )
                                .subscribe(this._rendererOperation$)
                        ),
                            e.push(
                                r
                                    .pipe(
                                        Ye(([e]) =>
                                            e.cacheImage$().pipe(ot(() => oe()))
                                        ),
                                        ke(
                                            (e) => (t) => (
                                                t.updateTextureImage(
                                                    e.image,
                                                    e
                                                ),
                                                t
                                            )
                                        )
                                    )
                                    .subscribe(this._rendererOperation$)
                            );
                        const s =
                                this._navigator.stateService.currentState$.pipe(
                                    ke((e) => e.state.alpha < 1),
                                    ft()
                                ),
                            a = He(
                                this._container.mouseService.active$,
                                this._container.touchService.active$,
                                this._navigator.stateService.inMotion$,
                                s
                            ).pipe(
                                ke(([e, t, i, n]) => !(e || t || i || n)),
                                nt((e) => e)
                            );
                        e.push(
                            this._navigator.stateService.state$
                                .pipe(
                                    kt((e) =>
                                        e === j_.Traversing
                                            ? this._navigator.panService
                                                  .panImages$
                                            : oe()
                                    ),
                                    kt((e) =>
                                        a.pipe(
                                            $t(
                                                this._container.renderService
                                                    .renderCamera$,
                                                this._navigator.stateService
                                                    .currentImage$,
                                                this._navigator.stateService
                                                    .currentTransform$
                                            ),
                                            Ye(([, t, i, n]) =>
                                                Ce([t, i, n, e])
                                            )
                                        )
                                    ),
                                    kt(([e, t, i, n]) => {
                                        const r = e.camera.lookat
                                                .clone()
                                                .sub(e.camera.position),
                                            s = [
                                                new Lp()
                                                    .viewingDirection(
                                                        t.rotation
                                                    )
                                                    .angleTo(r),
                                                void 0,
                                            ],
                                            a = new l_().viewportToBasic(
                                                0,
                                                0,
                                                i,
                                                e.perspective
                                            );
                                        a[0] >= 0 &&
                                            a[0] <= 1 &&
                                            a[1] >= 0 &&
                                            a[1] <= 1 &&
                                            (s[0] = Number.NEGATIVE_INFINITY);
                                        for (const [e] of n) {
                                            const t = new Lp()
                                                .viewingDirection(e.rotation)
                                                .angleTo(r);
                                            t < s[0] &&
                                                ((s[0] = t), (s[1] = e.id));
                                        }
                                        return s[1]
                                            ? this._navigator
                                                  .moveTo$(s[1])
                                                  .pipe(ot(() => oe()))
                                            : oe();
                                    })
                                )
                                .subscribe()
                        );
                    }
                    _deactivate() {
                        this._rendererDisposer$.next(null),
                            this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return {};
                    }
                }
                B_.componentName = "image";
                class F_ {
                    constructor(e, t, i) {
                        (this._component = e),
                            (this._container = t),
                            (this._navigator = i),
                            (this._enabled = !1);
                    }
                    get isEnabled() {
                        return this._enabled;
                    }
                    enable() {
                        !this._enabled &&
                            this._component.activated &&
                            (this._enable(),
                            (this._enabled = !0),
                            this._component.configure(
                                this._getConfiguration(!0)
                            ));
                    }
                    disable() {
                        this._enabled &&
                            (this._disable(),
                            (this._enabled = !1),
                            this._component.activated &&
                                this._component.configure(
                                    this._getConfiguration(!1)
                                ));
                    }
                }
                class H_ extends F_ {
                    _enable() {
                        const e =
                            this._navigator.stateService.currentImage$.pipe(
                                kt((e) => e.sequenceEdges$)
                            );
                        this._keyDownSubscription =
                            this._container.keyboardService.keyDown$
                                .pipe($t(e))
                                .subscribe(([e, t]) => {
                                    let i = null;
                                    switch (e.keyCode) {
                                        case 38:
                                            i = Dp.Next;
                                            break;
                                        case 40:
                                            i = Dp.Prev;
                                            break;
                                        default:
                                            return;
                                    }
                                    if (
                                        (e.preventDefault(),
                                        e.altKey && !e.shiftKey && t.cached)
                                    )
                                        for (const e of t.edges)
                                            if (e.data.direction === i)
                                                return void this._navigator
                                                    .moveTo$(e.target)
                                                    .subscribe(void 0, (e) => {
                                                        e instanceof d_ ||
                                                            console.error(e);
                                                    });
                                });
                    }
                    _disable() {
                        this._keyDownSubscription.unsubscribe();
                    }
                    _getConfiguration(e) {
                        return { keySequenceNavigation: e };
                    }
                }
                class G_ extends F_ {
                    constructor(e, t, i, n) {
                        super(e, t, i), (this._spatial = n);
                    }
                    _enable() {
                        const e =
                            this._navigator.stateService.currentImage$.pipe(
                                kt((e) => e.spatialEdges$)
                            );
                        this._keyDownSubscription =
                            this._container.keyboardService.keyDown$
                                .pipe(
                                    $t(
                                        e,
                                        this._navigator.stateService
                                            .currentState$
                                    )
                                )
                                .subscribe(([e, t, i]) => {
                                    let n = jp(i.state.currentImage.cameraType),
                                        r = null;
                                    switch (e.keyCode) {
                                        case 37:
                                            r =
                                                e.shiftKey && !n
                                                    ? Dp.TurnLeft
                                                    : Dp.StepLeft;
                                            break;
                                        case 38:
                                            r =
                                                e.shiftKey && !n
                                                    ? Dp.Spherical
                                                    : Dp.StepForward;
                                            break;
                                        case 39:
                                            r =
                                                e.shiftKey && !n
                                                    ? Dp.TurnRight
                                                    : Dp.StepRight;
                                            break;
                                        case 40:
                                            r =
                                                e.shiftKey && !n
                                                    ? Dp.TurnU
                                                    : Dp.StepBackward;
                                            break;
                                        default:
                                            return;
                                    }
                                    if (
                                        (e.preventDefault(),
                                        !(
                                            e.altKey ||
                                            !t.cached ||
                                            (e.shiftKey && n)
                                        ))
                                    )
                                        if (n) {
                                            const e = {};
                                            (e[Dp.StepBackward] = Math.PI),
                                                (e[Dp.StepForward] = 0),
                                                (e[Dp.StepLeft] = Math.PI / 2),
                                                (e[Dp.StepRight] =
                                                    -Math.PI / 2);
                                            const n = this._rotationFromCamera(
                                                    i.state.camera
                                                ).phi,
                                                s = this._spatial.wrapAngle(
                                                    n + e[r]
                                                ),
                                                a = Math.PI / 4,
                                                o = t.edges.filter(
                                                    (e) =>
                                                        e.data.direction ===
                                                            Dp.Spherical ||
                                                        e.data.direction === r
                                                );
                                            let c = Number.MAX_VALUE,
                                                l = null;
                                            for (const e of o) {
                                                const t = Math.abs(
                                                    this._spatial.wrapAngle(
                                                        e.data
                                                            .worldMotionAzimuth -
                                                            s
                                                    )
                                                );
                                                t < Math.min(c, a) &&
                                                    ((c = t), (l = e.target));
                                            }
                                            if (null == l) return;
                                            this._moveTo(l);
                                        } else this._moveDir(r, t);
                                });
                    }
                    _disable() {
                        this._keyDownSubscription.unsubscribe();
                    }
                    _getConfiguration(e) {
                        return { keySpatialNavigation: e };
                    }
                    _moveDir(e, t) {
                        for (const i of t.edges)
                            if (i.data.direction === e)
                                return void this._moveTo(i.target);
                    }
                    _moveTo(e) {
                        this._navigator.moveTo$(e).subscribe(void 0, (e) => {
                            e instanceof d_ || console.error(e);
                        });
                    }
                    _rotationFromCamera(e) {
                        let t = e.lookat.clone().sub(e.position),
                            i = t.clone().dot(e.up),
                            n = t.clone().sub(e.up.clone().multiplyScalar(i));
                        return {
                            phi: Math.atan2(n.y, n.x),
                            theta:
                                Math.PI / 2 -
                                this._spatial.angleToPlane(
                                    t.toArray(),
                                    [0, 0, 1]
                                ),
                        };
                    }
                }
                class V_ extends F_ {
                    constructor(e, t, i, n) {
                        super(e, t, i), (this._viewportCoords = n);
                    }
                    _enable() {
                        this._keyDownSubscription =
                            this._container.keyboardService.keyDown$
                                .pipe(
                                    $t(
                                        this._container.renderService
                                            .renderCamera$,
                                        this._navigator.stateService
                                            .currentTransform$
                                    )
                                )
                                .subscribe(([e, t, i]) => {
                                    if (e.altKey || e.ctrlKey || e.metaKey)
                                        return;
                                    let n = 0;
                                    switch (e.key) {
                                        case "+":
                                            n = 1;
                                            break;
                                        case "-":
                                            n = -1;
                                            break;
                                        default:
                                            return;
                                    }
                                    e.preventDefault();
                                    const r =
                                            this._viewportCoords.unprojectFromViewport(
                                                0,
                                                0,
                                                t.perspective
                                            ),
                                        s = i.projectBasic(r.toArray());
                                    this._navigator.stateService.zoomIn(n, s);
                                });
                    }
                    _disable() {
                        this._keyDownSubscription.unsubscribe();
                    }
                    _getConfiguration(e) {
                        return { keyZoom: e };
                    }
                }
                class Y_ extends F_ {
                    _enable() {
                        this._keyDownSubscription =
                            this._container.keyboardService.keyDown$
                                .pipe(
                                    $t(
                                        this._navigator.playService.playing$,
                                        this._navigator.playService.direction$,
                                        this._navigator.playService.speed$,
                                        this._navigator.stateService.currentImage$.pipe(
                                            kt((e) => e.sequenceEdges$)
                                        ),
                                        this._navigator.stateService.state$.pipe(
                                            ke((e) => e === j_.Earth),
                                            ft()
                                        )
                                    )
                                )
                                .subscribe(([e, t, i, n, r, s]) => {
                                    if (!(e.altKey || e.ctrlKey || e.metaKey)) {
                                        switch (e.key) {
                                            case "D":
                                                if (!e.shiftKey) return;
                                                const a = t
                                                    ? null
                                                    : i === Dp.Next
                                                    ? Dp.Prev
                                                    : i === Dp.Prev
                                                    ? Dp.Next
                                                    : null;
                                                null != a &&
                                                    this._navigator.playService.setDirection(
                                                        a
                                                    );
                                                break;
                                            case " ":
                                                if (e.shiftKey) return;
                                                if (!s)
                                                    if (t)
                                                        this._navigator.playService.stop();
                                                    else
                                                        for (let e of r.edges)
                                                            e.data.direction ===
                                                                i &&
                                                                this._navigator.playService.play();
                                                break;
                                            case "<":
                                                this._navigator.playService.setSpeed(
                                                    n - 0.05
                                                );
                                                break;
                                            case ">":
                                                this._navigator.playService.setSpeed(
                                                    n + 0.05
                                                );
                                                break;
                                            default:
                                                return;
                                        }
                                        e.preventDefault();
                                    }
                                });
                    }
                    _disable() {
                        this._keyDownSubscription.unsubscribe();
                    }
                    _getConfiguration(e) {
                        return { keyPlay: e };
                    }
                }
                class q_ extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i),
                            (this._keyPlayHandler = new Y_(this, t, i)),
                            (this._keySequenceNavigationHandler = new H_(
                                this,
                                t,
                                i
                            )),
                            (this._keySpatialNavigationHandler = new G_(
                                this,
                                t,
                                i,
                                new Lp()
                            )),
                            (this._keyZoomHandler = new V_(
                                this,
                                t,
                                i,
                                new l_()
                            ));
                    }
                    get keyPlay() {
                        return this._keyPlayHandler;
                    }
                    get keySequenceNavigation() {
                        return this._keySequenceNavigationHandler;
                    }
                    get keySpatialNavigation() {
                        return this._keySpatialNavigationHandler;
                    }
                    get keyZoom() {
                        return this._keyZoomHandler;
                    }
                    _activate() {
                        this._subscriptions.push(
                            this._configuration$.subscribe((e) => {
                                e.keyPlay
                                    ? this._keyPlayHandler.enable()
                                    : this._keyPlayHandler.disable(),
                                    e.keySequenceNavigation
                                        ? this._keySequenceNavigationHandler.enable()
                                        : this._keySequenceNavigationHandler.disable(),
                                    e.keySpatialNavigation
                                        ? this._keySpatialNavigationHandler.enable()
                                        : this._keySpatialNavigationHandler.disable(),
                                    e.keyZoom
                                        ? this._keyZoomHandler.enable()
                                        : this._keyZoomHandler.disable();
                            })
                        );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe(),
                            this._keyPlayHandler.disable(),
                            this._keySequenceNavigationHandler.disable(),
                            this._keySpatialNavigationHandler.disable(),
                            this._keyZoomHandler.disable();
                    }
                    _getDefaultConfiguration() {
                        return {
                            keyPlay: !0,
                            keySequenceNavigation: !0,
                            keySpatialNavigation: !0,
                            keyZoom: !0,
                        };
                    }
                }
                q_.componentName = "keyboard";
                class W_ {
                    constructor(e, t) {
                        (this._needsRender = !1),
                            (this._interactiveObjects = []),
                            (this._markers = {}),
                            (this._objectMarkers = {}),
                            (this._raycaster = t || new op()),
                            (this._scene = e || new ph());
                    }
                    get markers() {
                        return this._markers;
                    }
                    get needsRender() {
                        return this._needsRender;
                    }
                    add(e, t) {
                        e.id in this._markers && this._dispose(e.id),
                            e.createGeometry(t),
                            this._scene.add(e.geometry),
                            (this._markers[e.id] = e);
                        for (let t of e.getInteractiveObjects())
                            this._interactiveObjects.push(t),
                                (this._objectMarkers[t.uuid] = e.id);
                        this._needsRender = !0;
                    }
                    clear() {
                        for (const e in this._markers)
                            this._markers.hasOwnProperty && this._dispose(e);
                        this._needsRender = !0;
                    }
                    get(e) {
                        return this._markers[e];
                    }
                    getAll() {
                        return Object.keys(this._markers).map(
                            (e) => this._markers[e]
                        );
                    }
                    has(e) {
                        return e in this._markers;
                    }
                    intersectObjects([e, t], i) {
                        this._raycaster.setFromCamera(new Gr(e, t), i);
                        const n = this._raycaster.intersectObjects(
                            this._interactiveObjects
                        );
                        for (const e of n)
                            if (e.object.uuid in this._objectMarkers)
                                return this._objectMarkers[e.object.uuid];
                        return null;
                    }
                    lerpAltitude(e, t, i) {
                        e in this._markers &&
                            (this._markers[e].lerpAltitude(t, i),
                            (this._needsRender = !0));
                    }
                    remove(e) {
                        e in this._markers &&
                            (this._dispose(e), (this._needsRender = !0));
                    }
                    render(e, t) {
                        t.render(this._scene, e), (this._needsRender = !1);
                    }
                    update(e, t, i) {
                        e in this._markers &&
                            (this._markers[e].updatePosition(t, i),
                            (this._needsRender = !0));
                    }
                    _dispose(e) {
                        const t = this._markers[e];
                        this._scene.remove(t.geometry);
                        for (let i of t.getInteractiveObjects()) {
                            const t = this._interactiveObjects.indexOf(i);
                            -1 !== t
                                ? this._interactiveObjects.splice(t, 1)
                                : console.warn(
                                      `Object does not exist (${i.id}) for ${e}`
                                  ),
                                delete this._objectMarkers[i.uuid];
                        }
                        t.disposeGeometry(), delete this._markers[e];
                    }
                }
                class Q_ extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i),
                            (this._graphCalculator = new bp()),
                            (this._markerScene = new W_()),
                            (this._markerSet = new Bp()),
                            (this._viewportCoords = new l_()),
                            (this._relativeGroundAltitude = -2);
                    }
                    add(e) {
                        this._markerSet.add(e);
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    get(e) {
                        return this._markerSet.get(e);
                    }
                    getAll() {
                        return this._markerSet.getAll();
                    }
                    getMarkerIdAt(e) {
                        return new Promise((t, i) => {
                            this._container.renderService.renderCamera$
                                .pipe(
                                    bt(),
                                    ke((t) => {
                                        const i =
                                            this._viewportCoords.canvasToViewport(
                                                e[0],
                                                e[1],
                                                this._container.container
                                            );
                                        return this._markerScene.intersectObjects(
                                            i,
                                            t.perspective
                                        );
                                    })
                                )
                                .subscribe(
                                    (e) => {
                                        t(e);
                                    },
                                    (e) => {
                                        i(e);
                                    }
                                );
                        });
                    }
                    has(e) {
                        return this._markerSet.has(e);
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                    remove(e) {
                        this._markerSet.remove(e);
                    }
                    removeAll() {
                        this._markerSet.removeAll();
                    }
                    _activate() {
                        const e =
                                this._navigator.stateService.currentState$.pipe(
                                    ke(
                                        (e) =>
                                            e.state.camera.position.z +
                                            this._relativeGroundAltitude
                                    ),
                                    ft((e, t) => Math.abs(e - t) < 0.01),
                                    It(1),
                                    V()
                                ),
                            t = He(
                                e,
                                this._navigator.stateService.reference$
                            ).pipe(
                                bt(),
                                ke(() => {}),
                                It(1),
                                V()
                            ),
                            i = this._configuration$.pipe(
                                ke((e) => ({
                                    visibleBBoxSize: Math.max(
                                        1,
                                        Math.min(200, e.visibleBBoxSize)
                                    ),
                                }))
                            ),
                            n = this._navigator.stateService.currentImage$.pipe(
                                ke((e) => e.lngLat),
                                It(1),
                                V()
                            ),
                            r = He(i, n).pipe(
                                ke(([e, t]) =>
                                    this._graphCalculator.boundingBoxCorners(
                                        t,
                                        e.visibleBBoxSize / 2
                                    )
                                ),
                                It(1),
                                V()
                            ),
                            s = He(
                                We(
                                    Ce(this._markerSet),
                                    this._markerSet.changed$
                                ),
                                r
                            ).pipe(ke(([e, t]) => e.search(t))),
                            a = this._subscriptions;
                        a.push(
                            t
                                .pipe(
                                    kt(() =>
                                        s.pipe(
                                            $t(
                                                this._navigator.stateService
                                                    .reference$,
                                                e
                                            )
                                        )
                                    )
                                )
                                .subscribe(([e, t, i]) => {
                                    const n = this._markerScene,
                                        r = n.markers,
                                        s = Object.assign({}, r);
                                    for (const a of e)
                                        if (a.id in r) delete s[a.id];
                                        else {
                                            const e = vp(
                                                a.lngLat.lng,
                                                a.lngLat.lat,
                                                t.alt + i,
                                                t.lng,
                                                t.lat,
                                                t.alt
                                            );
                                            n.add(a, e);
                                        }
                                    for (const e in s)
                                        s.hasOwnProperty(e) && n.remove(e);
                                })
                        ),
                            a.push(
                                t
                                    .pipe(
                                        kt(() =>
                                            this._markerSet.updated$.pipe(
                                                $t(
                                                    r,
                                                    this._navigator.stateService
                                                        .reference$,
                                                    e
                                                )
                                            )
                                        )
                                    )
                                    .subscribe(([e, [t, i], n, r]) => {
                                        const s = this._markerScene;
                                        for (const a of e) {
                                            const e = s.has(a.id),
                                                o =
                                                    a.lngLat.lat > t.lat &&
                                                    a.lngLat.lat < i.lat &&
                                                    a.lngLat.lng > t.lng &&
                                                    a.lngLat.lng < i.lng;
                                            if (o) {
                                                const e = vp(
                                                    a.lngLat.lng,
                                                    a.lngLat.lat,
                                                    n.alt + r,
                                                    n.lng,
                                                    n.lat,
                                                    n.alt
                                                );
                                                s.add(a, e);
                                            } else !o && e && s.remove(a.id);
                                        }
                                    })
                            ),
                            a.push(
                                this._navigator.stateService.reference$
                                    .pipe(zt(1), $t(e))
                                    .subscribe(([e, t]) => {
                                        const i = this._markerScene;
                                        for (const n of i.getAll()) {
                                            const r = vp(
                                                n.lngLat.lng,
                                                n.lngLat.lat,
                                                e.alt + t,
                                                e.lng,
                                                e.lat,
                                                e.alt
                                            );
                                            i.update(n.id, r);
                                        }
                                    })
                            ),
                            a.push(
                                e
                                    .pipe(
                                        zt(1),
                                        $t(
                                            this._navigator.stateService
                                                .reference$,
                                            n
                                        )
                                    )
                                    .subscribe(([e, t, i]) => {
                                        const n = this._markerScene,
                                            r = vp(
                                                i.lng,
                                                i.lat,
                                                t.alt + e,
                                                t.lng,
                                                t.lat,
                                                t.alt
                                            );
                                        for (const i of n.getAll()) {
                                            const s = vp(
                                                    i.lngLat.lng,
                                                    i.lngLat.lat,
                                                    t.alt + e,
                                                    t.lng,
                                                    t.lat,
                                                    t.alt
                                                ),
                                                a = s[0] - r[0],
                                                o = s[1] - r[1],
                                                c = Math.sqrt(a * a + o * o);
                                            c > 50 ||
                                                n.lerpAltitude(
                                                    i.id,
                                                    e,
                                                    Math.min(
                                                        1,
                                                        Math.max(
                                                            0,
                                                            1.2 - (1.2 * c) / 50
                                                        )
                                                    )
                                                );
                                        }
                                    })
                            ),
                            a.push(
                                this._navigator.stateService.currentState$
                                    .pipe(
                                        ke((e) => {
                                            const t = this._markerScene;
                                            return {
                                                name: this._name,
                                                renderer: {
                                                    frameId: e.id,
                                                    needsRender: t.needsRender,
                                                    render: t.render.bind(t),
                                                    pass: i_.Opaque,
                                                },
                                            };
                                        })
                                    )
                                    .subscribe(
                                        this._container.glRenderer.render$
                                    )
                            );
                        const o = He(
                                this._container.renderService.renderCamera$,
                                this._container.mouseService.mouseMove$
                            ).pipe(
                                ke(([e, t]) => {
                                    const i = this._container.container,
                                        [n, r] =
                                            this._viewportCoords.canvasPosition(
                                                t,
                                                i
                                            ),
                                        s =
                                            this._viewportCoords.canvasToViewport(
                                                n,
                                                r,
                                                i
                                            );
                                    return this._markerScene.intersectObjects(
                                        s,
                                        e.perspective
                                    );
                                }),
                                It(1),
                                V()
                            ),
                            c = this._container.mouseService
                                .filtered$(
                                    this._name,
                                    this._container.mouseService.mouseDragStart$
                                )
                                .pipe(ke(() => !0)),
                            l = this._container.mouseService
                                .filtered$(
                                    this._name,
                                    this._container.mouseService.mouseDragEnd$
                                )
                                .pipe(ke(() => !1)),
                            h = tt(c, l).pipe(Ot(!1));
                        a.push(
                            tt(c.pipe($t(o)), He(l, Ce(null)))
                                .pipe(Ot([!1, null]), Nt())
                                .subscribe(([e, t]) => {
                                    const i = t[0],
                                        n = i
                                            ? "markerdragstart"
                                            : "markerdragend",
                                        r = i ? t[1] : e[1],
                                        s = {
                                            marker: this._markerScene.get(r),
                                            target: this,
                                            type: n,
                                        };
                                    this.fire(n, s);
                                })
                        );
                        const u = tt(
                            this._container.mouseService.mouseDown$.pipe(
                                ke(() => !0)
                            ),
                            this._container.mouseService.documentMouseUp$.pipe(
                                ke(() => !1)
                            )
                        ).pipe(Ot(!1));
                        a.push(
                            He(
                                this._container.mouseService.active$,
                                o.pipe(ft()),
                                u,
                                h
                            )
                                .pipe(
                                    ke(
                                        ([e, t, i, n]) =>
                                            (!e && null != t && i) || n
                                    ),
                                    ft()
                                )
                                .subscribe((e) => {
                                    e
                                        ? (this._container.mouseService.claimMouse(
                                              this._name,
                                              1
                                          ),
                                          this._container.mouseService.claimWheel(
                                              this._name,
                                              1
                                          ))
                                        : (this._container.mouseService.unclaimMouse(
                                              this._name
                                          ),
                                          this._container.mouseService.unclaimWheel(
                                              this._name
                                          ));
                                })
                        );
                        const d = this._container.mouseService
                            .filtered$(
                                this._name,
                                this._container.mouseService.mouseDragStart$
                            )
                            .pipe(
                                $t(
                                    o,
                                    this._container.renderService.renderCamera$
                                ),
                                ke(([e, t, i]) => {
                                    const n = this._markerScene.get(t),
                                        r = this._container.container,
                                        [s, a] =
                                            this._viewportCoords.projectToCanvas(
                                                n.geometry.position.toArray(),
                                                r,
                                                i.perspective
                                            ),
                                        [o, c] =
                                            this._viewportCoords.canvasPosition(
                                                e,
                                                r
                                            );
                                    return [n, [o - s, c - a], i];
                                }),
                                It(1),
                                V()
                            );
                        a.push(
                            this._container.mouseService
                                .filtered$(
                                    this._name,
                                    this._container.mouseService.mouseDrag$
                                )
                                .pipe(
                                    $t(
                                        d,
                                        this._navigator.stateService.reference$,
                                        i
                                    )
                                )
                                .subscribe(([e, [t, i, n], r, s]) => {
                                    if (!this._markerScene.has(t.id)) return;
                                    const a = this._container.container,
                                        [o, c] =
                                            this._viewportCoords.canvasPosition(
                                                e,
                                                a
                                            ),
                                        l = o - i[0],
                                        h = c - i[1],
                                        [u, d] =
                                            this._viewportCoords.canvasToViewport(
                                                l,
                                                h,
                                                a
                                            ),
                                        p = new rs(u, d, 1)
                                            .unproject(n.perspective)
                                            .sub(n.perspective.position)
                                            .normalize(),
                                        g = Math.min(
                                            this._relativeGroundAltitude / p.z,
                                            s.visibleBBoxSize / 2 - 0.1
                                        );
                                    if (g < 0) return;
                                    const m = p
                                        .clone()
                                        .multiplyScalar(g)
                                        .add(n.perspective.position);
                                    m.z =
                                        n.perspective.position.z +
                                        this._relativeGroundAltitude;
                                    const [f, _] = yp(
                                        m.x,
                                        m.y,
                                        m.z,
                                        r.lng,
                                        r.lat,
                                        r.alt
                                    );
                                    this._markerScene.update(
                                        t.id,
                                        m.toArray(),
                                        { lat: _, lng: f }
                                    ),
                                        this._markerSet.update(t);
                                    const M = "markerposition",
                                        v = {
                                            marker: t,
                                            target: this,
                                            type: M,
                                        };
                                    this.fire(M, v);
                                })
                        );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe(),
                            this._markerScene.clear();
                    }
                    _getDefaultConfiguration() {
                        return { visibleBBoxSize: 100 };
                    }
                }
                function Z_(e, t) {
                    return (
                        e.x <= Math.max(t.p1.x, t.p2.x) &&
                        e.x >= Math.min(t.p1.x, t.p2.x) &&
                        e.y >= Math.max(t.p1.y, t.p2.y) &&
                        e.y >= Math.min(t.p1.y, t.p2.y)
                    );
                }
                function X_(e, t) {
                    const i = e.p2.x - e.p1.x,
                        n = e.p2.y - e.p1.y,
                        r = t.p2.x - t.p1.x,
                        s = t.p2.y - t.p1.y,
                        a = i * s - n * r;
                    return a * a < 1e-10 * (i * i + n * n) * (r * r + s * s);
                }
                function J_(e, t, i) {
                    return (n =
                        (t.y - e.y) * (i.x - t.x) - (i.y - t.y) * (t.x - e.x)) >
                        0
                        ? 1
                        : n < 0
                        ? -1
                        : 0;
                    var n;
                }
                function K_(e, t) {
                    if (X_(e, t)) return !1;
                    const i = J_(e.p1, e.p2, t.p1),
                        n = J_(e.p1, e.p2, t.p2),
                        r = J_(t.p1, t.p2, e.p1),
                        s = J_(t.p1, t.p2, e.p2);
                    return (
                        (i !== n && r !== s) ||
                        !(0 !== i || !Z_(t.p1, e)) ||
                        !(0 !== n || !Z_(t.p2, e)) ||
                        !(0 !== r || !Z_(e.p1, t)) ||
                        !(0 !== s || !Z_(e.p2, t))
                    );
                }
                function eM(e, t) {
                    if (X_(e, t)) return;
                    const i = e.p1.x,
                        n = e.p2.x,
                        r = e.p1.y,
                        s = e.p2.y,
                        a = t.p1.x,
                        o = t.p2.x,
                        c = t.p1.y,
                        l = t.p2.y,
                        h = (i - n) * (c - l) - (r - s) * (a - o);
                    return {
                        x:
                            ((i * s - r * n) * (a - o) -
                                (i - n) * (a * l - c * o)) /
                            h,
                        y:
                            ((i * s - r * n) * (c - l) -
                                (r - s) * (a * l - c * o)) /
                            h,
                    };
                }
                function tM(e, t) {
                    return e >= -1 && e <= 1 && t >= -1 && t <= 1;
                }
                function iM(e, t) {
                    return e >= 0 && e <= 1 && t >= 0 && t <= 1;
                }
                function nM(e, t, i) {
                    const n = (function (e) {
                            let t = [],
                                i = [
                                    [0, 0],
                                    [1, 0],
                                    [1, 1],
                                    [0, 1],
                                ],
                                n = [
                                    [1, 0],
                                    [0, 1],
                                    [-1, 0],
                                    [0, -1],
                                ];
                            for (let e = 0; e < 4; ++e) {
                                let r = i[e],
                                    s = n[e];
                                for (let e = 0; e < 100; ++e)
                                    t.push([
                                        r[0] + (s[0] * e) / 100,
                                        r[1] + (s[1] * e) / 100,
                                    ]);
                            }
                            return t;
                        })().map((n) =>
                            i.basicToViewportSafe(n[0], n[1], e, t)
                        ),
                        r = [],
                        s = [
                            { x: -1, y: 1 },
                            { x: 1, y: 1 },
                            { x: 1, y: -1 },
                            { x: -1, y: -1 },
                        ],
                        a = [!1, !1, !1, !1];
                    for (let e = 0; e < n.length; e++) {
                        const t = n[e],
                            i = n[(e + 1) % n.length];
                        if (null === t) continue;
                        if (null === i) {
                            tM(t[0], t[1]) && r.push(t);
                            continue;
                        }
                        const [o, c] = t,
                            [l, h] = i;
                        if (tM(o, c))
                            if (tM(l, h)) r.push(t);
                            else
                                for (let e = 0; e < 4; e++) {
                                    const i = {
                                            p1: { x: o, y: c },
                                            p2: { x: l, y: h },
                                        },
                                        n = { p1: s[e], p2: s[(e + 1) % 4] };
                                    if (K_(i, n)) {
                                        const s = eM(i, n);
                                        r.push(t, [s.x, s.y]), (a[e] = !0);
                                    }
                                }
                    }
                    const [o, c] = i.viewportToBasic(-1, 1, e, t),
                        [l, h] = i.viewportToBasic(1, 1, e, t),
                        [u, d] = i.viewportToBasic(1, -1, e, t),
                        [p, g] = i.viewportToBasic(-1, -1, e, t);
                    iM(o, c) && (a[3] = a[0] = !0),
                        iM(l, h) && (a[0] = a[1] = !0),
                        iM(u, d) && (a[1] = a[2] = !0),
                        iM(p, g) && (a[2] = a[3] = !0);
                    const m = [-1, -1, 1, 1];
                    for (let e of r) {
                        const t = e[0],
                            i = e[1];
                        t > m[1] && (m[1] = t),
                            t < m[3] && (m[3] = t),
                            i > m[0] && (m[0] = i),
                            i < m[2] && (m[2] = i);
                    }
                    const f = [1, 1, -1, -1],
                        _ = [];
                    for (let e = 0; e < 4; e++)
                        a[e] ? _.push(0) : _.push(Math.abs(f[e] - m[e]));
                    return _;
                }
                Q_.componentName = "marker";
                class rM extends F_ {
                    constructor(e, t, i, n, r) {
                        super(e, t, i),
                            (this._spatial = r),
                            (this._viewportCoords = n);
                    }
                    _enable() {
                        const e =
                            this._navigator.stateService.currentState$.pipe(
                                ke((e) => e.state.alpha < 1),
                                ft()
                            );
                        this._bounceSubscription = He(
                            e,
                            this._navigator.stateService.inTranslation$,
                            this._container.mouseService.active$,
                            this._container.touchService.active$
                        )
                            .pipe(
                                ke((e) => e[0] || e[1] || e[2] || e[3]),
                                ft(),
                                kt((e) =>
                                    e
                                        ? oe()
                                        : He(
                                              this._container.renderService
                                                  .renderCamera$,
                                              this._navigator.stateService.currentTransform$.pipe(
                                                  bt()
                                              )
                                          )
                                ),
                                $t(this._navigator.panService.panImages$)
                            )
                            .subscribe(([[e, t], i]) => {
                                if (!t.hasValidScale && e.camera.focal < 0.1)
                                    return;
                                if (
                                    0 === e.perspective.aspect ||
                                    e.perspective.aspect ===
                                        Number.POSITIVE_INFINITY
                                )
                                    return;
                                const n = nM(
                                        t,
                                        e.perspective,
                                        this._viewportCoords
                                    ),
                                    r = this._viewportCoords.viewportToBasic(
                                        0,
                                        0,
                                        t,
                                        e.perspective
                                    );
                                (r[0] < 0 || r[0] > 1) &&
                                    i.length > 0 &&
                                    (n[0] = n[2] = 0);
                                for (const [, t] of i) {
                                    const i = nM(
                                        t,
                                        e.perspective,
                                        this._viewportCoords
                                    );
                                    for (let e = 1; e < n.length; e += 2)
                                        i[e] < n[e] && (n[e] = i[e]);
                                }
                                if (Math.max(...n) < 0.01) return;
                                const s = n[1] - n[3],
                                    a = n[0] - n[2],
                                    o = this._viewportCoords
                                        .unprojectFromViewport(
                                            0,
                                            0,
                                            e.perspective
                                        )
                                        .sub(e.perspective.position),
                                    c = this._viewportCoords
                                        .unprojectFromViewport(
                                            s,
                                            0,
                                            e.perspective
                                        )
                                        .sub(e.perspective.position),
                                    l = this._viewportCoords
                                        .unprojectFromViewport(
                                            0,
                                            a,
                                            e.perspective
                                        )
                                        .sub(e.perspective.position);
                                let h = (s > 0 ? 1 : -1) * c.angleTo(o),
                                    u = (a > 0 ? 1 : -1) * l.angleTo(o);
                                const d = Math.PI / 60;
                                (h = this._spatial.clamp(0.1 * h, -d, d)),
                                    (u = this._spatial.clamp(0.1 * u, -d, d)),
                                    this._navigator.stateService.rotateUnbounded(
                                        { phi: h, theta: u }
                                    );
                            });
                    }
                    _disable() {
                        this._bounceSubscription.unsubscribe();
                    }
                    _getConfiguration() {
                        return {};
                    }
                }
                class sM {
                    static filteredPairwiseMouseDrag$(e, t) {
                        return this._filteredPairwiseMouseDrag$(
                            e,
                            t,
                            t.mouseDragStart$,
                            t.mouseDrag$,
                            t.mouseDragEnd$
                        );
                    }
                    static filteredPairwiseMouseRightDrag$(e, t) {
                        return this._filteredPairwiseMouseDrag$(
                            e,
                            t,
                            t.mouseRightDragStart$,
                            t.mouseRightDrag$,
                            t.mouseRightDragEnd$
                        );
                    }
                    static _filteredPairwiseMouseDrag$(e, t, i, n, r) {
                        return t.filtered$(e, i).pipe(
                            kt((i) =>
                                tt(
                                    We(Ce(i), t.filtered$(e, n)),
                                    t.filtered$(e, r).pipe(ke(() => null))
                                ).pipe(
                                    Pt((e) => !!e),
                                    Ot(null)
                                )
                            ),
                            Nt(),
                            nt((e) => null != e[0] && null != e[1])
                        );
                    }
                }
                class aM extends F_ {
                    constructor(e, t, i, n, r) {
                        super(e, t, i),
                            (this._spatial = r),
                            (this._viewportCoords = n);
                    }
                    _enable() {
                        let e = this._container.mouseService
                                .filtered$(
                                    this._component.name,
                                    this._container.mouseService.mouseDragStart$
                                )
                                .pipe(
                                    ke(() => !0),
                                    Et()
                                ),
                            t = this._container.mouseService
                                .filtered$(
                                    this._component.name,
                                    this._container.mouseService.mouseDragEnd$
                                )
                                .pipe(
                                    ke(() => !1),
                                    Et()
                                );
                        this._activeMouseSubscription = tt(e, t).subscribe(
                            this._container.mouseService.activate$
                        );
                        const i = tt(e, t).pipe(
                            kt((e) =>
                                e
                                    ? this._container.mouseService
                                          .documentMouseMove$
                                    : oe()
                            )
                        );
                        this._preventDefaultSubscription = tt(
                            i,
                            this._container.touchService.touchMove$
                        ).subscribe((e) => {
                            e.preventDefault();
                        });
                        let n =
                                this._container.touchService.singleTouchDragStart$.pipe(
                                    ke(() => !0)
                                ),
                            r =
                                this._container.touchService.singleTouchDragEnd$.pipe(
                                    ke(() => !1)
                                );
                        this._activeTouchSubscription = tt(n, r).subscribe(
                            this._container.touchService.activate$
                        );
                        const s =
                            this._navigator.stateService.currentState$.pipe(
                                ke(
                                    (e) =>
                                        jp(e.state.currentImage.cameraType) ||
                                        e.state.imagesAhead < 1
                                ),
                                ft(),
                                kt((e) => {
                                    if (!e) return oe();
                                    const t = sM.filteredPairwiseMouseDrag$(
                                            this._component.name,
                                            this._container.mouseService
                                        ),
                                        i = tt(
                                            this._container.touchService
                                                .singleTouchDragStart$,
                                            this._container.touchService
                                                .singleTouchDrag$,
                                            this._container.touchService.singleTouchDragEnd$.pipe(
                                                ke(() => null)
                                            )
                                        ).pipe(
                                            ke((e) =>
                                                null != e &&
                                                e.touches.length > 0
                                                    ? e.touches[0]
                                                    : null
                                            ),
                                            Nt(),
                                            nt(
                                                (e) =>
                                                    null != e[0] && null != e[1]
                                            )
                                        );
                                    return tt(t, i);
                                }),
                                $t(
                                    this._container.renderService.renderCamera$,
                                    this._navigator.stateService
                                        .currentTransform$,
                                    this._navigator.panService.panImages$
                                ),
                                ke(([e, t, i, n]) => {
                                    let r = e[0],
                                        s = e[1],
                                        a = s.clientX - r.clientX,
                                        o = s.clientY - r.clientY,
                                        c = this._container.container,
                                        [l, h] =
                                            this._viewportCoords.canvasPosition(
                                                s,
                                                c
                                            ),
                                        u = this._viewportCoords
                                            .unprojectFromCanvas(
                                                l,
                                                h,
                                                c,
                                                t.perspective
                                            )
                                            .sub(t.perspective.position),
                                        d = this._viewportCoords
                                            .unprojectFromCanvas(
                                                l - a,
                                                h,
                                                c,
                                                t.perspective
                                            )
                                            .sub(t.perspective.position),
                                        p = this._viewportCoords
                                            .unprojectFromCanvas(
                                                l,
                                                h - o,
                                                c,
                                                t.perspective
                                            )
                                            .sub(t.perspective.position),
                                        g = (a > 0 ? 1 : -1) * d.angleTo(u),
                                        m = (o > 0 ? -1 : 1) * p.angleTo(u);
                                    const f = nM(
                                        i,
                                        t.perspective,
                                        this._viewportCoords
                                    );
                                    for (const [, e] of n) {
                                        const i = nM(
                                            e,
                                            t.perspective,
                                            this._viewportCoords
                                        );
                                        for (let e = 0; e < f.length; e++)
                                            i[e] < f[e] && (f[e] = i[e]);
                                    }
                                    return (
                                        f[0] > 0 &&
                                            m < 0 &&
                                            (m /= Math.max(1, 200 * f[0])),
                                        f[2] > 0 &&
                                            m > 0 &&
                                            (m /= Math.max(1, 200 * f[2])),
                                        f[1] > 0 &&
                                            g < 0 &&
                                            (g /= Math.max(1, 200 * f[1])),
                                        f[3] > 0 &&
                                            g > 0 &&
                                            (g /= Math.max(1, 200 * f[3])),
                                        { phi: g, theta: m }
                                    );
                                }),
                                Et()
                            );
                        var a;
                        (this._rotateWithoutInertiaSubscription = s.subscribe(
                            (e) => {
                                this._navigator.stateService.rotateWithoutInertia(
                                    e
                                );
                            }
                        )),
                            (this._rotateSubscription = s
                                .pipe(
                                    At(
                                        (e, t) => (
                                            this._drainBuffer(e),
                                            e.push([Date.now(), t]),
                                            e
                                        ),
                                        []
                                    ),
                                    ((a = tt(
                                        this._container.mouseService.filtered$(
                                            this._component.name,
                                            this._container.mouseService
                                                .mouseDragEnd$
                                        ),
                                        this._container.touchService
                                            .singleTouchDragEnd$
                                    )),
                                    H(function (e, t) {
                                        var i = !1,
                                            n = null;
                                        e.subscribe(
                                            new G(t, function (e) {
                                                (i = !0), (n = e);
                                            })
                                        ),
                                            a.subscribe(
                                                new G(
                                                    t,
                                                    function () {
                                                        if (i) {
                                                            i = !1;
                                                            var e = n;
                                                            (n = null),
                                                                t.next(e);
                                                        }
                                                    },
                                                    D
                                                )
                                            );
                                    })),
                                    ke((e) => {
                                        const t = this._drainBuffer(e.slice()),
                                            i = { phi: 0, theta: 0 };
                                        for (const e of t)
                                            (i.phi += e[1].phi),
                                                (i.theta += e[1].theta);
                                        const n = t.length;
                                        n > 0 && ((i.phi /= n), (i.theta /= n));
                                        const r = Math.PI / 18;
                                        return (
                                            (i.phi = this._spatial.clamp(
                                                i.phi,
                                                -r,
                                                r
                                            )),
                                            (i.theta = this._spatial.clamp(
                                                i.theta,
                                                -r,
                                                r
                                            )),
                                            i
                                        );
                                    })
                                )
                                .subscribe((e) => {
                                    this._navigator.stateService.rotate(e);
                                }));
                    }
                    _disable() {
                        this._activeMouseSubscription.unsubscribe(),
                            this._activeTouchSubscription.unsubscribe(),
                            this._preventDefaultSubscription.unsubscribe(),
                            this._rotateSubscription.unsubscribe(),
                            this._rotateWithoutInertiaSubscription.unsubscribe(),
                            (this._activeMouseSubscription = null),
                            (this._activeTouchSubscription = null),
                            (this._preventDefaultSubscription = null),
                            (this._rotateSubscription = null);
                    }
                    _getConfiguration(e) {
                        return { dragPan: e };
                    }
                    _drainBuffer(e) {
                        const t = Date.now();
                        for (; e.length > 0 && t - e[0][0] > 50; ) e.shift();
                        return e;
                    }
                }
                class oM extends F_ {
                    constructor(e, t, i, n, r) {
                        super(e, t, i),
                            (this._spatial = r),
                            (this._viewportCoords = n),
                            (this._subscriptions = new s_());
                    }
                    _enable() {
                        const e = this._navigator.stateService.state$.pipe(
                                ke((e) => e === j_.Earth),
                                It(1),
                                V()
                            ),
                            t = this._subscriptions;
                        t.push(
                            e
                                .pipe(
                                    kt((e) =>
                                        e
                                            ? this._container.mouseService
                                                  .mouseWheel$
                                            : oe()
                                    )
                                )
                                .subscribe((e) => {
                                    e.preventDefault();
                                })
                        ),
                            t.push(
                                e
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? sM
                                                      .filteredPairwiseMouseDrag$(
                                                          this._component.name,
                                                          this._container
                                                              .mouseService
                                                      )
                                                      .pipe(
                                                          nt(
                                                              ([e, t]) =>
                                                                  !(
                                                                      e.ctrlKey &&
                                                                      t.ctrlKey
                                                                  )
                                                          )
                                                      )
                                                : oe()
                                        ),
                                        $t(
                                            this._container.renderService
                                                .renderCamera$,
                                            this._navigator.stateService
                                                .currentTransform$
                                        ),
                                        ke(([[e, t], i, n]) => {
                                            const r = [0, 0, 1],
                                                s = [0, 0, -2],
                                                a = this._planeIntersection(
                                                    t,
                                                    r,
                                                    s,
                                                    i.perspective,
                                                    this._container.container
                                                ),
                                                o = this._planeIntersection(
                                                    e,
                                                    r,
                                                    s,
                                                    i.perspective,
                                                    this._container.container
                                                );
                                            return a && o
                                                ? new rs()
                                                      .subVectors(a, o)
                                                      .multiplyScalar(-1)
                                                      .toArray()
                                                : null;
                                        }),
                                        nt((e) => !!e)
                                    )
                                    .subscribe((e) => {
                                        this._navigator.stateService.truck(e);
                                    })
                            ),
                            t.push(
                                e
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? sM
                                                      .filteredPairwiseMouseDrag$(
                                                          this._component.name,
                                                          this._container
                                                              .mouseService
                                                      )
                                                      .pipe(
                                                          nt(
                                                              ([e, t]) =>
                                                                  e.ctrlKey &&
                                                                  t.ctrlKey
                                                          )
                                                      )
                                                : oe()
                                        ),
                                        ke(([e, t]) =>
                                            this._mousePairToRotation(e, t)
                                        )
                                    )
                                    .subscribe((e) => {
                                        this._navigator.stateService.orbit(e);
                                    })
                            ),
                            t.push(
                                e
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? sM
                                                      .filteredPairwiseMouseRightDrag$(
                                                          this._component.name,
                                                          this._container
                                                              .mouseService
                                                      )
                                                      .pipe(
                                                          nt(
                                                              ([e, t]) =>
                                                                  !e.ctrlKey &&
                                                                  !t.ctrlKey
                                                          )
                                                      )
                                                : oe()
                                        ),
                                        ke(([e, t]) =>
                                            this._mousePairToRotation(e, t)
                                        )
                                    )
                                    .subscribe((e) => {
                                        this._navigator.stateService.orbit(e);
                                    })
                            ),
                            t.push(
                                e
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? this._container.mouseService.filteredWheel$(
                                                      this._component.name,
                                                      this._container
                                                          .mouseService
                                                          .mouseWheel$
                                                  )
                                                : oe()
                                        ),
                                        ke((e) => {
                                            let t = e.deltaY;
                                            return (
                                                1 === e.deltaMode
                                                    ? (t *= 40)
                                                    : 2 === e.deltaMode &&
                                                      (t *= 800),
                                                -t /
                                                    this._viewportCoords.containerToCanvas(
                                                        this._container
                                                            .container
                                                    )[1]
                                            );
                                        })
                                    )
                                    .subscribe((e) => {
                                        this._navigator.stateService.dolly(e);
                                    })
                            );
                    }
                    _disable() {
                        this._subscriptions.unsubscribe();
                    }
                    _getConfiguration() {
                        return {};
                    }
                    _eventToViewport(e, t) {
                        const i = this._viewportCoords.canvasPosition(e, t);
                        return this._viewportCoords.canvasToViewport(
                            i[0],
                            i[1],
                            t
                        );
                    }
                    _mousePairToRotation(e, t) {
                        const [i, n] = this._eventToViewport(
                                t,
                                this._container.container
                            ),
                            [r, s] = this._eventToViewport(
                                e,
                                this._container.container
                            );
                        return {
                            phi: (r - i) * Math.PI,
                            theta: ((n - s) * Math.PI) / 2,
                        };
                    }
                    _planeIntersection(e, t, i, n, r) {
                        const [s, a] = this._viewportCoords.canvasPosition(
                                e,
                                r
                            ),
                            o = this._viewportCoords
                                .unprojectFromCanvas(s, a, r, n)
                                .sub(n.position)
                                .normalize();
                        if (
                            Math.abs(
                                this._spatial.angleToPlane(o.toArray(), t)
                            ) <
                            Math.PI / 90
                        )
                            return null;
                        const c = n.position.clone(),
                            l = new rs().fromArray(t),
                            h = new rs().fromArray(i),
                            u =
                                new rs().subVectors(h, c).dot(l) /
                                o.clone().dot(l),
                            d = new rs().addVectors(c, o.multiplyScalar(u));
                        return this._viewportCoords.worldToCamera(
                            d.toArray(),
                            n
                        )[2] > 0
                            ? null
                            : d;
                    }
                }
                class cM extends F_ {
                    constructor(e, t, i, n) {
                        super(e, t, i), (this._viewportCoords = n);
                    }
                    _enable() {
                        this._container.mouseService.claimWheel(
                            this._component.name,
                            0
                        ),
                            (this._preventDefaultSubscription =
                                this._container.mouseService.mouseWheel$.subscribe(
                                    (e) => {
                                        e.preventDefault();
                                    }
                                )),
                            (this._zoomSubscription =
                                this._container.mouseService
                                    .filteredWheel$(
                                        this._component.name,
                                        this._container.mouseService.mouseWheel$
                                    )
                                    .pipe(
                                        $t(
                                            this._navigator.stateService
                                                .currentState$,
                                            (e, t) => [e, t]
                                        ),
                                        nt((e) => {
                                            let t = e[1].state;
                                            return (
                                                jp(t.currentImage.cameraType) ||
                                                t.imagesAhead < 1
                                            );
                                        }),
                                        ke((e) => e[0]),
                                        $t(
                                            this._container.renderService
                                                .renderCamera$,
                                            this._navigator.stateService
                                                .currentTransform$,
                                            (e, t, i) => [e, t, i]
                                        )
                                    )
                                    .subscribe((e) => {
                                        let t = e[0],
                                            i = e[1],
                                            n = e[2],
                                            r = this._container.container,
                                            [s, a] =
                                                this._viewportCoords.canvasPosition(
                                                    t,
                                                    r
                                                ),
                                            o =
                                                this._viewportCoords.unprojectFromCanvas(
                                                    s,
                                                    a,
                                                    r,
                                                    i.perspective
                                                ),
                                            c = n.projectBasic(o.toArray()),
                                            l = t.deltaY;
                                        1 === t.deltaMode
                                            ? (l *= 40)
                                            : 2 === t.deltaMode && (l *= 800);
                                        let h =
                                            (-3 * l) /
                                            this._viewportCoords.containerToCanvas(
                                                r
                                            )[1];
                                        this._navigator.stateService.zoomIn(
                                            h,
                                            c
                                        );
                                    }));
                    }
                    _disable() {
                        this._container.mouseService.unclaimWheel(
                            this._component.name
                        ),
                            this._preventDefaultSubscription.unsubscribe(),
                            this._zoomSubscription.unsubscribe(),
                            (this._preventDefaultSubscription = null),
                            (this._zoomSubscription = null);
                    }
                    _getConfiguration(e) {
                        return { scrollZoom: e };
                    }
                }
                class lM extends F_ {
                    constructor(e, t, i, n) {
                        super(e, t, i), (this._viewportCoords = n);
                    }
                    _enable() {
                        this._preventDefaultSubscription =
                            this._container.touchService.pinch$.subscribe(
                                (e) => {
                                    e.originalEvent.preventDefault();
                                }
                            );
                        let e = this._container.touchService.pinchStart$.pipe(
                                ke((e) => !0)
                            ),
                            t = this._container.touchService.pinchEnd$.pipe(
                                ke((e) => !1)
                            );
                        (this._activeSubscription = tt(e, t).subscribe(
                            this._container.touchService.activate$
                        )),
                            (this._zoomSubscription =
                                this._container.touchService.pinch$
                                    .pipe(
                                        $t(
                                            this._navigator.stateService
                                                .currentState$
                                        ),
                                        nt((e) => {
                                            let t = e[1].state;
                                            return (
                                                jp(t.currentImage.cameraType) ||
                                                t.imagesAhead < 1
                                            );
                                        }),
                                        ke((e) => e[0]),
                                        $t(
                                            this._container.renderService
                                                .renderCamera$,
                                            this._navigator.stateService
                                                .currentTransform$
                                        )
                                    )
                                    .subscribe(([e, t, i]) => {
                                        let n = this._container.container,
                                            [r, s] =
                                                this._viewportCoords.canvasPosition(
                                                    e,
                                                    n
                                                ),
                                            a =
                                                this._viewportCoords.unprojectFromCanvas(
                                                    r,
                                                    s,
                                                    n,
                                                    t.perspective
                                                ),
                                            o = i.projectBasic(a.toArray());
                                        const [c, l] =
                                            this._viewportCoords.containerToCanvas(
                                                n
                                            );
                                        let h =
                                            (3 * e.distanceChange) /
                                            Math.min(c, l);
                                        this._navigator.stateService.zoomIn(
                                            h,
                                            o
                                        );
                                    }));
                    }
                    _disable() {
                        this._activeSubscription.unsubscribe(),
                            this._preventDefaultSubscription.unsubscribe(),
                            this._zoomSubscription.unsubscribe(),
                            (this._preventDefaultSubscription = null),
                            (this._zoomSubscription = null);
                    }
                    _getConfiguration(e) {
                        return { touchZoom: e };
                    }
                }
                class hM extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i);
                        const n = new Lp(),
                            r = new l_();
                        (this._bounceHandler = new rM(this, t, i, r, n)),
                            (this._dragPanHandler = new aM(this, t, i, r, n)),
                            (this._earthControlHandler = new oM(
                                this,
                                t,
                                i,
                                r,
                                n
                            )),
                            (this._scrollZoomHandler = new cM(this, t, i, r)),
                            (this._touchZoomHandler = new lM(this, t, i, r));
                    }
                    get dragPan() {
                        return this._dragPanHandler;
                    }
                    get earthControl() {
                        return this._earthControlHandler;
                    }
                    get scrollZoom() {
                        return this._scrollZoomHandler;
                    }
                    get touchZoom() {
                        return this._touchZoomHandler;
                    }
                    _activate() {
                        this._bounceHandler.enable(),
                            this._subscriptions.push(
                                this._configuration$.subscribe((e) => {
                                    e.dragPan
                                        ? this._dragPanHandler.enable()
                                        : this._dragPanHandler.disable(),
                                        e.earthControl
                                            ? this._earthControlHandler.enable()
                                            : this._earthControlHandler.disable(),
                                        e.scrollZoom
                                            ? this._scrollZoomHandler.enable()
                                            : this._scrollZoomHandler.disable(),
                                        e.touchZoom
                                            ? this._touchZoomHandler.enable()
                                            : this._touchZoomHandler.disable();
                                })
                            ),
                            this._container.mouseService.claimMouse(
                                this._name,
                                0
                            );
                    }
                    _deactivate() {
                        this._container.mouseService.unclaimMouse(this._name),
                            this._subscriptions.unsubscribe(),
                            this._bounceHandler.disable(),
                            this._dragPanHandler.disable(),
                            this._earthControlHandler.disable(),
                            this._scrollZoomHandler.disable(),
                            this._touchZoomHandler.disable();
                    }
                    _getDefaultConfiguration() {
                        return {
                            dragPan: !0,
                            earthControl: !0,
                            scrollZoom: !0,
                            touchZoom: !0,
                        };
                    }
                }
                hM.componentName = "pointer";
                class uM {
                    constructor(e) {
                        this._document = e || document;
                    }
                    get document() {
                        return this._document;
                    }
                    createElement(e, t, i) {
                        const n = this._document.createElement(e);
                        return t && (n.className = t), i && i.appendChild(n), n;
                    }
                }
                class dM extends a_ {
                    constructor(e, t, i, n) {
                        super(e, t, i),
                            (this._dom = n || new uM()),
                            (this._popups = []),
                            (this._added$ = new W()),
                            (this._popups$ = new W());
                    }
                    add(e) {
                        for (const t of e)
                            -1 === this._popups.indexOf(t) &&
                                (this._popups.push(t),
                                this._activated &&
                                    t.setParentContainer(this._popupContainer));
                        this._added$.next(e), this._popups$.next(this._popups);
                    }
                    getAll() {
                        return this._popups.slice();
                    }
                    remove(e) {
                        for (const t of e) this._remove(t);
                        this._popups$.next(this._popups);
                    }
                    removeAll() {
                        for (const e of this._popups.slice()) this._remove(e);
                        this._popups$.next(this._popups);
                    }
                    _activate() {
                        this._popupContainer = this._dom.createElement(
                            "div",
                            "mapillary-popup-container",
                            this._container.container
                        );
                        for (const e of this._popups)
                            e.setParentContainer(this._popupContainer);
                        const e = this._subscriptions;
                        e.push(
                            He(
                                this._container.renderService.renderCamera$,
                                this._container.renderService.size$,
                                this._navigator.stateService.currentTransform$
                            ).subscribe(([e, t, i]) => {
                                for (const n of this._popups) n.update(e, t, i);
                            })
                        );
                        const t = this._popups$.pipe(
                            Ot(this._popups),
                            kt((e) => ye(e).pipe(Ye((e) => e.changed$))),
                            ke((e) => [e])
                        );
                        e.push(
                            tt(this._added$, t)
                                .pipe(
                                    $t(
                                        this._container.renderService
                                            .renderCamera$,
                                        this._container.renderService.size$,
                                        this._navigator.stateService
                                            .currentTransform$
                                    )
                                )
                                .subscribe(([e, t, i, n]) => {
                                    for (const r of e) r.update(t, i, n);
                                })
                        );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                        for (const e of this._popups) e.remove();
                        this._container.container.removeChild(
                            this._popupContainer
                        ),
                            delete this._popupContainer;
                    }
                    _getDefaultConfiguration() {
                        return {};
                    }
                    _remove(e) {
                        const t = this._popups.indexOf(e);
                        if (-1 === t) return;
                        const i = this._popups.splice(t, 1)[0];
                        this._activated && i.remove();
                    }
                }
                (dM.componentName = "popup"),
                    (function (e) {
                        (e[(e.Sequence = 0)] = "Sequence"),
                            (e[(e.Spatial = 1)] = "Spatial");
                    })(O_ || (O_ = {})),
                    (function (e) {
                        (e[(e.Default = 0)] = "Default"),
                            (e[(e.Playback = 1)] = "Playback"),
                            (e[(e.Timeline = 2)] = "Timeline");
                    })(k_ || (k_ = {}));
                class pM {
                    constructor(e) {
                        (this._container = e),
                            (this._minThresholdWidth = 320),
                            (this._maxThresholdWidth = 1480),
                            (this._minThresholdHeight = 240),
                            (this._maxThresholdHeight = 820),
                            (this._stepperDefaultWidth = 108),
                            (this._controlsDefaultWidth = 88),
                            (this._defaultHeight = 30),
                            (this._expandControls = !1),
                            (this._mode = k_.Default),
                            (this._speed = 0.5),
                            (this._changingSpeed = !1),
                            (this._index = null),
                            (this._changingPosition = !1),
                            (this._mouseEnterDirection$ = new W()),
                            (this._mouseLeaveDirection$ = new W()),
                            (this._notifyChanged$ = new W()),
                            (this._notifyChangingPositionChanged$ = new W()),
                            (this._notifySpeedChanged$ = new W()),
                            (this._notifyIndexChanged$ = new W());
                    }
                    get changed$() {
                        return this._notifyChanged$;
                    }
                    get changingPositionChanged$() {
                        return this._notifyChangingPositionChanged$;
                    }
                    get speed$() {
                        return this._notifySpeedChanged$;
                    }
                    get index$() {
                        return this._notifyIndexChanged$;
                    }
                    get mouseEnterDirection$() {
                        return this._mouseEnterDirection$;
                    }
                    get mouseLeaveDirection$() {
                        return this._mouseLeaveDirection$;
                    }
                    activate() {
                        this._changingSubscription ||
                            (this._changingSubscription = tt(
                                this._container.mouseService.documentMouseUp$,
                                this._container.touchService.touchEnd$.pipe(
                                    nt((e) => 0 === e.touches.length)
                                )
                            ).subscribe(() => {
                                this._changingSpeed &&
                                    (this._changingSpeed = !1),
                                    this._changingPosition &&
                                        this._setChangingPosition(!1);
                            }));
                    }
                    deactivate() {
                        this._changingSubscription &&
                            ((this._changingSpeed = !1),
                            (this._changingPosition = !1),
                            (this._expandControls = !1),
                            (this._mode = k_.Default),
                            this._changingSubscription.unsubscribe(),
                            (this._changingSubscription = null));
                    }
                    render(e, t, i, n, r, s, a, o, c) {
                        if (!1 === t.visible)
                            return n_.h(
                                "div.mapillary-sequence-container",
                                {},
                                []
                            );
                        const l = this._createStepper(e, t, a, i, o, c),
                            h = this._createSequenceControls(i),
                            u = this._createPlaybackControls(i, n, o, t),
                            d = this._createTimelineControls(i, r, s);
                        return n_.h("div.mapillary-sequence-container", [
                            l,
                            h,
                            u,
                            d,
                        ]);
                    }
                    getContainerWidth(e, t) {
                        let i = t.minWidth,
                            n = t.maxWidth;
                        n < i && (n = i);
                        let r =
                                (e.width - this._minThresholdWidth) /
                                (this._maxThresholdWidth -
                                    this._minThresholdWidth),
                            s =
                                (e.height - this._minThresholdHeight) /
                                (this._maxThresholdHeight -
                                    this._minThresholdHeight);
                        return (
                            i +
                            Math.max(0, Math.min(1, Math.min(r, s))) * (n - i)
                        );
                    }
                    _createPositionInput(e, t) {
                        this._index = e;
                        const i = (e) => {
                                (this._index = Number(e.target.value)),
                                    this._notifyIndexChanged$.next(this._index);
                            },
                            n =
                                this._container.domContainer.getBoundingClientRect(),
                            r = (e) => {
                                e.stopPropagation(),
                                    this._setChangingPosition(!0);
                            },
                            s = (e) => {
                                !0 === this._changingPosition &&
                                    e.stopPropagation();
                            },
                            a = {
                                max: null != t ? t : 1,
                                min: 0,
                                onchange: i,
                                oninput: i,
                                onkeydown: (e) => {
                                    ("ArrowDown" !== e.key &&
                                        "ArrowLeft" !== e.key &&
                                        "ArrowRight" !== e.key &&
                                        "ArrowUp" !== e.key) ||
                                        e.preventDefault();
                                },
                                onpointerdown: r,
                                onpointermove: s,
                                ontouchmove: s,
                                ontouchstart: r,
                                style: {
                                    width:
                                        Math.max(
                                            276,
                                            Math.min(410, 5 + 0.8 * n.width)
                                        ) -
                                        65 +
                                        "px",
                                },
                                type: "range",
                                value: null != e ? e : 0,
                            },
                            o = null == e || null == t || t <= 1;
                        o && (a.disabled = "true");
                        const c = n_.h(
                                "input.mapillary-sequence-position",
                                a,
                                []
                            ),
                            l = o
                                ? ".mapillary-sequence-position-container-inactive"
                                : ".mapillary-sequence-position-container";
                        return n_.h("div" + l, [c]);
                    }
                    _createSpeedInput(e) {
                        this._speed = e;
                        const t = (e) => {
                                (this._speed = Number(e.target.value) / 1e3),
                                    this._notifySpeedChanged$.next(this._speed);
                            },
                            i =
                                this._container.domContainer.getBoundingClientRect(),
                            n =
                                Math.max(
                                    276,
                                    Math.min(410, 5 + 0.8 * i.width)
                                ) - 160,
                            r = (e) => {
                                (this._changingSpeed = !0), e.stopPropagation();
                            },
                            s = (e) => {
                                !0 === this._changingSpeed &&
                                    e.stopPropagation();
                            },
                            a = n_.h(
                                "input.mapillary-sequence-speed",
                                {
                                    max: 1e3,
                                    min: 0,
                                    onchange: t,
                                    oninput: t,
                                    onkeydown: (e) => {
                                        ("ArrowDown" !== e.key &&
                                            "ArrowLeft" !== e.key &&
                                            "ArrowRight" !== e.key &&
                                            "ArrowUp" !== e.key) ||
                                            e.preventDefault();
                                    },
                                    onpointerdown: r,
                                    onpointermove: s,
                                    ontouchmove: s,
                                    ontouchstart: r,
                                    style: { width: `${n}px` },
                                    type: "range",
                                    value: 1e3 * e,
                                },
                                []
                            );
                        return n_.h("div.mapillary-sequence-speed-container", [
                            a,
                        ]);
                    }
                    _createPlaybackControls(e, t, i, n) {
                        if (this._mode !== k_.Playback)
                            return n_.h("div.mapillary-sequence-playback", []);
                        const r = n_.h(
                                "div.mapillary-sequence-switch-icon.mapillary-sequence-icon-visible",
                                []
                            ),
                            s = n.direction === Dp.Next ? Dp.Prev : Dp.Next,
                            a = n.playing,
                            o = {
                                onclick: () => {
                                    a || i.configure({ direction: s });
                                },
                            },
                            c = n.playing
                                ? ".mapillary-sequence-switch-button-inactive"
                                : ".mapillary-sequence-switch-button",
                            l = n_.h("div" + c, o, [r]),
                            h = n_.h(
                                "div.mapillary-sequence-slow-icon.mapillary-sequence-icon-visible",
                                []
                            ),
                            u = n_.h("div.mapillary-sequence-slow-container", [
                                h,
                            ]),
                            d = n_.h(
                                "div.mapillary-sequence-fast-icon.mapillary-sequence-icon-visible",
                                []
                            ),
                            p = n_.h("div.mapillary-sequence-fast-container", [
                                d,
                            ]),
                            g = n_.h(
                                "div.mapillary-sequence-close-icon.mapillary-sequence-icon-visible",
                                []
                            ),
                            m = {
                                onclick: () => {
                                    (this._mode = k_.Default),
                                        this._notifyChanged$.next(this);
                                },
                            },
                            f = n_.h("div.mapillary-sequence-close-button", m, [
                                g,
                            ]),
                            _ = [l, u, this._createSpeedInput(t), p, f],
                            M = {
                                style: {
                                    top: `${Math.round(
                                        (e / this._stepperDefaultWidth) *
                                            this._defaultHeight +
                                            10
                                    )}px`,
                                },
                            };
                        return n_.h("div.mapillary-sequence-playback", M, _);
                    }
                    _createPlayingButton(e, t, i, n, r) {
                        let s =
                            (n.direction === Dp.Next && null != e) ||
                            (n.direction === Dp.Prev && null != t);
                        s = s && i;
                        let a = {
                                onclick: n.playing
                                    ? () => {
                                          r.stop();
                                      }
                                    : s
                                    ? () => {
                                          r.play();
                                      }
                                    : null,
                            },
                            o = {};
                        n.direction === Dp.Prev &&
                            (o.style = {
                                transform: "rotate(180deg) translate(50%, 50%)",
                            });
                        let c = n_.h("div.mapillary-sequence-icon", o, []),
                            l = n.playing
                                ? "mapillary-sequence-stop"
                                : s
                                ? "mapillary-sequence-play"
                                : "mapillary-sequence-play-inactive";
                        return n_.h("div." + l, a, [c]);
                    }
                    _createSequenceControls(e) {
                        const t = Math.round(
                                (8 / this._stepperDefaultWidth) * e
                            ),
                            i = {
                                onclick: () => {
                                    (this._expandControls =
                                        !this._expandControls),
                                        (this._mode = k_.Default),
                                        this._notifyChanged$.next(this);
                                },
                                style: {
                                    "border-bottom-right-radius": `${t}px`,
                                    "border-top-right-radius": `${t}px`,
                                },
                            },
                            n = n_.h("div.mapillary-sequence-expander-bar", []),
                            r = n_.h(
                                "div.mapillary-sequence-expander-button",
                                i,
                                [n]
                            ),
                            s =
                                this._mode === k_.Playback
                                    ? ".mapillary-sequence-fast-icon-gray.mapillary-sequence-icon-visible"
                                    : ".mapillary-sequence-fast-icon",
                            a = n_.h("div" + s, []),
                            o = {
                                onclick: () => {
                                    (this._mode =
                                        this._mode === k_.Playback
                                            ? k_.Default
                                            : k_.Playback),
                                        this._notifyChanged$.next(this);
                                },
                            },
                            c = n_.h(
                                "div.mapillary-sequence-playback-button",
                                o,
                                [a]
                            ),
                            l =
                                this._mode === k_.Timeline
                                    ? ".mapillary-sequence-timeline-icon-gray.mapillary-sequence-icon-visible"
                                    : ".mapillary-sequence-timeline-icon",
                            h = n_.h("div" + l, []),
                            u = {
                                onclick: () => {
                                    (this._mode =
                                        this._mode === k_.Timeline
                                            ? k_.Default
                                            : k_.Timeline),
                                        this._notifyChanged$.next(this);
                                },
                            },
                            d = n_.h(
                                "div.mapillary-sequence-timeline-button",
                                u,
                                [h]
                            ),
                            p = {
                                style: {
                                    height:
                                        (this._defaultHeight /
                                            this._stepperDefaultWidth) *
                                            e +
                                        "px",
                                    transform: `translate(${e / 2 + 2}px, 0)`,
                                    width:
                                        (this._controlsDefaultWidth /
                                            this._stepperDefaultWidth) *
                                            e +
                                        "px",
                                },
                            },
                            g =
                                ".mapillary-sequence-controls" +
                                (this._expandControls
                                    ? ".mapillary-sequence-controls-expanded"
                                    : "");
                        return n_.h("div" + g, p, [c, d, r]);
                    }
                    _createSequenceArrows(e, t, i, n, r) {
                        let s = {
                            onclick:
                                null != e
                                    ? () => {
                                          r.moveDir$(Dp.Next).subscribe(
                                              void 0,
                                              (e) => {
                                                  e instanceof d_ ||
                                                      console.error(e);
                                              }
                                          );
                                      }
                                    : null,
                            onpointerenter: () => {
                                this._mouseEnterDirection$.next(Dp.Next);
                            },
                            onpointerleave: () => {
                                this._mouseLeaveDirection$.next(Dp.Next);
                            },
                        };
                        const a = Math.round(
                            (8 / this._stepperDefaultWidth) * i
                        );
                        let o = {
                                onclick:
                                    null != t
                                        ? () => {
                                              r.moveDir$(Dp.Prev).subscribe(
                                                  void 0,
                                                  (e) => {
                                                      e instanceof d_ ||
                                                          console.error(e);
                                                  }
                                              );
                                          }
                                        : null,
                                onpointerenter: () => {
                                    this._mouseEnterDirection$.next(Dp.Prev);
                                },
                                onpointerleave: () => {
                                    this._mouseLeaveDirection$.next(Dp.Prev);
                                },
                                style: {
                                    "border-bottom-left-radius": `${a}px`,
                                    "border-top-left-radius": `${a}px`,
                                },
                            },
                            c = this._getStepClassName(
                                Dp.Next,
                                e,
                                n.highlightId
                            ),
                            l = this._getStepClassName(
                                Dp.Prev,
                                t,
                                n.highlightId
                            ),
                            h = n_.h("div.mapillary-sequence-icon", []),
                            u = n_.h("div.mapillary-sequence-icon", []);
                        return [
                            n_.h("div." + l, o, [u]),
                            n_.h("div." + c, s, [h]),
                        ];
                    }
                    _createStepper(e, t, i, n, r, s) {
                        let a = null,
                            o = null;
                        for (let t of e.edges)
                            t.data.direction === Dp.Next && (a = t.target),
                                t.data.direction === Dp.Prev && (o = t.target);
                        const c = this._createPlayingButton(a, o, i, t, r),
                            l = this._createSequenceArrows(a, o, n, t, s);
                        l.splice(1, 0, c);
                        const h = {
                            oncontextmenu: (e) => {
                                e.preventDefault();
                            },
                            style: {
                                height:
                                    (this._defaultHeight /
                                        this._stepperDefaultWidth) *
                                        n +
                                    "px",
                                width: n + "px",
                            },
                        };
                        return n_.h("div.mapillary-sequence-stepper", h, l);
                    }
                    _createTimelineControls(e, t, i) {
                        if (this._mode !== k_.Timeline)
                            return n_.h("div.mapillary-sequence-timeline", []);
                        const n = this._createPositionInput(t, i),
                            r = n_.h(
                                "div.mapillary-sequence-close-icon.mapillary-sequence-icon-visible",
                                []
                            ),
                            s = {
                                onclick: () => {
                                    (this._mode = k_.Default),
                                        this._notifyChanged$.next(this);
                                },
                            },
                            a = n_.h("div.mapillary-sequence-close-button", s, [
                                r,
                            ]),
                            o = {
                                style: {
                                    top: `${Math.round(
                                        (e / this._stepperDefaultWidth) *
                                            this._defaultHeight +
                                            10
                                    )}px`,
                                },
                            };
                        return n_.h("div.mapillary-sequence-timeline", o, [
                            n,
                            a,
                        ]);
                    }
                    _getStepClassName(e, t, i) {
                        let n =
                            e === Dp.Next
                                ? "mapillary-sequence-step-next"
                                : "mapillary-sequence-step-prev";
                        return (
                            null == t
                                ? (n += "-inactive")
                                : i === t && (n += "-highlight"),
                            n
                        );
                    }
                    _setChangingPosition(e) {
                        (this._changingPosition = e),
                            this._notifyChangingPositionChanged$.next(e);
                    }
                }
                class gM extends a_ {
                    constructor(e, t, i, n, r) {
                        super(e, t, i),
                            (this._sequenceDOMRenderer = n || new pM(t)),
                            (this._scheduler = r),
                            (this._containerWidth$ = new W()),
                            (this._hoveredIdSubject$ = new W()),
                            (this._hoveredId$ = this._hoveredIdSubject$.pipe(
                                Et()
                            )),
                            this._navigator.playService.playing$
                                .pipe(zt(1), $t(this._configuration$))
                                .subscribe(([e, t]) => {
                                    const i = "playing",
                                        n = {
                                            playing: e,
                                            target: this,
                                            type: i,
                                        };
                                    this.fire(i, n),
                                        e !== t.playing &&
                                            (e ? this.play() : this.stop());
                                }),
                            this._navigator.playService.direction$
                                .pipe(zt(1), $t(this._configuration$))
                                .subscribe(([e, t]) => {
                                    e !== t.direction &&
                                        this.configure({ direction: e });
                                });
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                    play() {
                        this.configure({ playing: !0 });
                    }
                    stop() {
                        this.configure({ playing: !1 });
                    }
                    _activate() {
                        this._sequenceDOMRenderer.activate();
                        const e =
                                this._navigator.stateService.currentImage$.pipe(
                                    kt((e) => e.sequenceEdges$),
                                    It(1),
                                    V()
                                ),
                            t = this._navigator.stateService.currentImage$.pipe(
                                ft(void 0, (e) => e.sequenceId),
                                kt((e) =>
                                    We(
                                        Ce(null),
                                        this._navigator.graphService
                                            .cacheSequence$(e.sequenceId)
                                            .pipe(
                                                Ct(3),
                                                ot(
                                                    (e) => (
                                                        console.error(
                                                            "Failed to cache sequence",
                                                            e
                                                        ),
                                                        Ce(null)
                                                    )
                                                )
                                            )
                                    )
                                ),
                                Ot(null),
                                It(1),
                                V()
                            ),
                            i = this._subscriptions;
                        i.push(t.subscribe());
                        const n = this._sequenceDOMRenderer.index$.pipe(
                            $t(t),
                            ke(([e, t]) => (null != t ? t.imageIds[e] : null)),
                            nt((e) => !!e),
                            ft(),
                            Dt(),
                            V()
                        );
                        i.push(
                            tt(
                                n.pipe(pt(100, this._scheduler)),
                                n.pipe(st(400, this._scheduler))
                            )
                                .pipe(
                                    ft(),
                                    kt((e) =>
                                        this._navigator
                                            .moveTo$(e)
                                            .pipe(ot(() => oe()))
                                    )
                                )
                                .subscribe()
                        ),
                            i.push(
                                this._sequenceDOMRenderer.changingPositionChanged$
                                    .pipe(nt((e) => e))
                                    .subscribe(() => {
                                        this._navigator.graphService.setGraphMode(
                                            O_.Sequence
                                        );
                                    })
                            ),
                            i.push(
                                this._sequenceDOMRenderer.changingPositionChanged$
                                    .pipe(nt((e) => !e))
                                    .subscribe(() => {
                                        this._navigator.graphService.setGraphMode(
                                            O_.Spatial
                                        );
                                    })
                            ),
                            this._navigator.graphService.graphMode$
                                .pipe(
                                    kt((e) =>
                                        e === O_.Spatial
                                            ? this._navigator.stateService.currentImage$.pipe(
                                                  mt(2)
                                              )
                                            : oe()
                                    ),
                                    nt((e) => !e.spatialEdges.cached),
                                    kt((e) =>
                                        this._navigator.graphService
                                            .cacheImage$(e.id)
                                            .pipe(ot(() => oe()))
                                    )
                                )
                                .subscribe(),
                            i.push(
                                this._sequenceDOMRenderer.changingPositionChanged$
                                    .pipe(nt((e) => e))
                                    .subscribe(() => {
                                        this._navigator.playService.stop();
                                    })
                            ),
                            i.push(
                                He(
                                    this._navigator.graphService.graphMode$,
                                    this._sequenceDOMRenderer.changingPositionChanged$.pipe(
                                        Ot(!1),
                                        ft()
                                    )
                                )
                                    .pipe(
                                        $t(
                                            this._navigator.stateService
                                                .currentImage$
                                        ),
                                        kt(([[e, t], i]) =>
                                            t && e === O_.Sequence
                                                ? this._navigator.graphService
                                                      .cacheSequenceImages$(
                                                          i.sequenceId,
                                                          i.id
                                                      )
                                                      .pipe(
                                                          Ct(3),
                                                          ot(
                                                              (e) => (
                                                                  console.error(
                                                                      "Failed to cache sequence images.",
                                                                      e
                                                                  ),
                                                                  oe()
                                                              )
                                                          )
                                                      )
                                                : oe()
                                        )
                                    )
                                    .subscribe()
                            );
                        const r = t.pipe(
                                kt((e) => {
                                    if (!e)
                                        return Ce({ index: null, max: null });
                                    let t = !0;
                                    return this._sequenceDOMRenderer.changingPositionChanged$.pipe(
                                        Ot(!1),
                                        ft(),
                                        kt((e) => {
                                            const i = !e && t ? 0 : 1;
                                            return (
                                                (t = !1),
                                                e
                                                    ? n
                                                    : this._navigator.stateService.currentImage$.pipe(
                                                          ke((e) => e.id),
                                                          ft(),
                                                          zt(i)
                                                      )
                                            );
                                        }),
                                        ke((t) => {
                                            const i = e.imageIds.indexOf(t);
                                            return -1 === i
                                                ? { index: null, max: null }
                                                : {
                                                      index: i,
                                                      max:
                                                          e.imageIds.length - 1,
                                                  };
                                        })
                                    );
                                })
                            ),
                            s = this._navigator.stateService.state$.pipe(
                                ke((e) => e === j_.Earth),
                                ft()
                            );
                        i.push(
                            He(
                                e,
                                this._configuration$,
                                this._containerWidth$,
                                this._sequenceDOMRenderer.changed$.pipe(
                                    Ot(this._sequenceDOMRenderer)
                                ),
                                this._navigator.playService.speed$,
                                r,
                                s
                            )
                                .pipe(
                                    ke(([e, t, i, , n, r, s]) => {
                                        const a =
                                            this._sequenceDOMRenderer.render(
                                                e,
                                                t,
                                                i,
                                                n,
                                                r.index,
                                                r.max,
                                                !s,
                                                this,
                                                this._navigator
                                            );
                                        return { name: this._name, vNode: a };
                                    })
                                )
                                .subscribe(this._container.domRenderer.render$)
                        ),
                            i.push(
                                this._sequenceDOMRenderer.speed$.subscribe(
                                    (e) => {
                                        this._navigator.playService.setSpeed(e);
                                    }
                                )
                            ),
                            i.push(
                                this._configuration$
                                    .pipe(
                                        ke((e) => e.direction),
                                        ft()
                                    )
                                    .subscribe((e) => {
                                        this._navigator.playService.setDirection(
                                            e
                                        );
                                    })
                            ),
                            i.push(
                                He(
                                    this._container.renderService.size$,
                                    this._configuration$.pipe(
                                        ft(
                                            (e, t) =>
                                                e[0] === t[0] && e[1] === t[1],
                                            (e) => [e.minWidth, e.maxWidth]
                                        )
                                    )
                                )
                                    .pipe(
                                        ke(([e, t]) =>
                                            this._sequenceDOMRenderer.getContainerWidth(
                                                e,
                                                t
                                            )
                                        )
                                    )
                                    .subscribe(this._containerWidth$)
                            ),
                            i.push(
                                this._configuration$
                                    .pipe(
                                        ke((e) => e.playing),
                                        ft()
                                    )
                                    .subscribe((e) => {
                                        e
                                            ? this._navigator.playService.play()
                                            : this._navigator.playService.stop();
                                    })
                            ),
                            i.push(
                                this._sequenceDOMRenderer.mouseEnterDirection$
                                    .pipe(
                                        kt((t) =>
                                            We(
                                                e.pipe(
                                                    ke((e) => {
                                                        for (let i of e.edges)
                                                            if (
                                                                i.data
                                                                    .direction ===
                                                                t
                                                            )
                                                                return i.target;
                                                        return null;
                                                    }),
                                                    Rt(
                                                        this
                                                            ._sequenceDOMRenderer
                                                            .mouseLeaveDirection$
                                                    )
                                                ),
                                                Ce(null)
                                            )
                                        ),
                                        ft()
                                    )
                                    .subscribe(this._hoveredIdSubject$)
                            ),
                            i.push(
                                this._hoveredId$.subscribe((e) => {
                                    const t = "hover",
                                        i = { id: e, target: this, type: t };
                                    this.fire(t, i);
                                })
                            );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe(),
                            this._sequenceDOMRenderer.deactivate();
                    }
                    _getDefaultConfiguration() {
                        return {
                            direction: Dp.Next,
                            maxWidth: 108,
                            minWidth: 70,
                            playing: !1,
                            visible: !0,
                        };
                    }
                }
                (gM.componentName = "sequence"),
                    (function (e) {
                        (e[(e.Motion = 0)] = "Motion"),
                            (e[(e.Stationary = 1)] = "Stationary");
                    })(R_ || (R_ = {}));
                class mM {
                    constructor(e, t, i, n, r, s, a, o, c, l) {
                        this._orientation = this._getValue(e, 1);
                        let h = null != a ? a.width : 4,
                            u = null != a ? a.height : 3,
                            d = this._orientation < 5;
                        (this._width = this._getValue(t, d ? h : u)),
                            (this._height = this._getValue(i, d ? u : h)),
                            (this._basicAspect = d
                                ? this._width / this._height
                                : this._height / this._width),
                            (this._basicWidth = d ? t : i),
                            (this._basicHeight = d ? i : t);
                        const p = this._getCameraParameters(c, l),
                            g = p[0],
                            m = p[1],
                            f = p[2];
                        (this._focal = this._getValue(g, 1)),
                            (this._scale = this._getValue(n, 0)),
                            (this._worldToCamera = this.createWorldToCamera(
                                r,
                                s
                            )),
                            (this._worldToCameraInverse = new Os()
                                .copy(this._worldToCamera)
                                .invert()),
                            (this._scaledWorldToCamera =
                                this._createScaledWorldToCamera(
                                    this._worldToCamera,
                                    this._scale
                                )),
                            (this._scaledWorldToCameraInverse = new Os()
                                .copy(this._scaledWorldToCamera)
                                .invert()),
                            (this._basicWorldToCamera =
                                this._createBasicWorldToCamera(
                                    this._worldToCamera,
                                    e
                                )),
                            (this._textureScale = o || [1, 1]),
                            (this._ck1 = m || 0),
                            (this._ck2 = f || 0),
                            (this._cameraType = l || "perspective"),
                            (this._radialPeak = this._getRadialPeak(
                                this._ck1,
                                this._ck2
                            ));
                    }
                    get ck1() {
                        return this._ck1;
                    }
                    get ck2() {
                        return this._ck2;
                    }
                    get cameraType() {
                        return this._cameraType;
                    }
                    get basicAspect() {
                        return this._basicAspect;
                    }
                    get basicHeight() {
                        return this._basicHeight;
                    }
                    get basicRt() {
                        return this._basicWorldToCamera;
                    }
                    get basicWidth() {
                        return this._basicWidth;
                    }
                    get focal() {
                        return this._focal;
                    }
                    get height() {
                        return this._height;
                    }
                    get orientation() {
                        return this._orientation;
                    }
                    get rt() {
                        return this._worldToCamera;
                    }
                    get srt() {
                        return this._scaledWorldToCamera;
                    }
                    get srtInverse() {
                        return this._scaledWorldToCameraInverse;
                    }
                    get scale() {
                        return this._scale;
                    }
                    get hasValidScale() {
                        return this._scale > 0.01 && this._scale < 50;
                    }
                    get radialPeak() {
                        return this._radialPeak;
                    }
                    get width() {
                        return this._width;
                    }
                    upVector() {
                        let e = this._worldToCamera.elements;
                        switch (this._orientation) {
                            case 1:
                            default:
                                return new rs(-e[1], -e[5], -e[9]);
                            case 3:
                                return new rs(e[1], e[5], e[9]);
                            case 6:
                                return new rs(-e[0], -e[4], -e[8]);
                            case 8:
                                return new rs(e[0], e[4], e[8]);
                        }
                    }
                    projectorMatrix() {
                        let e = this._normalizedToTextureMatrix(),
                            t = this._focal,
                            i = new Os().set(
                                t,
                                0,
                                0,
                                0,
                                0,
                                t,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0
                            );
                        return (
                            e.multiply(i), e.multiply(this._worldToCamera), e
                        );
                    }
                    projectBasic(e) {
                        let t = this.projectSfM(e);
                        return this._sfmToBasic(t);
                    }
                    unprojectBasic(e, t, i) {
                        let n = this._basicToSfm(e);
                        return this.unprojectSfM(n, t, i);
                    }
                    projectSfM(e) {
                        let t = new es(e[0], e[1], e[2], 1);
                        return (
                            t.applyMatrix4(this._worldToCamera),
                            this._bearingToSfm([t.x, t.y, t.z])
                        );
                    }
                    unprojectSfM(e, t, i) {
                        const n = this._sfmToBearing(e),
                            r = (
                                i && !jp(this._cameraType)
                                    ? new es(
                                          (t * n[0]) / n[2],
                                          (t * n[1]) / n[2],
                                          t,
                                          1
                                      )
                                    : new es(t * n[0], t * n[1], t * n[2], 1)
                            ).applyMatrix4(this._worldToCameraInverse);
                        return [r.x / r.w, r.y / r.w, r.z / r.w];
                    }
                    _sfmToBearing(e) {
                        if (jp(this._cameraType)) {
                            let t = 2 * e[0] * Math.PI,
                                i = 2 * -e[1] * Math.PI;
                            return [
                                Math.cos(i) * Math.sin(t),
                                -Math.sin(i),
                                Math.cos(i) * Math.cos(t),
                            ];
                        }
                        if (Op(this._cameraType)) {
                            let [t, i] = [
                                e[0] / this._focal,
                                e[1] / this._focal,
                            ];
                            const n = Math.sqrt(t * t + i * i);
                            let r =
                                    n /
                                    this._distortionFromDistortedRadius(
                                        n,
                                        this._ck1,
                                        this._ck2,
                                        this._radialPeak
                                    ),
                                s = Math.cos(r),
                                a = Math.sin(r);
                            const o = n > 1e-8 ? 1 / n : 1;
                            return [a * t * o, a * i * o, s];
                        }
                        {
                            let [t, i] = [
                                e[0] / this._focal,
                                e[1] / this._focal,
                            ];
                            const n = Math.sqrt(t * t + i * i);
                            let r = this._distortionFromDistortedRadius(
                                    n,
                                    this._ck1,
                                    this._ck2,
                                    this._radialPeak
                                ),
                                s = new rs(t / r, i / r, 1);
                            return s.normalize(), [s.x, s.y, s.z];
                        }
                    }
                    _distortionFromDistortedRadius(e, t, i, n) {
                        let r = 1;
                        for (let s = 0; s < 10; s++) {
                            let s = e / r;
                            s > n && (s = n),
                                (r =
                                    1 +
                                    t * Math.pow(s, 2) +
                                    i * Math.pow(s, 4));
                        }
                        return r;
                    }
                    _bearingToSfm(e) {
                        if (jp(this._cameraType)) {
                            let t = e[0],
                                i = e[1],
                                n = e[2],
                                r = Math.atan2(t, n),
                                s = Math.atan2(-i, Math.sqrt(t * t + n * n));
                            return [r / (2 * Math.PI), -s / (2 * Math.PI)];
                        }
                        if (Op(this._cameraType)) {
                            if (e[2] > 0) {
                                const [t, i, n] = e,
                                    r = Math.sqrt(t * t + i * i);
                                let s = Math.atan2(r, n);
                                s > this._radialPeak && (s = this._radialPeak);
                                const a =
                                        1 +
                                        Math.pow(s, 2) *
                                            (this._ck1 +
                                                Math.pow(s, 2) * this._ck2),
                                    o = (this._focal * a * s) / r;
                                return [o * t, o * i];
                            }
                            return [
                                e[0] < 0
                                    ? Number.NEGATIVE_INFINITY
                                    : Number.POSITIVE_INFINITY,
                                e[1] < 0
                                    ? Number.NEGATIVE_INFINITY
                                    : Number.POSITIVE_INFINITY,
                            ];
                        }
                        if (e[2] > 0) {
                            let [t, i] = [e[0] / e[2], e[1] / e[2]],
                                n = t * t + i * i;
                            const r = Math.pow(this._radialPeak, 2);
                            n > r && (n = r);
                            const s =
                                1 + this._ck1 * n + this._ck2 * Math.pow(n, 2);
                            return [this._focal * s * t, this._focal * s * i];
                        }
                        return [
                            e[0] < 0
                                ? Number.NEGATIVE_INFINITY
                                : Number.POSITIVE_INFINITY,
                            e[1] < 0
                                ? Number.NEGATIVE_INFINITY
                                : Number.POSITIVE_INFINITY,
                        ];
                    }
                    _basicToSfm(e) {
                        let t, i;
                        switch (this._orientation) {
                            case 1:
                            default:
                                (t = e[0]), (i = e[1]);
                                break;
                            case 3:
                                (t = 1 - e[0]), (i = 1 - e[1]);
                                break;
                            case 6:
                                (t = e[1]), (i = 1 - e[0]);
                                break;
                            case 8:
                                (t = 1 - e[1]), (i = e[0]);
                        }
                        let n = this._width,
                            r = this._height,
                            s = Math.max(n, r);
                        return [
                            (t * n) / s - n / s / 2,
                            (i * r) / s - r / s / 2,
                        ];
                    }
                    _sfmToBasic(e) {
                        let t,
                            i,
                            n = this._width,
                            r = this._height,
                            s = Math.max(n, r),
                            a = ((e[0] + n / s / 2) / n) * s,
                            o = ((e[1] + r / s / 2) / r) * s;
                        switch (this._orientation) {
                            case 1:
                            default:
                                (t = a), (i = o);
                                break;
                            case 3:
                                (t = 1 - a), (i = 1 - o);
                                break;
                            case 6:
                                (t = 1 - o), (i = a);
                                break;
                            case 8:
                                (t = o), (i = 1 - a);
                        }
                        return [t, i];
                    }
                    _getValue(e, t) {
                        return null != e && e > 0 ? e : t;
                    }
                    _getCameraParameters(e, t) {
                        if (jp(t)) return [];
                        if (!e || 0 === e.length) return [1, 0, 0];
                        const i = 3 - e.length;
                        return i <= 0 ? e : e.concat(new Array(i).fill(0));
                    }
                    createWorldToCamera(e, t) {
                        const i = new rs(e[0], e[1], e[2]),
                            n = i.length();
                        n > 0 && i.normalize();
                        const r = new Os();
                        return (
                            r.makeRotationAxis(i, n),
                            r.setPosition(new rs(t[0], t[1], t[2])),
                            r
                        );
                    }
                    _createScaledWorldToCamera(e, t) {
                        const i = e.clone(),
                            n = i.elements;
                        return (
                            (n[12] = t * n[12]),
                            (n[13] = t * n[13]),
                            (n[14] = t * n[14]),
                            i.scale(new rs(t, t, t)),
                            i
                        );
                    }
                    _createBasicWorldToCamera(e, t) {
                        const i = new rs(0, 0, 1);
                        let n = 0;
                        switch (t) {
                            case 3:
                                n = Math.PI;
                                break;
                            case 6:
                                n = Math.PI / 2;
                                break;
                            case 8:
                                n = (3 * Math.PI) / 2;
                        }
                        return new Os().makeRotationAxis(i, n).multiply(e);
                    }
                    _getRadialPeak(e, t) {
                        const i = 5 * t,
                            n = 3 * e,
                            r = Math.pow(n, 2) - 4 * i * 1;
                        if (r < 0) return;
                        const s = (-n - Math.sqrt(r)) / 2 / i,
                            a = (-n + Math.sqrt(r)) / 2 / i,
                            o = Math.min(s, a),
                            c = Math.max(s, a);
                        return o > 0
                            ? Math.sqrt(o)
                            : c > 0
                            ? Math.sqrt(c)
                            : void 0;
                    }
                    _normalizedToTextureMatrix() {
                        const e = Math.max(this._width, this._height),
                            t =
                                this._orientation < 5
                                    ? this._textureScale[0]
                                    : this._textureScale[1],
                            i =
                                this._orientation < 5
                                    ? this._textureScale[1]
                                    : this._textureScale[0],
                            n = (e / this._width) * t,
                            r = (e / this._height) * i;
                        switch (this._orientation) {
                            case 1:
                            default:
                                return new Os().set(
                                    n,
                                    0,
                                    0,
                                    0.5,
                                    0,
                                    -r,
                                    0,
                                    0.5,
                                    0,
                                    0,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    1
                                );
                            case 3:
                                return new Os().set(
                                    -n,
                                    0,
                                    0,
                                    0.5,
                                    0,
                                    r,
                                    0,
                                    0.5,
                                    0,
                                    0,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    1
                                );
                            case 6:
                                return new Os().set(
                                    0,
                                    -r,
                                    0,
                                    0.5,
                                    -n,
                                    0,
                                    0,
                                    0.5,
                                    0,
                                    0,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    1
                                );
                            case 8:
                                return new Os().set(
                                    0,
                                    r,
                                    0,
                                    0.5,
                                    n,
                                    0,
                                    0,
                                    0.5,
                                    0,
                                    0,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    1
                                );
                        }
                    }
                }
                class fM {
                    constructor() {
                        (this._factory = new __()),
                            (this._scene = new M_()),
                            (this._spatial = new Lp()),
                            (this._currentKey = null),
                            (this._previousKey = null),
                            (this._disabled = !1),
                            (this._curtain = 1),
                            (this._frameId = 0),
                            (this._needsRender = !1),
                            (this._mode = null),
                            (this._currentProviderDisposers = {}),
                            (this._previousProviderDisposers = {});
                    }
                    get disabled() {
                        return this._disabled;
                    }
                    get frameId() {
                        return this._frameId;
                    }
                    get needsRender() {
                        return this._needsRender;
                    }
                    setTextureProvider(e, t) {
                        this._setTextureProvider(
                            e,
                            this._currentKey,
                            t,
                            this._currentProviderDisposers,
                            this._updateTexture.bind(this)
                        );
                    }
                    setTextureProviderPrev(e, t) {
                        this._setTextureProvider(
                            e,
                            this._previousKey,
                            t,
                            this._previousProviderDisposers,
                            this._updateTexturePrev.bind(this)
                        );
                    }
                    update(e, t) {
                        this._updateFrameId(e.id),
                            this._updateImagePlanes(e.state, t);
                    }
                    updateCurtain(e) {
                        this._curtain !== e &&
                            ((this._curtain = e),
                            this._updateCurtain(),
                            (this._needsRender = !0));
                    }
                    updateTexture(e, t) {
                        const i =
                            t.id === this._currentKey
                                ? this._scene.planes
                                : t.id === this._previousKey
                                ? this._scene.planesOld
                                : {};
                        if (0 !== Object.keys(i).length) {
                            this._needsRender = !0;
                            for (const t in i) {
                                if (!i.hasOwnProperty(t)) continue;
                                let n =
                                    i[t].material.uniforms.projectorTex.value;
                                (n.image = e), (n.needsUpdate = !0);
                            }
                        }
                    }
                    updateTextureImage(e, t) {
                        if (this._currentKey !== t.id) return;
                        this._needsRender = !0;
                        const i = this._scene.planes;
                        for (const t in i) {
                            if (!i.hasOwnProperty(t)) continue;
                            let n = i[t].material.uniforms.projectorTex.value;
                            (n.image = e), (n.needsUpdate = !0);
                        }
                    }
                    render(e, t) {
                        this.disabled || t.render(this._scene.sceneOld, e),
                            t.render(this._scene.scene, e),
                            (this._needsRender = !1);
                    }
                    dispose() {
                        this._scene.clear();
                        for (const e in this._currentProviderDisposers)
                            this._currentProviderDisposers.hasOwnProperty(e) &&
                                this._currentProviderDisposers[e]();
                        for (const e in this._previousProviderDisposers)
                            this._previousProviderDisposers.hasOwnProperty(e) &&
                                this._previousProviderDisposers[e]();
                        (this._currentProviderDisposers = {}),
                            (this._previousProviderDisposers = {});
                    }
                    _getBasicCorners(e, t) {
                        let i, n;
                        return (
                            e > t
                                ? ((i = 0.5), (n = (0.5 * e) / t))
                                : ((i = (0.5 * t) / e), (n = 0.5)),
                            [
                                [0.5 - i, 0.5 - n],
                                [0.5 + i, 0.5 + n],
                            ]
                        );
                    }
                    _setDisabled(e) {
                        this._disabled =
                            null == e.currentImage ||
                            null == e.previousImage ||
                            (jp(e.currentImage.cameraType) &&
                                !jp(e.previousImage.cameraType));
                    }
                    _setTextureProvider(e, t, i, n, r) {
                        if (e !== t) return;
                        let s = i.textureCreated$.subscribe(r),
                            a = i.textureUpdated$.subscribe((e) => {
                                this._needsRender = !0;
                            });
                        e in n && ((0, n[e])(), delete n[e]),
                            (n[e] = () => {
                                s.unsubscribe(), a.unsubscribe(), i.dispose();
                            });
                    }
                    _updateCurtain() {
                        const e = this._scene.planes;
                        for (const t in e) {
                            if (!e.hasOwnProperty(t)) continue;
                            let i = e[t].material;
                            i.uniforms.curtain &&
                                (i.uniforms.curtain.value = this._curtain);
                        }
                    }
                    _updateFrameId(e) {
                        this._frameId = e;
                    }
                    _updateImagePlanes(e, t) {
                        const i =
                                null != e.currentImage &&
                                this._currentKey !== e.currentImage.id,
                            n =
                                null != e.previousImage &&
                                this._previousKey !== e.previousImage.id,
                            r = this._mode !== t;
                        if (!(i || n || r)) return;
                        this._setDisabled(e),
                            (this._needsRender = !0),
                            (this._mode = t);
                        const s =
                            e.motionless ||
                            t === R_.Stationary ||
                            jp(e.currentImage.cameraType);
                        if (
                            ((this.disabled || n) &&
                                this._previousKey in
                                    this._previousProviderDisposers &&
                                (this._previousProviderDisposers[
                                    this._previousKey
                                ](),
                                delete this._previousProviderDisposers[
                                    this._previousKey
                                ]),
                            this.disabled)
                        )
                            this._scene.setImagePlanesOld({});
                        else if (n || r) {
                            const t = e.previousImage;
                            this._previousKey = t.id;
                            const i = e.currentTransform.rt.elements;
                            let n = [i[12], i[13], i[14]];
                            const r = e.currentTransform.basicAspect,
                                a = e.previousTransform.basicAspect,
                                o = r > a ? [1, a / r] : [r / a, 1];
                            let c = e.currentImage.rotation,
                                l = e.currentImage.width,
                                h = e.currentImage.height;
                            jp(t.cameraType) &&
                                ((c = e.previousImage.rotation),
                                (n = this._spatial
                                    .rotate(
                                        this._spatial
                                            .opticalCenter(
                                                e.currentImage.rotation,
                                                n
                                            )
                                            .toArray(),
                                        c
                                    )
                                    .multiplyScalar(-1)
                                    .toArray()),
                                (l = e.previousImage.width),
                                (h = e.previousImage.height));
                            const u = new mM(
                                e.currentImage.exifOrientation,
                                l,
                                h,
                                e.currentImage.scale,
                                c,
                                n,
                                t.image,
                                o,
                                e.currentImage.cameraParameters,
                                e.currentImage.cameraType
                            );
                            let d;
                            if (jp(t.cameraType))
                                d = this._factory.createMesh(
                                    t,
                                    s || jp(e.currentImage.cameraType)
                                        ? u
                                        : e.previousTransform
                                );
                            else if (s) {
                                const [[t, i], [n, s]] = this._getBasicCorners(
                                    r,
                                    a
                                );
                                d = this._factory.createFlatMesh(
                                    e.previousImage,
                                    u,
                                    t,
                                    n,
                                    i,
                                    s
                                );
                            } else
                                d = this._factory.createMesh(
                                    e.previousImage,
                                    e.previousTransform
                                );
                            const p = {};
                            (p[t.id] = d), this._scene.setImagePlanesOld(p);
                        }
                        if (i || r) {
                            this._currentKey in
                                this._currentProviderDisposers &&
                                (this._currentProviderDisposers[
                                    this._currentKey
                                ](),
                                delete this._currentProviderDisposers[
                                    this._currentKey
                                ]),
                                (this._currentKey = e.currentImage.id);
                            const t = {};
                            jp(e.currentImage.cameraType)
                                ? (t[e.currentImage.id] =
                                      this._factory.createCurtainMesh(
                                          e.currentImage,
                                          e.currentTransform
                                      ))
                                : (t[e.currentImage.id] = s
                                      ? this._factory.createDistortedCurtainMesh(
                                            e.currentImage,
                                            e.currentTransform
                                        )
                                      : this._factory.createCurtainMesh(
                                            e.currentImage,
                                            e.currentTransform
                                        )),
                                this._scene.setImagePlanes(t),
                                this._updateCurtain();
                        }
                    }
                    _updateTexture(e) {
                        this._needsRender = !0;
                        const t = this._scene.planes;
                        for (const i in t) {
                            if (!t.hasOwnProperty(i)) continue;
                            let n = t[i].material,
                                r = n.uniforms.projectorTex.value;
                            (n.uniforms.projectorTex.value = null),
                                r.dispose(),
                                (n.uniforms.projectorTex.value = e);
                        }
                    }
                    _updateTexturePrev(e) {
                        this._needsRender = !0;
                        const t = this._scene.planesOld;
                        for (const i in t) {
                            if (!t.hasOwnProperty(i)) continue;
                            let n = t[i].material,
                                r = n.uniforms.projectorTex.value;
                            (n.uniforms.projectorTex.value = null),
                                r.dispose(),
                                (n.uniforms.projectorTex.value = e);
                        }
                    }
                }
                class _M {
                    constructor(e) {
                        (this._container = e),
                            (this._interacting = !1),
                            (this._notifyModeChanged$ = new W()),
                            (this._notifyPositionChanged$ = new W()),
                            (this._stopInteractionSubscription = null);
                    }
                    get mode$() {
                        return this._notifyModeChanged$;
                    }
                    get position$() {
                        return this._notifyPositionChanged$;
                    }
                    activate() {
                        this._stopInteractionSubscription ||
                            (this._stopInteractionSubscription = tt(
                                this._container.mouseService.documentMouseUp$,
                                this._container.touchService.touchEnd$.pipe(
                                    nt((e) => 0 === e.touches.length)
                                )
                            ).subscribe((e) => {
                                this._interacting && (this._interacting = !1);
                            }));
                    }
                    deactivate() {
                        this._stopInteractionSubscription &&
                            ((this._interacting = !1),
                            this._stopInteractionSubscription.unsubscribe(),
                            (this._stopInteractionSubscription = null));
                    }
                    render(e, t, i, n, r) {
                        const s = [];
                        if (r) {
                            s.push(n_.h("div.mapillary-slider-border", []));
                            const r = !(i || n);
                            r &&
                                (s.push(this._createModeButton(t)),
                                s.push(this._createModeButton2d(t))),
                                s.push(this._createPositionInput(e, r));
                        }
                        const a =
                                this._container.domContainer.getBoundingClientRect(),
                            o = Math.max(215, Math.min(400, a.width - 100));
                        return n_.h(
                            "div.mapillary-slider-container",
                            { style: { width: `${o}px` } },
                            s
                        );
                    }
                    _createModeButton(e) {
                        const t = {
                                onclick: () => {
                                    e !== R_.Motion &&
                                        this._notifyModeChanged$.next(
                                            R_.Motion
                                        );
                                },
                            },
                            i =
                                e === R_.Stationary
                                    ? "mapillary-slider-mode-button-inactive"
                                    : "mapillary-slider-mode-button";
                        return n_.h("div." + i, t, [
                            n_.h("div.mapillary-slider-mode-icon", []),
                        ]);
                    }
                    _createModeButton2d(e) {
                        const t = {
                                onclick: () => {
                                    e !== R_.Stationary &&
                                        this._notifyModeChanged$.next(
                                            R_.Stationary
                                        );
                                },
                            },
                            i =
                                e === R_.Motion
                                    ? "mapillary-slider-mode-button-2d-inactive"
                                    : "mapillary-slider-mode-button-2d";
                        return n_.h("div." + i, t, [
                            n_.h("div.mapillary-slider-mode-icon-2d", []),
                        ]);
                    }
                    _createPositionInput(e, t) {
                        const i = (e) => {
                                this._notifyPositionChanged$.next(
                                    Number(e.target.value) / 1e3
                                );
                            },
                            n = (e) => {
                                (this._interacting = !0), e.stopPropagation();
                            },
                            r = (e) => {
                                this._interacting && e.stopPropagation();
                            },
                            s =
                                this._container.domContainer.getBoundingClientRect(),
                            a =
                                Math.max(215, Math.min(400, s.width - 105)) -
                                84 +
                                (t ? 0 : 52),
                            o = n_.h(
                                "input.mapillary-slider-position",
                                {
                                    max: 1e3,
                                    min: 0,
                                    onchange: i,
                                    oninput: i,
                                    onkeydown: (e) => {
                                        ("ArrowDown" !== e.key &&
                                            "ArrowLeft" !== e.key &&
                                            "ArrowRight" !== e.key &&
                                            "ArrowUp" !== e.key) ||
                                            e.preventDefault();
                                    },
                                    onpointerdown: n,
                                    onpointermove: r,
                                    ontouchmove: r,
                                    ontouchstart: n,
                                    style: { width: `${a}px` },
                                    type: "range",
                                    value: 1e3 * e,
                                },
                                []
                            );
                        return n_.h("div.mapillary-slider-position-container", [
                            o,
                        ]);
                    }
                }
                class MM extends a_ {
                    constructor(e, t, i, n) {
                        super(e, t, i),
                            (this._viewportCoords = n || new l_()),
                            (this._domRenderer = new _M(t)),
                            (this._imageTileLoader = new y_(i.api)),
                            (this._roiCalculator = new b_()),
                            (this._spatial = new Lp()),
                            (this._glRendererOperation$ = new W()),
                            (this._glRendererCreator$ = new W()),
                            (this._glRendererDisposer$ = new W()),
                            (this._glRenderer$ =
                                this._glRendererOperation$.pipe(
                                    At((e, t) => t(e), null),
                                    nt((e) => null != e),
                                    ft(void 0, (e) => e.frameId)
                                )),
                            this._glRendererCreator$
                                .pipe(
                                    ke(() => (e) => {
                                        if (null != e)
                                            throw new Error(
                                                "Multiple slider states can not be created at the same time"
                                            );
                                        return new fM();
                                    })
                                )
                                .subscribe(this._glRendererOperation$),
                            this._glRendererDisposer$
                                .pipe(ke(() => (e) => (e.dispose(), null)))
                                .subscribe(this._glRendererOperation$);
                    }
                    _activate() {
                        const e = this._subscriptions;
                        e.push(
                            this._domRenderer.mode$.subscribe((e) => {
                                this.configure({ mode: e });
                            })
                        ),
                            e.push(
                                this._glRenderer$
                                    .pipe(
                                        ke((e) => ({
                                            name: this._name,
                                            renderer: {
                                                frameId: e.frameId,
                                                needsRender: e.needsRender,
                                                render: e.render.bind(e),
                                                pass: i_.Background,
                                            },
                                        }))
                                    )
                                    .subscribe(
                                        this._container.glRenderer.render$
                                    )
                            );
                        const t = We(
                                this.configuration$.pipe(
                                    ke((e) =>
                                        null != e.initialPosition
                                            ? e.initialPosition
                                            : 1
                                    ),
                                    bt()
                                ),
                                this._domRenderer.position$
                            ),
                            i = this.configuration$.pipe(
                                ke((e) => e.mode),
                                ft()
                            ),
                            n = this._navigator.stateService.currentState$.pipe(
                                ke((e) => e.state.motionless),
                                ft()
                            ),
                            r = this._navigator.stateService.currentState$.pipe(
                                ke((e) => jp(e.state.currentImage.cameraType)),
                                ft()
                            ),
                            s = He(
                                this._configuration$.pipe(
                                    ke((e) => e.sliderVisible)
                                ),
                                this._navigator.stateService.currentState$.pipe(
                                    ke(
                                        (e) =>
                                            !(
                                                null == e.state.currentImage ||
                                                null == e.state.previousImage ||
                                                (jp(
                                                    e.state.currentImage
                                                        .cameraType
                                                ) &&
                                                    !jp(
                                                        e.state.previousImage
                                                            .cameraType
                                                    ))
                                            )
                                    ),
                                    ft()
                                )
                            ).pipe(
                                ke(([e, t]) => e && t),
                                ft()
                            );
                        (this._waitSubscription = He(i, n, r, s)
                            .pipe($t(this._navigator.stateService.state$))
                            .subscribe(([[e, t, i, n], r]) => {
                                const s = n && (t || e === R_.Stationary || i);
                                s && r !== j_.WaitingInteractively
                                    ? this._navigator.stateService.waitInteractively()
                                    : s ||
                                      r === j_.Waiting ||
                                      this._navigator.stateService.wait();
                            })),
                            e.push(
                                He(t, i, n, r, s).subscribe(([e, t, i, n]) => {
                                    i || t === R_.Stationary || n
                                        ? this._navigator.stateService.moveTo(1)
                                        : this._navigator.stateService.moveTo(
                                              e
                                          );
                                })
                            ),
                            e.push(
                                He(
                                    t,
                                    i,
                                    n,
                                    r,
                                    s,
                                    this._container.renderService.size$
                                )
                                    .pipe(
                                        ke(([e, t, i, n, r]) => ({
                                            name: this._name,
                                            vNode: this._domRenderer.render(
                                                e,
                                                t,
                                                i,
                                                n,
                                                r
                                            ),
                                        }))
                                    )
                                    .subscribe(
                                        this._container.domRenderer.render$
                                    )
                            ),
                            this._glRendererCreator$.next(null),
                            e.push(
                                He(
                                    t,
                                    r,
                                    s,
                                    this._container.renderService.renderCamera$,
                                    this._navigator.stateService
                                        .currentTransform$
                                )
                                    .pipe(
                                        ke(([e, t, i, n, r]) => {
                                            if (!t) return i ? e : 1;
                                            const s =
                                                    this._viewportCoords.viewportToBasic(
                                                        -1.15,
                                                        0,
                                                        r,
                                                        n.perspective
                                                    ),
                                                a =
                                                    this._viewportCoords.viewportToBasic(
                                                        1.15,
                                                        0,
                                                        r,
                                                        n.perspective
                                                    ),
                                                o =
                                                    a[0] < s[0]
                                                        ? a[0] + 1
                                                        : a[0],
                                                c = s[0] + e * (o - s[0]);
                                            return c > 1 ? c - 1 : c;
                                        }),
                                        ke(
                                            (e) => (t) => (
                                                t.updateCurtain(e), t
                                            )
                                        )
                                    )
                                    .subscribe(this._glRendererOperation$)
                            ),
                            e.push(
                                He(
                                    this._navigator.stateService.currentState$,
                                    i
                                )
                                    .pipe(
                                        ke(
                                            ([e, t]) =>
                                                (i) => (i.update(e, t), i)
                                        )
                                    )
                                    .subscribe(this._glRendererOperation$)
                            ),
                            e.push(
                                this._configuration$
                                    .pipe(
                                        nt((e) => null != e.ids),
                                        kt((e) =>
                                            rt(
                                                rt(
                                                    this._catchCacheImage$(
                                                        e.ids.background
                                                    ),
                                                    this._catchCacheImage$(
                                                        e.ids.foreground
                                                    )
                                                ).pipe(
                                                    ke((e) => ({
                                                        background: e[0],
                                                        foreground: e[1],
                                                    }))
                                                ),
                                                this._navigator.stateService.currentState$.pipe(
                                                    bt()
                                                )
                                            ).pipe(
                                                ke((e) => ({
                                                    images: e[0],
                                                    state: e[1].state,
                                                }))
                                            )
                                        )
                                    )
                                    .subscribe(
                                        (e) => {
                                            (null != e.state.currentImage &&
                                                null != e.state.previousImage &&
                                                e.state.currentImage.id ===
                                                    e.images.foreground.id &&
                                                e.state.previousImage.id ===
                                                    e.images.background.id) ||
                                                (e.state.currentImage.id !==
                                                e.images.background.id
                                                    ? e.state.currentImage
                                                          .id !==
                                                          e.images.foreground
                                                              .id ||
                                                      1 !==
                                                          e.state.trajectory
                                                              .length
                                                        ? (this._navigator.stateService.setImages(
                                                              [
                                                                  e.images
                                                                      .background,
                                                              ]
                                                          ),
                                                          this._navigator.stateService.setImages(
                                                              [
                                                                  e.images
                                                                      .foreground,
                                                              ]
                                                          ))
                                                        : this._navigator.stateService.prependImages(
                                                              [
                                                                  e.images
                                                                      .background,
                                                              ]
                                                          )
                                                    : this._navigator.stateService.setImages(
                                                          [e.images.foreground]
                                                      ));
                                        },
                                        (e) => {
                                            console.error(e);
                                        }
                                    )
                            );
                        const a =
                            this._container.configurationService.imageTiling$.pipe(
                                kt((e) =>
                                    e
                                        ? this._navigator.stateService
                                              .currentState$
                                        : new W()
                                ),
                                ft(void 0, (e) => e.state.currentImage.id),
                                $t(
                                    this._container.glRenderer.webGLRenderer$,
                                    this._container.renderService.size$
                                ),
                                ke(([e, t, i]) => {
                                    const n = e.state;
                                    Math.max(i.width, i.height);
                                    const r = n.currentImage,
                                        s = n.currentTransform;
                                    return new z_(
                                        r.id,
                                        s.basicWidth,
                                        s.basicHeight,
                                        r.image,
                                        this._imageTileLoader,
                                        new x_(),
                                        t
                                    );
                                }),
                                It(1),
                                V()
                            );
                        e.push(a.subscribe(() => {})),
                            e.push(
                                a
                                    .pipe(
                                        ke(
                                            (e) => (t) => (
                                                t.setTextureProvider(e.id, e), t
                                            )
                                        )
                                    )
                                    .subscribe(this._glRendererOperation$)
                            ),
                            e.push(
                                a.pipe(Nt()).subscribe((e) => {
                                    e[0].abort();
                                })
                            );
                        const o =
                            this._container.configurationService.imageTiling$.pipe(
                                kt((e) =>
                                    e
                                        ? He(
                                              this._container.renderService
                                                  .renderCameraFrame$,
                                              this._container.renderService.size$.pipe(
                                                  pt(250)
                                              )
                                          )
                                        : new W()
                                ),
                                ke(([e, t]) => [
                                    e.camera.position.clone(),
                                    e.camera.lookat.clone(),
                                    e.zoom.valueOf(),
                                    t.height.valueOf(),
                                    t.width.valueOf(),
                                ]),
                                Nt(),
                                jt(
                                    (e) =>
                                        e[1][2] - e[0][2] < 0 || 0 === e[1][2]
                                ),
                                ke((e) => {
                                    let t = e[0][0].equals(e[1][0]),
                                        i = e[0][1].equals(e[1][1]),
                                        n = e[0][2] === e[1][2],
                                        r = e[0][3] === e[1][3],
                                        s = e[0][4] === e[1][4];
                                    return t && i && n && r && s;
                                }),
                                ft(),
                                nt((e) => e),
                                kt(() =>
                                    this._container.renderService.renderCameraFrame$.pipe(
                                        bt()
                                    )
                                ),
                                $t(
                                    this._container.renderService.size$,
                                    this._navigator.stateService
                                        .currentTransform$
                                )
                            );
                        e.push(
                            a
                                .pipe(
                                    kt((e) =>
                                        o.pipe(
                                            ke(([t, i, n]) => [
                                                this._roiCalculator.computeRegionOfInterest(
                                                    t,
                                                    i,
                                                    n
                                                ),
                                                e,
                                            ])
                                        )
                                    ),
                                    nt((e) => !e[1].disposed)
                                )
                                .subscribe((e) => {
                                    let t = e[0];
                                    e[1].setRegionOfInterest(t);
                                })
                        );
                        const c = a.pipe(
                            kt((e) => e.hasTexture$),
                            Ot(!1),
                            It(1),
                            V()
                        );
                        e.push(c.subscribe(() => {}));
                        const l =
                            this._container.configurationService.imageTiling$.pipe(
                                kt((e) =>
                                    e
                                        ? this._navigator.stateService
                                              .currentState$
                                        : new W()
                                ),
                                nt((e) => !!e.state.previousImage),
                                ft(void 0, (e) => e.state.previousImage.id),
                                $t(
                                    this._container.glRenderer.webGLRenderer$,
                                    this._container.renderService.size$
                                ),
                                ke(([e, t, i]) => {
                                    const n = e.state,
                                        r = n.previousImage,
                                        s = n.previousTransform;
                                    return new z_(
                                        r.id,
                                        s.basicWidth,
                                        s.basicHeight,
                                        r.image,
                                        this._imageTileLoader,
                                        new x_(),
                                        t
                                    );
                                }),
                                It(1),
                                V()
                            );
                        e.push(l.subscribe(() => {})),
                            e.push(
                                l
                                    .pipe(
                                        ke(
                                            (e) => (t) => (
                                                t.setTextureProviderPrev(
                                                    e.id,
                                                    e
                                                ),
                                                t
                                            )
                                        )
                                    )
                                    .subscribe(this._glRendererOperation$)
                            ),
                            e.push(
                                l.pipe(Nt()).subscribe((e) => {
                                    e[0].abort();
                                })
                            );
                        const h =
                            this._container.configurationService.imageTiling$.pipe(
                                kt((e) =>
                                    e
                                        ? He(
                                              this._container.renderService
                                                  .renderCameraFrame$,
                                              this._container.renderService.size$.pipe(
                                                  pt(250)
                                              )
                                          )
                                        : new W()
                                ),
                                ke(([e, t]) => [
                                    e.camera.position.clone(),
                                    e.camera.lookat.clone(),
                                    e.zoom.valueOf(),
                                    t.height.valueOf(),
                                    t.width.valueOf(),
                                ]),
                                Nt(),
                                jt(
                                    (e) =>
                                        e[1][2] - e[0][2] < 0 || 0 === e[1][2]
                                ),
                                ke((e) => {
                                    let t = e[0][0].equals(e[1][0]),
                                        i = e[0][1].equals(e[1][1]),
                                        n = e[0][2] === e[1][2],
                                        r = e[0][3] === e[1][3],
                                        s = e[0][4] === e[1][4];
                                    return t && i && n && r && s;
                                }),
                                ft(),
                                nt((e) => e),
                                kt(() =>
                                    this._container.renderService.renderCameraFrame$.pipe(
                                        bt()
                                    )
                                ),
                                $t(
                                    this._container.renderService.size$,
                                    this._navigator.stateService
                                        .currentTransform$
                                )
                            );
                        e.push(
                            l
                                .pipe(
                                    kt((e) =>
                                        h.pipe(
                                            ke(([t, i, n]) => [
                                                this._roiCalculator.computeRegionOfInterest(
                                                    t,
                                                    i,
                                                    n
                                                ),
                                                e,
                                            ])
                                        )
                                    ),
                                    nt((e) => !e[1].disposed),
                                    $t(
                                        this._navigator.stateService
                                            .currentState$
                                    )
                                )
                                .subscribe(([[e, t], i]) => {
                                    let n = null;
                                    if (jp(i.state.previousImage.cameraType))
                                        if (
                                            jp(i.state.currentImage.cameraType)
                                        ) {
                                            const t =
                                                    this._spatial.viewingDirection(
                                                        i.state.currentImage
                                                            .rotation
                                                    ),
                                                r =
                                                    this._spatial.viewingDirection(
                                                        i.state.previousImage
                                                            .rotation
                                                    ),
                                                s =
                                                    this._spatial.angleBetweenVector2(
                                                        t.x,
                                                        t.y,
                                                        r.x,
                                                        r.y
                                                    ) /
                                                    (2 * Math.PI);
                                            n = {
                                                bbox: {
                                                    maxX: this._spatial.wrap(
                                                        e.bbox.maxX + s,
                                                        0,
                                                        1
                                                    ),
                                                    maxY: e.bbox.maxY,
                                                    minX: this._spatial.wrap(
                                                        e.bbox.minX + s,
                                                        0,
                                                        1
                                                    ),
                                                    minY: e.bbox.minY,
                                                },
                                                pixelHeight: e.pixelHeight,
                                                pixelWidth: e.pixelWidth,
                                            };
                                        } else {
                                            const t =
                                                    this._spatial.viewingDirection(
                                                        i.state.currentImage
                                                            .rotation
                                                    ),
                                                r =
                                                    this._spatial.viewingDirection(
                                                        i.state.previousImage
                                                            .rotation
                                                    ),
                                                s =
                                                    this._spatial.angleBetweenVector2(
                                                        t.x,
                                                        t.y,
                                                        r.x,
                                                        r.y
                                                    ) /
                                                    (2 * Math.PI),
                                                a = this._spatial.angleToPlane(
                                                    t.toArray(),
                                                    [0, 0, 1]
                                                ),
                                                o =
                                                    (this._spatial.angleToPlane(
                                                        r.toArray(),
                                                        [0, 0, 1]
                                                    ) -
                                                        a) /
                                                    (2 * Math.PI),
                                                c = i.state.currentTransform,
                                                l = Math.max(
                                                    c.basicWidth,
                                                    c.basicHeight
                                                ),
                                                h =
                                                    l > 0
                                                        ? 2 *
                                                          Math.atan(
                                                              (0.5 *
                                                                  c.basicWidth) /
                                                                  (l * c.focal)
                                                          )
                                                        : Math.PI / 3,
                                                u =
                                                    l > 0
                                                        ? 2 *
                                                          Math.atan(
                                                              (0.5 *
                                                                  c.basicHeight) /
                                                                  (l * c.focal)
                                                          )
                                                        : Math.PI / 3,
                                                d = h / (2 * Math.PI),
                                                p = u / Math.PI,
                                                g =
                                                    (e.bbox.maxX -
                                                        e.bbox.minX) *
                                                    d,
                                                m =
                                                    (e.bbox.maxY -
                                                        e.bbox.minY) *
                                                    p,
                                                f = e.pixelWidth * d,
                                                _ = e.pixelHeight * p,
                                                M =
                                                    (e.bbox.minX +
                                                        e.bbox.maxX) /
                                                        2 -
                                                    0.5,
                                                v =
                                                    (e.bbox.minY +
                                                        e.bbox.maxY) /
                                                        2 -
                                                    0.5,
                                                y = 0.5 + s + d * M - g / 2,
                                                x = 0.5 + s + d * M + g / 2,
                                                b = 0.5 + o + p * v - m / 2,
                                                w = 0.5 + o + p * v + m / 2;
                                            n = {
                                                bbox: {
                                                    maxX: this._spatial.wrap(
                                                        x,
                                                        0,
                                                        1
                                                    ),
                                                    maxY: w,
                                                    minX: this._spatial.wrap(
                                                        y,
                                                        0,
                                                        1
                                                    ),
                                                    minY: b,
                                                },
                                                pixelHeight: _,
                                                pixelWidth: f,
                                            };
                                        }
                                    else {
                                        const t =
                                                i.state.currentTransform
                                                    .basicAspect,
                                            r =
                                                i.state.previousTransform
                                                    .basicAspect,
                                            [[s, a], [o, c]] =
                                                this._getBasicCorners(t, r),
                                            l = o - s,
                                            h = c - a,
                                            u = e.pixelWidth / l,
                                            d = e.pixelHeight / h,
                                            p =
                                                (l - 1) / (2 * l) +
                                                e.bbox.minX / l,
                                            g =
                                                (l - 1) / (2 * l) +
                                                e.bbox.maxX / l,
                                            m =
                                                (h - 1) / (2 * h) +
                                                e.bbox.minY / h,
                                            f = {
                                                maxX: g,
                                                maxY:
                                                    (h - 1) / (2 * h) +
                                                    e.bbox.maxY / h,
                                                minX: p,
                                                minY: m,
                                            };
                                        this._clipBoundingBox(f),
                                            (n = {
                                                bbox: f,
                                                pixelHeight: d,
                                                pixelWidth: u,
                                            });
                                    }
                                    t.setRegionOfInterest(n);
                                })
                        );
                        const u = l.pipe(
                            kt((e) => e.hasTexture$),
                            Ot(!1),
                            It(1),
                            V()
                        );
                        e.push(u.subscribe(() => {}));
                    }
                    _deactivate() {
                        this._waitSubscription.unsubscribe(),
                            this._navigator.stateService.state$
                                .pipe(bt())
                                .subscribe((e) => {
                                    e !== j_.Traversing &&
                                        this._navigator.stateService.traverse();
                                }),
                            this._glRendererDisposer$.next(null),
                            this._domRenderer.deactivate(),
                            this._subscriptions.unsubscribe(),
                            this.configure({ ids: null });
                    }
                    _getDefaultConfiguration() {
                        return {
                            initialPosition: 1,
                            mode: R_.Motion,
                            sliderVisible: !0,
                        };
                    }
                    _catchCacheImage$(e) {
                        return this._navigator.graphService
                            .cacheImage$(e)
                            .pipe(
                                ot(
                                    (t) => (
                                        console.error(
                                            `Failed to cache slider image (${e})`,
                                            t
                                        ),
                                        oe()
                                    )
                                )
                            );
                    }
                    _getBasicCorners(e, t) {
                        let i, n;
                        return (
                            e > t
                                ? ((i = 0.5), (n = (0.5 * e) / t))
                                : ((i = (0.5 * t) / e), (n = 0.5)),
                            [
                                [0.5 - i, 0.5 - n],
                                [0.5 + i, 0.5 + n],
                            ]
                        );
                    }
                    _clipBoundingBox(e) {
                        (e.minX = Math.max(0, Math.min(1, e.minX))),
                            (e.maxX = Math.max(0, Math.min(1, e.maxX))),
                            (e.minY = Math.max(0, Math.min(1, e.minY))),
                            (e.maxY = Math.max(0, Math.min(1, e.maxY)));
                    }
                }
                MM.componentName = "slider";
                class vM {
                    constructor(e, t) {
                        (this._subscriptions = new s_()),
                            (this._graphService = e),
                            (this._stateService = t);
                        const i = this._subscriptions;
                        (this._directionSubject$ = new W()),
                            (this._direction$ = this._directionSubject$.pipe(
                                Ot(Dp.Next),
                                It(1),
                                V()
                            )),
                            i.push(this._direction$.subscribe()),
                            (this._playing = !1),
                            (this._playingSubject$ = new W()),
                            (this._playing$ = this._playingSubject$.pipe(
                                Ot(this._playing),
                                It(1),
                                V()
                            )),
                            i.push(this._playing$.subscribe()),
                            (this._speed = 0.5),
                            (this._speedSubject$ = new W()),
                            (this._speed$ = this._speedSubject$.pipe(
                                Ot(this._speed),
                                It(1),
                                V()
                            )),
                            i.push(this._speed$.subscribe()),
                            (this._imagesAhead = this._mapImagesAhead(
                                this._mapSpeed(this._speed)
                            )),
                            (this._bridging$ = null);
                    }
                    get playing() {
                        return this._playing;
                    }
                    get direction$() {
                        return this._direction$;
                    }
                    get playing$() {
                        return this._playing$;
                    }
                    get speed$() {
                        return this._speed$;
                    }
                    play() {
                        if (this._playing) return;
                        this._stateService.cutImages();
                        const e = this._setSpeed(this._speed);
                        this._stateService.setSpeed(e),
                            (this._graphModeSubscription = this._speed$
                                .pipe(
                                    ke((e) =>
                                        e > vM.sequenceSpeed
                                            ? O_.Sequence
                                            : O_.Spatial
                                    ),
                                    ft()
                                )
                                .subscribe((e) => {
                                    this._graphService.setGraphMode(e);
                                })),
                            (this._cacheSubscription = He(
                                this._stateService.currentImage$.pipe(
                                    ke((e) => [e.sequenceId, e.id]),
                                    ft(void 0, ([e]) => e)
                                ),
                                this._graphService.graphMode$,
                                this._direction$
                            )
                                .pipe(
                                    kt(([[e, t], i, n]) =>
                                        n !== Dp.Next && n !== Dp.Prev
                                            ? Ce([void 0, n])
                                            : He(
                                                  (i === O_.Sequence
                                                      ? this._graphService.cacheSequenceImages$(
                                                            e,
                                                            t
                                                        )
                                                      : this._graphService.cacheSequence$(
                                                            e
                                                        )
                                                  ).pipe(
                                                      Ct(3),
                                                      ot(
                                                          (e) => (
                                                              console.error(e),
                                                              Ce(void 0)
                                                          )
                                                      )
                                                  ),
                                                  Ce(n)
                                              )
                                    ),
                                    kt(([e, t]) => {
                                        if (void 0 === e) return oe();
                                        const i = e.imageIds.slice();
                                        return (
                                            t === Dp.Prev && i.reverse(),
                                            this._stateService.currentState$.pipe(
                                                ke((e) => [
                                                    e.state.trajectory[
                                                        e.state.trajectory
                                                            .length - 1
                                                    ].id,
                                                    e.state.imagesAhead,
                                                ]),
                                                At(
                                                    ([e, t], [n, r]) => {
                                                        void 0 === e && (e = n);
                                                        const s = i.length - 1;
                                                        if (
                                                            r >=
                                                                this
                                                                    ._imagesAhead ||
                                                            i[s] === e
                                                        )
                                                            return [e, []];
                                                        const a = i.indexOf(n),
                                                            o =
                                                                i.indexOf(e) +
                                                                1,
                                                            c =
                                                                Math.min(
                                                                    s,
                                                                    a +
                                                                        this
                                                                            ._imagesAhead -
                                                                        r
                                                                ) + 1;
                                                        return c <= o
                                                            ? [e, []]
                                                            : [
                                                                  i[c - 1],
                                                                  i.slice(o, c),
                                                              ];
                                                    },
                                                    [void 0, []]
                                                ),
                                                Ye(([e, t]) => ye(t))
                                            )
                                        );
                                    }),
                                    Ye(
                                        (e) =>
                                            this._graphService
                                                .cacheImage$(e)
                                                .pipe(ot(() => oe())),
                                        6
                                    )
                                )
                                .subscribe()),
                            (this._playingSubscription =
                                this._stateService.currentState$
                                    .pipe(
                                        nt(
                                            (e) =>
                                                e.state.imagesAhead <
                                                this._imagesAhead
                                        ),
                                        ft(void 0, (e) => e.state.lastImage.id),
                                        ke((e) => {
                                            const t = e.state.lastImage,
                                                i = e.state.trajectory;
                                            let n;
                                            for (
                                                let e = i.length - 2;
                                                e >= 0;
                                                e--
                                            ) {
                                                const r = i[e];
                                                if (
                                                    r.sequenceId !==
                                                    t.sequenceId
                                                )
                                                    break;
                                                if (
                                                    r.capturedAt !==
                                                    t.capturedAt
                                                ) {
                                                    n =
                                                        r.capturedAt <
                                                        t.capturedAt;
                                                    break;
                                                }
                                            }
                                            return [e.state.lastImage, n];
                                        }),
                                        $t(this._direction$),
                                        kt(([[e, t], i]) =>
                                            rt(
                                                ([Dp.Next, Dp.Prev].indexOf(i) >
                                                -1
                                                    ? e.sequenceEdges$
                                                    : e.spatialEdges$
                                                ).pipe(
                                                    bt((e) => e.cached),
                                                    je(15e3)
                                                ),
                                                Ce(i)
                                            ).pipe(
                                                ke(([e, t]) => {
                                                    for (let i of e.edges)
                                                        if (
                                                            i.data.direction ===
                                                            t
                                                        )
                                                            return i.target;
                                                    return null;
                                                }),
                                                kt((e) =>
                                                    null != e
                                                        ? this._graphService.cacheImage$(
                                                              e
                                                          )
                                                        : oe()
                                                )
                                            )
                                        )
                                    )
                                    .subscribe(
                                        (e) => {
                                            this._stateService.appendImagess([
                                                e,
                                            ]);
                                        },
                                        (e) => {
                                            console.error(e), this.stop();
                                        }
                                    )),
                            (this._clearSubscription =
                                this._stateService.currentImage$
                                    .pipe(at(1, 10))
                                    .subscribe((e) => {
                                        this._stateService.clearPriorImages();
                                    })),
                            this._setPlaying(!0);
                        const t = this._stateService.currentState$.pipe(
                            ke((e) => e.state),
                            ft(
                                ([e, t], [i, n]) => e === i && t === n,
                                (e) => [e.currentImage.id, e.lastImage.id]
                            ),
                            nt(
                                (e) =>
                                    e.currentImage.id === e.lastImage.id &&
                                    e.currentIndex === e.trajectory.length - 1
                            ),
                            ke((e) => e.currentImage)
                        );
                        (this._stopSubscription = He(t, this._direction$)
                            .pipe(
                                kt(([e, t]) => {
                                    const i = (
                                        [Dp.Next, Dp.Prev].indexOf(t) > -1
                                            ? e.sequenceEdges$
                                            : e.spatialEdges$
                                    ).pipe(
                                        bt((e) => e.cached),
                                        je(15e3),
                                        ot(
                                            (e) => (
                                                console.error(e),
                                                Ce({ cached: !1, edges: [] })
                                            )
                                        )
                                    );
                                    return He(Ce(t), i).pipe(
                                        ke(([e, t]) => {
                                            for (const i of t.edges)
                                                if (i.data.direction === e)
                                                    return !0;
                                            return !1;
                                        })
                                    );
                                }),
                                Ye((e) =>
                                    e || !this._bridging$
                                        ? Ce(e)
                                        : this._bridging$.pipe(
                                              ke((e) => null != e),
                                              ot(
                                                  (e) => (
                                                      console.error(e), Ce(!1)
                                                  )
                                              )
                                          )
                                ),
                                bt((e) => !e)
                            )
                            .subscribe(void 0, void 0, () => {
                                this.stop();
                            })),
                            this._stopSubscription.closed &&
                                (this._stopSubscription = null),
                            (this._earthSubscription = this._stateService.state$
                                .pipe(
                                    ke((e) => e === j_.Earth),
                                    ft(),
                                    bt((e) => e)
                                )
                                .subscribe(void 0, void 0, () => {
                                    this.stop();
                                })),
                            this._earthSubscription.closed &&
                                (this._earthSubscription = null);
                    }
                    dispose() {
                        this.stop(), this._subscriptions.unsubscribe();
                    }
                    setDirection(e) {
                        this._directionSubject$.next(e);
                    }
                    setSpeed(e) {
                        if ((e = Math.max(0, Math.min(1, e))) === this._speed)
                            return;
                        const t = this._setSpeed(e);
                        this._playing && this._stateService.setSpeed(t),
                            this._speedSubject$.next(this._speed);
                    }
                    stop() {
                        this._playing &&
                            (this._stopSubscription &&
                                (this._stopSubscription.closed ||
                                    this._stopSubscription.unsubscribe(),
                                (this._stopSubscription = null)),
                            this._earthSubscription &&
                                (this._earthSubscription.closed ||
                                    this._earthSubscription.unsubscribe(),
                                (this._earthSubscription = null)),
                            this._graphModeSubscription.unsubscribe(),
                            (this._graphModeSubscription = null),
                            this._cacheSubscription.unsubscribe(),
                            (this._cacheSubscription = null),
                            this._playingSubscription.unsubscribe(),
                            (this._playingSubscription = null),
                            this._clearSubscription.unsubscribe(),
                            (this._clearSubscription = null),
                            this._stateService.setSpeed(1),
                            this._stateService.cutImages(),
                            this._graphService.setGraphMode(O_.Spatial),
                            this._setPlaying(!1));
                    }
                    _mapSpeed(e) {
                        const t = 2 * e - 1;
                        return Math.pow(10, t) - 0.2 * t;
                    }
                    _mapImagesAhead(e) {
                        return Math.round(
                            Math.max(10, Math.min(50, 8 + 6 * e))
                        );
                    }
                    _setPlaying(e) {
                        (this._playing = e), this._playingSubject$.next(e);
                    }
                    _setSpeed(e) {
                        this._speed = e;
                        const t = this._mapSpeed(this._speed);
                        return (this._imagesAhead = this._mapImagesAhead(t)), t;
                    }
                }
                (vM.sequenceSpeed = 0.54),
                    (function (e) {
                        (e[(e.Hidden = 0)] = "Hidden"),
                            (e[(e.Homogeneous = 1)] = "Homogeneous"),
                            (e[(e.Cluster = 2)] = "Cluster"),
                            (e[(e.ConnectedComponent = 3)] =
                                "ConnectedComponent"),
                            (e[(e.Sequence = 4)] = "Sequence");
                    })(P_ || (P_ = {})),
                    (function (e) {
                        (e[(e.Hidden = 0)] = "Hidden"),
                            (e[(e.Altitude = 1)] = "Altitude"),
                            (e[(e.Flat = 2)] = "Flat");
                    })(U_ || (U_ = {}));
                class yM extends su {
                    constructor(e) {
                        super(), (this._originalSize = e.originalSize);
                        const {
                            cluster: t,
                            color: i,
                            scale: n,
                            translation: r,
                        } = e;
                        this._makeAttributes(t),
                            (this.material.size = n * this._originalSize),
                            this.setColor(i),
                            (this.matrixAutoUpdate = !1),
                            this.position.fromArray(r),
                            this.updateMatrix(),
                            this.updateMatrixWorld(!1);
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose();
                    }
                    setColor(e) {
                        (this.material.vertexColors = null == e),
                            (this.material.color = new Na(e)),
                            (this.material.needsUpdate = !0);
                    }
                    resize(e) {
                        (this.material.size = e * this._originalSize),
                            (this.material.needsUpdate = !0);
                    }
                    _makeAttributes(e) {
                        const t = [],
                            i = [],
                            n = e.points;
                        for (const e in n) {
                            if (!n.hasOwnProperty(e)) continue;
                            const r = n[e];
                            t.push(...r.coordinates);
                            const s = r.color;
                            i.push(s[0]), i.push(s[1]), i.push(s[2]);
                        }
                        const r = this.geometry;
                        r.setAttribute(
                            "position",
                            new Aa(new Float32Array(t), 3)
                        ),
                            r.setAttribute(
                                "color",
                                new Aa(new Float32Array(i), 3)
                            );
                    }
                }
                class xM extends Zh {
                    constructor(e) {
                        super(),
                            this._makeAttributes(e),
                            (this.matrixAutoUpdate = !1),
                            this.updateMatrix(),
                            this.updateMatrixWorld(!1);
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose();
                    }
                    _makeAttributes(e) {
                        const t = e.slice();
                        t.push(e[0]);
                        let i = 0;
                        const n = new Float32Array(3 * (e.length + 1));
                        for (const e of t)
                            (n[i++] = e[0]), (n[i++] = e[1]), (n[i++] = e[2]);
                        this.geometry.setAttribute("position", new Aa(n, 3));
                    }
                }
                function bM(e, t) {
                    return e === t;
                }
                class wM {
                    constructor(e, t, i, n) {
                        (this.level = e),
                            (this.leafLevel = t),
                            (this.boundingBox = i),
                            (this.parent = n),
                            (this.children = []),
                            (this.items = []),
                            n && n.children.push(this);
                    }
                    get isEmpty() {
                        return !(this.children.length || this.items.length);
                    }
                    add(e) {
                        const t = this;
                        if (!t.boundingBox.containsPoint(e.position))
                            throw new Error("Item not contained in node");
                        if (bM(t.level, t.leafLevel))
                            return t.items.push(e), this;
                        for (const i of t.children)
                            if (i.boundingBox.containsPoint(e.position))
                                return i.add(e);
                        for (const i of t._generateBoundingBoxes())
                            if (i.containsPoint(e.position))
                                return new wM(
                                    t.level - 1,
                                    t.leafLevel,
                                    i,
                                    t
                                ).add(e);
                        throw new Error("Item not contained in children");
                    }
                    intersect(e, t, i) {
                        if (e.intersectBox(this.boundingBox, t))
                            if (bM(this.level, this.leafLevel)) i.push(this);
                            else
                                for (const n of this.children)
                                    n.intersect(e, t, i);
                    }
                    remove(e) {
                        const t = this.items.indexOf(e);
                        if (t < 0)
                            throw new Error(`Item does not exist ${e.uuid}`);
                        this.items.splice(t, 1);
                    }
                    traverse() {
                        const e = this;
                        if (!e.isEmpty) return;
                        const t = e.parent;
                        if (!t) return;
                        const i = t.children.indexOf(e);
                        if (i < 0) throw new Error("Corrupt octree");
                        t.children.splice(i, 1),
                            (this.parent = null),
                            t.traverse();
                    }
                    _generateBoundingBoxes() {
                        const e = this.boundingBox.min,
                            t = (this.boundingBox.max.x - e.x) / 2,
                            i = [
                                [e.x, e.y + t, e.z + t],
                                [e.x + t, e.y + t, e.z + t],
                                [e.x, e.y, e.z + t],
                                [e.x + t, e.y, e.z + t],
                                [e.x, e.y + t, e.z],
                                [e.x + t, e.y + t, e.z],
                                [e.x, e.y, e.z],
                                [e.x + t, e.y, e.z],
                            ],
                            n = [];
                        for (const [e, r, s] of i)
                            n.push(
                                new os(
                                    new rs(e, r, s),
                                    new rs(e + t, r + t, s + t)
                                )
                            );
                        return n;
                    }
                }
                class TM {
                    constructor(e, t) {
                        if (((this.rootLevel = e), (this.leafLevel = t), t > e))
                            throw new Error();
                        (this._index = new Map()),
                            (this._root = this._makeRoot());
                    }
                    get root() {
                        return this._root;
                    }
                    add(e) {
                        if (!this.root.boundingBox.containsPoint(e.position))
                            return void console.warn(
                                `Object outside bounding box ${e.uuid}`
                            );
                        const t = this._root.add(e);
                        this._index.set(e.uuid, t);
                    }
                    has(e) {
                        return this._index.has(e.uuid);
                    }
                    intersect(e) {
                        const t = [],
                            i = new rs();
                        return (
                            this._root.intersect(e, i, t),
                            t
                                .map((e) => e.items)
                                .reduce((e, t) => (e.push(...t), e), [])
                        );
                    }
                    reset() {
                        (this._root = this._makeRoot()), this._index.clear();
                    }
                    remove(e) {
                        if (!this.has(e))
                            throw new Error(`Frame does not exist ${e.uuid}`);
                        const t = this._index.get(e.uuid);
                        t.remove(e), t.traverse(), this._index.delete(e.uuid);
                    }
                    _makeRoot() {
                        const e = this.rootLevel,
                            t = (function (e) {
                                const t = (function (e) {
                                        return Math.pow(2, e);
                                    })(e),
                                    i = t / 2;
                                return { min: [-i, -i, -i], max: [i, i, i] };
                            })(e),
                            i = new os(
                                new rs().fromArray(t.min),
                                new rs().fromArray(t.max)
                            );
                        return new wM(e, this.leafLevel, i);
                    }
                }
                class SM {
                    constructor(e, t) {
                        (this._objects = []),
                            (this._objectImageMap = new Map()),
                            (this._octree = null != e ? e : new TM(14, 6)),
                            (this._raycaster = null != t ? t : new op()),
                            (this._interactiveLayer = 1),
                            (this._raycaster =
                                t || new op(void 0, void 0, 1, 1e4)),
                            (this._lineThreshold = 0.2),
                            (this._largeLineThreshold = 0.4),
                            (this._raycaster.params.Line.threshold =
                                this._lineThreshold),
                            this._raycaster.layers.set(this._interactiveLayer);
                    }
                    get interactiveLayer() {
                        return this._interactiveLayer;
                    }
                    get octree() {
                        return this._octree;
                    }
                    get raycaster() {
                        return this._raycaster;
                    }
                    add(e, t) {
                        const i = e.uuid;
                        this._objectImageMap.set(i, t),
                            this._objects.push(e),
                            this._octree.add(e);
                    }
                    intersectObjects(e, t) {
                        this._raycaster.setFromCamera(new Gr().fromArray(e), t);
                        const i = this._octree.intersect(this.raycaster.ray),
                            n = this._raycaster.intersectObjects(i),
                            r = this._objectImageMap;
                        for (const e of n) {
                            const t = e.object.uuid;
                            if (r.has(t)) return r.get(t);
                        }
                        return null;
                    }
                    remove(e) {
                        const t = this._objects,
                            i = t.indexOf(e);
                        if (-1 !== i) {
                            const n = t.splice(i, 1);
                            for (const e of n)
                                this._objectImageMap.delete(e.uuid);
                            this._octree.remove(e);
                        } else console.warn("Object does not exist");
                    }
                    resetIntersectionThreshold(e) {
                        this._raycaster.params.Line.threshold = e
                            ? this._largeLineThreshold
                            : this._lineThreshold;
                    }
                }
                class NM extends Zh {
                    constructor(e) {
                        super(e.geometry, e.material);
                        const t = e.mode,
                            i = e.originalOrigin,
                            n = e.transform.unprojectBasic([0, 0], 0);
                        (this._relativeAltitude = i[2] - n[2]),
                            this._makeAttributes(n, i, t),
                            (this.matrixAutoUpdate = !1),
                            this.position.fromArray(n),
                            this.updateMatrix(),
                            this.updateMatrixWorld(!1);
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose();
                    }
                    setMode(e) {
                        const t = this.geometry.attributes.position;
                        (t.array[5] = this._modeToAltitude(e)),
                            (t.needsUpdate = !0),
                            this.geometry.computeBoundingSphere();
                    }
                    _makeAttributes(e, t, i) {
                        const n = new Float32Array(6);
                        (n[0] = 0),
                            (n[1] = 0),
                            (n[2] = 0),
                            (n[3] = t[0] - e[0]),
                            (n[4] = t[1] - e[1]),
                            (n[5] = this._modeToAltitude(i));
                        const r = new Aa(n, 3);
                        this.geometry.setAttribute("position", r),
                            (r.needsUpdate = !0),
                            this.geometry.computeBoundingSphere();
                    }
                    _modeToAltitude(e) {
                        return e === U_.Altitude ? this._relativeAltitude : 0;
                    }
                }
                class DM extends Kh {
                    constructor(e) {
                        super(e.geometry, e.material);
                        const t = e.color,
                            i = e.size,
                            n = e.scale,
                            r = e.transform,
                            s = r.unprojectBasic([0, 0], 0),
                            a = this._makePositions(i, r, s);
                        this._makeAttributes(a, t),
                            this.geometry.computeBoundingSphere(),
                            this.geometry.computeBoundingBox(),
                            (this.matrixAutoUpdate = !1),
                            this.position.fromArray(s),
                            this.scale.set(n, n, n),
                            this.updateMatrix(),
                            this.updateMatrixWorld(!1);
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose();
                    }
                    setColor(e) {
                        return this._updateColorAttribute(e), this;
                    }
                    resize(e) {
                        return (
                            this.scale.set(e, e, e),
                            this.updateMatrix(),
                            this.updateMatrixWorld(!1),
                            this
                        );
                    }
                    _makeAttributes(e, t) {
                        const i = this.geometry,
                            n = new Aa(new Float32Array(e), 3);
                        i.setAttribute("position", n), (n.needsUpdate = !0);
                        const r = new Aa(new Float32Array(e.length), 3);
                        i.setAttribute("color", r),
                            this._updateColorAttribute(t);
                    }
                    _updateColorAttribute(e) {
                        const [t, i, n] = new Na(e).toArray(),
                            r = this.geometry.attributes.color,
                            s = r.array,
                            a = s.length;
                        let o = 0;
                        for (let e = 0; e < a; e++)
                            (s[o++] = t), (s[o++] = i), (s[o++] = n);
                        r.needsUpdate = !0;
                    }
                }
                class IM extends DM {
                    _makePositions(e, t, i) {
                        const n = [];
                        n.push(...this._makeAxis(e, t, i)),
                            n.push(...this._makeLat(0.5, 10, e, t, i));
                        for (const r of [0, 0.25, 0.5, 0.75])
                            n.push(...this._makeLng(r, 10, e, t, i));
                        return n;
                    }
                    _makeAxis(e, t, i) {
                        const n = t.unprojectBasic([0.5, 1], 0.8 * e),
                            r = t.unprojectBasic([0.5, 0], 1.2 * e);
                        return [
                            n[0] - i[0],
                            n[1] - i[1],
                            n[2] - i[2],
                            r[0] - i[0],
                            r[1] - i[1],
                            r[2] - i[2],
                        ];
                    }
                    _makeLat(e, t, i, n, r) {
                        const s = 0.8 * i,
                            [a, o, c] = r,
                            l = [],
                            h = n.unprojectBasic([0, e], s);
                        (h[0] -= a), (h[1] -= o), (h[2] -= c), l.push(...h);
                        for (let i = 1; i <= t; i++) {
                            const r = n.unprojectBasic([i / t, e], s);
                            (r[0] -= a),
                                (r[1] -= o),
                                (r[2] -= c),
                                l.push(...r, ...r);
                        }
                        return l.push(...h), l;
                    }
                    _makeLng(e, t, i, n, r) {
                        const s = 0.8 * i,
                            [a, o, c] = r,
                            l = [],
                            h = n.unprojectBasic([e, 0], s);
                        (h[0] -= a), (h[1] -= o), (h[2] -= c), l.push(...h);
                        for (let i = 0; i <= t; i++) {
                            const r = n.unprojectBasic([e, i / t], s);
                            (r[0] -= a),
                                (r[1] -= o),
                                (r[2] -= c),
                                l.push(...r, ...r);
                        }
                        return l.push(...h), l;
                    }
                }
                class CM extends DM {
                    _makePositions(e, t, i) {
                        const n = [];
                        return (
                            n.push(...this._makeDiags(e, t, i)),
                            n.push(...this._makeFrame(e, 8, t, i)),
                            n
                        );
                    }
                    _makeDiags(e, t, i) {
                        const [n, r, s] = i,
                            a = [0, 0, 0],
                            o = [];
                        for (const i of [
                            [0, 0],
                            [1, 0],
                            [1, 1],
                            [0, 1],
                        ]) {
                            const c = t.unprojectBasic(i, e);
                            (c[0] -= n),
                                (c[1] -= r),
                                (c[2] -= s),
                                o.push(...a, ...c);
                        }
                        return o;
                    }
                    _makeFrame(e, t, i, n) {
                        const r = [];
                        r.push(...this._subsample([0, 1], [0, 0], t)),
                            r.push(...this._subsample([0, 0], [1, 0], t)),
                            r.push(...this._subsample([1, 0], [1, 1], t));
                        const [s, a, o] = n,
                            c = [];
                        for (const t of r) {
                            const n = i.unprojectBasic(t, e);
                            (n[0] -= s), (n[1] -= a), (n[2] -= o), c.push(...n);
                        }
                        return c;
                    }
                    _interpolate(e, t, i) {
                        return e + i * (t - e);
                    }
                    _subsample(e, t, i) {
                        if (i < 1) return [e, t];
                        const n = [];
                        n.push(e);
                        for (let r = 0; r <= i; r++) {
                            const s = [];
                            for (let n = 0; n < 3; n++)
                                s.push(
                                    this._interpolate(e[n], t[n], r / (i + 1))
                                );
                            n.push(s), n.push(s);
                        }
                        return n.push(t), n;
                    }
                }
                function AM(e, t, i) {
                    const [n, r, s] = t,
                        [a, o, c] = yp(n, r, s, i.lng, i.lat, i.alt);
                    return vp(a, o, c, e.lng, e.lat, e.alt);
                }
                class EM {
                    constructor(e, t, i) {
                        (this.id = e),
                            (this._scene = t),
                            (this._intersection = i),
                            (this.cameras = new aa()),
                            (this.keys = []),
                            (this._positionLines = {}),
                            (this._positions = new aa()),
                            (this._cameraFrames = {}),
                            (this._clusters = new Map()),
                            (this._connectedComponents = new Map()),
                            (this._sequences = new Map()),
                            (this._props = {}),
                            (this.clusterVisibles = {}),
                            (this._frameMaterial = new Gh({
                                fog: !1,
                                vertexColors: !0,
                            })),
                            (this._positionMaterial = new Gh({
                                fog: !1,
                                color: 16711680,
                            })),
                            this._scene.add(this.cameras, this._positions);
                    }
                    addImage(e) {
                        const t = e.image,
                            i = t.id;
                        if (this.hasImage(i))
                            throw new Error(`Image exists ${i}`);
                        const n = e.idMap.ccId;
                        this._connectedComponents.has(n) ||
                            this._connectedComponents.set(n, []);
                        const r = e.idMap.clusterId;
                        this._clusters.has(r) || this._clusters.set(r, []);
                        const s = e.idMap.sequenceId;
                        this._sequences.has(s) || this._sequences.set(s, []),
                            (this._props[i] = {
                                image: t,
                                ids: { ccId: n, clusterId: r, sequenceId: s },
                            }),
                            this.keys.push(i);
                    }
                    applyCameraColor(e, t) {
                        this._cameraFrames[e].setColor(t);
                    }
                    applyCameraSize(e) {
                        for (const t of this.cameras.children) t.resize(e);
                    }
                    applyFilter(e) {
                        var t;
                        const i = this.clusterVisibles;
                        for (const e in i) i.hasOwnProperty(e) && (i[e] = !1);
                        const n = this._cameraFrames,
                            r = this._positionLines,
                            s = this._intersection.interactiveLayer;
                        for (const a of Object.values(this._props)) {
                            const o = a.image,
                                c = e(o),
                                l = o.id;
                            r[l].visible = c;
                            const h = n[l];
                            this._setCameraVisibility(h, c, s),
                                i[(t = a.ids.clusterId)] || (i[t] = c);
                        }
                    }
                    applyPositionMode(e) {
                        this._positions.visible = e !== U_.Hidden;
                        for (const t of this._positions.children) t.setMode(e);
                    }
                    dispose() {
                        this._disposeCameras(),
                            this._disposePositions(),
                            (this._scene = null),
                            (this._intersection = null);
                    }
                    getCamerasByMode(e) {
                        if (e === P_.Cluster) return this._clusters;
                        if (e === P_.ConnectedComponent)
                            return this._connectedComponents;
                        if (e === P_.Sequence) return this._sequences;
                        const t = P_[P_.Homogeneous],
                            i = new Map();
                        return i.set(t, this.cameras.children), i;
                    }
                    getColorId(e, t) {
                        const i = this._props[e],
                            n = P_;
                        switch (t) {
                            case n.Cluster:
                                return i.ids.clusterId;
                            case n.ConnectedComponent:
                                return i.ids.ccId;
                            case n.Sequence:
                                return i.ids.sequenceId;
                            default:
                                return n[n.Homogeneous];
                        }
                    }
                    hasImage(e) {
                        return -1 !== this.keys.indexOf(e);
                    }
                    resetReference(e, t) {
                        const i = this._cameraFrames;
                        for (const n in i) {
                            if (!i.hasOwnProperty(n)) continue;
                            const r = i[n];
                            r.position.fromArray(
                                AM(e, r.position.toArray(), t)
                            );
                        }
                        const n = this._positionLines;
                        for (const i in n) {
                            if (!n.hasOwnProperty(i)) continue;
                            const r = n[i];
                            r.position.fromArray(
                                AM(e, r.position.toArray(), t)
                            );
                        }
                    }
                    visualize(e) {
                        var t, i;
                        const n = e.id,
                            r = e.visible,
                            s = e.transform,
                            a = {
                                color: e.color,
                                material: this._frameMaterial,
                                scale: e.scale,
                                size: e.maxSize,
                                transform: s,
                            },
                            o = jp(s.cameraType) ? new IM(a) : new CM(a),
                            c = this._intersection.interactiveLayer;
                        this._setCameraVisibility(o, r, c),
                            this.cameras.add(o),
                            (this._cameraFrames[n] = o),
                            this._intersection.add(o, n);
                        const l = this._props[n].ids;
                        (t = this.clusterVisibles)[(i = l.clusterId)] ||
                            (t[i] = r),
                            this._connectedComponents.get(l.ccId).push(o),
                            this._clusters.get(l.clusterId).push(o),
                            this._sequences.get(l.sequenceId).push(o);
                        const h = {
                                material: this._positionMaterial,
                                mode: e.positionMode,
                                originalOrigin: e.originalPosition,
                                transform: s,
                            },
                            u = new NM(h);
                        (u.visible = r),
                            this._positions.add(u),
                            (this._positionLines[n] = u);
                    }
                    _disposeCameras() {
                        const e = this._intersection,
                            t = this.cameras;
                        for (const i of t.children.slice())
                            i.dispose(), e.remove(i), t.remove(i);
                        this._scene.remove(this.cameras);
                    }
                    _disposePositions() {
                        const e = this._positions;
                        for (const t of e.children.slice())
                            t.dispose(), e.remove(t);
                        this._scene.remove(this._positions);
                    }
                    _setCameraVisibility(e, t, i) {
                        (e.visible = t),
                            t ? e.layers.enable(i) : e.layers.disable(i);
                    }
                }
                class LM {
                    constructor() {
                        this._colors = new Map();
                        const e = P_;
                        this._colors.set(e[e.Homogeneous], "#FFFFFF");
                    }
                    getColor(e) {
                        const t = this._colors;
                        return (
                            t.has(e) || t.set(e, this._randomColor()), t.get(e)
                        );
                    }
                    _randomColor() {
                        return `hsl(${Math.floor(
                            360 * Math.random()
                        )}, 100%, 50%)`;
                    }
                }
                function zM(e) {
                    return e !== P_.Hidden;
                }
                !(function (e) {
                    (e[(e.Hidden = 0)] = "Hidden"),
                        (e[(e.Original = 1)] = "Original"),
                        (e[(e.Cluster = 2)] = "Cluster");
                })($_ || ($_ = {}));
                class jM {
                    constructor(e, t) {
                        (this._rayNearScale = 1.1),
                            (this._originalPointSize = 2),
                            (this._originalCameraSize = 2),
                            (this._imageCellMap = new Map()),
                            (this._scene = t || new ph()),
                            (this._scene.autoUpdate = !1),
                            (this._intersection = new SM()),
                            (this._assets = new LM()),
                            (this._needsRender = !1),
                            (this._images = {}),
                            (this._cells = {}),
                            (this._cellClusters = {}),
                            (this._clusters = {}),
                            (this._cameraVisualizationMode =
                                e.cameraVisualizationMode
                                    ? e.cameraVisualizationMode
                                    : P_.Homogeneous),
                            (this._cameraSize = e.cameraSize),
                            (this._pointSize = e.pointSize),
                            (this._pointVisualizationMode =
                                e.pointVisualizationMode
                                    ? e.pointVisualizationMode
                                    : $_.Original),
                            (this._positionMode = e.originalPositionMode),
                            (this._cellsVisible = e.cellsVisible),
                            (this._hoveredId = null),
                            (this._selectedId = null),
                            (this._colors = {
                                hover: "#FF0000",
                                select: "#FF8000",
                            }),
                            (this._filter = () => !0);
                    }
                    get needsRender() {
                        return this._needsRender;
                    }
                    get intersection() {
                        return this._intersection;
                    }
                    addCluster(e, t, i) {
                        if (this.hasCluster(e.id, i)) return;
                        const n = e.id;
                        if (!(n in this._clusters)) {
                            this._clusters[n] = {
                                points: new aa(),
                                cellIds: [],
                            };
                            const i = this._getClusterVisible(n),
                                r = this._clusters[n],
                                s =
                                    this._pointVisualizationMode === $_.Cluster
                                        ? this._assets.getColor(n)
                                        : null,
                                a = new yM({
                                    cluster: e,
                                    color: s,
                                    originalSize: this._originalPointSize,
                                    scale: this._pointSize,
                                    translation: t,
                                });
                            (r.points.visible = i),
                                r.points.add(a),
                                this._scene.add(r.points);
                        }
                        -1 === this._clusters[n].cellIds.indexOf(i) &&
                            this._clusters[n].cellIds.push(i),
                            i in this._cellClusters ||
                                (this._cellClusters[i] = { keys: [] }),
                            -1 === this._cellClusters[i].keys.indexOf(n) &&
                                this._cellClusters[i].keys.push(n),
                            (this._needsRender = !0);
                    }
                    addImage(e, t, i, n) {
                        var r, s, a;
                        const o = e.id,
                            c = {
                                clusterId:
                                    null !== (r = e.clusterId) && void 0 !== r
                                        ? r
                                        : "NO_CLUSTER_ID",
                                sequenceId:
                                    null !== (s = e.sequenceId) && void 0 !== s
                                        ? s
                                        : "NO_SEQUENCE_ID",
                                ccId:
                                    null !== (a = e.mergeId) && void 0 !== a
                                        ? a
                                        : "NO_MERGE_ID",
                            };
                        if (!(n in this._images)) {
                            const e = new EM(
                                n,
                                this._scene,
                                this._intersection
                            );
                            (e.cameras.visible = zM(
                                this._cameraVisualizationMode
                            )),
                                e.applyPositionMode(this._positionMode),
                                (this._images[n] = e);
                        }
                        const l = this._images[n];
                        if (l.hasImage(o)) return;
                        l.addImage({ idMap: c, image: e });
                        const h = l.getColorId(
                                o,
                                this._cameraVisualizationMode
                            ),
                            u = this._assets.getColor(h),
                            d = this._filter(e);
                        if (
                            (l.visualize({
                                id: o,
                                color: u,
                                positionMode: this._positionMode,
                                scale: this._cameraSize,
                                transform: t,
                                visible: d,
                                maxSize: this._originalCameraSize,
                                originalPosition: i,
                            }),
                            this._imageCellMap.set(o, n),
                            o === this._selectedId &&
                                this._highlight(
                                    o,
                                    this._colors.select,
                                    this._cameraVisualizationMode
                                ),
                            c.clusterId in this._clusters)
                        ) {
                            const e = this._getClusterVisible(c.clusterId);
                            this._clusters[c.clusterId].points.visible = e;
                        }
                        this._needsRender = !0;
                    }
                    addCell(e, t) {
                        if (this.hasCell(t)) return;
                        const i = new xM(e);
                        (this._cells[t] = new aa()),
                            (this._cells[t].visible = this._cellsVisible),
                            this._cells[t].add(i),
                            this._scene.add(this._cells[t]),
                            (this._needsRender = !0);
                    }
                    deactivate() {
                        (this._filter = () => !0),
                            (this._selectedId = null),
                            (this._hoveredId = null),
                            this.uncache();
                    }
                    hasCluster(e, t) {
                        return (
                            e in this._clusters &&
                            -1 !== this._clusters[e].cellIds.indexOf(t)
                        );
                    }
                    hasCell(e) {
                        return e in this._cells;
                    }
                    hasImage(e, t) {
                        return t in this._images && this._images[t].hasImage(e);
                    }
                    render(e, t) {
                        t.render(this._scene, e), (this._needsRender = !1);
                    }
                    resetReference(e, t) {
                        const i = this._clusters;
                        for (const n in i) {
                            if (!i.hasOwnProperty(n)) continue;
                            const r = i[n];
                            r.points.position.fromArray(
                                AM(e, r.points.position.toArray(), t)
                            );
                        }
                        const n = this._cells;
                        for (const i in n) {
                            if (!n.hasOwnProperty(i)) continue;
                            const r = n[i];
                            r.position.fromArray(
                                AM(e, r.position.toArray(), t)
                            );
                        }
                        const r = this._images;
                        for (const i in r)
                            r.hasOwnProperty(i) && r[i].resetReference(e, t);
                    }
                    setCameraSize(e) {
                        if (Math.abs(e - this._cameraSize) < 0.001) return;
                        const t = this._images;
                        for (const i of Object.keys(t)) t[i].applyCameraSize(e);
                        (this._intersection.raycaster.near = this._getNear(e)),
                            (this._cameraSize = e),
                            (this._needsRender = !0);
                    }
                    setFilter(e) {
                        this._filter = e;
                        const t = {};
                        for (const i of Object.values(this._images)) {
                            i.applyFilter(e);
                            const n = i.clusterVisibles;
                            for (const e in n)
                                n.hasOwnProperty(e) &&
                                    (e in t || (t[e] = !1),
                                    t[e] || (t[e] = n[e]));
                        }
                        const i = this._pointVisualizationMode !== $_.Hidden;
                        for (const e in t) {
                            if (!t.hasOwnProperty(e)) continue;
                            t[e] && (t[e] = i);
                            const n = t[e];
                            e in this._clusters &&
                                (this._clusters[e].points.visible = n);
                        }
                        this._needsRender = !0;
                    }
                    setHoveredImage(e) {
                        if (null != e && !this._imageCellMap.has(e))
                            throw new Ap(`Image does not exist: ${e}`);
                        this._hoveredId !== e &&
                            ((this._needsRender = !0),
                            null != this._hoveredId &&
                                (this._hoveredId === this._selectedId
                                    ? this._highlight(
                                          this._hoveredId,
                                          this._colors.select,
                                          this._cameraVisualizationMode
                                      )
                                    : this._resetCameraColor(this._hoveredId)),
                            this._highlight(
                                e,
                                this._colors.hover,
                                this._cameraVisualizationMode
                            ),
                            (this._hoveredId = e));
                    }
                    setNavigationState(e) {
                        this._intersection.resetIntersectionThreshold(e);
                    }
                    setPointSize(e) {
                        if (Math.abs(e - this._pointSize) < 0.001) return;
                        const t = this._clusters;
                        for (const i in t)
                            if (t.hasOwnProperty(i))
                                for (const n of t[i].points.children)
                                    n.resize(e);
                        (this._pointSize = e), (this._needsRender = !0);
                    }
                    setPointVisualizationMode(e) {
                        if (e !== this._pointVisualizationMode) {
                            this._pointVisualizationMode = e;
                            for (const t in this._clusters) {
                                if (!this._clusters.hasOwnProperty(t)) continue;
                                const i = this._clusters[t];
                                i.points.visible = this._getClusterVisible(t);
                                for (const n of i.points.children) {
                                    const i =
                                        e === $_.Cluster
                                            ? this._assets.getColor(t)
                                            : null;
                                    n.setColor(i);
                                }
                            }
                            this._needsRender = !0;
                        }
                    }
                    setPositionMode(e) {
                        if (e !== this._positionMode) {
                            for (const t of Object.values(this._images))
                                t.applyPositionMode(e);
                            (this._positionMode = e), (this._needsRender = !0);
                        }
                    }
                    setSelectedImage(e) {
                        this._selectedId !== e &&
                            ((this._needsRender = !0),
                            null != this._selectedId &&
                                this._resetCameraColor(this._selectedId),
                            this._highlight(
                                e,
                                this._colors.select,
                                this._cameraVisualizationMode
                            ),
                            (this._selectedId = e));
                    }
                    setCellVisibility(e) {
                        if (e !== this._cellsVisible) {
                            for (const t in this._cells)
                                this._cells.hasOwnProperty(t) &&
                                    (this._cells[t].visible = e);
                            (this._cellsVisible = e), (this._needsRender = !0);
                        }
                    }
                    setCameraVisualizationMode(e) {
                        if (e === this._cameraVisualizationMode) return;
                        const t = zM(e),
                            i = this._assets;
                        for (const n of Object.values(this._images))
                            (n.cameras.visible = t),
                                n.getCamerasByMode(e).forEach((e, t) => {
                                    const n = i.getColor(t);
                                    for (const t of e) t.setColor(n);
                                });
                        this._highlight(this._hoveredId, this._colors.hover, e),
                            this._highlight(
                                this._selectedId,
                                this._colors.select,
                                e
                            ),
                            (this._cameraVisualizationMode = e),
                            (this._needsRender = !0);
                    }
                    uncache(e) {
                        for (const t of Object.keys(this._cellClusters))
                            (e && -1 !== e.indexOf(t)) ||
                                this._disposeReconstruction(t);
                        for (const t of Object.keys(this._images)) {
                            if (e && -1 !== e.indexOf(t)) continue;
                            const i = this._imageCellMap,
                                n = this._images[t].keys;
                            for (const e of n) i.delete(e);
                            this._images[t].dispose(), delete this._images[t];
                        }
                        for (const t of Object.keys(this._cells))
                            (e && -1 !== e.indexOf(t)) || this._disposeCell(t);
                        this._needsRender = !0;
                    }
                    _getClusterVisible(e) {
                        if (this._pointVisualizationMode === $_.Hidden)
                            return !1;
                        let t = !1;
                        for (const i of Object.values(this._images)) {
                            const n = i.clusterVisibles;
                            e in n && (t || (t = n[e]));
                        }
                        return t;
                    }
                    _disposePoints(e) {
                        for (const t of this._cellClusters[e].keys) {
                            if (!(t in this._clusters)) continue;
                            const i = this._clusters[t].cellIds.indexOf(e);
                            if (
                                -1 !== i &&
                                (this._clusters[t].cellIds.splice(i, 1),
                                !(this._clusters[t].cellIds.length > 0))
                            ) {
                                for (const e of this._clusters[
                                    t
                                ].points.children.slice())
                                    e.dispose();
                                this._scene.remove(this._clusters[t].points),
                                    delete this._clusters[t];
                            }
                        }
                    }
                    _disposeReconstruction(e) {
                        this._disposePoints(e), delete this._cellClusters[e];
                    }
                    _disposeCell(e) {
                        const t = this._cells[e];
                        for (const e of t.children.slice())
                            e.dispose(), t.remove(e);
                        this._scene.remove(t), delete this._cells[e];
                    }
                    _getNear(e) {
                        const t =
                            this._rayNearScale * this._originalCameraSize * e;
                        return Math.max(1, t);
                    }
                    _resetCameraColor(e) {
                        const t = this._imageCellMap;
                        if (null == e || !t.has(e)) return;
                        const i = t.get(e),
                            n = this._images[i],
                            r = n.getColorId(e, this._cameraVisualizationMode),
                            s = this._assets.getColor(r);
                        n.applyCameraColor(e, s);
                    }
                    _highlight(e, t, i) {
                        const n = this._imageCellMap;
                        if (null == e || !n.has(e)) return;
                        const r = n.get(e);
                        (t = i === P_.Homogeneous ? t : "#FFFFFF"),
                            this._images[r].applyCameraColor(e, t);
                    }
                }
                class OM {
                    constructor(e, t) {
                        (this._graphService = e),
                            (this._data = t),
                            (this._cells = {}),
                            (this._cacheRequests = {}),
                            (this._clusters = {}),
                            (this._clusterCells = {}),
                            (this._cellClusters = {}),
                            (this._cachingCells$ = {}),
                            (this._cachingClusters$ = {});
                    }
                    cacheClusters$(e) {
                        if (!this.hasCell(e))
                            throw new Error(
                                "Cannot cache reconstructions of a non-existing cell."
                            );
                        if (this.hasClusters(e))
                            throw new Error(
                                "Cannot cache reconstructions that already exists."
                            );
                        if (this.isCachingClusters(e))
                            return this._cachingClusters$[e];
                        const t = this.getCell(e)
                                .filter((e) => !!e.clusterId && !!e.clusterUrl)
                                .map((e) => ({
                                    key: e.clusterId,
                                    url: e.clusterUrl,
                                })),
                            i = Array.from(
                                new Map(t.map((e) => [e.key, e])).values()
                            );
                        let n;
                        (this._cellClusters[e] = i),
                            (this._cacheRequests[e] = []);
                        const r = new Promise((e, t) => {
                            n = t;
                        });
                        return (
                            this._cacheRequests[e].push(n),
                            (this._cachingClusters$[e] = this._cacheClusters$(
                                i,
                                e,
                                r
                            ).pipe(
                                xt(() => {
                                    e in this._cachingClusters$ &&
                                        delete this._cachingClusters$[e],
                                        e in this._cacheRequests &&
                                            delete this._cacheRequests[e];
                                }),
                                Dt(),
                                V()
                            )),
                            this._cachingClusters$[e]
                        );
                    }
                    cacheCell$(e) {
                        if (this.hasCell(e))
                            throw new Error(
                                "Cannot cache cell that already exists."
                            );
                        return (
                            this.isCachingCell(e) ||
                                (this._cachingCells$[e] = this._graphService
                                    .cacheCell$(e)
                                    .pipe(
                                        ot((e) => (console.error(e), oe())),
                                        nt(() => !(e in this._cells)),
                                        Ut((t) => {
                                            (this._cells[e] = []),
                                                this._cells[e].push(...t),
                                                delete this._cachingCells$[e];
                                        }),
                                        xt(() => {
                                            e in this._cachingCells$ &&
                                                delete this._cachingCells$[e];
                                        }),
                                        Dt(),
                                        V()
                                    )),
                            this._cachingCells$[e]
                        );
                    }
                    isCachingClusters(e) {
                        return e in this._cachingClusters$;
                    }
                    isCachingCell(e) {
                        return e in this._cachingCells$;
                    }
                    hasClusters(e) {
                        if (
                            e in this._cachingClusters$ ||
                            !(e in this._cellClusters)
                        )
                            return !1;
                        for (const t of this._cellClusters[e])
                            if (!(t.key in this._clusters)) return !1;
                        return !0;
                    }
                    hasCell(e) {
                        return !(e in this._cachingCells$) && e in this._cells;
                    }
                    getClusters(e) {
                        return e in this._cellClusters
                            ? this._cellClusters[e]
                                  .map((e) => this._clusters[e.key])
                                  .filter((e) => !!e)
                            : [];
                    }
                    getCell(e) {
                        return e in this._cells ? this._cells[e] : [];
                    }
                    uncache(e) {
                        for (let t of Object.keys(this._cacheRequests))
                            if (!e || -1 === e.indexOf(t)) {
                                for (const e of this._cacheRequests[t]) e();
                                delete this._cacheRequests[t];
                            }
                        for (let t of Object.keys(this._cellClusters))
                            if (!e || -1 === e.indexOf(t)) {
                                for (const e of this._cellClusters[t]) {
                                    if (!(e.key in this._clusterCells))
                                        continue;
                                    const i =
                                        this._clusterCells[e.key].indexOf(t);
                                    -1 !== i &&
                                        (this._clusterCells[e.key].splice(i, 1),
                                        this._clusterCells[e.key].length > 0 ||
                                            (delete this._clusterCells[e.key],
                                            delete this._clusters[e.key]));
                                }
                                delete this._cellClusters[t];
                            }
                        for (let t of Object.keys(this._cells))
                            (e && -1 !== e.indexOf(t)) || delete this._cells[t];
                    }
                    updateCell$(e) {
                        if (!this.hasCell(e))
                            throw new Error(
                                "Cannot update cell that does not exists."
                            );
                        return this._graphService.cacheCell$(e).pipe(
                            ot((e) => (console.error(e), oe())),
                            nt(() => e in this._cells),
                            Ut((t) => {
                                (this._cells[e] = []),
                                    this._cells[e].push(...t);
                            }),
                            Dt(),
                            V()
                        );
                    }
                    updateClusters$(e) {
                        if (!this.hasCell(e))
                            throw new Error(
                                "Cannot update reconstructions of a non-existing cell."
                            );
                        if (!this.hasClusters(e))
                            throw new Error(
                                "Cannot update reconstructions for cell that is not cached."
                            );
                        const t = this.getCell(e)
                                .filter((e) => !!e.clusterId && !!e.clusterUrl)
                                .map((e) => ({
                                    key: e.clusterId,
                                    url: e.clusterUrl,
                                })),
                            i = Array.from(
                                new Map(t.map((e) => [e.key, e])).values()
                            ).filter((e) => !(e.key in this._clusters));
                        return (
                            this._cellClusters[e].push(...i),
                            this._cacheClusters$(i, e, null)
                        );
                    }
                    _cacheClusters$(e, t, i) {
                        return ye(e).pipe(
                            Ye(
                                (e) =>
                                    this._hasCluster(e.key)
                                        ? Ce(this._getCluster(e.key))
                                        : this._getCluster$(
                                              e.url,
                                              e.key,
                                              i
                                          ).pipe(
                                              ot(
                                                  (e) => (
                                                      e instanceof d_ ||
                                                          console.error(e),
                                                      oe()
                                                  )
                                              )
                                          ),
                                6
                            ),
                            nt(() => t in this._cellClusters),
                            Ut((e) => {
                                this._hasCluster(e.id) ||
                                    (this._clusters[e.id] = e),
                                    e.id in this._clusterCells ||
                                        (this._clusterCells[e.id] = []),
                                    -1 ===
                                        this._clusterCells[e.id].indexOf(t) &&
                                        this._clusterCells[e.id].push(t);
                            })
                        );
                    }
                    _getCluster(e) {
                        return this._clusters[e];
                    }
                    _getCluster$(e, t, i) {
                        return $.create((n) => {
                            this._data.getCluster(e, i).then(
                                (e) => {
                                    (e.id = t), n.next(e), n.complete();
                                },
                                (e) => {
                                    n.error(e);
                                }
                            );
                        });
                    }
                    _hasCluster(e) {
                        return e in this._clusters;
                    }
                }
                function kM(e, t, i) {
                    const n = new Set();
                    return n.add(e), RM(n, [e], 0, t, i), Array.from(n);
                }
                function RM(e, t, i, n, r) {
                    if (i >= n) return;
                    const s = [];
                    for (const e of t) {
                        const t = r.getAdjacent(e);
                        s.push(...t);
                    }
                    const a = [];
                    for (const t of s) e.has(t) || (e.add(t), a.push(t));
                    RM(e, a, i + 1, n, r);
                }
                class PM extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i),
                            (this._cache = new OM(i.graphService, i.api.data)),
                            (this._scene = new jM(
                                this._getDefaultConfiguration()
                            )),
                            (this._viewportCoords = new l_()),
                            (this._spatial = new Lp());
                    }
                    getFrameIdAt(e) {
                        return new Promise((t, i) => {
                            this._container.renderService.renderCamera$
                                .pipe(
                                    bt(),
                                    ke((t) => {
                                        const i =
                                            this._viewportCoords.canvasToViewport(
                                                e[0],
                                                e[1],
                                                this._container.container
                                            );
                                        return this._scene.intersection.intersectObjects(
                                            i,
                                            t.perspective
                                        );
                                    })
                                )
                                .subscribe(
                                    (e) => {
                                        t(e);
                                    },
                                    (e) => {
                                        i(e);
                                    }
                                );
                        });
                    }
                    _activate() {
                        this._navigator.cacheService.configure({
                            cellDepth: 3,
                        });
                        const e = this._subscriptions;
                        e.push(
                            this._navigator.stateService.reference$
                                .pipe(Nt())
                                .subscribe(([e, t]) => {
                                    this._scene.resetReference(t, e);
                                })
                        ),
                            e.push(
                                this._navigator.graphService.filter$.subscribe(
                                    (e) => {
                                        this._scene.setFilter(e);
                                    }
                                )
                            );
                        const t = this._container.renderService.bearing$.pipe(
                                ke((e) => 6 * Math.floor(e / 6)),
                                ft(),
                                It(1),
                                V()
                            ),
                            i = this._navigator.stateService.currentImage$.pipe(
                                ke((e) =>
                                    this._navigator.api.data.geometry.lngLatToCellId(
                                        e.originalLngLat
                                    )
                                ),
                                ft(),
                                It(1),
                                V()
                            ),
                            n = this._configuration$.pipe(
                                ke((e) =>
                                    this._spatial.clamp(e.cellGridDepth, 1, 3)
                                ),
                                ft(),
                                It(1),
                                V()
                            ),
                            r = He(
                                this._navigator.playService.playing$,
                                this._navigator.playService.speed$
                            ).pipe(
                                ke(([e, t]) => e && t > vM.sequenceSpeed),
                                ft(),
                                It(1),
                                V()
                            ),
                            s = this._navigator.stateService.state$.pipe(
                                ke((e) =>
                                    (function (e) {
                                        return (
                                            e === j_.Custom || e === j_.Earth
                                        );
                                    })(e)
                                ),
                                ft(),
                                It(1),
                                V()
                            );
                        e.push(
                            s.subscribe((e) => {
                                this._scene.setNavigationState(e);
                            })
                        );
                        const a = He(
                            s,
                            r,
                            t,
                            n,
                            this._navigator.stateService.currentImage$
                        ).pipe(
                            ft(([e, t, i, n, r], [s, a, o, c, l]) => {
                                if (e !== s) return !1;
                                const h = r.id === l.id && t === a && n === c;
                                return e ? h : h && i === o;
                            }),
                            ht(([e, t, i, n, r]) => {
                                if (e) {
                                    const e = this._navigator.api.data.geometry,
                                        i = e.lngLatToCellId(r.originalLngLat);
                                    return Ce(t ? [i] : kM(i, n, e));
                                }
                                const s = t ? 30 : 90;
                                return Ce(this._cellsInFov(r, i, s));
                            }),
                            kt((e) =>
                                ye(e).pipe(
                                    Ye(
                                        (e) =>
                                            (this._cache.hasCell(e)
                                                ? Ce(this._cache.getCell(e))
                                                : this._cache.cacheCell$(e)
                                            ).pipe(
                                                ke((t) => ({
                                                    id: e,
                                                    images: t,
                                                }))
                                            ),
                                        6
                                    )
                                )
                            )
                        );
                        e.push(
                            a
                                .pipe(
                                    $t(this._navigator.stateService.reference$)
                                )
                                .subscribe(([e, t]) => {
                                    this._scene.hasCell(e.id) ||
                                        this._scene.addCell(
                                            this._cellToTopocentric(e.id, t),
                                            e.id
                                        );
                                })
                        ),
                            e.push(
                                a
                                    .pipe(
                                        $t(
                                            this._navigator.stateService
                                                .reference$
                                        )
                                    )
                                    .subscribe(([e, t]) => {
                                        this._addSceneImages(e, t);
                                    })
                            ),
                            e.push(
                                a
                                    .pipe(
                                        ht((e) => {
                                            const t = e.id;
                                            let i;
                                            return (
                                                (i = this._cache.hasClusters(t)
                                                    ? ye(
                                                          this._cache.getClusters(
                                                              t
                                                          )
                                                      )
                                                    : this._cache.isCachingClusters(
                                                          t
                                                      )
                                                    ? this._cache
                                                          .cacheClusters$(t)
                                                          .pipe(
                                                              Tt(null, {}),
                                                              kt(() =>
                                                                  ye(
                                                                      this._cache.getClusters(
                                                                          t
                                                                      )
                                                                  )
                                                              )
                                                          )
                                                    : this._cache.hasCell(t)
                                                    ? this._cache.cacheClusters$(
                                                          t
                                                      )
                                                    : oe()),
                                                He(Ce(t), i)
                                            );
                                        }),
                                        $t(
                                            this._navigator.stateService
                                                .reference$
                                        )
                                    )
                                    .subscribe(([[e, t], i]) => {
                                        this._scene.hasCluster(t.id, e) ||
                                            this._scene.addCluster(
                                                t,
                                                this._computeTranslation(t, i),
                                                e
                                            );
                                    })
                            ),
                            e.push(
                                this._configuration$
                                    .pipe(
                                        ke((e) => {
                                            var t;
                                            (e.cameraSize = this._spatial.clamp(
                                                e.cameraSize,
                                                0.01,
                                                1
                                            )),
                                                (e.pointSize =
                                                    this._spatial.clamp(
                                                        e.pointSize,
                                                        0.01,
                                                        1
                                                    ));
                                            const i = e.pointsVisible
                                                ? null !==
                                                      (t =
                                                          e.pointVisualizationMode) &&
                                                  void 0 !== t
                                                    ? t
                                                    : $_.Original
                                                : $_.Hidden;
                                            return {
                                                cameraSize: e.cameraSize,
                                                cameraVisualizationMode:
                                                    e.cameraVisualizationMode,
                                                cellsVisible: e.cellsVisible,
                                                originalPositionMode:
                                                    e.originalPositionMode,
                                                pointSize: e.pointSize,
                                                pointVisualizationMode: i,
                                            };
                                        }),
                                        ft(
                                            (e, t) =>
                                                e.cameraSize === t.cameraSize &&
                                                e.cameraVisualizationMode ===
                                                    t.cameraVisualizationMode &&
                                                e.cellsVisible ===
                                                    t.cellsVisible &&
                                                e.originalPositionMode ===
                                                    t.originalPositionMode &&
                                                e.pointSize === t.pointSize &&
                                                e.pointVisualizationMode ===
                                                    t.pointVisualizationMode
                                        )
                                    )
                                    .subscribe((e) => {
                                        this._scene.setCameraSize(e.cameraSize);
                                        const t = e.cameraVisualizationMode;
                                        this._scene.setCameraVisualizationMode(
                                            t
                                        ),
                                            this._scene.setCellVisibility(
                                                e.cellsVisible
                                            ),
                                            this._scene.setPointSize(
                                                e.pointSize
                                            );
                                        const i = e.pointVisualizationMode;
                                        this._scene.setPointVisualizationMode(
                                            i
                                        );
                                        const n = e.originalPositionMode;
                                        this._scene.setPositionMode(n);
                                    })
                            ),
                            e.push(
                                He(i, n).subscribe(([e, t]) => {
                                    const i = kM(
                                        e,
                                        t,
                                        this._navigator.api.data.geometry
                                    );
                                    this._scene.uncache(i),
                                        this._cache.uncache(i);
                                })
                            ),
                            e.push(
                                this._navigator.playService.playing$
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? oe()
                                                : this._container.mouseService
                                                      .dblClick$
                                        ),
                                        $t(
                                            this._container.renderService
                                                .renderCamera$
                                        ),
                                        kt(([e, t]) => {
                                            const i = this._container.container,
                                                [n, r] =
                                                    this._viewportCoords.canvasPosition(
                                                        e,
                                                        i
                                                    ),
                                                s =
                                                    this._viewportCoords.canvasToViewport(
                                                        n,
                                                        r,
                                                        i
                                                    ),
                                                a =
                                                    this._scene.intersection.intersectObjects(
                                                        s,
                                                        t.perspective
                                                    );
                                            return a
                                                ? this._navigator
                                                      .moveTo$(a)
                                                      .pipe(ot(() => oe()))
                                                : oe();
                                        })
                                    )
                                    .subscribe()
                            );
                        const o = He(
                                this._configuration$,
                                this._navigator.stateService.state$
                            ).pipe(
                                ke(
                                    ([e, t]) => (
                                        (e.cameraSize = this._spatial.clamp(
                                            e.cameraSize,
                                            0.01,
                                            1
                                        )),
                                        {
                                            size: e.cameraSize,
                                            visible: zM(
                                                e.cameraVisualizationMode
                                            ),
                                            state: t,
                                        }
                                    )
                                ),
                                ft(
                                    (e, t) =>
                                        e.size === t.size &&
                                        e.visible === t.visible &&
                                        e.state === t.state
                                )
                            ),
                            c = this._container.mouseService.mouseMove$.pipe(
                                It(1),
                                V()
                            );
                        e.push(c.subscribe());
                        const l = tt(
                            this._container.mouseService.mouseEnter$,
                            this._container.mouseService.mouseLeave$,
                            this._container.mouseService.windowBlur$
                        );
                        e.push(
                            He(
                                this._navigator.playService.playing$,
                                l,
                                s,
                                this._navigator.graphService.filter$
                            )
                                .pipe(
                                    kt(([e, t]) =>
                                        e || "pointerenter" !== t.type
                                            ? He(Ce(t), Ce(null), Ce(null))
                                            : He(
                                                  We(
                                                      c.pipe(mt(1)),
                                                      this._container
                                                          .mouseService
                                                          .mouseMove$
                                                  ),
                                                  this._container.renderService
                                                      .renderCamera$,
                                                  o
                                              )
                                    )
                                )
                                .subscribe(([e, t]) => {
                                    if ("pointermove" !== e.type)
                                        return void this._scene.setHoveredImage(
                                            null
                                        );
                                    const i = this._container.container,
                                        [n, r] =
                                            this._viewportCoords.canvasPosition(
                                                e,
                                                i
                                            ),
                                        s =
                                            this._viewportCoords.canvasToViewport(
                                                n,
                                                r,
                                                i
                                            ),
                                        a =
                                            this._scene.intersection.intersectObjects(
                                                s,
                                                t.perspective
                                            );
                                    this._scene.setHoveredImage(a);
                                })
                        ),
                            e.push(
                                this._navigator.stateService.currentId$.subscribe(
                                    (e) => {
                                        this._scene.setSelectedImage(e);
                                    }
                                )
                            ),
                            e.push(
                                this._navigator.stateService.currentState$
                                    .pipe(
                                        ke((e) => {
                                            const t = this._scene;
                                            return {
                                                name: this._name,
                                                renderer: {
                                                    frameId: e.id,
                                                    needsRender: t.needsRender,
                                                    render: t.render.bind(t),
                                                    pass: i_.Opaque,
                                                },
                                            };
                                        })
                                    )
                                    .subscribe(
                                        this._container.glRenderer.render$
                                    )
                            );
                        const h = this._navigator.graphService.dataAdded$.pipe(
                            nt((e) => this._cache.hasCell(e)),
                            Ye((e) =>
                                this._cache.updateCell$(e).pipe(
                                    ke((t) => ({ id: e, images: t })),
                                    $t(this._navigator.stateService.reference$)
                                )
                            ),
                            Dt(),
                            V()
                        );
                        e.push(
                            h.subscribe(([e, t]) => {
                                this._addSceneImages(e, t);
                            })
                        ),
                            e.push(
                                h
                                    .pipe(
                                        ht(([e]) => {
                                            const t = e.id,
                                                i = this._cache;
                                            let n;
                                            return (
                                                (n = i.hasClusters(t)
                                                    ? i.updateClusters$(t)
                                                    : i.isCachingClusters(t)
                                                    ? this._cache
                                                          .cacheClusters$(t)
                                                          .pipe(
                                                              Tt(null, {}),
                                                              kt(() =>
                                                                  ye(
                                                                      i.updateClusters$(
                                                                          t
                                                                      )
                                                                  )
                                                              )
                                                          )
                                                    : oe()),
                                                He(Ce(t), n)
                                            );
                                        }),
                                        $t(
                                            this._navigator.stateService
                                                .reference$
                                        )
                                    )
                                    .subscribe(([[e, t], i]) => {
                                        this._scene.hasCluster(t.id, e) ||
                                            this._scene.addCluster(
                                                t,
                                                this._computeTranslation(t, i),
                                                e
                                            );
                                    })
                            );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe(),
                            this._cache.uncache(),
                            this._scene.deactivate(),
                            this._navigator.cacheService.configure();
                    }
                    _getDefaultConfiguration() {
                        return {
                            cameraSize: 0.1,
                            cameraVisualizationMode: P_.Homogeneous,
                            cellGridDepth: 1,
                            originalPositionMode: U_.Hidden,
                            pointSize: 0.1,
                            pointsVisible: !0,
                            pointVisualizationMode: $_.Original,
                            cellsVisible: !1,
                        };
                    }
                    _addSceneImages(e, t) {
                        const i = e.id,
                            n = e.images;
                        for (const e of n)
                            this._scene.hasImage(e.id, i) ||
                                this._scene.addImage(
                                    e,
                                    this._createTransform(e, t),
                                    this._computeOriginalPosition(e, t),
                                    i
                                );
                    }
                    _cellsInFov(e, t, i) {
                        const n = this._spatial,
                            r = this._navigator.api.data.geometry,
                            s = r.lngLatToCellId(e.originalLngLat),
                            a = [s],
                            o = i / 2,
                            c = r.getAdjacent(s);
                        for (const i of c) {
                            const s = r.getVertices(i);
                            for (const r of s) {
                                const [s, c] = vp(
                                        r.lng,
                                        r.lat,
                                        0,
                                        e.lngLat.lng,
                                        e.lngLat.lat,
                                        0
                                    ),
                                    l = Math.atan2(c, s),
                                    h = n.radToDeg(n.azimuthalToBearing(l));
                                Math.abs(h - t) < o && a.push(i);
                            }
                        }
                        return a;
                    }
                    _computeOriginalPosition(e, t) {
                        return vp(
                            e.originalLngLat.lng,
                            e.originalLngLat.lat,
                            null != e.originalAltitude
                                ? e.originalAltitude
                                : e.computedAltitude,
                            t.lng,
                            t.lat,
                            t.alt
                        );
                    }
                    _cellToTopocentric(e, t) {
                        const i = this._navigator.api.data.geometry
                            .getVertices(e)
                            .map((e) =>
                                vp(e.lng, e.lat, -2, t.lng, t.lat, t.alt)
                            );
                        return i;
                    }
                    _computeTranslation(e, t) {
                        return vp(
                            e.reference.lng,
                            e.reference.lat,
                            e.reference.alt,
                            t.lng,
                            t.lat,
                            t.alt
                        );
                    }
                    _createTransform(e, t) {
                        const i = kp(
                            {
                                alt: e.computedAltitude,
                                lat: e.lngLat.lat,
                                lng: e.lngLat.lng,
                            },
                            e.rotation,
                            t
                        );
                        return new mM(
                            e.exifOrientation,
                            e.width,
                            e.height,
                            e.scale,
                            e.rotation,
                            i,
                            void 0,
                            void 0,
                            e.cameraParameters,
                            e.cameraType
                        );
                    }
                }
                PM.componentName = "spatial";
                class UM {
                    constructor() {
                        this._notifyChanged$ = new W();
                    }
                    get changed$() {
                        return this._notifyChanged$;
                    }
                }
                class $M extends Ap {
                    constructor(e) {
                        super(
                            null != e
                                ? e
                                : "The provided geometry value is incorrect"
                        ),
                            Object.setPrototypeOf(this, $M.prototype),
                            (this.name = "GeometryTagError");
                    }
                }
                class BM extends UM {
                    constructor(e) {
                        if ((super(), e.length < 2))
                            throw new $M(
                                "A points geometry must have two or more positions."
                            );
                        this._points = [];
                        for (const t of e) {
                            if (t[0] < 0 || t[0] > 1 || t[1] < 0 || t[1] > 1)
                                throw new $M(
                                    "Basic coordinates of points must be on the interval [0, 1]."
                                );
                            this._points.push(t.slice());
                        }
                    }
                    get points() {
                        return this._points;
                    }
                    addPoint2d(e) {
                        const t = [
                            Math.max(0, Math.min(1, e[0])),
                            Math.max(0, Math.min(1, e[1])),
                        ];
                        this._points.push(t), this._notifyChanged$.next(this);
                    }
                    getPoint2d(e) {
                        return this._points[e].slice();
                    }
                    removePoint2d(e) {
                        if (
                            e < 0 ||
                            e >= this._points.length ||
                            this._points.length < 3
                        )
                            throw new $M(
                                "Index for removed point must be valid."
                            );
                        this._points.splice(e, 1),
                            this._notifyChanged$.next(this);
                    }
                    setVertex2d(e, t, i) {
                        this.setPoint2d(e, t, i);
                    }
                    setPoint2d(e, t, i) {
                        const n = [
                            Math.max(0, Math.min(1, t[0])),
                            Math.max(0, Math.min(1, t[1])),
                        ];
                        (this._points[e] = n), this._notifyChanged$.next(this);
                    }
                    getPoints3d(e) {
                        return this._getPoints3d(this._points, e);
                    }
                    getPoint3d(e, t) {
                        return t.unprojectBasic(this._points[e], 200);
                    }
                    getPoints2d() {
                        return this._points.slice();
                    }
                    getCentroid2d(e) {
                        if (!e)
                            throw new $M(
                                "Get centroid must be called with a transform for points geometries."
                            );
                        const [t, i, n, r] = this.getRect2d(e);
                        return [
                            t < n ? (t + n) / 2 : ((t + n + 1) / 2) % 1,
                            (i + r) / 2,
                        ];
                    }
                    getCentroid3d(e) {
                        let t = this.getCentroid2d();
                        return e.unprojectBasic(t, 200);
                    }
                    getRect2d(e) {
                        let t = 1,
                            i = 0,
                            n = 1,
                            r = 0;
                        const s = this._points;
                        for (const e of s)
                            e[0] < t && (t = e[0]),
                                e[0] > i && (i = e[0]),
                                e[1] < n && (n = e[1]),
                                e[1] > r && (r = e[1]);
                        if (jp(e.cameraType)) {
                            const e = [];
                            for (let t = 0; t < s.length; t++) e[t] = t;
                            e.sort((e, t) =>
                                s[e][0] < s[t][0]
                                    ? -1
                                    : s[e][0] > s[t][0]
                                    ? 1
                                    : e < t
                                    ? -1
                                    : 1
                            );
                            let n = s[e[0]][0] + 1 - s[e[e.length - 1]][0],
                                r = 0;
                            for (let t = 0; t < e.length - 1; t++) {
                                const i = e[t],
                                    a = e[t + 1],
                                    o = s[a][0] - s[i][0];
                                o > n && ((n = o), (r = t + 1));
                            }
                            r > 0 && ((t = s[e[r]][0]), (i = s[e[r - 1]][0]));
                        }
                        return [t, n, i, r];
                    }
                    setCentroid2d(e, t) {
                        throw new Error("Not implemented");
                    }
                    _getPoints3d(e, t) {
                        return e.map((e) => t.unprojectBasic(e, 200));
                    }
                }
                class FM {
                    constructor(e, t, i) {
                        (this._geometry = e),
                            (this._transform = t),
                            (this._viewportCoords = i || new l_()),
                            (this._aborted$ = new W()),
                            (this._created$ = new W()),
                            (this._glObjectsChanged$ = new W()),
                            (this._geometryChangedSubscription =
                                this._geometry.changed$.subscribe(() => {
                                    this._onGeometryChanged(),
                                        this._glObjectsChanged$.next(this);
                                }));
                    }
                    get geometry() {
                        return this._geometry;
                    }
                    get glObjects() {
                        return this._glObjects;
                    }
                    get aborted$() {
                        return this._aborted$;
                    }
                    get created$() {
                        return this._created$;
                    }
                    get glObjectsChanged$() {
                        return this._glObjectsChanged$;
                    }
                    get geometryChanged$() {
                        return this._geometry.changed$.pipe(ke(() => this));
                    }
                    dispose() {
                        this._geometryChangedSubscription.unsubscribe();
                    }
                    _canvasToTransform(e) {
                        return `translate(-50%,-50%) translate(${Math.round(
                            e[0]
                        )}px,${Math.round(e[1])}px)`;
                    }
                    _colorToBackground(e) {
                        return "#" + ("000000" + e.toString(16)).substr(-6);
                    }
                    _createOutine(e, t) {
                        const i = this._getLinePositions(e),
                            n = new Ba();
                        n.setAttribute("position", new Aa(i, 3));
                        const r = new Gh({ color: t, linewidth: 1 });
                        return new Zh(n, r);
                    }
                    _disposeLine(e) {
                        null != e &&
                            (e.geometry.dispose(), e.material.dispose());
                    }
                    _getLinePositions(e) {
                        const t = e.length,
                            i = new Float32Array(3 * t);
                        for (let n = 0; n < t; ++n) {
                            const t = 3 * n,
                                r = e[n];
                            (i[t] = r[0]), (i[t + 1] = r[1]), (i[t + 2] = r[2]);
                        }
                        return i;
                    }
                }
                var HM = { exports: {} };
                function GM(e, t, i) {
                    i = i || 2;
                    var n,
                        r,
                        s,
                        a,
                        o,
                        c,
                        l,
                        h = t && t.length,
                        u = h ? t[0] * i : e.length,
                        d = VM(e, 0, u, i, !0),
                        p = [];
                    if (!d || d.next === d.prev) return p;
                    if (
                        (h &&
                            (d = (function (e, t, i, n) {
                                var r,
                                    s,
                                    a,
                                    o = [];
                                for (r = 0, s = t.length; r < s; r++)
                                    (a = VM(
                                        e,
                                        t[r] * n,
                                        r < s - 1 ? t[r + 1] * n : e.length,
                                        n,
                                        !1
                                    )) === a.next && (a.steiner = !0),
                                        o.push(iv(a));
                                for (o.sort(JM), r = 0; r < o.length; r++)
                                    i = YM((i = KM(o[r], i)), i.next);
                                return i;
                            })(e, t, d, i)),
                        e.length > 80 * i)
                    ) {
                        (n = s = e[0]), (r = a = e[1]);
                        for (var g = i; g < u; g += i)
                            (o = e[g]) < n && (n = o),
                                (c = e[g + 1]) < r && (r = c),
                                o > s && (s = o),
                                c > a && (a = c);
                        l = 0 !== (l = Math.max(s - n, a - r)) ? 1 / l : 0;
                    }
                    return qM(d, p, i, n, r, l), p;
                }
                function VM(e, t, i, n, r) {
                    var s, a;
                    if (r === mv(e, t, i, n) > 0)
                        for (s = t; s < i; s += n) a = dv(s, e[s], e[s + 1], a);
                    else
                        for (s = i - n; s >= t; s -= n)
                            a = dv(s, e[s], e[s + 1], a);
                    return a && av(a, a.next) && (pv(a), (a = a.next)), a;
                }
                function YM(e, t) {
                    if (!e) return e;
                    t || (t = e);
                    var i,
                        n = e;
                    do {
                        if (
                            ((i = !1),
                            n.steiner ||
                                (!av(n, n.next) && 0 !== sv(n.prev, n, n.next)))
                        )
                            n = n.next;
                        else {
                            if ((pv(n), (n = t = n.prev) === n.next)) break;
                            i = !0;
                        }
                    } while (i || n !== t);
                    return t;
                }
                function qM(e, t, i, n, r, s, a) {
                    if (e) {
                        !a &&
                            s &&
                            (function (e, t, i, n) {
                                var r = e;
                                do {
                                    null === r.z &&
                                        (r.z = tv(r.x, r.y, t, i, n)),
                                        (r.prevZ = r.prev),
                                        (r.nextZ = r.next),
                                        (r = r.next);
                                } while (r !== e);
                                (r.prevZ.nextZ = null),
                                    (r.prevZ = null),
                                    (function (e) {
                                        var t,
                                            i,
                                            n,
                                            r,
                                            s,
                                            a,
                                            o,
                                            c,
                                            l = 1;
                                        do {
                                            for (
                                                i = e,
                                                    e = null,
                                                    s = null,
                                                    a = 0;
                                                i;

                                            ) {
                                                for (
                                                    a++, n = i, o = 0, t = 0;
                                                    t < l &&
                                                    (o++, (n = n.nextZ));
                                                    t++
                                                );
                                                for (
                                                    c = l;
                                                    o > 0 || (c > 0 && n);

                                                )
                                                    0 !== o &&
                                                    (0 === c ||
                                                        !n ||
                                                        i.z <= n.z)
                                                        ? ((r = i),
                                                          (i = i.nextZ),
                                                          o--)
                                                        : ((r = n),
                                                          (n = n.nextZ),
                                                          c--),
                                                        s
                                                            ? (s.nextZ = r)
                                                            : (e = r),
                                                        (r.prevZ = s),
                                                        (s = r);
                                                i = n;
                                            }
                                            (s.nextZ = null), (l *= 2);
                                        } while (a > 1);
                                    })(r);
                            })(e, n, r, s);
                        for (var o, c, l = e; e.prev !== e.next; )
                            if (
                                ((o = e.prev),
                                (c = e.next),
                                s ? QM(e, n, r, s) : WM(e))
                            )
                                t.push(o.i / i),
                                    t.push(e.i / i),
                                    t.push(c.i / i),
                                    pv(e),
                                    (e = c.next),
                                    (l = c.next);
                            else if ((e = c) === l) {
                                a
                                    ? 1 === a
                                        ? qM(
                                              (e = ZM(YM(e), t, i)),
                                              t,
                                              i,
                                              n,
                                              r,
                                              s,
                                              2
                                          )
                                        : 2 === a && XM(e, t, i, n, r, s)
                                    : qM(YM(e), t, i, n, r, s, 1);
                                break;
                            }
                    }
                }
                function WM(e) {
                    var t = e.prev,
                        i = e,
                        n = e.next;
                    if (sv(t, i, n) >= 0) return !1;
                    for (var r = e.next.next; r !== e.prev; ) {
                        if (
                            nv(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) &&
                            sv(r.prev, r, r.next) >= 0
                        )
                            return !1;
                        r = r.next;
                    }
                    return !0;
                }
                function QM(e, t, i, n) {
                    var r = e.prev,
                        s = e,
                        a = e.next;
                    if (sv(r, s, a) >= 0) return !1;
                    for (
                        var o =
                                r.x < s.x
                                    ? r.x < a.x
                                        ? r.x
                                        : a.x
                                    : s.x < a.x
                                    ? s.x
                                    : a.x,
                            c =
                                r.y < s.y
                                    ? r.y < a.y
                                        ? r.y
                                        : a.y
                                    : s.y < a.y
                                    ? s.y
                                    : a.y,
                            l =
                                r.x > s.x
                                    ? r.x > a.x
                                        ? r.x
                                        : a.x
                                    : s.x > a.x
                                    ? s.x
                                    : a.x,
                            h =
                                r.y > s.y
                                    ? r.y > a.y
                                        ? r.y
                                        : a.y
                                    : s.y > a.y
                                    ? s.y
                                    : a.y,
                            u = tv(o, c, t, i, n),
                            d = tv(l, h, t, i, n),
                            p = e.prevZ,
                            g = e.nextZ;
                        p && p.z >= u && g && g.z <= d;

                    ) {
                        if (
                            p !== e.prev &&
                            p !== e.next &&
                            nv(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
                            sv(p.prev, p, p.next) >= 0
                        )
                            return !1;
                        if (
                            ((p = p.prevZ),
                            g !== e.prev &&
                                g !== e.next &&
                                nv(r.x, r.y, s.x, s.y, a.x, a.y, g.x, g.y) &&
                                sv(g.prev, g, g.next) >= 0)
                        )
                            return !1;
                        g = g.nextZ;
                    }
                    for (; p && p.z >= u; ) {
                        if (
                            p !== e.prev &&
                            p !== e.next &&
                            nv(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
                            sv(p.prev, p, p.next) >= 0
                        )
                            return !1;
                        p = p.prevZ;
                    }
                    for (; g && g.z <= d; ) {
                        if (
                            g !== e.prev &&
                            g !== e.next &&
                            nv(r.x, r.y, s.x, s.y, a.x, a.y, g.x, g.y) &&
                            sv(g.prev, g, g.next) >= 0
                        )
                            return !1;
                        g = g.nextZ;
                    }
                    return !0;
                }
                function ZM(e, t, i) {
                    var n = e;
                    do {
                        var r = n.prev,
                            s = n.next.next;
                        !av(r, s) &&
                            ov(r, n, n.next, s) &&
                            hv(r, s) &&
                            hv(s, r) &&
                            (t.push(r.i / i),
                            t.push(n.i / i),
                            t.push(s.i / i),
                            pv(n),
                            pv(n.next),
                            (n = e = s)),
                            (n = n.next);
                    } while (n !== e);
                    return YM(n);
                }
                function XM(e, t, i, n, r, s) {
                    var a = e;
                    do {
                        for (var o = a.next.next; o !== a.prev; ) {
                            if (a.i !== o.i && rv(a, o)) {
                                var c = uv(a, o);
                                return (
                                    (a = YM(a, a.next)),
                                    (c = YM(c, c.next)),
                                    qM(a, t, i, n, r, s),
                                    void qM(c, t, i, n, r, s)
                                );
                            }
                            o = o.next;
                        }
                        a = a.next;
                    } while (a !== e);
                }
                function JM(e, t) {
                    return e.x - t.x;
                }
                function KM(e, t) {
                    var i = (function (e, t) {
                        var i,
                            n = t,
                            r = e.x,
                            s = e.y,
                            a = -1 / 0;
                        do {
                            if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                                var o =
                                    n.x +
                                    ((s - n.y) * (n.next.x - n.x)) /
                                        (n.next.y - n.y);
                                if (o <= r && o > a) {
                                    if (((a = o), o === r)) {
                                        if (s === n.y) return n;
                                        if (s === n.next.y) return n.next;
                                    }
                                    i = n.x < n.next.x ? n : n.next;
                                }
                            }
                            n = n.next;
                        } while (n !== t);
                        if (!i) return null;
                        if (r === a) return i;
                        var c,
                            l = i,
                            h = i.x,
                            u = i.y,
                            d = 1 / 0;
                        n = i;
                        do {
                            r >= n.x &&
                                n.x >= h &&
                                r !== n.x &&
                                nv(
                                    s < u ? r : a,
                                    s,
                                    h,
                                    u,
                                    s < u ? a : r,
                                    s,
                                    n.x,
                                    n.y
                                ) &&
                                ((c = Math.abs(s - n.y) / (r - n.x)),
                                hv(n, e) &&
                                    (c < d ||
                                        (c === d &&
                                            (n.x > i.x ||
                                                (n.x === i.x && ev(i, n))))) &&
                                    ((i = n), (d = c))),
                                (n = n.next);
                        } while (n !== l);
                        return i;
                    })(e, t);
                    if (!i) return t;
                    var n = uv(i, e),
                        r = YM(i, i.next);
                    return YM(n, n.next), t === i ? r : t;
                }
                function ev(e, t) {
                    return (
                        sv(e.prev, e, t.prev) < 0 && sv(t.next, e, e.next) < 0
                    );
                }
                function tv(e, t, i, n, r) {
                    return (
                        (e =
                            1431655765 &
                            ((e =
                                858993459 &
                                ((e =
                                    252645135 &
                                    ((e =
                                        16711935 &
                                        ((e = 32767 * (e - i) * r) |
                                            (e << 8))) |
                                        (e << 4))) |
                                    (e << 2))) |
                                (e << 1))) |
                        ((t =
                            1431655765 &
                            ((t =
                                858993459 &
                                ((t =
                                    252645135 &
                                    ((t =
                                        16711935 &
                                        ((t = 32767 * (t - n) * r) |
                                            (t << 8))) |
                                        (t << 4))) |
                                    (t << 2))) |
                                (t << 1))) <<
                            1)
                    );
                }
                function iv(e) {
                    var t = e,
                        i = e;
                    do {
                        (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t),
                            (t = t.next);
                    } while (t !== e);
                    return i;
                }
                function nv(e, t, i, n, r, s, a, o) {
                    return (
                        (r - a) * (t - o) - (e - a) * (s - o) >= 0 &&
                        (e - a) * (n - o) - (i - a) * (t - o) >= 0 &&
                        (i - a) * (s - o) - (r - a) * (n - o) >= 0
                    );
                }
                function rv(e, t) {
                    return (
                        e.next.i !== t.i &&
                        e.prev.i !== t.i &&
                        !(function (e, t) {
                            var i = e;
                            do {
                                if (
                                    i.i !== e.i &&
                                    i.next.i !== e.i &&
                                    i.i !== t.i &&
                                    i.next.i !== t.i &&
                                    ov(i, i.next, e, t)
                                )
                                    return !0;
                                i = i.next;
                            } while (i !== e);
                            return !1;
                        })(e, t) &&
                        ((hv(e, t) &&
                            hv(t, e) &&
                            (function (e, t) {
                                var i = e,
                                    n = !1,
                                    r = (e.x + t.x) / 2,
                                    s = (e.y + t.y) / 2;
                                do {
                                    i.y > s != i.next.y > s &&
                                        i.next.y !== i.y &&
                                        r <
                                            ((i.next.x - i.x) * (s - i.y)) /
                                                (i.next.y - i.y) +
                                                i.x &&
                                        (n = !n),
                                        (i = i.next);
                                } while (i !== e);
                                return n;
                            })(e, t) &&
                            (sv(e.prev, e, t.prev) || sv(e, t.prev, t))) ||
                            (av(e, t) &&
                                sv(e.prev, e, e.next) > 0 &&
                                sv(t.prev, t, t.next) > 0))
                    );
                }
                function sv(e, t, i) {
                    return (
                        (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
                    );
                }
                function av(e, t) {
                    return e.x === t.x && e.y === t.y;
                }
                function ov(e, t, i, n) {
                    var r = lv(sv(e, t, i)),
                        s = lv(sv(e, t, n)),
                        a = lv(sv(i, n, e)),
                        o = lv(sv(i, n, t));
                    return (
                        (r !== s && a !== o) ||
                        !(0 !== r || !cv(e, i, t)) ||
                        !(0 !== s || !cv(e, n, t)) ||
                        !(0 !== a || !cv(i, e, n)) ||
                        !(0 !== o || !cv(i, t, n))
                    );
                }
                function cv(e, t, i) {
                    return (
                        t.x <= Math.max(e.x, i.x) &&
                        t.x >= Math.min(e.x, i.x) &&
                        t.y <= Math.max(e.y, i.y) &&
                        t.y >= Math.min(e.y, i.y)
                    );
                }
                function lv(e) {
                    return e > 0 ? 1 : e < 0 ? -1 : 0;
                }
                function hv(e, t) {
                    return sv(e.prev, e, e.next) < 0
                        ? sv(e, t, e.next) >= 0 && sv(e, e.prev, t) >= 0
                        : sv(e, t, e.prev) < 0 || sv(e, e.next, t) < 0;
                }
                function uv(e, t) {
                    var i = new gv(e.i, e.x, e.y),
                        n = new gv(t.i, t.x, t.y),
                        r = e.next,
                        s = t.prev;
                    return (
                        (e.next = t),
                        (t.prev = e),
                        (i.next = r),
                        (r.prev = i),
                        (n.next = i),
                        (i.prev = n),
                        (s.next = n),
                        (n.prev = s),
                        n
                    );
                }
                function dv(e, t, i, n) {
                    var r = new gv(e, t, i);
                    return (
                        n
                            ? ((r.next = n.next),
                              (r.prev = n),
                              (n.next.prev = r),
                              (n.next = r))
                            : ((r.prev = r), (r.next = r)),
                        r
                    );
                }
                function pv(e) {
                    (e.next.prev = e.prev),
                        (e.prev.next = e.next),
                        e.prevZ && (e.prevZ.nextZ = e.nextZ),
                        e.nextZ && (e.nextZ.prevZ = e.prevZ);
                }
                function gv(e, t, i) {
                    (this.i = e),
                        (this.x = t),
                        (this.y = i),
                        (this.prev = null),
                        (this.next = null),
                        (this.z = null),
                        (this.prevZ = null),
                        (this.nextZ = null),
                        (this.steiner = !1);
                }
                function mv(e, t, i, n) {
                    for (var r = 0, s = t, a = i - n; s < i; s += n)
                        (r += (e[a] - e[s]) * (e[s + 1] + e[a + 1])), (a = s);
                    return r;
                }
                (HM.exports = GM),
                    (HM.exports.default = GM),
                    (GM.deviation = function (e, t, i, n) {
                        var r = t && t.length,
                            s = r ? t[0] * i : e.length,
                            a = Math.abs(mv(e, 0, s, i));
                        if (r)
                            for (var o = 0, c = t.length; o < c; o++) {
                                var l = t[o] * i,
                                    h = o < c - 1 ? t[o + 1] * i : e.length;
                                a -= Math.abs(mv(e, l, h, i));
                            }
                        var u = 0;
                        for (o = 0; o < n.length; o += 3) {
                            var d = n[o] * i,
                                p = n[o + 1] * i,
                                g = n[o + 2] * i;
                            u += Math.abs(
                                (e[d] - e[g]) * (e[p + 1] - e[d + 1]) -
                                    (e[d] - e[p]) * (e[g + 1] - e[d + 1])
                            );
                        }
                        return 0 === a && 0 === u ? 0 : Math.abs((u - a) / a);
                    }),
                    (GM.flatten = function (e) {
                        for (
                            var t = e[0][0].length,
                                i = { vertices: [], holes: [], dimensions: t },
                                n = 0,
                                r = 0;
                            r < e.length;
                            r++
                        ) {
                            for (var s = 0; s < e[r].length; s++)
                                for (var a = 0; a < t; a++)
                                    i.vertices.push(e[r][s][a]);
                            r > 0 && ((n += e[r - 1].length), i.holes.push(n));
                        }
                        return i;
                    });
                var fv = HM.exports,
                    _v = { exports: {} };
                function Mv(e, t) {
                    return e < t ? -1 : e > t ? 1 : 0;
                }
                var vv = lg(
                    Object.freeze({
                        __proto__: null,
                        default: class {
                            constructor(e = [], t = Mv) {
                                if (
                                    ((this.data = e),
                                    (this.length = this.data.length),
                                    (this.compare = t),
                                    this.length > 0)
                                )
                                    for (
                                        let e = (this.length >> 1) - 1;
                                        e >= 0;
                                        e--
                                    )
                                        this._down(e);
                            }
                            push(e) {
                                this.data.push(e),
                                    this.length++,
                                    this._up(this.length - 1);
                            }
                            pop() {
                                if (0 === this.length) return;
                                const e = this.data[0],
                                    t = this.data.pop();
                                return (
                                    this.length--,
                                    this.length > 0 &&
                                        ((this.data[0] = t), this._down(0)),
                                    e
                                );
                            }
                            peek() {
                                return this.data[0];
                            }
                            _up(e) {
                                const { data: t, compare: i } = this,
                                    n = t[e];
                                for (; e > 0; ) {
                                    const r = (e - 1) >> 1,
                                        s = t[r];
                                    if (i(n, s) >= 0) break;
                                    (t[e] = s), (e = r);
                                }
                                t[e] = n;
                            }
                            _down(e) {
                                const { data: t, compare: i } = this,
                                    n = this.length >> 1,
                                    r = t[e];
                                for (; e < n; ) {
                                    let n = 1 + (e << 1),
                                        s = t[n];
                                    const a = n + 1;
                                    if (
                                        (a < this.length &&
                                            i(t[a], s) < 0 &&
                                            ((n = a), (s = t[a])),
                                        i(s, r) >= 0)
                                    )
                                        break;
                                    (t[e] = s), (e = n);
                                }
                                t[e] = r;
                            }
                        },
                    })
                );
                function yv(e, t, i) {
                    var n, r, s, a;
                    t = t || 1;
                    for (var o = 0; o < e[0].length; o++) {
                        var c = e[0][o];
                        (!o || c[0] < n) && (n = c[0]),
                            (!o || c[1] < r) && (r = c[1]),
                            (!o || c[0] > s) && (s = c[0]),
                            (!o || c[1] > a) && (a = c[1]);
                    }
                    var l = s - n,
                        h = a - r,
                        u = Math.min(l, h),
                        d = u / 2;
                    if (0 === u) {
                        var p = [n, r];
                        return (p.distance = 0), p;
                    }
                    for (var g = new vv(void 0, xv), m = n; m < s; m += u)
                        for (var f = r; f < a; f += u)
                            g.push(new bv(m + d, f + d, d, e));
                    var _ = (function (e) {
                            for (
                                var t = 0,
                                    i = 0,
                                    n = 0,
                                    r = e[0],
                                    s = 0,
                                    a = r.length,
                                    o = a - 1;
                                s < a;
                                o = s++
                            ) {
                                var c = r[s],
                                    l = r[o],
                                    h = c[0] * l[1] - l[0] * c[1];
                                (i += (c[0] + l[0]) * h),
                                    (n += (c[1] + l[1]) * h),
                                    (t += 3 * h);
                            }
                            return 0 === t
                                ? new bv(r[0][0], r[0][1], 0, e)
                                : new bv(i / t, n / t, 0, e);
                        })(e),
                        M = new bv(n + l / 2, r + h / 2, 0, e);
                    M.d > _.d && (_ = M);
                    for (var v = g.length; g.length; ) {
                        var y = g.pop();
                        y.d > _.d &&
                            ((_ = y),
                            i &&
                                console.log(
                                    "found best %d after %d probes",
                                    Math.round(1e4 * y.d) / 1e4,
                                    v
                                )),
                            y.max - _.d <= t ||
                                ((d = y.h / 2),
                                g.push(new bv(y.x - d, y.y - d, d, e)),
                                g.push(new bv(y.x + d, y.y - d, d, e)),
                                g.push(new bv(y.x - d, y.y + d, d, e)),
                                g.push(new bv(y.x + d, y.y + d, d, e)),
                                (v += 4));
                    }
                    i &&
                        (console.log("num probes: " + v),
                        console.log("best distance: " + _.d));
                    var x = [_.x, _.y];
                    return (x.distance = _.d), x;
                }
                function xv(e, t) {
                    return t.max - e.max;
                }
                function bv(e, t, i, n) {
                    (this.x = e),
                        (this.y = t),
                        (this.h = i),
                        (this.d = (function (e, t, i) {
                            for (
                                var n = !1, r = 1 / 0, s = 0;
                                s < i.length;
                                s++
                            )
                                for (
                                    var a = i[s],
                                        o = 0,
                                        c = a.length,
                                        l = c - 1;
                                    o < c;
                                    l = o++
                                ) {
                                    var h = a[o],
                                        u = a[l];
                                    h[1] > t != u[1] > t &&
                                        e <
                                            ((u[0] - h[0]) * (t - h[1])) /
                                                (u[1] - h[1]) +
                                                h[0] &&
                                        (n = !n),
                                        (r = Math.min(r, wv(e, t, h, u)));
                                }
                            return 0 === r ? 0 : (n ? 1 : -1) * Math.sqrt(r);
                        })(e, t, n)),
                        (this.max = this.d + this.h * Math.SQRT2);
                }
                function wv(e, t, i, n) {
                    var r = i[0],
                        s = i[1],
                        a = n[0] - r,
                        o = n[1] - s;
                    if (0 !== a || 0 !== o) {
                        var c = ((e - r) * a + (t - s) * o) / (a * a + o * o);
                        c > 1
                            ? ((r = n[0]), (s = n[1]))
                            : c > 0 && ((r += a * c), (s += o * c));
                    }
                    return (a = e - r) * a + (o = t - s) * o;
                }
                vv.default && (vv = vv.default),
                    (_v.exports = yv),
                    (_v.exports.default = yv);
                var Tv = _v.exports;
                function Sv(e, t) {
                    return e > t ? 1 : e < t ? -1 : 0;
                }
                class Nv {
                    constructor(e = Sv, t = !1) {
                        (this._compare = e),
                            (this._root = null),
                            (this._size = 0),
                            (this._noDuplicates = !!t);
                    }
                    rotateLeft(e) {
                        var t = e.right;
                        t &&
                            ((e.right = t.left),
                            t.left && (t.left.parent = e),
                            (t.parent = e.parent)),
                            e.parent
                                ? e === e.parent.left
                                    ? (e.parent.left = t)
                                    : (e.parent.right = t)
                                : (this._root = t),
                            t && (t.left = e),
                            (e.parent = t);
                    }
                    rotateRight(e) {
                        var t = e.left;
                        t &&
                            ((e.left = t.right),
                            t.right && (t.right.parent = e),
                            (t.parent = e.parent)),
                            e.parent
                                ? e === e.parent.left
                                    ? (e.parent.left = t)
                                    : (e.parent.right = t)
                                : (this._root = t),
                            t && (t.right = e),
                            (e.parent = t);
                    }
                    _splay(e) {
                        for (; e.parent; ) {
                            var t = e.parent;
                            t.parent
                                ? t.left === e && t.parent.left === t
                                    ? (this.rotateRight(t.parent),
                                      this.rotateRight(t))
                                    : t.right === e && t.parent.right === t
                                    ? (this.rotateLeft(t.parent),
                                      this.rotateLeft(t))
                                    : t.left === e && t.parent.right === t
                                    ? (this.rotateRight(t), this.rotateLeft(t))
                                    : (this.rotateLeft(t), this.rotateRight(t))
                                : t.left === e
                                ? this.rotateRight(t)
                                : this.rotateLeft(t);
                        }
                    }
                    splay(e) {
                        for (var t, i, n, r, s; e.parent; )
                            (i = (t = e.parent).parent) && i.parent
                                ? ((n = i.parent).left === i
                                      ? (n.left = e)
                                      : (n.right = e),
                                  (e.parent = n))
                                : ((e.parent = null), (this._root = e)),
                                (r = e.left),
                                (s = e.right),
                                e === t.left
                                    ? (i &&
                                          (i.left === t
                                              ? (t.right
                                                    ? ((i.left = t.right),
                                                      (i.left.parent = i))
                                                    : (i.left = null),
                                                (t.right = i),
                                                (i.parent = t))
                                              : (r
                                                    ? ((i.right = r),
                                                      (r.parent = i))
                                                    : (i.right = null),
                                                (e.left = i),
                                                (i.parent = e))),
                                      s
                                          ? ((t.left = s), (s.parent = t))
                                          : (t.left = null),
                                      (e.right = t),
                                      (t.parent = e))
                                    : (i &&
                                          (i.right === t
                                              ? (t.left
                                                    ? ((i.right = t.left),
                                                      (i.right.parent = i))
                                                    : (i.right = null),
                                                (t.left = i),
                                                (i.parent = t))
                                              : (s
                                                    ? ((i.left = s),
                                                      (s.parent = i))
                                                    : (i.left = null),
                                                (e.right = i),
                                                (i.parent = e))),
                                      r
                                          ? ((t.right = r), (r.parent = t))
                                          : (t.right = null),
                                      (e.left = t),
                                      (t.parent = e));
                    }
                    replace(e, t) {
                        e.parent
                            ? e === e.parent.left
                                ? (e.parent.left = t)
                                : (e.parent.right = t)
                            : (this._root = t),
                            t && (t.parent = e.parent);
                    }
                    minNode(e = this._root) {
                        if (e) for (; e.left; ) e = e.left;
                        return e;
                    }
                    maxNode(e = this._root) {
                        if (e) for (; e.right; ) e = e.right;
                        return e;
                    }
                    insert(e, t) {
                        var i = this._root,
                            n = null,
                            r = this._compare;
                        if (this._noDuplicates)
                            for (; i; ) {
                                if (((n = i), 0 === r(i.key, e))) return;
                                i = r(i.key, e) < 0 ? i.right : i.left;
                            }
                        else
                            for (; i; )
                                (n = i),
                                    (i = r(i.key, e) < 0 ? i.right : i.left);
                        return (
                            (i = {
                                key: e,
                                data: t,
                                left: null,
                                right: null,
                                parent: n,
                            }),
                            n
                                ? r(n.key, i.key) < 0
                                    ? (n.right = i)
                                    : (n.left = i)
                                : (this._root = i),
                            this.splay(i),
                            this._size++,
                            i
                        );
                    }
                    find(e) {
                        for (var t = this._root, i = this._compare; t; ) {
                            var n = i(t.key, e);
                            if (n < 0) t = t.right;
                            else {
                                if (!(n > 0)) return t;
                                t = t.left;
                            }
                        }
                        return null;
                    }
                    contains(e) {
                        for (var t = this._root, i = this._compare; t; ) {
                            var n = i(e, t.key);
                            if (0 === n) return !0;
                            t = n < 0 ? t.left : t.right;
                        }
                        return !1;
                    }
                    remove(e) {
                        var t = this.find(e);
                        if (!t) return !1;
                        if ((this.splay(t), t.left))
                            if (t.right) {
                                var i = this.minNode(t.right);
                                i.parent !== t &&
                                    (this.replace(i, i.right),
                                    (i.right = t.right),
                                    (i.right.parent = i)),
                                    this.replace(t, i),
                                    (i.left = t.left),
                                    (i.left.parent = i);
                            } else this.replace(t, t.left);
                        else this.replace(t, t.right);
                        return this._size--, !0;
                    }
                    removeNode(e) {
                        if (!e) return !1;
                        if ((this.splay(e), e.left))
                            if (e.right) {
                                var t = this.minNode(e.right);
                                t.parent !== e &&
                                    (this.replace(t, t.right),
                                    (t.right = e.right),
                                    (t.right.parent = t)),
                                    this.replace(e, t),
                                    (t.left = e.left),
                                    (t.left.parent = t);
                            } else this.replace(e, e.left);
                        else this.replace(e, e.right);
                        return this._size--, !0;
                    }
                    erase(e) {
                        var t = this.find(e);
                        if (t) {
                            this.splay(t);
                            var i = t.left,
                                n = t.right,
                                r = null;
                            i &&
                                ((i.parent = null),
                                (r = this.maxNode(i)),
                                this.splay(r),
                                (this._root = r)),
                                n &&
                                    (i ? (r.right = n) : (this._root = n),
                                    (n.parent = r)),
                                this._size--;
                        }
                    }
                    pop() {
                        var e = this._root,
                            t = null;
                        if (e) {
                            for (; e.left; ) e = e.left;
                            (t = { key: e.key, data: e.data }),
                                this.remove(e.key);
                        }
                        return t;
                    }
                    next(e) {
                        var t = e;
                        if (t)
                            if (t.right)
                                for (t = t.right; t && t.left; ) t = t.left;
                            else
                                for (t = e.parent; t && t.right === e; )
                                    (e = t), (t = t.parent);
                        return t;
                    }
                    prev(e) {
                        var t = e;
                        if (t)
                            if (t.left)
                                for (t = t.left; t && t.right; ) t = t.right;
                            else
                                for (t = e.parent; t && t.left === e; )
                                    (e = t), (t = t.parent);
                        return t;
                    }
                    forEach(e) {
                        for (var t = this._root, i = [], n = !1, r = 0; !n; )
                            t
                                ? (i.push(t), (t = t.left))
                                : i.length > 0
                                ? (e((t = i.pop()), r++), (t = t.right))
                                : (n = !0);
                        return this;
                    }
                    range(e, t, i, n) {
                        const r = [],
                            s = this._compare;
                        let a,
                            o = this._root;
                        for (; 0 !== r.length || o; )
                            if (o) r.push(o), (o = o.left);
                            else {
                                if (((o = r.pop()), (a = s(o.key, t)), a > 0))
                                    break;
                                if (s(o.key, e) >= 0 && i.call(n, o))
                                    return this;
                                o = o.right;
                            }
                        return this;
                    }
                    keys() {
                        for (var e = this._root, t = [], i = [], n = !1; !n; )
                            e
                                ? (t.push(e), (e = e.left))
                                : t.length > 0
                                ? ((e = t.pop()), i.push(e.key), (e = e.right))
                                : (n = !0);
                        return i;
                    }
                    values() {
                        for (var e = this._root, t = [], i = [], n = !1; !n; )
                            e
                                ? (t.push(e), (e = e.left))
                                : t.length > 0
                                ? ((e = t.pop()), i.push(e.data), (e = e.right))
                                : (n = !0);
                        return i;
                    }
                    at(e) {
                        for (var t = this._root, i = [], n = !1, r = 0; !n; )
                            if (t) i.push(t), (t = t.left);
                            else if (i.length > 0) {
                                if (((t = i.pop()), r === e)) return t;
                                r++, (t = t.right);
                            } else n = !0;
                        return null;
                    }
                    load(e = [], t = [], i = !1) {
                        if (0 !== this._size)
                            throw new Error("bulk-load: tree is not empty");
                        const n = e.length;
                        return (
                            i && Iv(e, t, 0, n - 1, this._compare),
                            (this._root = Dv(null, e, t, 0, n)),
                            (this._size = n),
                            this
                        );
                    }
                    min() {
                        var e = this.minNode(this._root);
                        return e ? e.key : null;
                    }
                    max() {
                        var e = this.maxNode(this._root);
                        return e ? e.key : null;
                    }
                    isEmpty() {
                        return null === this._root;
                    }
                    get size() {
                        return this._size;
                    }
                    static createTree(e, t, i, n, r) {
                        return new Nv(i, r).load(e, t, n);
                    }
                }
                function Dv(e, t, i, n, r) {
                    const s = r - n;
                    if (s > 0) {
                        const a = n + Math.floor(s / 2),
                            o = { key: t[a], data: i[a], parent: e };
                        return (
                            (o.left = Dv(o, t, i, n, a)),
                            (o.right = Dv(o, t, i, a + 1, r)),
                            o
                        );
                    }
                    return null;
                }
                function Iv(e, t, i, n, r) {
                    if (i >= n) return;
                    const s = e[(i + n) >> 1];
                    let a = i - 1,
                        o = n + 1;
                    for (;;) {
                        do {
                            a++;
                        } while (r(e[a], s) < 0);
                        do {
                            o--;
                        } while (r(e[o], s) > 0);
                        if (a >= o) break;
                        let i = e[a];
                        (e[a] = e[o]),
                            (e[o] = i),
                            (i = t[a]),
                            (t[a] = t[o]),
                            (t[o] = i);
                    }
                    Iv(e, t, i, o, r), Iv(e, t, o + 1, n, r);
                }
                const Cv = 0,
                    Av = 1,
                    Ev = 2,
                    Lv = 3,
                    zv = 0,
                    jv = 1,
                    Ov = 2,
                    kv = 3;
                function Rv(e, t, i) {
                    null === t
                        ? ((e.inOut = !1), (e.otherInOut = !0))
                        : (e.isSubject === t.isSubject
                              ? ((e.inOut = !t.inOut),
                                (e.otherInOut = t.otherInOut))
                              : ((e.inOut = !t.otherInOut),
                                (e.otherInOut = t.isVertical()
                                    ? !t.inOut
                                    : t.inOut)),
                          t &&
                              (e.prevInResult =
                                  !Pv(t, i) || t.isVertical()
                                      ? t.prevInResult
                                      : t));
                    let n = Pv(e, i);
                    e.resultTransition = n
                        ? (function (e, t) {
                              let i,
                                  n = !e.inOut,
                                  r = !e.otherInOut;
                              switch (t) {
                                  case zv:
                                      i = n && r;
                                      break;
                                  case jv:
                                      i = n || r;
                                      break;
                                  case kv:
                                      i = n ^ r;
                                      break;
                                  case Ov:
                                      i = e.isSubject ? n && !r : r && !n;
                              }
                              return i ? 1 : -1;
                          })(e, i)
                        : 0;
                }
                function Pv(e, t) {
                    switch (e.type) {
                        case Cv:
                            switch (t) {
                                case zv:
                                    return !e.otherInOut;
                                case jv:
                                    return e.otherInOut;
                                case Ov:
                                    return (
                                        (e.isSubject && e.otherInOut) ||
                                        (!e.isSubject && !e.otherInOut)
                                    );
                                case kv:
                                    return !0;
                            }
                            break;
                        case Ev:
                            return t === zv || t === jv;
                        case Lv:
                            return t === Ov;
                        case Av:
                            return !1;
                    }
                    return !1;
                }
                class Uv {
                    constructor(e, t, i, n, r) {
                        (this.left = t),
                            (this.point = e),
                            (this.otherEvent = i),
                            (this.isSubject = n),
                            (this.type = r || Cv),
                            (this.inOut = !1),
                            (this.otherInOut = !1),
                            (this.prevInResult = null),
                            (this.resultTransition = 0),
                            (this.otherPos = -1),
                            (this.outputContourId = -1),
                            (this.isExteriorRing = !0);
                    }
                    isBelow(e) {
                        const t = this.point,
                            i = this.otherEvent.point;
                        return this.left
                            ? (t[0] - e[0]) * (i[1] - e[1]) -
                                  (i[0] - e[0]) * (t[1] - e[1]) >
                                  0
                            : (i[0] - e[0]) * (t[1] - e[1]) -
                                  (t[0] - e[0]) * (i[1] - e[1]) >
                                  0;
                    }
                    isAbove(e) {
                        return !this.isBelow(e);
                    }
                    isVertical() {
                        return this.point[0] === this.otherEvent.point[0];
                    }
                    get inResult() {
                        return 0 !== this.resultTransition;
                    }
                    clone() {
                        const e = new Uv(
                            this.point,
                            this.left,
                            this.otherEvent,
                            this.isSubject,
                            this.type
                        );
                        return (
                            (e.contourId = this.contourId),
                            (e.resultTransition = this.resultTransition),
                            (e.prevInResult = this.prevInResult),
                            (e.isExteriorRing = this.isExteriorRing),
                            (e.inOut = this.inOut),
                            (e.otherInOut = this.otherInOut),
                            e
                        );
                    }
                }
                function $v(e, t) {
                    return e[0] === t[0] && e[1] === t[1];
                }
                const Bv = 11102230246251565e-32,
                    Fv = 134217729,
                    Hv = (3 + 8 * Bv) * Bv;
                function Gv(e, t, i, n, r) {
                    let s,
                        a,
                        o,
                        c,
                        l = t[0],
                        h = n[0],
                        u = 0,
                        d = 0;
                    h > l == h > -l
                        ? ((s = l), (l = t[++u]))
                        : ((s = h), (h = n[++d]));
                    let p = 0;
                    if (u < e && d < i)
                        for (
                            h > l == h > -l
                                ? ((a = l + s), (o = s - (a - l)), (l = t[++u]))
                                : ((a = h + s),
                                  (o = s - (a - h)),
                                  (h = n[++d])),
                                s = a,
                                0 !== o && (r[p++] = o);
                            u < e && d < i;

                        )
                            h > l == h > -l
                                ? ((a = s + l),
                                  (c = a - s),
                                  (o = s - (a - c) + (l - c)),
                                  (l = t[++u]))
                                : ((a = s + h),
                                  (c = a - s),
                                  (o = s - (a - c) + (h - c)),
                                  (h = n[++d])),
                                (s = a),
                                0 !== o && (r[p++] = o);
                    for (; u < e; )
                        (a = s + l),
                            (c = a - s),
                            (o = s - (a - c) + (l - c)),
                            (l = t[++u]),
                            (s = a),
                            0 !== o && (r[p++] = o);
                    for (; d < i; )
                        (a = s + h),
                            (c = a - s),
                            (o = s - (a - c) + (h - c)),
                            (h = n[++d]),
                            (s = a),
                            0 !== o && (r[p++] = o);
                    return (0 === s && 0 !== p) || (r[p++] = s), p;
                }
                function Vv(e) {
                    return new Float64Array(e);
                }
                const Yv = 33306690738754716e-32,
                    qv = 22204460492503146e-32,
                    Wv = 11093356479670487e-47,
                    Qv = Vv(4),
                    Zv = Vv(8),
                    Xv = Vv(12),
                    Jv = Vv(16),
                    Kv = Vv(4);
                function ey(e, t, i) {
                    const n = (function (e, t, i, n, r, s) {
                        const a = (t - s) * (i - r),
                            o = (e - r) * (n - s),
                            c = a - o;
                        if (0 === a || 0 === o || a > 0 != o > 0) return c;
                        const l = Math.abs(a + o);
                        return Math.abs(c) >= Yv * l
                            ? c
                            : -(function (e, t, i, n, r, s, a) {
                                  let o,
                                      c,
                                      l,
                                      h,
                                      u,
                                      d,
                                      p,
                                      g,
                                      m,
                                      f,
                                      _,
                                      M,
                                      v,
                                      y,
                                      x,
                                      b,
                                      w,
                                      T;
                                  const S = e - r,
                                      N = i - r,
                                      D = t - s,
                                      I = n - s;
                                  (y = S * I),
                                      (d = Fv * S),
                                      (p = d - (d - S)),
                                      (g = S - p),
                                      (d = Fv * I),
                                      (m = d - (d - I)),
                                      (f = I - m),
                                      (x = g * f - (y - p * m - g * m - p * f)),
                                      (b = D * N),
                                      (d = Fv * D),
                                      (p = d - (d - D)),
                                      (g = D - p),
                                      (d = Fv * N),
                                      (m = d - (d - N)),
                                      (f = N - m),
                                      (w = g * f - (b - p * m - g * m - p * f)),
                                      (_ = x - w),
                                      (u = x - _),
                                      (Qv[0] = x - (_ + u) + (u - w)),
                                      (M = y + _),
                                      (u = M - y),
                                      (v = y - (M - u) + (_ - u)),
                                      (_ = v - b),
                                      (u = v - _),
                                      (Qv[1] = v - (_ + u) + (u - b)),
                                      (T = M + _),
                                      (u = T - M),
                                      (Qv[2] = M - (T - u) + (_ - u)),
                                      (Qv[3] = T);
                                  let C = (function (e, t) {
                                          let i = t[0];
                                          for (let e = 1; e < 4; e++) i += t[e];
                                          return i;
                                      })(0, Qv),
                                      A = qv * a;
                                  if (C >= A || -C >= A) return C;
                                  if (
                                      ((u = e - S),
                                      (o = e - (S + u) + (u - r)),
                                      (u = i - N),
                                      (l = i - (N + u) + (u - r)),
                                      (u = t - D),
                                      (c = t - (D + u) + (u - s)),
                                      (u = n - I),
                                      (h = n - (I + u) + (u - s)),
                                      0 === o && 0 === c && 0 === l && 0 === h)
                                  )
                                      return C;
                                  if (
                                      ((A = Wv * a + Hv * Math.abs(C)),
                                      (C += S * h + I * o - (D * l + N * c)),
                                      C >= A || -C >= A)
                                  )
                                      return C;
                                  (y = o * I),
                                      (d = Fv * o),
                                      (p = d - (d - o)),
                                      (g = o - p),
                                      (d = Fv * I),
                                      (m = d - (d - I)),
                                      (f = I - m),
                                      (x = g * f - (y - p * m - g * m - p * f)),
                                      (b = c * N),
                                      (d = Fv * c),
                                      (p = d - (d - c)),
                                      (g = c - p),
                                      (d = Fv * N),
                                      (m = d - (d - N)),
                                      (f = N - m),
                                      (w = g * f - (b - p * m - g * m - p * f)),
                                      (_ = x - w),
                                      (u = x - _),
                                      (Kv[0] = x - (_ + u) + (u - w)),
                                      (M = y + _),
                                      (u = M - y),
                                      (v = y - (M - u) + (_ - u)),
                                      (_ = v - b),
                                      (u = v - _),
                                      (Kv[1] = v - (_ + u) + (u - b)),
                                      (T = M + _),
                                      (u = T - M),
                                      (Kv[2] = M - (T - u) + (_ - u)),
                                      (Kv[3] = T);
                                  const E = Gv(4, Qv, 4, Kv, Zv);
                                  (y = S * h),
                                      (d = Fv * S),
                                      (p = d - (d - S)),
                                      (g = S - p),
                                      (d = Fv * h),
                                      (m = d - (d - h)),
                                      (f = h - m),
                                      (x = g * f - (y - p * m - g * m - p * f)),
                                      (b = D * l),
                                      (d = Fv * D),
                                      (p = d - (d - D)),
                                      (g = D - p),
                                      (d = Fv * l),
                                      (m = d - (d - l)),
                                      (f = l - m),
                                      (w = g * f - (b - p * m - g * m - p * f)),
                                      (_ = x - w),
                                      (u = x - _),
                                      (Kv[0] = x - (_ + u) + (u - w)),
                                      (M = y + _),
                                      (u = M - y),
                                      (v = y - (M - u) + (_ - u)),
                                      (_ = v - b),
                                      (u = v - _),
                                      (Kv[1] = v - (_ + u) + (u - b)),
                                      (T = M + _),
                                      (u = T - M),
                                      (Kv[2] = M - (T - u) + (_ - u)),
                                      (Kv[3] = T);
                                  const L = Gv(E, Zv, 4, Kv, Xv);
                                  (y = o * h),
                                      (d = Fv * o),
                                      (p = d - (d - o)),
                                      (g = o - p),
                                      (d = Fv * h),
                                      (m = d - (d - h)),
                                      (f = h - m),
                                      (x = g * f - (y - p * m - g * m - p * f)),
                                      (b = c * l),
                                      (d = Fv * c),
                                      (p = d - (d - c)),
                                      (g = c - p),
                                      (d = Fv * l),
                                      (m = d - (d - l)),
                                      (f = l - m),
                                      (w = g * f - (b - p * m - g * m - p * f)),
                                      (_ = x - w),
                                      (u = x - _),
                                      (Kv[0] = x - (_ + u) + (u - w)),
                                      (M = y + _),
                                      (u = M - y),
                                      (v = y - (M - u) + (_ - u)),
                                      (_ = v - b),
                                      (u = v - _),
                                      (Kv[1] = v - (_ + u) + (u - b)),
                                      (T = M + _),
                                      (u = T - M),
                                      (Kv[2] = M - (T - u) + (_ - u)),
                                      (Kv[3] = T);
                                  const z = Gv(L, Xv, 4, Kv, Jv);
                                  return Jv[z - 1];
                              })(e, t, i, n, r, s, l);
                    })(e[0], e[1], t[0], t[1], i[0], i[1]);
                    return n > 0 ? -1 : n < 0 ? 1 : 0;
                }
                function ty(e, t) {
                    const i = e.point,
                        n = t.point;
                    return i[0] > n[0]
                        ? 1
                        : i[0] < n[0]
                        ? -1
                        : i[1] !== n[1]
                        ? i[1] > n[1]
                            ? 1
                            : -1
                        : (function (e, t, i, n) {
                              return e.left !== t.left
                                  ? e.left
                                      ? 1
                                      : -1
                                  : 0 !==
                                    ey(
                                        i,
                                        e.otherEvent.point,
                                        t.otherEvent.point
                                    )
                                  ? e.isBelow(t.otherEvent.point)
                                      ? -1
                                      : 1
                                  : !e.isSubject && t.isSubject
                                  ? 1
                                  : -1;
                          })(e, t, i);
                }
                function iy(e, t, i) {
                    const n = new Uv(t, !1, e, e.isSubject),
                        r = new Uv(t, !0, e.otherEvent, e.isSubject);
                    return (
                        $v(e.point, e.otherEvent.point) &&
                            console.warn(
                                "what is that, a collapsed segment?",
                                e
                            ),
                        (n.contourId = r.contourId = e.contourId),
                        ty(r, e.otherEvent) > 0 &&
                            ((e.otherEvent.left = !0), (r.left = !1)),
                        (e.otherEvent.otherEvent = r),
                        (e.otherEvent = n),
                        i.push(r),
                        i.push(n),
                        i
                    );
                }
                function ny(e, t) {
                    return e[0] * t[1] - e[1] * t[0];
                }
                function ry(e, t) {
                    return e[0] * t[0] + e[1] * t[1];
                }
                function sy(e, t, i) {
                    const n = (function (e, t, i, n, r) {
                            const s = [t[0] - e[0], t[1] - e[1]],
                                a = [n[0] - i[0], n[1] - i[1]];
                            function o(e, t, i) {
                                return [e[0] + t * i[0], e[1] + t * i[1]];
                            }
                            const c = [i[0] - e[0], i[1] - e[1]];
                            let l = ny(s, a),
                                h = l * l;
                            const u = ry(s, s);
                            if (h > 0) {
                                const t = ny(c, a) / l;
                                if (t < 0 || t > 1) return null;
                                const n = ny(c, s) / l;
                                return n < 0 || n > 1
                                    ? null
                                    : 0 === t || 1 === t
                                    ? [o(e, t, s)]
                                    : 0 === n || 1 === n
                                    ? [o(i, n, a)]
                                    : [o(e, t, s)];
                            }
                            if (((l = ny(c, s)), (h = l * l), h > 0))
                                return null;
                            const d = ry(s, c) / u,
                                p = d + ry(s, a) / u,
                                g = Math.min(d, p),
                                m = Math.max(d, p);
                            return g <= 1 && m >= 0
                                ? 1 === g
                                    ? [o(e, g > 0 ? g : 0, s)]
                                    : 0 === m
                                    ? [o(e, m < 1 ? m : 1, s)]
                                    : [
                                          o(e, g > 0 ? g : 0, s),
                                          o(e, m < 1 ? m : 1, s),
                                      ]
                                : null;
                        })(
                            e.point,
                            e.otherEvent.point,
                            t.point,
                            t.otherEvent.point
                        ),
                        r = n ? n.length : 0;
                    if (0 === r) return 0;
                    if (
                        1 === r &&
                        ($v(e.point, t.point) ||
                            $v(e.otherEvent.point, t.otherEvent.point))
                    )
                        return 0;
                    if (2 === r && e.isSubject === t.isSubject) return 0;
                    if (1 === r)
                        return (
                            $v(e.point, n[0]) ||
                                $v(e.otherEvent.point, n[0]) ||
                                iy(e, n[0], i),
                            $v(t.point, n[0]) ||
                                $v(t.otherEvent.point, n[0]) ||
                                iy(t, n[0], i),
                            1
                        );
                    const s = [];
                    let a = !1,
                        o = !1;
                    return (
                        $v(e.point, t.point)
                            ? (a = !0)
                            : 1 === ty(e, t)
                            ? s.push(t, e)
                            : s.push(e, t),
                        $v(e.otherEvent.point, t.otherEvent.point)
                            ? (o = !0)
                            : 1 === ty(e.otherEvent, t.otherEvent)
                            ? s.push(t.otherEvent, e.otherEvent)
                            : s.push(e.otherEvent, t.otherEvent),
                        (a && o) || a
                            ? ((t.type = Av),
                              (e.type = t.inOut === e.inOut ? Ev : Lv),
                              a && !o && iy(s[1].otherEvent, s[0].point, i),
                              2)
                            : o
                            ? (iy(s[0], s[1].point, i), 3)
                            : s[0] !== s[3].otherEvent
                            ? (iy(s[0], s[1].point, i),
                              iy(s[1], s[2].point, i),
                              3)
                            : (iy(s[0], s[1].point, i),
                              iy(s[3].otherEvent, s[2].point, i),
                              3)
                    );
                }
                function ay(e, t) {
                    if (e === t) return 0;
                    if (
                        0 !== ey(e.point, e.otherEvent.point, t.point) ||
                        0 !==
                            ey(e.point, e.otherEvent.point, t.otherEvent.point)
                    )
                        return $v(e.point, t.point)
                            ? e.isBelow(t.otherEvent.point)
                                ? -1
                                : 1
                            : e.point[0] === t.point[0]
                            ? e.point[1] < t.point[1]
                                ? -1
                                : 1
                            : 1 === ty(e, t)
                            ? t.isAbove(e.point)
                                ? -1
                                : 1
                            : e.isBelow(t.point)
                            ? -1
                            : 1;
                    if (e.isSubject !== t.isSubject)
                        return e.isSubject ? -1 : 1;
                    {
                        let i = e.point,
                            n = t.point;
                        if (i[0] === n[0] && i[1] === n[1])
                            return (
                                (i = e.otherEvent.point),
                                (n = t.otherEvent.point),
                                i[0] === n[0] && i[1] === n[1]
                                    ? 0
                                    : e.contourId > t.contourId
                                    ? 1
                                    : -1
                            );
                    }
                    return 1 === ty(e, t) ? 1 : -1;
                }
                class oy {
                    constructor() {
                        (this.points = []),
                            (this.holeIds = []),
                            (this.holeOf = null),
                            (this.depth = null);
                    }
                    isExterior() {
                        return null == this.holeOf;
                    }
                }
                function cy(e, t, i, n) {
                    let r,
                        s = e + 1,
                        a = t[e].point;
                    const o = t.length;
                    for (
                        s < o && (r = t[s].point);
                        s < o && r[0] === a[0] && r[1] === a[1];

                    ) {
                        if (!i[s]) return s;
                        s++, (r = t[s].point);
                    }
                    for (s = e - 1; i[s] && s > n; ) s--;
                    return s;
                }
                function ly(e, t, i) {
                    const n = new oy();
                    if (null != e.prevInResult) {
                        const r = e.prevInResult,
                            s = r.outputContourId;
                        if (r.resultTransition > 0) {
                            const e = t[s];
                            if (null != e.holeOf) {
                                const r = e.holeOf;
                                t[r].holeIds.push(i),
                                    (n.holeOf = r),
                                    (n.depth = t[s].depth);
                            } else
                                t[s].holeIds.push(i),
                                    (n.holeOf = s),
                                    (n.depth = t[s].depth + 1);
                        } else (n.holeOf = null), (n.depth = t[s].depth);
                    } else (n.holeOf = null), (n.depth = 0);
                    return n;
                }
                var hy = { exports: {} };
                function uy(e, t) {
                    if (!(this instanceof uy)) return new uy(e, t);
                    if (
                        ((this.data = e || []),
                        (this.length = this.data.length),
                        (this.compare = t || dy),
                        this.length > 0)
                    )
                        for (var i = (this.length >> 1) - 1; i >= 0; i--)
                            this._down(i);
                }
                function dy(e, t) {
                    return e < t ? -1 : e > t ? 1 : 0;
                }
                (hy.exports = uy),
                    (hy.exports.default = uy),
                    (uy.prototype = {
                        push: function (e) {
                            this.data.push(e),
                                this.length++,
                                this._up(this.length - 1);
                        },
                        pop: function () {
                            if (0 !== this.length) {
                                var e = this.data[0];
                                return (
                                    this.length--,
                                    this.length > 0 &&
                                        ((this.data[0] =
                                            this.data[this.length]),
                                        this._down(0)),
                                    this.data.pop(),
                                    e
                                );
                            }
                        },
                        peek: function () {
                            return this.data[0];
                        },
                        _up: function (e) {
                            for (
                                var t = this.data, i = this.compare, n = t[e];
                                e > 0;

                            ) {
                                var r = (e - 1) >> 1,
                                    s = t[r];
                                if (i(n, s) >= 0) break;
                                (t[e] = s), (e = r);
                            }
                            t[e] = n;
                        },
                        _down: function (e) {
                            for (
                                var t = this.data,
                                    i = this.compare,
                                    n = this.length >> 1,
                                    r = t[e];
                                e < n;

                            ) {
                                var s = 1 + (e << 1),
                                    a = s + 1,
                                    o = t[s];
                                if (
                                    (a < this.length &&
                                        i(t[a], o) < 0 &&
                                        ((s = a), (o = t[a])),
                                    i(o, r) >= 0)
                                )
                                    break;
                                (t[e] = o), (e = s);
                            }
                            t[e] = r;
                        },
                    });
                var py = hy.exports;
                const gy = Math.max,
                    my = Math.min;
                let fy = 0;
                function _y(e, t, i, n, r, s) {
                    let a, o, c, l, h, u;
                    for (a = 0, o = e.length - 1; a < o; a++) {
                        if (
                            ((c = e[a]),
                            (l = e[a + 1]),
                            (h = new Uv(c, !1, void 0, t)),
                            (u = new Uv(l, !1, h, t)),
                            (h.otherEvent = u),
                            c[0] === l[0] && c[1] === l[1])
                        )
                            continue;
                        (h.contourId = u.contourId = i),
                            s ||
                                ((h.isExteriorRing = !1),
                                (u.isExteriorRing = !1)),
                            ty(h, u) > 0 ? (u.left = !0) : (h.left = !0);
                        const o = c[0],
                            d = c[1];
                        (r[0] = my(r[0], o)),
                            (r[1] = my(r[1], d)),
                            (r[2] = gy(r[2], o)),
                            (r[3] = gy(r[3], d)),
                            n.push(h),
                            n.push(u);
                    }
                }
                const My = [];
                function vy(e, t, i) {
                    "number" == typeof e[0][0][0] && (e = [e]),
                        "number" == typeof t[0][0][0] && (t = [t]);
                    let n = (function (e, t, i) {
                        let n = null;
                        return (
                            e.length * t.length == 0 &&
                                (i === zv
                                    ? (n = My)
                                    : i === Ov
                                    ? (n = e)
                                    : (i !== jv && i !== kv) ||
                                      (n = 0 === e.length ? t : e)),
                            n
                        );
                    })(e, t, i);
                    if (n) return n === My ? null : n;
                    const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        s = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        a = (function (e, t, i, n, r) {
                            const s = new py(null, ty);
                            let a, o, c, l, h, u;
                            for (c = 0, l = e.length; c < l; c++)
                                for (a = e[c], h = 0, u = a.length; h < u; h++)
                                    (o = 0 === h),
                                        o && fy++,
                                        _y(a[h], !0, fy, s, i, o);
                            for (c = 0, l = t.length; c < l; c++)
                                for (a = t[c], h = 0, u = a.length; h < u; h++)
                                    (o = 0 === h),
                                        r === Ov && (o = !1),
                                        o && fy++,
                                        _y(a[h], !1, fy, s, n, o);
                            return s;
                        })(e, t, r, s, i);
                    if (
                        ((n = (function (e, t, i, n, r) {
                            let s = null;
                            return (
                                (i[0] > n[2] ||
                                    n[0] > i[2] ||
                                    i[1] > n[3] ||
                                    n[1] > i[3]) &&
                                    (r === zv
                                        ? (s = My)
                                        : r === Ov
                                        ? (s = e)
                                        : (r !== jv && r !== kv) ||
                                          (s = e.concat(t))),
                                s
                            );
                        })(e, t, r, s, i)),
                        n)
                    )
                        return n === My ? null : n;
                    const o = (function (e, t, i, n, r, s) {
                            const a = new Nv(ay),
                                o = [],
                                c = Math.min(n[2], r[2]);
                            let l, h, u;
                            for (; 0 !== e.length; ) {
                                let t = e.pop();
                                if (
                                    (o.push(t),
                                    (s === zv && t.point[0] > c) ||
                                        (s === Ov && t.point[0] > n[2]))
                                )
                                    break;
                                if (t.left) {
                                    (h = l = a.insert(t)),
                                        (u = a.minNode()),
                                        (l = l !== u ? a.prev(l) : null),
                                        (h = a.next(h));
                                    const i = l ? l.key : null;
                                    let n;
                                    if (
                                        (Rv(t, i, s),
                                        h &&
                                            2 === sy(t, h.key, e) &&
                                            (Rv(t, i, s), Rv(t, h.key, s)),
                                        l && 2 === sy(l.key, t, e))
                                    ) {
                                        let e = l;
                                        (e = e !== u ? a.prev(e) : null),
                                            (n = e ? e.key : null),
                                            Rv(i, n, s),
                                            Rv(t, i, s);
                                    }
                                } else
                                    (t = t.otherEvent),
                                        (h = l = a.find(t)),
                                        l &&
                                            h &&
                                            ((l = l !== u ? a.prev(l) : null),
                                            (h = a.next(h)),
                                            a.remove(t),
                                            h && l && sy(l.key, h.key, e));
                            }
                            return o;
                        })(a, 0, 0, r, s, i),
                        c = (function (e) {
                            let t, i;
                            const n = (function (e) {
                                    let t, i, n, r;
                                    const s = [];
                                    for (i = 0, n = e.length; i < n; i++)
                                        (t = e[i]),
                                            ((t.left && t.inResult) ||
                                                (!t.left &&
                                                    t.otherEvent.inResult)) &&
                                                s.push(t);
                                    let a = !1;
                                    for (; !a; )
                                        for (
                                            a = !0, i = 0, n = s.length;
                                            i < n;
                                            i++
                                        )
                                            i + 1 < n &&
                                                1 === ty(s[i], s[i + 1]) &&
                                                ((r = s[i]),
                                                (s[i] = s[i + 1]),
                                                (s[i + 1] = r),
                                                (a = !1));
                                    for (i = 0, n = s.length; i < n; i++)
                                        (t = s[i]), (t.otherPos = i);
                                    for (i = 0, n = s.length; i < n; i++)
                                        (t = s[i]),
                                            t.left ||
                                                ((r = t.otherPos),
                                                (t.otherPos =
                                                    t.otherEvent.otherPos),
                                                (t.otherEvent.otherPos = r));
                                    return s;
                                })(e),
                                r = {},
                                s = [];
                            for (t = 0, i = n.length; t < i; t++) {
                                if (r[t]) continue;
                                const e = s.length,
                                    i = ly(n[t], s, e),
                                    a = (t) => {
                                        (r[t] = !0), (n[t].outputContourId = e);
                                    };
                                let o = t,
                                    c = t;
                                const l = n[t].point;
                                for (
                                    i.points.push(l);
                                    a(o),
                                        (o = n[o].otherPos),
                                        a(o),
                                        i.points.push(n[o].point),
                                        (o = cy(o, n, r, c)),
                                        o != c;

                                );
                                s.push(i);
                            }
                            return s;
                        })(o),
                        l = [];
                    for (let e = 0; e < c.length; e++) {
                        let t = c[e];
                        if (t.isExterior()) {
                            let e = [t.points];
                            for (let i = 0; i < t.holeIds.length; i++) {
                                let n = t.holeIds[i];
                                e.push(c[n].points);
                            }
                            l.push(e);
                        }
                    }
                    return l;
                }
                class yy extends UM {
                    constructor() {
                        super(), (this._subsampleThreshold = 0.005);
                    }
                    _getPoleOfInaccessibility2d(e) {
                        return Tv([e], 0.03);
                    }
                    _project(e, t) {
                        const i = this._createCamera(
                            t.upVector().toArray(),
                            t.unprojectSfM([0, 0], 0),
                            t.unprojectSfM([0, 0], 10)
                        );
                        return this._deunproject(e, t, i);
                    }
                    _subsample(e, t = this._subsampleThreshold) {
                        const i = [],
                            n = e.length;
                        for (let r = 0; r < n; r++) {
                            const s = e[r],
                                a = e[(r + 1) % n];
                            i.push(s);
                            const o = Math.sqrt(
                                    Math.pow(a[0] - s[0], 2) +
                                        Math.pow(a[1] - s[1], 2)
                                ),
                                c = Math.floor(o / t),
                                l = 1 / (c + 1);
                            for (let e = 1; e <= c; e++) {
                                const t = e * l,
                                    n = [
                                        (1 - t) * s[0] + t * a[0],
                                        (1 - t) * s[1] + t * a[1],
                                    ];
                                i.push(n);
                            }
                        }
                        return i;
                    }
                    _triangulate(e, t, i, n) {
                        let r = [e.slice(0, -1)];
                        for (let e of null != i ? i : [])
                            r.push(e.slice(0, -1));
                        let s = t.slice(0, -1);
                        for (let e of null != n ? n : [])
                            s = s.concat(e.slice(0, -1));
                        let a = fv.flatten(r),
                            o = fv(a.vertices, a.holes, a.dimensions),
                            c = [];
                        for (let e = 0; e < o.length; ++e) {
                            let t = s[o[e]];
                            c.push(t[0]), c.push(t[1]), c.push(t[2]);
                        }
                        return c;
                    }
                    _triangulateSpherical(e, t, i) {
                        const n = [],
                            r = 1e-9;
                        for (let s = 0; s < 3; s++)
                            for (let a = 0; a < 3; a++) {
                                const o = s / 3 + (0 === s ? -1e-9 : r),
                                    c = a / 3 + (0 === a ? -1e-9 : r),
                                    l = (s + 1) / 3 + r,
                                    h = (a + 1) / 3 + r,
                                    u = [
                                        [o, c],
                                        [o, h],
                                        [l, h],
                                        [l, c],
                                        [o, c],
                                    ],
                                    d = [(2 * s + 1) / 6, (2 * a + 1) / 6];
                                n.push(
                                    ...this._triangulateSubarea(e, t, u, d, i)
                                );
                            }
                        return n;
                    }
                    _unproject(e, t, i = 200) {
                        return e.map((e) => t.unprojectBasic(e, i));
                    }
                    _createCamera(e, t, i) {
                        const n = new po();
                        return (
                            n.up.copy(new rs().fromArray(e)),
                            n.position.copy(new rs().fromArray(t)),
                            n.lookAt(new rs().fromArray(i)),
                            n.updateMatrix(),
                            n.updateMatrixWorld(!0),
                            n
                        );
                    }
                    _deunproject(e, t, i) {
                        return e.map((e) => {
                            const n = t.unprojectBasic(e, 1e4),
                                r = new rs(n[0], n[1], n[2]).applyMatrix4(
                                    i.matrixWorldInverse
                                );
                            return [r.x / r.z, r.y / r.z];
                        });
                    }
                    _triangulateSubarea(e, t, i, n, r) {
                        const s = vy([e, ...t], [i], zv);
                        if (!s) return [];
                        const a = [],
                            o = this._subsampleThreshold,
                            c = this._createCamera(
                                r.upVector().toArray(),
                                r.unprojectSfM([0, 0], 0),
                                r.unprojectBasic(n, 10)
                            );
                        for (const e of s) {
                            const t = this._subsample(e[0], o),
                                i = this._deunproject(t, r, c),
                                n = this._unproject(t, r),
                                s = [],
                                l = [];
                            for (let t = 1; t < e.length; t++) {
                                let i = this._subsample(e[t], o);
                                const n = this._deunproject(i, r, c),
                                    a = this._unproject(i, r);
                                s.push(n), l.push(a);
                            }
                            a.push(...this._triangulate(i, n, s, l));
                        }
                        return a;
                    }
                }
                class xy extends yy {
                    constructor(e) {
                        if ((super(), 4 !== e.length))
                            throw new $M(
                                "Rectangle needs to have four values."
                            );
                        if (e[1] > e[3])
                            throw new $M(
                                "Basic Y coordinates values can not be inverted."
                            );
                        for (let t of e)
                            if (t < 0 || t > 1)
                                throw new $M(
                                    "Basic coordinates must be on the interval [0, 1]."
                                );
                        (this._anchorIndex = void 0),
                            (this._rect = e.slice(0, 4)),
                            (this._inverted = this._rect[0] > this._rect[2]);
                    }
                    get anchorIndex() {
                        return this._anchorIndex;
                    }
                    get inverted() {
                        return this._inverted;
                    }
                    get rect() {
                        return this._rect;
                    }
                    initializeAnchorIndexing(e) {
                        if (void 0 !== this._anchorIndex)
                            throw new $M(
                                "Anchor indexing is already initialized."
                            );
                        if (e < 0 || e > 3)
                            throw new $M(`Invalid anchor index: ${e}.`);
                        this._anchorIndex = void 0 === e ? 0 : e;
                    }
                    terminateAnchorIndexing() {
                        this._anchorIndex = void 0;
                    }
                    setOppositeVertex2d(e, t) {
                        if (void 0 === this._anchorIndex)
                            throw new $M(
                                "Anchor indexing needs to be initialized."
                            );
                        const i = [
                                Math.max(0, Math.min(1, e[0])),
                                Math.max(0, Math.min(1, e[1])),
                            ],
                            n = this._rect.slice(),
                            r =
                                0 === this._anchorIndex
                                    ? [n[0], n[3]]
                                    : 1 === this._anchorIndex
                                    ? [n[0], n[1]]
                                    : 2 === this._anchorIndex
                                    ? [n[2], n[1]]
                                    : [n[2], n[3]];
                        if (jp(t.cameraType)) {
                            const e =
                                this._anchorIndex < 2
                                    ? i[0] - n[2]
                                    : i[0] - n[0];
                            (!this._inverted &&
                                this._anchorIndex < 2 &&
                                i[0] < 0.25 &&
                                n[2] > 0.75 &&
                                e < -0.5) ||
                            (!this._inverted &&
                                this._anchorIndex >= 2 &&
                                i[0] < 0.25 &&
                                n[2] > 0.75 &&
                                e < -0.5)
                                ? ((this._inverted = !0),
                                  (this._anchorIndex = r[1] > i[1] ? 0 : 1))
                                : this._inverted &&
                                  this._anchorIndex >= 2 &&
                                  i[0] < 0.25 &&
                                  n[0] > 0.75 &&
                                  e < -0.5
                                ? ((this._inverted = !1),
                                  (this._anchorIndex =
                                      r[0] > i[0]
                                          ? r[1] > i[1]
                                              ? 3
                                              : 2
                                          : r[1] > i[1]
                                          ? 0
                                          : 1))
                                : (!this._inverted &&
                                      this._anchorIndex >= 2 &&
                                      i[0] > 0.75 &&
                                      n[0] < 0.25 &&
                                      e > 0.5) ||
                                  (!this._inverted &&
                                      this._anchorIndex < 2 &&
                                      i[0] > 0.75 &&
                                      n[0] < 0.25 &&
                                      e > 0.5)
                                ? ((this._inverted = !0),
                                  (this._anchorIndex = r[1] > i[1] ? 3 : 2))
                                : this._inverted &&
                                  this._anchorIndex < 2 &&
                                  i[0] > 0.75 &&
                                  n[2] < 0.25 &&
                                  e > 0.5
                                ? ((this._inverted = !1),
                                  (this._anchorIndex =
                                      r[0] > i[0]
                                          ? r[1] > i[1]
                                              ? 3
                                              : 2
                                          : r[1] > i[1]
                                          ? 0
                                          : 1))
                                : this._inverted &&
                                  this._anchorIndex < 2 &&
                                  i[0] > n[0]
                                ? ((this._inverted = !1),
                                  (this._anchorIndex = r[1] > i[1] ? 0 : 1))
                                : this._inverted &&
                                  this._anchorIndex >= 2 &&
                                  i[0] < n[2]
                                ? ((this._inverted = !1),
                                  (this._anchorIndex = r[1] > i[1] ? 3 : 2))
                                : this._inverted
                                ? this._anchorIndex < 2
                                    ? (this._anchorIndex = r[1] > i[1] ? 0 : 1)
                                    : (this._anchorIndex = r[1] > i[1] ? 3 : 2)
                                : (this._anchorIndex =
                                      r[0] <= i[0] && r[1] > i[1]
                                          ? 0
                                          : r[0] <= i[0] && r[1] <= i[1]
                                          ? 1
                                          : r[0] > i[0] && r[1] <= i[1]
                                          ? 2
                                          : 3);
                            const t = [];
                            0 === this._anchorIndex
                                ? ((t[0] = r[0]),
                                  (t[1] = i[1]),
                                  (t[2] = i[0]),
                                  (t[3] = r[1]))
                                : 1 === this._anchorIndex
                                ? ((t[0] = r[0]),
                                  (t[1] = r[1]),
                                  (t[2] = i[0]),
                                  (t[3] = i[1]))
                                : 2 === this._anchorIndex
                                ? ((t[0] = i[0]),
                                  (t[1] = r[1]),
                                  (t[2] = r[0]),
                                  (t[3] = i[1]))
                                : ((t[0] = i[0]),
                                  (t[1] = i[1]),
                                  (t[2] = r[0]),
                                  (t[3] = r[1])),
                                ((!this._inverted && t[0] > t[2]) ||
                                    (this._inverted && t[0] < t[2])) &&
                                    ((t[0] = n[0]), (t[2] = n[2])),
                                t[1] > t[3] && ((t[1] = n[1]), (t[3] = n[3])),
                                (this._rect[0] = t[0]),
                                (this._rect[1] = t[1]),
                                (this._rect[2] = t[2]),
                                (this._rect[3] = t[3]);
                        } else {
                            this._anchorIndex =
                                r[0] <= i[0] && r[1] > i[1]
                                    ? 0
                                    : r[0] <= i[0] && r[1] <= i[1]
                                    ? 1
                                    : r[0] > i[0] && r[1] <= i[1]
                                    ? 2
                                    : 3;
                            const e = [];
                            0 === this._anchorIndex
                                ? ((e[0] = r[0]),
                                  (e[1] = i[1]),
                                  (e[2] = i[0]),
                                  (e[3] = r[1]))
                                : 1 === this._anchorIndex
                                ? ((e[0] = r[0]),
                                  (e[1] = r[1]),
                                  (e[2] = i[0]),
                                  (e[3] = i[1]))
                                : 2 === this._anchorIndex
                                ? ((e[0] = i[0]),
                                  (e[1] = r[1]),
                                  (e[2] = r[0]),
                                  (e[3] = i[1]))
                                : ((e[0] = i[0]),
                                  (e[1] = i[1]),
                                  (e[2] = r[0]),
                                  (e[3] = r[1])),
                                e[0] > e[2] && ((e[0] = n[0]), (e[2] = n[2])),
                                e[1] > e[3] && ((e[1] = n[1]), (e[3] = n[3])),
                                (this._rect[0] = e[0]),
                                (this._rect[1] = e[1]),
                                (this._rect[2] = e[2]),
                                (this._rect[3] = e[3]);
                        }
                        this._notifyChanged$.next(this);
                    }
                    setVertex2d(e, t, i) {
                        let n = this._rect.slice(),
                            r = [
                                Math.max(0, Math.min(1, t[0])),
                                Math.max(0, Math.min(1, t[1])),
                            ],
                            s = [];
                        if (
                            (0 === e
                                ? ((s[0] = r[0]),
                                  (s[1] = n[1]),
                                  (s[2] = n[2]),
                                  (s[3] = r[1]))
                                : 1 === e
                                ? ((s[0] = r[0]),
                                  (s[1] = r[1]),
                                  (s[2] = n[2]),
                                  (s[3] = n[3]))
                                : 2 === e
                                ? ((s[0] = n[0]),
                                  (s[1] = r[1]),
                                  (s[2] = r[0]),
                                  (s[3] = n[3]))
                                : 3 === e &&
                                  ((s[0] = n[0]),
                                  (s[1] = n[1]),
                                  (s[2] = r[0]),
                                  (s[3] = r[1])),
                            jp(i.cameraType))
                        ) {
                            let t =
                                    (e < 2 && r[0] > 0.75 && n[0] < 0.25) ||
                                    (e >= 2 &&
                                        this._inverted &&
                                        r[0] > 0.75 &&
                                        n[2] < 0.25),
                                i =
                                    (e < 2 &&
                                        this._inverted &&
                                        r[0] < 0.25 &&
                                        n[0] > 0.75) ||
                                    (e >= 2 && r[0] < 0.25 && n[2] > 0.75);
                            t || i
                                ? (this._inverted = !this._inverted)
                                : (s[0] - n[0] < -0.25 && (s[0] = n[0]),
                                  s[2] - n[2] > 0.25 && (s[2] = n[2])),
                                ((!this._inverted && s[0] > s[2]) ||
                                    (this._inverted && s[0] < s[2])) &&
                                    ((s[0] = n[0]), (s[2] = n[2]));
                        } else s[0] > s[2] && ((s[0] = n[0]), (s[2] = n[2]));
                        s[1] > s[3] && ((s[1] = n[1]), (s[3] = n[3])),
                            (this._rect[0] = s[0]),
                            (this._rect[1] = s[1]),
                            (this._rect[2] = s[2]),
                            (this._rect[3] = s[3]),
                            this._notifyChanged$.next(this);
                    }
                    setCentroid2d(e, t) {
                        let i = this._rect.slice(),
                            n = i[0],
                            r = this._inverted ? i[2] + 1 : i[2],
                            s = i[1],
                            a = i[3],
                            o = n + (r - n) / 2,
                            c = s + (a - s) / 2,
                            l = 0;
                        if (jp(t.cameraType))
                            l = this._inverted ? e[0] + 1 - o : e[0] - o;
                        else {
                            let t = -n,
                                i = 1 - r;
                            l = Math.max(t, Math.min(i, e[0] - o));
                        }
                        let h = -s,
                            u = 1 - a,
                            d = Math.max(h, Math.min(u, e[1] - c));
                        (this._rect[0] = i[0] + l),
                            (this._rect[1] = i[1] + d),
                            (this._rect[2] = i[2] + l),
                            (this._rect[3] = i[3] + d),
                            this._rect[0] < 0
                                ? ((this._rect[0] += 1),
                                  (this._inverted = !this._inverted))
                                : this._rect[0] > 1 &&
                                  ((this._rect[0] -= 1),
                                  (this._inverted = !this._inverted)),
                            this._rect[2] < 0
                                ? ((this._rect[2] += 1),
                                  (this._inverted = !this._inverted))
                                : this._rect[2] > 1 &&
                                  ((this._rect[2] -= 1),
                                  (this._inverted = !this._inverted)),
                            this._notifyChanged$.next(this);
                    }
                    getPoints3d(e) {
                        return this._getPoints2d().map((t) =>
                            e.unprojectBasic(t, 200)
                        );
                    }
                    getVertex2d(e) {
                        return this._rectToVertices2d(this._rect)[e];
                    }
                    getNonAdjustedVertex2d(e) {
                        return this._rectToNonAdjustedVertices2d(this._rect)[e];
                    }
                    getVertex3d(e, t) {
                        return t.unprojectBasic(
                            this._rectToVertices2d(this._rect)[e],
                            200
                        );
                    }
                    getVertices2d() {
                        return this._rectToVertices2d(this._rect);
                    }
                    getVertices3d(e) {
                        return this._rectToVertices2d(this._rect).map((t) =>
                            e.unprojectBasic(t, 200)
                        );
                    }
                    getCentroid2d() {
                        const e = this._rect;
                        return [
                            (e[0] + (this._inverted ? e[2] + 1 : e[2])) / 2,
                            (e[1] + e[3]) / 2,
                        ];
                    }
                    getCentroid3d(e) {
                        const t = this.getCentroid2d();
                        return e.unprojectBasic(t, 200);
                    }
                    getPoleOfInaccessibility2d() {
                        return this._getPoleOfInaccessibility2d(
                            this._rectToVertices2d(this._rect)
                        );
                    }
                    getPoleOfInaccessibility3d(e) {
                        let t = this._getPoleOfInaccessibility2d(
                            this._rectToVertices2d(this._rect)
                        );
                        return e.unprojectBasic(t, 200);
                    }
                    getTriangles3d(e) {
                        return jp(e.cameraType)
                            ? []
                            : this._triangulate(
                                  this._project(this._getPoints2d(), e),
                                  this.getPoints3d(e)
                              );
                    }
                    validate(e) {
                        let t = this._rect;
                        return !(
                            (!this._inverted && e[0] < t[0]) ||
                            e[0] - t[2] > 0.25 ||
                            e[1] < t[1]
                        );
                    }
                    _getPoints2d() {
                        let e = this._rectToVertices2d(this._rect),
                            t = e.length - 1,
                            i = [];
                        for (let n = 0; n < t; ++n) {
                            let t = e[n][0],
                                r = e[n][1],
                                s = (e[n + 1][0] - t) / 9,
                                a = (e[n + 1][1] - r) / 9;
                            for (let e = 0; e < 10; ++e) {
                                let n = [t + e * s, r + e * a];
                                i.push(n);
                            }
                        }
                        return i;
                    }
                    _rectToVertices2d(e) {
                        return [
                            [e[0], e[3]],
                            [e[0], e[1]],
                            [this._inverted ? e[2] + 1 : e[2], e[1]],
                            [this._inverted ? e[2] + 1 : e[2], e[3]],
                            [e[0], e[3]],
                        ];
                    }
                    _rectToNonAdjustedVertices2d(e) {
                        return [
                            [e[0], e[3]],
                            [e[0], e[1]],
                            [e[2], e[1]],
                            [e[2], e[3]],
                            [e[0], e[3]],
                        ];
                    }
                }
                class by extends FM {
                    constructor(e, t, i, n) {
                        super(e, i, n),
                            (this._options = {
                                color: null == t.color ? 16777215 : t.color,
                                indicateCompleter:
                                    null == t.indicateCompleter ||
                                    t.indicateCompleter,
                            }),
                            (this._rectGeometry = new xy(
                                this._geometry.getRect2d(i)
                            )),
                            this._createGlObjects();
                    }
                    create() {
                        this._geometry.points.length < 3 ||
                            (this._geometry.removePoint2d(
                                this._geometry.points.length - 1
                            ),
                            this._created$.next(this));
                    }
                    dispose() {
                        super.dispose(), this._disposeObjects();
                    }
                    getDOMObjects(e, t) {
                        const i = {
                                offsetHeight: t.height,
                                offsetWidth: t.width,
                            },
                            n = [],
                            r = this._geometry.getPoints2d(),
                            s = r.length;
                        for (let t = 0; t < s - 1; t++) {
                            const a = t,
                                [o, c] = r[t],
                                l = this._viewportCoords.basicToCanvasSafe(
                                    o,
                                    c,
                                    i,
                                    this._transform,
                                    e
                                );
                            if (!l) continue;
                            const h = (e) => {
                                    e.stopPropagation(),
                                        this._aborted$.next(this);
                                },
                                u = (e) => {
                                    e.stopPropagation(),
                                        this._geometry.removePoint2d(a);
                                },
                                d = this._canvasToTransform(l),
                                p = {
                                    onclick: 0 === t && s < 3 ? h : u,
                                    style: { transform: d },
                                };
                            n.push(n_.h("div.mapillary-tag-interactor", p, []));
                            const g = {
                                style: {
                                    background: this._colorToBackground(
                                        this._options.color
                                    ),
                                    transform: d,
                                },
                            };
                            n.push(n_.h("div.mapillary-tag-vertex", g, []));
                        }
                        if (s > 2 && !0 === this._options.indicateCompleter) {
                            const [t, r] = this._geometry.getCentroid2d(
                                    this._transform
                                ),
                                s = this._viewportCoords.basicToCanvasSafe(
                                    t,
                                    r,
                                    i,
                                    this._transform,
                                    e
                                );
                            if (s) {
                                const e = (e) => {
                                        e.stopPropagation(),
                                            this._geometry.removePoint2d(
                                                this._geometry.points.length - 1
                                            ),
                                            this._created$.next(this);
                                    },
                                    t = this._canvasToTransform(s),
                                    i = { onclick: e, style: { transform: t } };
                                n.push(
                                    n_.h(
                                        "div.mapillary-tag-completer.mapillary-tag-larger",
                                        i,
                                        []
                                    )
                                );
                                const r = {
                                    style: {
                                        background: this._colorToBackground(
                                            this._options.color
                                        ),
                                        transform: t,
                                    },
                                };
                                n.push(
                                    n_.h(
                                        "div.mapillary-tag-vertex.mapillary-tag-larger",
                                        r,
                                        []
                                    )
                                );
                                const a = { style: { transform: t } };
                                n.push(n_.h("div.mapillary-tag-dot", a, []));
                            }
                        }
                        return n;
                    }
                    _onGeometryChanged() {
                        this._disposeObjects(),
                            (this._rectGeometry = new xy(
                                this._geometry.getRect2d(this._transform)
                            )),
                            this._createGlObjects();
                    }
                    _createGlObjects() {
                        this._glObjects = [];
                        const e = this._rectGeometry.getPoints3d(
                            this._transform
                        );
                        (this._outline = this._createOutine(
                            e,
                            this._options.color
                        )),
                            this._glObjects.push(this._outline);
                    }
                    _disposeObjects() {
                        this._disposeLine(this._outline),
                            (this._outline = null),
                            (this._glObjects = null);
                    }
                }
                class wy extends yy {
                    constructor(e, t) {
                        super();
                        let i = e.length;
                        if (i < 3)
                            throw new $M(
                                "A polygon must have three or more positions."
                            );
                        if (e[0][0] !== e[i - 1][0] || e[0][1] !== e[i - 1][1])
                            throw new $M(
                                "First and last positions must be equivalent."
                            );
                        this._polygon = [];
                        for (let t of e) {
                            if (t[0] < 0 || t[0] > 1 || t[1] < 0 || t[1] > 1)
                                throw new $M(
                                    "Basic coordinates of polygon must be on the interval [0, 1]."
                                );
                            this._polygon.push(t.slice());
                        }
                        if (((this._holes = []), null != t))
                            for (let e = 0; e < t.length; e++) {
                                let i = t[e],
                                    n = i.length;
                                if (n < 3)
                                    throw new $M(
                                        "A polygon hole must have three or more positions."
                                    );
                                if (
                                    i[0][0] !== i[n - 1][0] ||
                                    i[0][1] !== i[n - 1][1]
                                )
                                    throw new $M(
                                        "First and last positions of hole must be equivalent."
                                    );
                                this._holes.push([]);
                                for (let t of i) {
                                    if (
                                        t[0] < 0 ||
                                        t[0] > 1 ||
                                        t[1] < 0 ||
                                        t[1] > 1
                                    )
                                        throw new $M(
                                            "Basic coordinates of hole must be on the interval [0, 1]."
                                        );
                                    this._holes[e].push(t.slice());
                                }
                            }
                    }
                    get polygon() {
                        return this._polygon;
                    }
                    get holes() {
                        return this._holes;
                    }
                    addVertex2d(e) {
                        let t = [
                            Math.max(0, Math.min(1, e[0])),
                            Math.max(0, Math.min(1, e[1])),
                        ];
                        this._polygon.splice(this._polygon.length - 1, 0, t),
                            this._notifyChanged$.next(this);
                    }
                    getVertex2d(e) {
                        return this._polygon[e].slice();
                    }
                    removeVertex2d(e) {
                        if (
                            e < 0 ||
                            e >= this._polygon.length ||
                            this._polygon.length < 4
                        )
                            throw new $M(
                                "Index for removed vertex must be valid."
                            );
                        if (e > 0 && e < this._polygon.length - 1)
                            this._polygon.splice(e, 1);
                        else {
                            this._polygon.splice(0, 1), this._polygon.pop();
                            let e = this._polygon[0].slice();
                            this._polygon.push(e);
                        }
                        this._notifyChanged$.next(this);
                    }
                    setVertex2d(e, t, i) {
                        let n = [
                            Math.max(0, Math.min(1, t[0])),
                            Math.max(0, Math.min(1, t[1])),
                        ];
                        0 === e || e === this._polygon.length - 1
                            ? ((this._polygon[0] = n.slice()),
                              (this._polygon[this._polygon.length - 1] =
                                  n.slice()))
                            : (this._polygon[e] = n.slice()),
                            this._notifyChanged$.next(this);
                    }
                    setCentroid2d(e, t) {
                        let i = this._polygon.map((e) => e[0]),
                            n = this._polygon.map((e) => e[1]),
                            r = Math.min.apply(Math, i),
                            s = Math.max.apply(Math, i),
                            a = Math.min.apply(Math, n),
                            o = Math.max.apply(Math, n),
                            c = this.getCentroid2d(),
                            l = -r,
                            h = 1 - s,
                            u = -a,
                            d = 1 - o,
                            p = Math.max(l, Math.min(h, e[0] - c[0])),
                            g = Math.max(u, Math.min(d, e[1] - c[1]));
                        for (let e of this._polygon) (e[0] += p), (e[1] += g);
                        this._notifyChanged$.next(this);
                    }
                    getPoints3d(e) {
                        return this._getPoints3d(
                            this._subsample(this._polygon),
                            e
                        );
                    }
                    getVertex3d(e, t) {
                        return t.unprojectBasic(this._polygon[e], 200);
                    }
                    getVertices2d() {
                        return this._polygon.slice();
                    }
                    getVertices3d(e) {
                        return this._getPoints3d(this._polygon, e);
                    }
                    getHolePoints3d(e) {
                        return this._holes.map((t) =>
                            this._getPoints3d(this._subsample(t), e)
                        );
                    }
                    getHoleVertices3d(e) {
                        return this._holes.map((t) => this._getPoints3d(t, e));
                    }
                    getCentroid2d() {
                        let e = this._polygon,
                            t = 0,
                            i = 0,
                            n = 0;
                        for (let r = 0; r < e.length - 1; r++) {
                            let s = e[r][0],
                                a = e[r][1],
                                o = e[r + 1][0],
                                c = e[r + 1][1],
                                l = s * c - o * a;
                            (t += l), (i += (s + o) * l), (n += (a + c) * l);
                        }
                        return (t /= 2), (i /= 6 * t), (n /= 6 * t), [i, n];
                    }
                    getCentroid3d(e) {
                        let t = this.getCentroid2d();
                        return e.unprojectBasic(t, 200);
                    }
                    get3dDomainTriangles3d(e) {
                        return this._triangulate(
                            this._project(this._polygon, e),
                            this.getVertices3d(e),
                            this._holes.map((t) => this._project(t, e)),
                            this.getHoleVertices3d(e)
                        );
                    }
                    getTriangles3d(e) {
                        if (jp(e.cameraType))
                            return this._triangulateSpherical(
                                this._polygon.slice(),
                                this.holes.slice(),
                                e
                            );
                        const t = this._project(
                                this._subsample(this._polygon),
                                e
                            ),
                            i = this.getPoints3d(e),
                            n = this._holes.map((t) =>
                                this._project(this._subsample(t), e)
                            ),
                            r = this.getHolePoints3d(e);
                        return this._triangulate(t, i, n, r);
                    }
                    getPoleOfInaccessibility2d() {
                        return this._getPoleOfInaccessibility2d(
                            this._polygon.slice()
                        );
                    }
                    getPoleOfInaccessibility3d(e) {
                        let t = this._getPoleOfInaccessibility2d(
                            this._polygon.slice()
                        );
                        return e.unprojectBasic(t, 200);
                    }
                    _getPoints3d(e, t) {
                        return e.map((e) => t.unprojectBasic(e, 200));
                    }
                }
                class Ty extends FM {
                    constructor(e, t, i, n) {
                        super(e, i, n),
                            (this._options = {
                                color: null == t.color ? 16777215 : t.color,
                            }),
                            this._createGlObjects();
                    }
                    create() {
                        if (this._geometry instanceof xy)
                            this._created$.next(this);
                        else if (this._geometry instanceof wy) {
                            const e = this._geometry;
                            e.removeVertex2d(e.polygon.length - 2),
                                this._created$.next(this);
                        }
                    }
                    dispose() {
                        super.dispose(),
                            this._disposeLine(this._outline),
                            this._disposeObjects();
                    }
                    getDOMObjects(e, t) {
                        const i = [],
                            n = {
                                offsetHeight: t.height,
                                offsetWidth: t.width,
                            },
                            r = (e) => {
                                e.stopPropagation(), this._aborted$.next(this);
                            };
                        if (this._geometry instanceof xy) {
                            const t = this._geometry.anchorIndex,
                                s = void 0 === t ? 1 : t,
                                [a, o] = this._geometry.getVertex2d(s),
                                c = this._viewportCoords.basicToCanvasSafe(
                                    a,
                                    o,
                                    n,
                                    this._transform,
                                    e
                                );
                            if (null != c) {
                                const e = this._colorToBackground(
                                        this._options.color
                                    ),
                                    t = this._canvasToTransform(c),
                                    n = {
                                        style: { background: e, transform: t },
                                    },
                                    s = { onclick: r, style: { transform: t } };
                                i.push(
                                    n_.h("div.mapillary-tag-interactor", s, [])
                                ),
                                    i.push(
                                        n_.h("div.mapillary-tag-vertex", n, [])
                                    );
                            }
                        } else if (this._geometry instanceof wy) {
                            const t = this._geometry,
                                [s, a] = t.getVertex2d(0),
                                o = this._viewportCoords.basicToCanvasSafe(
                                    s,
                                    a,
                                    n,
                                    this._transform,
                                    e
                                );
                            if (null != o) {
                                const e = {
                                        onclick:
                                            t.polygon.length > 4
                                                ? (e) => {
                                                      e.stopPropagation(),
                                                          t.removeVertex2d(
                                                              t.polygon.length -
                                                                  2
                                                          ),
                                                          this._created$.next(
                                                              this
                                                          );
                                                  }
                                                : r,
                                        style: {
                                            transform:
                                                this._canvasToTransform(o),
                                        },
                                    },
                                    n =
                                        t.polygon.length > 4
                                            ? "mapillary-tag-completer"
                                            : "mapillary-tag-interactor";
                                i.push(n_.h("div." + n, e, []));
                            }
                            if (t.polygon.length > 3) {
                                const [r, s] = t.getVertex2d(
                                        t.polygon.length - 3
                                    ),
                                    a = this._viewportCoords.basicToCanvasSafe(
                                        r,
                                        s,
                                        n,
                                        this._transform,
                                        e
                                    );
                                if (null != a) {
                                    const e = {
                                        onclick: (e) => {
                                            e.stopPropagation(),
                                                t.removeVertex2d(
                                                    t.polygon.length - 3
                                                );
                                        },
                                        style: {
                                            transform:
                                                this._canvasToTransform(a),
                                        },
                                    };
                                    i.push(
                                        n_.h(
                                            "div.mapillary-tag-interactor",
                                            e,
                                            []
                                        )
                                    );
                                }
                            }
                            const c = t.polygon.slice();
                            c.splice(-2, 2);
                            for (const t of c) {
                                const r =
                                    this._viewportCoords.basicToCanvasSafe(
                                        t[0],
                                        t[1],
                                        n,
                                        this._transform,
                                        e
                                    );
                                if (null != r) {
                                    const e = {
                                        style: {
                                            background: this._colorToBackground(
                                                this._options.color
                                            ),
                                            transform:
                                                this._canvasToTransform(r),
                                        },
                                    };
                                    i.push(
                                        n_.h("div.mapillary-tag-vertex", e, [])
                                    );
                                }
                            }
                        }
                        return i;
                    }
                    addPoint(e) {
                        if (this._geometry instanceof xy) {
                            if (!this._geometry.validate(e)) return;
                            this._created$.next(this);
                        } else
                            this._geometry instanceof wy &&
                                this._geometry.addVertex2d(e);
                    }
                    _onGeometryChanged() {
                        this._disposeLine(this._outline),
                            this._disposeObjects(),
                            this._createGlObjects();
                    }
                    _disposeObjects() {
                        (this._outline = null), (this._glObjects = []);
                    }
                    _createGlObjects() {
                        const e =
                            this._geometry instanceof xy
                                ? this._geometry.getPoints3d(this._transform)
                                : this._geometry.getVertices3d(this._transform);
                        (this._outline = this._createOutine(
                            e,
                            this._options.color
                        )),
                            (this._glObjects = [this._outline]);
                    }
                }
                class Sy {
                    constructor(e, t) {
                        (this._component = e),
                            (this._navigator = t),
                            (this._tagOperation$ = new W()),
                            (this._createPoints$ = new W()),
                            (this._createPolygon$ = new W()),
                            (this._createRect$ = new W()),
                            (this._delete$ = new W()),
                            (this._tag$ = this._tagOperation$.pipe(
                                At((e, t) => t(e), null),
                                Et()
                            )),
                            (this._replayedTag$ = this._tag$.pipe(It(1), V())),
                            this._replayedTag$.subscribe(),
                            this._createPoints$
                                .pipe(
                                    $t(
                                        this._component.configuration$,
                                        this._navigator.stateService
                                            .currentTransform$
                                    ),
                                    ke(([e, t, i]) => () => {
                                        const n = new BM([
                                            [e[0], e[1]],
                                            [e[0], e[1]],
                                        ]);
                                        return new by(
                                            n,
                                            {
                                                color: t.createColor,
                                                indicateCompleter:
                                                    t.indicatePointsCompleter,
                                            },
                                            i
                                        );
                                    })
                                )
                                .subscribe(this._tagOperation$),
                            this._createRect$
                                .pipe(
                                    $t(
                                        this._component.configuration$,
                                        this._navigator.stateService
                                            .currentTransform$
                                    ),
                                    ke(([e, t, i]) => () => {
                                        const n = new xy([
                                            e[0],
                                            e[1],
                                            e[0],
                                            e[1],
                                        ]);
                                        return new Ty(
                                            n,
                                            { color: t.createColor },
                                            i
                                        );
                                    })
                                )
                                .subscribe(this._tagOperation$),
                            this._createPolygon$
                                .pipe(
                                    $t(
                                        this._component.configuration$,
                                        this._navigator.stateService
                                            .currentTransform$
                                    ),
                                    ke(([e, t, i]) => () => {
                                        const n = new wy([
                                            [e[0], e[1]],
                                            [e[0], e[1]],
                                            [e[0], e[1]],
                                        ]);
                                        return new Ty(
                                            n,
                                            { color: t.createColor },
                                            i
                                        );
                                    })
                                )
                                .subscribe(this._tagOperation$),
                            this._delete$
                                .pipe(ke(() => () => null))
                                .subscribe(this._tagOperation$);
                    }
                    get createRect$() {
                        return this._createRect$;
                    }
                    get createPolygon$() {
                        return this._createPolygon$;
                    }
                    get createPoints$() {
                        return this._createPoints$;
                    }
                    get delete$() {
                        return this._delete$;
                    }
                    get tag$() {
                        return this._tag$;
                    }
                    get replayedTag$() {
                        return this._replayedTag$;
                    }
                }
                class Ny {
                    render(e, t, i, n, r) {
                        let s = [];
                        for (const t of e)
                            s = s.concat(t.getDOMObjects(i, n, r));
                        return (
                            null != t && (s = s.concat(t.getDOMObjects(n, r))),
                            n_.h("div.mapillary-tag-container", {}, s)
                        );
                    }
                    clear() {
                        return n_.h("div", {}, []);
                    }
                }
                class Dy {
                    constructor(e, t) {
                        (this._createTag = null),
                            (this._needsRender = !1),
                            (this._raycaster = t || new op()),
                            (this._scene = e || new ph()),
                            (this._objectTags = {}),
                            (this._retrievableObjects = []),
                            (this._tags = {});
                    }
                    get needsRender() {
                        return this._needsRender;
                    }
                    add(e) {
                        for (let t of e)
                            t.tag.id in this._tags && this._remove(t.tag.id),
                                this._add(t);
                        this._needsRender = !0;
                    }
                    addCreateTag(e) {
                        for (const t of e.glObjects) this._scene.add(t);
                        (this._createTag = { tag: e, objects: e.glObjects }),
                            (this._needsRender = !0);
                    }
                    clear() {
                        for (const e of Object.keys(this._tags))
                            this._remove(e);
                        this._needsRender = !1;
                    }
                    get(e) {
                        return this.has(e) ? this._tags[e].tag : void 0;
                    }
                    has(e) {
                        return e in this._tags;
                    }
                    hasCreateTag() {
                        return null != this._createTag;
                    }
                    intersectObjects([e, t], i) {
                        this._raycaster.setFromCamera(new Gr(e, t), i);
                        const n = this._raycaster.intersectObjects(
                                this._retrievableObjects
                            ),
                            r = [];
                        for (const e of n)
                            e.object.uuid in this._objectTags &&
                                r.push(this._objectTags[e.object.uuid]);
                        return r;
                    }
                    remove(e) {
                        for (const t of e) this._remove(t);
                        this._needsRender = !0;
                    }
                    removeAll() {
                        for (const e of Object.keys(this._tags))
                            this._remove(e);
                        this._needsRender = !0;
                    }
                    removeCreateTag() {
                        if (null != this._createTag) {
                            for (const e of this._createTag.objects)
                                this._scene.remove(e);
                            this._createTag.tag.dispose(),
                                (this._createTag = null),
                                (this._needsRender = !0);
                        }
                    }
                    render(e, t) {
                        t.render(this._scene, e), (this._needsRender = !1);
                    }
                    update() {
                        this._needsRender = !0;
                    }
                    updateCreateTagObjects(e) {
                        if (this._createTag.tag !== e)
                            throw new Error(
                                "Create tags do not have the same reference."
                            );
                        for (let e of this._createTag.objects)
                            this._scene.remove(e);
                        for (const t of e.glObjects) this._scene.add(t);
                        (this._createTag.objects = e.glObjects),
                            (this._needsRender = !0);
                    }
                    updateObjects(e) {
                        const t = e.tag.id;
                        if (this._tags[t].tag !== e)
                            throw new Error(
                                "Tags do not have the same reference."
                            );
                        const i = this._tags[t];
                        this._removeObjects(i),
                            delete this._tags[t],
                            this._add(e),
                            (this._needsRender = !0);
                    }
                    _add(e) {
                        const t = e.tag.id,
                            i = { tag: e, objects: [], retrievableObjects: [] };
                        this._tags[t] = i;
                        for (const t of e.getGLObjects())
                            i.objects.push(t), this._scene.add(t);
                        for (const t of e.getRetrievableObjects())
                            i.retrievableObjects.push(t),
                                this._retrievableObjects.push(t),
                                (this._objectTags[t.uuid] = e.tag.id);
                    }
                    _remove(e) {
                        const t = this._tags[e];
                        this._removeObjects(t),
                            t.tag.dispose(),
                            delete this._tags[e];
                    }
                    _removeObjects(e) {
                        for (const t of e.objects) this._scene.remove(t);
                        for (const t of e.retrievableObjects) {
                            const e = this._retrievableObjects.indexOf(t);
                            -1 !== e && this._retrievableObjects.splice(e, 1);
                        }
                    }
                }
                var Iy, Cy, Ay, Ey;
                !(function (e) {
                    (e[(e.Default = 0)] = "Default"),
                        (e[(e.CreatePoint = 1)] = "CreatePoint"),
                        (e[(e.CreatePoints = 2)] = "CreatePoints"),
                        (e[(e.CreatePolygon = 3)] = "CreatePolygon"),
                        (e[(e.CreateRect = 4)] = "CreateRect"),
                        (e[(e.CreateRectDrag = 5)] = "CreateRectDrag");
                })(Iy || (Iy = {})),
                    (function (e) {
                        (e[(e.None = 0)] = "None"),
                            (e[(e.Centroid = 1)] = "Centroid"),
                            (e[(e.Vertex = 2)] = "Vertex");
                    })(Cy || (Cy = {}));
                class Ly {
                    constructor(e, t, i) {
                        (this._tag = e),
                            (this._transform = t),
                            (this._viewportCoords = i || new l_()),
                            (this._glObjectsChanged$ = new W()),
                            (this._interact$ = new W());
                    }
                    get glObjectsChanged$() {
                        return this._glObjectsChanged$;
                    }
                    get interact$() {
                        return this._interact$;
                    }
                    get tag() {
                        return this._tag;
                    }
                }
                class zy extends Ly {
                    constructor(e, t) {
                        super(e, t),
                            (this._geometryChangedSubscription =
                                this._tag.geometry.changed$.subscribe(() => {
                                    this._onGeometryChanged();
                                })),
                            (this._changedSubscription =
                                this._tag.changed$.subscribe(() => {
                                    this._onTagChanged() &&
                                        this._glObjectsChanged$.next(this);
                                }));
                    }
                    dispose() {
                        this._changedSubscription.unsubscribe(),
                            this._geometryChangedSubscription.unsubscribe();
                    }
                    _colorToCss(e) {
                        return "#" + ("000000" + e.toString(16)).substr(-6);
                    }
                    _createFill() {
                        let e = this._getTriangles(),
                            t = new Float32Array(e),
                            i = new Ba();
                        i.setAttribute("position", new Aa(t, 3)),
                            i.computeBoundingSphere();
                        let n = new Da({ side: Zt, transparent: !0 });
                        return this._updateFillMaterial(n), new so(i, n);
                    }
                    _createLine(e) {
                        let t = this._getLinePositions(e),
                            i = new Ba();
                        i.setAttribute("position", new Aa(t, 3)),
                            i.computeBoundingSphere();
                        let n = new Gh();
                        this._updateLineBasicMaterial(n);
                        const r = new Zh(i, n);
                        return (r.renderOrder = 1), r;
                    }
                    _createOutline() {
                        return this._createLine(this._getPoints3d());
                    }
                    _disposeFill() {
                        null != this._fill &&
                            (this._fill.geometry.dispose(),
                            this._fill.material.dispose(),
                            (this._fill = null));
                    }
                    _disposeOutline() {
                        null != this._outline &&
                            (this._outline.geometry.dispose(),
                            this._outline.material.dispose(),
                            (this._outline = null));
                    }
                    _getLinePositions(e) {
                        let t = e.length,
                            i = new Float32Array(3 * t);
                        for (let n = 0; n < t; ++n) {
                            let t = 3 * n,
                                r = e[n];
                            (i[t + 0] = r[0]),
                                (i[t + 1] = r[1]),
                                (i[t + 2] = r[2]);
                        }
                        return i;
                    }
                    _interact(e, t, i) {
                        return (n) => {
                            let r = n.offsetX - n.target.offsetWidth / 2,
                                s = n.offsetY - n.target.offsetHeight / 2;
                            this._interact$.next({
                                cursor: t,
                                offsetX: r,
                                offsetY: s,
                                operation: e,
                                tag: this._tag,
                                vertexIndex: i,
                            });
                        };
                    }
                    _updateFillGeometry() {
                        let e = this._getTriangles(),
                            t = new Float32Array(e),
                            i = this._fill.geometry,
                            n = i.getAttribute("position");
                        n.array.length === t.length
                            ? (n.set(t), (n.needsUpdate = !0))
                            : (i.deleteAttribute("position"),
                              i.setAttribute("position", new Aa(t, 3))),
                            i.computeBoundingSphere();
                    }
                    _updateLine(e, t) {
                        let i = this._getLinePositions(t),
                            n = e.geometry,
                            r = n.getAttribute("position");
                        r.set(i),
                            (r.needsUpdate = !0),
                            n.computeBoundingSphere();
                    }
                    _updateOulineGeometry() {
                        this._updateLine(this._outline, this._getPoints3d());
                    }
                }
                class jy extends zy {
                    constructor(e, t) {
                        super(e, t),
                            (this._rectGeometry = new xy(
                                this._tag.geometry.getRect2d(t)
                            )),
                            (this._fill = jp(t.cameraType)
                                ? null
                                : this._createFill()),
                            (this._outline =
                                this._tag.lineWidth >= 1
                                    ? this._createOutline()
                                    : null);
                    }
                    dispose() {
                        super.dispose(),
                            this._disposeFill(),
                            this._disposeOutline();
                    }
                    getDOMObjects(e, t, i) {
                        const n = [],
                            r = {
                                offsetHeight: i.height,
                                offsetWidth: i.width,
                            };
                        if (!this._tag.editable) return n;
                        const s = this._colorToCss(this._tag.lineColor),
                            a = this._tag.geometry.getPoints2d();
                        for (let e = 0; e < a.length; e++) {
                            const [i, o] = a[e],
                                c = this._viewportCoords.basicToCanvasSafe(
                                    i,
                                    o,
                                    r,
                                    this._transform,
                                    t
                                );
                            if (null == c) continue;
                            const l = "crosshair",
                                h = this._interact(Cy.Vertex, l, e),
                                u = `translate(-50%, -50%) translate(${Math.round(
                                    c[0]
                                )}px,${Math.round(c[1])}px)`,
                                d = {
                                    onpointerdown: h,
                                    style: {
                                        background: s,
                                        transform: u,
                                        cursor: l,
                                    },
                                };
                            if (
                                (n.push(
                                    n_.h("div.mapillary-tag-resizer", d, [])
                                ),
                                !this._tag.indicateVertices)
                            )
                                continue;
                            const p = {
                                style: { background: s, transform: u },
                            };
                            n.push(n_.h("div.mapillary-tag-vertex", p, []));
                        }
                        return n;
                    }
                    getGLObjects() {
                        const e = [];
                        return (
                            null != this._fill && e.push(this._fill),
                            null != this._outline && e.push(this._outline),
                            e
                        );
                    }
                    getRetrievableObjects() {
                        return null != this._fill ? [this._fill] : [];
                    }
                    _onGeometryChanged() {
                        (this._rectGeometry = new xy(
                            this._tag.geometry.getRect2d(this._transform)
                        )),
                            null != this._fill && this._updateFillGeometry(),
                            null != this._outline &&
                                this._updateOulineGeometry();
                    }
                    _onTagChanged() {
                        let e = !1;
                        return (
                            null != this._fill &&
                                this._updateFillMaterial(this._fill.material),
                            null == this._outline
                                ? this._tag.lineWidth >= 1 &&
                                  ((this._outline = this._createOutline()),
                                  (e = !0))
                                : this._updateOutlineMaterial(),
                            e
                        );
                    }
                    _getPoints3d() {
                        return this._rectGeometry.getPoints3d(this._transform);
                    }
                    _getTriangles() {
                        return this._rectGeometry.getTriangles3d(
                            this._transform
                        );
                    }
                    _updateFillMaterial(e) {
                        (e.color = new Na(this._tag.fillColor)),
                            (e.opacity = this._tag.fillOpacity),
                            (e.needsUpdate = !0);
                    }
                    _updateLineBasicMaterial(e) {
                        (e.color = new Na(this._tag.lineColor)),
                            (e.linewidth = Math.max(this._tag.lineWidth, 1)),
                            (e.visible =
                                this._tag.lineWidth >= 1 &&
                                this._tag.lineOpacity > 0),
                            (e.opacity = this._tag.lineOpacity),
                            (e.transparent = this._tag.lineOpacity < 1),
                            (e.needsUpdate = !0);
                    }
                    _updateOutlineMaterial() {
                        let e = this._outline.material;
                        this._updateLineBasicMaterial(e);
                    }
                }
                class Oy extends r_ {
                    constructor(e, t) {
                        super(),
                            (this._id = e),
                            (this._geometry = t),
                            (this._notifyChanged$ = new W()),
                            this._notifyChanged$.subscribe((e) => {
                                const t = { target: this, type: "tag" };
                                this.fire("tag", t);
                            }),
                            this._geometry.changed$.subscribe((e) => {
                                const t = "geometry",
                                    i = { target: this, type: t };
                                this.fire(t, i);
                            });
                    }
                    get id() {
                        return this._id;
                    }
                    get geometry() {
                        return this._geometry;
                    }
                    get changed$() {
                        return this._notifyChanged$;
                    }
                    get geometryChanged$() {
                        return this._geometry.changed$.pipe(
                            ke(() => this),
                            Et()
                        );
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                }
                class ky extends Oy {
                    constructor(e, t, i) {
                        super(e, t),
                            (i = i || {}),
                            (this._editable = null != i.editable && i.editable),
                            (this._fillColor =
                                null == i.fillColor ? 16777215 : i.fillColor),
                            (this._fillOpacity =
                                null == i.fillOpacity ? 0 : i.fillOpacity),
                            (this._indicateVertices =
                                null == i.indicateVertices ||
                                i.indicateVertices),
                            (this._lineColor =
                                null == i.lineColor ? 16777215 : i.lineColor),
                            (this._lineOpacity =
                                null == i.lineOpacity ? 1 : i.lineOpacity),
                            (this._lineWidth =
                                null == i.lineWidth ? 1 : i.lineWidth);
                    }
                    get editable() {
                        return this._editable;
                    }
                    set editable(e) {
                        (this._editable = e), this._notifyChanged$.next(this);
                    }
                    get fillColor() {
                        return this._fillColor;
                    }
                    set fillColor(e) {
                        (this._fillColor = e), this._notifyChanged$.next(this);
                    }
                    get fillOpacity() {
                        return this._fillOpacity;
                    }
                    set fillOpacity(e) {
                        (this._fillOpacity = e),
                            this._notifyChanged$.next(this);
                    }
                    get geometry() {
                        return this._geometry;
                    }
                    get indicateVertices() {
                        return this._indicateVertices;
                    }
                    set indicateVertices(e) {
                        (this._indicateVertices = e),
                            this._notifyChanged$.next(this);
                    }
                    get lineColor() {
                        return this._lineColor;
                    }
                    set lineColor(e) {
                        (this._lineColor = e), this._notifyChanged$.next(this);
                    }
                    get lineOpacity() {
                        return this._lineOpacity;
                    }
                    set lineOpacity(e) {
                        (this._lineOpacity = e),
                            this._notifyChanged$.next(this);
                    }
                    get lineWidth() {
                        return this._lineWidth;
                    }
                    set lineWidth(e) {
                        (this._lineWidth = e), this._notifyChanged$.next(this);
                    }
                    setOptions(e) {
                        (this._editable =
                            null == e.editable ? this._editable : e.editable),
                            (this._indicateVertices =
                                null == e.indicateVertices
                                    ? this._indicateVertices
                                    : e.indicateVertices),
                            (this._lineColor =
                                null == e.lineColor
                                    ? this._lineColor
                                    : e.lineColor),
                            (this._lineWidth =
                                null == e.lineWidth
                                    ? this._lineWidth
                                    : e.lineWidth),
                            (this._fillColor =
                                null == e.fillColor
                                    ? this._fillColor
                                    : e.fillColor),
                            (this._fillOpacity =
                                null == e.fillOpacity
                                    ? this._fillOpacity
                                    : e.fillOpacity),
                            this._notifyChanged$.next(this);
                    }
                }
                !(function (e) {
                    (e[(e.TwoDimensional = 0)] = "TwoDimensional"),
                        (e[(e.ThreeDimensional = 1)] = "ThreeDimensional");
                })(Ay || (Ay = {}));
                class Ry extends zy {
                    constructor(e, t) {
                        super(e, t),
                            (this._fill = jp(t.cameraType)
                                ? e.domain === Ay.TwoDimensional &&
                                  e.geometry instanceof wy
                                    ? this._createFill()
                                    : null
                                : this._createFill()),
                            (this._holes =
                                this._tag.lineWidth >= 1
                                    ? this._createHoles()
                                    : []),
                            (this._outline =
                                this._tag.lineWidth >= 1
                                    ? this._createOutline()
                                    : null);
                    }
                    dispose() {
                        super.dispose(),
                            this._disposeFill(),
                            this._disposeHoles(),
                            this._disposeOutline();
                    }
                    getDOMObjects(e, t, i) {
                        const n = [],
                            r = this._tag.geometry instanceof xy,
                            s = !jp(this._transform.cameraType),
                            a = {
                                offsetHeight: i.height,
                                offsetWidth: i.width,
                            };
                        if (null != this._tag.icon && (r || s)) {
                            const [i, r] =
                                    this._tag.geometry instanceof xy
                                        ? this._tag.geometry.getVertex2d(
                                              this._tag.iconIndex
                                          )
                                        : this._tag.geometry.getPoleOfInaccessibility2d(),
                                s = this._viewportCoords.basicToCanvasSafe(
                                    i,
                                    r,
                                    a,
                                    this._transform,
                                    t
                                );
                            if (null != s) {
                                const t = () => {
                                    this._interact$.next({
                                        offsetX: 0,
                                        offsetY: 0,
                                        operation: Cy.None,
                                        tag: this._tag,
                                    });
                                };
                                if (e.loaded) {
                                    const i = e.getDOMSprite(
                                            this._tag.icon,
                                            this._tag.iconFloat
                                        ),
                                        r = {
                                            onclick: (e) => {
                                                e.stopPropagation(),
                                                    this._tag.click$.next(
                                                        this._tag
                                                    );
                                            },
                                            onpointerdown: t,
                                            style: {
                                                transform: `translate(${Math.round(
                                                    s[0]
                                                )}px,${Math.round(s[1])}px)`,
                                            },
                                        };
                                    n.push(
                                        n_.h("div.mapillary-tag-symbol", r, [i])
                                    );
                                }
                            }
                        } else if (null != this._tag.text && (r || s)) {
                            const [e, i] =
                                    this._tag.geometry instanceof xy
                                        ? this._tag.geometry.getVertex2d(3)
                                        : this._tag.geometry.getPoleOfInaccessibility2d(),
                                r = this._viewportCoords.basicToCanvasSafe(
                                    e,
                                    i,
                                    a,
                                    this._transform,
                                    t
                                );
                            if (null != r) {
                                const e = Math.round(r[0]),
                                    t = Math.round(r[1]),
                                    i =
                                        this._tag.geometry instanceof xy
                                            ? `translate(${e}px,${t}px)`
                                            : `translate(-50%, -50%) translate(${e}px,${t}px)`,
                                    s = {
                                        onpointerdown: () => {
                                            this._interact$.next({
                                                offsetX: 0,
                                                offsetY: 0,
                                                operation: Cy.None,
                                                tag: this._tag,
                                            });
                                        },
                                        style: {
                                            color: this._colorToCss(
                                                this._tag.textColor
                                            ),
                                            transform: i,
                                        },
                                        textContent: this._tag.text,
                                    };
                                n.push(
                                    n_.h("span.mapillary-tag-symbol", s, [])
                                );
                            }
                        }
                        if (!this._tag.editable) return n;
                        const o = this._colorToCss(this._tag.lineColor);
                        if (this._tag.geometry instanceof xy) {
                            const [e, i] = this._tag.geometry.getCentroid2d(),
                                r = this._viewportCoords.basicToCanvasSafe(
                                    e,
                                    i,
                                    a,
                                    this._transform,
                                    t
                                );
                            if (null != r) {
                                const e = {
                                    onpointerdown: this._interact(
                                        Cy.Centroid,
                                        "move"
                                    ),
                                    style: {
                                        background: o,
                                        transform: `translate(-50%, -50%) translate(${Math.round(
                                            r[0]
                                        )}px,${Math.round(r[1])}px)`,
                                    },
                                };
                                n.push(n_.h("div.mapillary-tag-mover", e, []));
                            }
                        }
                        const c = this._tag.geometry.getVertices2d();
                        for (let e = 0; e < c.length - 1; e++) {
                            if (
                                r &&
                                ((null != this._tag.icon &&
                                    e === this._tag.iconIndex) ||
                                    (null == this._tag.icon &&
                                        null != this._tag.text &&
                                        3 === e))
                            )
                                continue;
                            const [i, s] = c[e],
                                l = this._viewportCoords.basicToCanvasSafe(
                                    i,
                                    s,
                                    a,
                                    this._transform,
                                    t
                                );
                            if (null == l) continue;
                            const h = r
                                    ? e % 2 == 0
                                        ? "nesw-resize"
                                        : "nwse-resize"
                                    : "crosshair",
                                u = this._interact(Cy.Vertex, h, e),
                                d = `translate(-50%, -50%) translate(${Math.round(
                                    l[0]
                                )}px,${Math.round(l[1])}px)`,
                                p = {
                                    onpointerdown: u,
                                    style: {
                                        background: o,
                                        transform: d,
                                        cursor: h,
                                    },
                                };
                            if (
                                (n.push(
                                    n_.h("div.mapillary-tag-resizer", p, [])
                                ),
                                !this._tag.indicateVertices)
                            )
                                continue;
                            const g = {
                                style: { background: o, transform: d },
                            };
                            n.push(n_.h("div.mapillary-tag-vertex", g, []));
                        }
                        return n;
                    }
                    getGLObjects() {
                        const e = [];
                        null != this._fill && e.push(this._fill);
                        for (const t of this._holes) e.push(t);
                        return (
                            null != this._outline && e.push(this._outline), e
                        );
                    }
                    getRetrievableObjects() {
                        return null != this._fill ? [this._fill] : [];
                    }
                    _onGeometryChanged() {
                        null != this._fill && this._updateFillGeometry(),
                            this._holes.length > 0 &&
                                this._updateHoleGeometries(),
                            null != this._outline &&
                                this._updateOulineGeometry();
                    }
                    _onTagChanged() {
                        let e = !1;
                        return (
                            null != this._fill &&
                                this._updateFillMaterial(this._fill.material),
                            null == this._outline
                                ? this._tag.lineWidth >= 1 &&
                                  ((this._holes = this._createHoles()),
                                  (this._outline = this._createOutline()),
                                  (e = !0))
                                : (this._updateHoleMaterials(),
                                  this._updateOutlineMaterial()),
                            e
                        );
                    }
                    _getPoints3d() {
                        return this._in3dDomain()
                            ? this._tag.geometry.getVertices3d(this._transform)
                            : this._tag.geometry.getPoints3d(this._transform);
                    }
                    _getTriangles() {
                        return this._in3dDomain()
                            ? this._tag.geometry.get3dDomainTriangles3d(
                                  this._transform
                              )
                            : this._tag.geometry.getTriangles3d(
                                  this._transform
                              );
                    }
                    _updateFillMaterial(e) {
                        (e.color = new Na(this._tag.fillColor)),
                            (e.opacity = this._tag.fillOpacity),
                            (e.needsUpdate = !0);
                    }
                    _updateLineBasicMaterial(e) {
                        (e.color = new Na(this._tag.lineColor)),
                            (e.linewidth = Math.max(this._tag.lineWidth, 1)),
                            (e.visible =
                                this._tag.lineWidth >= 1 &&
                                this._tag.lineOpacity > 0),
                            (e.opacity = this._tag.lineOpacity),
                            (e.transparent = this._tag.lineOpacity < 1),
                            (e.needsUpdate = !0);
                    }
                    _createHoles() {
                        let e = [];
                        if (this._tag.geometry instanceof wy) {
                            let t = this._getHoles3d();
                            for (let i of t) {
                                let t = this._createLine(i);
                                e.push(t);
                            }
                        }
                        return e;
                    }
                    _disposeHoles() {
                        for (let e of this._holes)
                            e.geometry.dispose(), e.material.dispose();
                        this._holes = [];
                    }
                    _getHoles3d() {
                        const e = this._tag.geometry;
                        return this._in3dDomain()
                            ? e.getHoleVertices3d(this._transform)
                            : e.getHolePoints3d(this._transform);
                    }
                    _in3dDomain() {
                        return (
                            this._tag.geometry instanceof wy &&
                            this._tag.domain === Ay.ThreeDimensional
                        );
                    }
                    _updateHoleGeometries() {
                        let e = this._getHoles3d();
                        if (e.length !== this._holes.length)
                            throw new Error(
                                "Changing the number of holes is not supported."
                            );
                        for (let t = 0; t < this._holes.length; t++) {
                            let i = e[t],
                                n = this._holes[t];
                            this._updateLine(n, i);
                        }
                    }
                    _updateHoleMaterials() {
                        for (const e of this._holes)
                            this._updateLineBasicMaterial(e.material);
                    }
                    _updateOutlineMaterial() {
                        this._updateLineBasicMaterial(this._outline.material);
                    }
                }
                !(function (e) {
                    (e[(e.Bottom = 0)] = "Bottom"),
                        (e[(e.BottomLeft = 1)] = "BottomLeft"),
                        (e[(e.BottomRight = 2)] = "BottomRight"),
                        (e[(e.Center = 3)] = "Center"),
                        (e[(e.Left = 4)] = "Left"),
                        (e[(e.Right = 5)] = "Right"),
                        (e[(e.Top = 6)] = "Top"),
                        (e[(e.TopLeft = 7)] = "TopLeft"),
                        (e[(e.TopRight = 8)] = "TopRight");
                })(Ey || (Ey = {}));
                class Py extends Oy {
                    constructor(e, t, i) {
                        super(e, t);
                        const n =
                                null != (i = i || {}).domain && t instanceof wy
                                    ? i.domain
                                    : Ay.TwoDimensional,
                            r = this._twoDimensionalPolygon(n, t);
                        (this._domain = n),
                            (this._editable =
                                null != i.editable && !r && i.editable),
                            (this._fillColor =
                                null == i.fillColor ? 16777215 : i.fillColor),
                            (this._fillOpacity =
                                null == i.fillOpacity ? 0 : i.fillOpacity),
                            (this._icon = void 0 === i.icon ? null : i.icon),
                            (this._iconFloat =
                                null == i.iconFloat ? Ey.Center : i.iconFloat),
                            (this._iconIndex =
                                null == i.iconIndex ? 3 : i.iconIndex),
                            (this._indicateVertices =
                                null == i.indicateVertices ||
                                i.indicateVertices),
                            (this._lineColor =
                                null == i.lineColor ? 16777215 : i.lineColor),
                            (this._lineOpacity =
                                null == i.lineOpacity ? 1 : i.lineOpacity),
                            (this._lineWidth =
                                null == i.lineWidth ? 1 : i.lineWidth),
                            (this._text = void 0 === i.text ? null : i.text),
                            (this._textColor =
                                null == i.textColor ? 16777215 : i.textColor),
                            (this._click$ = new W()),
                            this._click$.subscribe(() => {
                                const e = "click",
                                    t = { target: this, type: e };
                                this.fire(e, t);
                            });
                    }
                    get click$() {
                        return this._click$;
                    }
                    get domain() {
                        return this._domain;
                    }
                    get editable() {
                        return this._editable;
                    }
                    set editable(e) {
                        this._twoDimensionalPolygon(
                            this._domain,
                            this._geometry
                        ) ||
                            ((this._editable = e),
                            this._notifyChanged$.next(this));
                    }
                    get fillColor() {
                        return this._fillColor;
                    }
                    set fillColor(e) {
                        (this._fillColor = e), this._notifyChanged$.next(this);
                    }
                    get fillOpacity() {
                        return this._fillOpacity;
                    }
                    set fillOpacity(e) {
                        (this._fillOpacity = e),
                            this._notifyChanged$.next(this);
                    }
                    get geometry() {
                        return this._geometry;
                    }
                    get icon() {
                        return this._icon;
                    }
                    set icon(e) {
                        (this._icon = e), this._notifyChanged$.next(this);
                    }
                    get iconFloat() {
                        return this._iconFloat;
                    }
                    set iconFloat(e) {
                        (this._iconFloat = e), this._notifyChanged$.next(this);
                    }
                    get iconIndex() {
                        return this._iconIndex;
                    }
                    set iconIndex(e) {
                        (this._iconIndex = e), this._notifyChanged$.next(this);
                    }
                    get indicateVertices() {
                        return this._indicateVertices;
                    }
                    set indicateVertices(e) {
                        (this._indicateVertices = e),
                            this._notifyChanged$.next(this);
                    }
                    get lineColor() {
                        return this._lineColor;
                    }
                    set lineColor(e) {
                        (this._lineColor = e), this._notifyChanged$.next(this);
                    }
                    get lineOpacity() {
                        return this._lineOpacity;
                    }
                    set lineOpacity(e) {
                        (this._lineOpacity = e),
                            this._notifyChanged$.next(this);
                    }
                    get lineWidth() {
                        return this._lineWidth;
                    }
                    set lineWidth(e) {
                        (this._lineWidth = e), this._notifyChanged$.next(this);
                    }
                    get text() {
                        return this._text;
                    }
                    set text(e) {
                        (this._text = e), this._notifyChanged$.next(this);
                    }
                    get textColor() {
                        return this._textColor;
                    }
                    set textColor(e) {
                        (this._textColor = e), this._notifyChanged$.next(this);
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                    setOptions(e) {
                        const t = this._twoDimensionalPolygon(
                            this._domain,
                            this._geometry
                        );
                        (this._editable =
                            t || null == e.editable
                                ? this._editable
                                : e.editable),
                            (this._icon =
                                void 0 === e.icon ? this._icon : e.icon),
                            (this._iconFloat =
                                null == e.iconFloat
                                    ? this._iconFloat
                                    : e.iconFloat),
                            (this._iconIndex =
                                null == e.iconIndex
                                    ? this._iconIndex
                                    : e.iconIndex),
                            (this._indicateVertices =
                                null == e.indicateVertices
                                    ? this._indicateVertices
                                    : e.indicateVertices),
                            (this._lineColor =
                                null == e.lineColor
                                    ? this._lineColor
                                    : e.lineColor),
                            (this._lineWidth =
                                null == e.lineWidth
                                    ? this._lineWidth
                                    : e.lineWidth),
                            (this._fillColor =
                                null == e.fillColor
                                    ? this._fillColor
                                    : e.fillColor),
                            (this._fillOpacity =
                                null == e.fillOpacity
                                    ? this._fillOpacity
                                    : e.fillOpacity),
                            (this._text =
                                void 0 === e.text ? this._text : e.text),
                            (this._textColor =
                                null == e.textColor
                                    ? this._textColor
                                    : e.textColor),
                            this._notifyChanged$.next(this);
                    }
                    _twoDimensionalPolygon(e, t) {
                        return e !== Ay.ThreeDimensional && t instanceof wy;
                    }
                }
                class Uy extends Ly {
                    dispose() {}
                    getDOMObjects(e, t, i) {
                        const n = this._tag,
                            r = {
                                offsetHeight: i.height,
                                offsetWidth: i.width,
                            },
                            s = [],
                            [a, o] = n.geometry.getCentroid2d(),
                            c = this._viewportCoords.basicToCanvasSafe(
                                a,
                                o,
                                r,
                                this._transform,
                                t
                            );
                        if (null != c) {
                            const t = (e) => {
                                    this._interact$.next({
                                        offsetX: 0,
                                        offsetY: 0,
                                        operation: Cy.None,
                                        tag: n,
                                    });
                                },
                                i = Math.round(c[0]),
                                r = Math.round(c[1]);
                            if (null != n.icon) {
                                if (e.loaded) {
                                    const a = e.getDOMSprite(n.icon, Ey.Bottom),
                                        o = {
                                            onpointerdown: t,
                                            style: {
                                                pointerEvents: "all",
                                                transform: `translate(${i}px,${
                                                    r + 8
                                                }px)`,
                                            },
                                        };
                                    s.push(n_.h("div", o, [a]));
                                }
                            } else if (null != n.text) {
                                const e = `translate(-50%,0%) translate(${i}px,${
                                        r + 8
                                    }px)`,
                                    a = {
                                        onpointerdown: t,
                                        style: {
                                            color: this._colorToCss(
                                                n.textColor
                                            ),
                                            transform: e,
                                        },
                                        textContent: n.text,
                                    };
                                s.push(
                                    n_.h("span.mapillary-tag-symbol", a, [])
                                );
                            }
                            const a = this._interact(Cy.Centroid, n, "move"),
                                o = this._colorToCss(n.color),
                                l = `translate(-50%,-50%) translate(${i}px,${r}px)`;
                            if (n.editable) {
                                let e = {
                                    onpointerdown: a,
                                    style: { background: o, transform: l },
                                };
                                s.push(
                                    n_.h(
                                        "div.mapillary-tag-spot-interactor",
                                        e,
                                        []
                                    )
                                );
                            }
                            const h = {
                                style: { background: o, transform: l },
                            };
                            s.push(n_.h("div.mapillary-tag-vertex", h, []));
                        }
                        return s;
                    }
                    getGLObjects() {
                        return [];
                    }
                    getRetrievableObjects() {
                        return [];
                    }
                    _colorToCss(e) {
                        return "#" + ("000000" + e.toString(16)).substr(-6);
                    }
                    _interact(e, t, i, n) {
                        return (r) => {
                            const s = r.offsetX - r.target.offsetWidth / 2,
                                a = r.offsetY - r.target.offsetHeight / 2;
                            this._interact$.next({
                                cursor: i,
                                offsetX: s,
                                offsetY: a,
                                operation: e,
                                tag: t,
                                vertexIndex: n,
                            });
                        };
                    }
                }
                class $y extends Oy {
                    constructor(e, t, i) {
                        super(e, t),
                            (i = i || {}),
                            (this._color =
                                null == i.color ? 16777215 : i.color),
                            (this._editable = null != i.editable && i.editable),
                            (this._icon = void 0 === i.icon ? null : i.icon),
                            (this._text = void 0 === i.text ? null : i.text),
                            (this._textColor =
                                null == i.textColor ? 16777215 : i.textColor);
                    }
                    get color() {
                        return this._color;
                    }
                    set color(e) {
                        (this._color = e), this._notifyChanged$.next(this);
                    }
                    get editable() {
                        return this._editable;
                    }
                    set editable(e) {
                        (this._editable = e), this._notifyChanged$.next(this);
                    }
                    get icon() {
                        return this._icon;
                    }
                    set icon(e) {
                        (this._icon = e), this._notifyChanged$.next(this);
                    }
                    get text() {
                        return this._text;
                    }
                    set text(e) {
                        (this._text = e), this._notifyChanged$.next(this);
                    }
                    get textColor() {
                        return this._textColor;
                    }
                    set textColor(e) {
                        (this._textColor = e), this._notifyChanged$.next(this);
                    }
                    setOptions(e) {
                        (this._color = null == e.color ? this._color : e.color),
                            (this._editable =
                                null == e.editable
                                    ? this._editable
                                    : e.editable),
                            (this._icon =
                                void 0 === e.icon ? this._icon : e.icon),
                            (this._text =
                                void 0 === e.text ? this._text : e.text),
                            (this._textColor =
                                null == e.textColor
                                    ? this._textColor
                                    : e.textColor),
                            this._notifyChanged$.next(this);
                    }
                }
                class By {
                    constructor() {
                        (this._active = !1),
                            (this._hash = {}),
                            (this._hashDeactivated = {}),
                            (this._notifyChanged$ = new W());
                    }
                    get active() {
                        return this._active;
                    }
                    get changed$() {
                        return this._notifyChanged$;
                    }
                    activate(e) {
                        if (!this._active) {
                            for (const t in this._hashDeactivated) {
                                if (!this._hashDeactivated.hasOwnProperty(t))
                                    continue;
                                const i = this._hashDeactivated[t];
                                this._add(i, e);
                            }
                            (this._hashDeactivated = {}),
                                (this._active = !0),
                                this._notifyChanged$.next(this);
                        }
                    }
                    deactivate() {
                        if (this._active) {
                            for (const e in this._hash)
                                this._hash.hasOwnProperty(e) &&
                                    (this._hashDeactivated[e] =
                                        this._hash[e].tag);
                            (this._hash = {}), (this._active = !1);
                        }
                    }
                    add(e, t) {
                        this._assertActivationState(!0);
                        for (const i of e) this._add(i, t);
                        this._notifyChanged$.next(this);
                    }
                    addDeactivated(e) {
                        this._assertActivationState(!1);
                        for (const t of e) {
                            if (
                                !(
                                    t instanceof Py ||
                                    t instanceof $y ||
                                    t instanceof ky
                                )
                            )
                                throw new Error("Tag type not supported");
                            this._hashDeactivated[t.id] = t;
                        }
                    }
                    get(e) {
                        return this.has(e) ? this._hash[e] : void 0;
                    }
                    getAll() {
                        const e = this._hash;
                        return Object.keys(e).map((t) => e[t]);
                    }
                    getAllDeactivated() {
                        const e = this._hashDeactivated;
                        return Object.keys(e).map((t) => e[t]);
                    }
                    getDeactivated(e) {
                        return this.hasDeactivated(e)
                            ? this._hashDeactivated[e]
                            : void 0;
                    }
                    has(e) {
                        return e in this._hash;
                    }
                    hasDeactivated(e) {
                        return e in this._hashDeactivated;
                    }
                    remove(e) {
                        this._assertActivationState(!0);
                        const t = this._hash;
                        for (const i of e) i in t && delete t[i];
                        this._notifyChanged$.next(this);
                    }
                    removeAll() {
                        this._assertActivationState(!0),
                            (this._hash = {}),
                            this._notifyChanged$.next(this);
                    }
                    removeAllDeactivated() {
                        this._assertActivationState(!1),
                            (this._hashDeactivated = {});
                    }
                    removeDeactivated(e) {
                        this._assertActivationState(!1);
                        const t = this._hashDeactivated;
                        for (const i of e) i in t && delete t[i];
                    }
                    _add(e, t) {
                        if (e instanceof Py) this._hash[e.id] = new Ry(e, t);
                        else if (e instanceof $y)
                            this._hash[e.id] = new Uy(e, t);
                        else {
                            if (!(e instanceof ky))
                                throw new Error("Tag type not supported");
                            this._hash[e.id] = new jy(e, t);
                        }
                    }
                    _assertActivationState(e) {
                        if (e !== this._active)
                            throw new Error(
                                "Tag set not in correct state for operation."
                            );
                    }
                }
                class Fy extends UM {
                    constructor(e) {
                        super();
                        let t = e[0],
                            i = e[1];
                        if (t < 0 || t > 1 || i < 0 || i > 1)
                            throw new $M(
                                "Basic coordinates must be on the interval [0, 1]."
                            );
                        this._point = e.slice();
                    }
                    get point() {
                        return this._point;
                    }
                    getCentroid2d() {
                        return this._point.slice();
                    }
                    getCentroid3d(e) {
                        return e.unprojectBasic(this._point, 200);
                    }
                    setCentroid2d(e, t) {
                        let i = [
                            Math.max(0, Math.min(1, e[0])),
                            Math.max(0, Math.min(1, e[1])),
                        ];
                        (this._point[0] = i[0]),
                            (this._point[1] = i[1]),
                            this._notifyChanged$.next(this);
                    }
                }
                class Hy extends F_ {
                    constructor(e, t, i, n) {
                        super(e, t, i),
                            (this._name = `${
                                this._component.name
                            }-${this._getNameExtension()}`),
                            (this._viewportCoords = n);
                    }
                    _getConfiguration(e) {
                        return {};
                    }
                    _mouseEventToBasic(e, t, i, n, r, s) {
                        (r = null != r ? r : 0), (s = null != s ? s : 0);
                        const [a, o] = this._viewportCoords.canvasPosition(
                            e,
                            t
                        );
                        return this._viewportCoords.canvasToBasic(
                            a - r,
                            o - s,
                            t,
                            n,
                            i.perspective
                        );
                    }
                }
                class Gy extends Hy {
                    constructor(e, t, i, n, r) {
                        super(e, t, i, n),
                            (this._tagCreator = r),
                            (this._geometryCreated$ = new W());
                    }
                    get geometryCreated$() {
                        return this._geometryCreated$;
                    }
                    _enable() {
                        this._enableCreate(),
                            this._container.container.classList.add(
                                "component-tag-create"
                            );
                    }
                    _disable() {
                        this._container.container.classList.remove(
                            "component-tag-create"
                        ),
                            this._disableCreate();
                    }
                    _validateBasic(e) {
                        const t = e[0],
                            i = e[1];
                        return 0 <= t && t <= 1 && 0 <= i && i <= 1;
                    }
                    _mouseEventToBasic$(e) {
                        return e.pipe(
                            $t(
                                this._container.renderService.renderCamera$,
                                this._navigator.stateService.currentTransform$
                            ),
                            ke(([e, t, i]) =>
                                this._mouseEventToBasic(
                                    e,
                                    this._container.container,
                                    t,
                                    i
                                )
                            )
                        );
                    }
                }
                class Vy extends Gy {
                    _enableCreate() {
                        this._container.mouseService.deferPixels(this._name, 4),
                            (this._geometryCreatedSubscription =
                                this._mouseEventToBasic$(
                                    this._container.mouseService.proximateClick$
                                )
                                    .pipe(
                                        nt(this._validateBasic),
                                        ke((e) => new Fy(e))
                                    )
                                    .subscribe(this._geometryCreated$));
                    }
                    _disableCreate() {
                        this._container.mouseService.undeferPixels(this._name),
                            this._geometryCreatedSubscription.unsubscribe();
                    }
                    _getNameExtension() {
                        return "create-point";
                    }
                }
                class Yy extends Gy {
                    _enableCreate() {
                        this._container.mouseService.deferPixels(this._name, 4);
                        const e =
                            this._navigator.stateService.currentTransform$.pipe(
                                ke(() => {}),
                                It(1),
                                V()
                            );
                        this._deleteSubscription = e
                            .pipe(zt(1))
                            .subscribe(this._tagCreator.delete$);
                        const t = this._mouseEventToBasic$(
                            this._container.mouseService.proximateClick$
                        ).pipe(Et());
                        (this._createSubscription = e
                            .pipe(
                                kt(() => t.pipe(nt(this._validateBasic), mt(1)))
                            )
                            .subscribe(this._create$)),
                            (this._setVertexSubscription = this._tagCreator.tag$
                                .pipe(
                                    kt((e) =>
                                        e
                                            ? He(
                                                  Ce(e),
                                                  tt(
                                                      this._container
                                                          .mouseService
                                                          .mouseMove$,
                                                      this._container
                                                          .mouseService
                                                          .domMouseMove$
                                                  ),
                                                  this._container.renderService
                                                      .renderCamera$,
                                                  this._navigator.stateService
                                                      .currentTransform$
                                              )
                                            : oe()
                                    )
                                )
                                .subscribe(([e, t, i, n]) => {
                                    const r = this._mouseEventToBasic(
                                        t,
                                        this._container.container,
                                        i,
                                        n
                                    );
                                    this._setVertex2d(e, r, n);
                                })),
                            (this._addPointSubscription = this._tagCreator.tag$
                                .pipe(kt((e) => (e ? He(Ce(e), t) : oe())))
                                .subscribe(([e, t]) => {
                                    this._addPoint(e, t);
                                })),
                            (this._geometryCreateSubscription =
                                this._tagCreator.tag$
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? e.created$.pipe(
                                                      ke((e) => e.geometry)
                                                  )
                                                : oe()
                                        )
                                    )
                                    .subscribe(this._geometryCreated$));
                    }
                    _disableCreate() {
                        this._container.mouseService.undeferPixels(this._name),
                            this._tagCreator.delete$.next(null),
                            this._addPointSubscription.unsubscribe(),
                            this._createSubscription.unsubscribe(),
                            this._deleteSubscription.unsubscribe(),
                            this._geometryCreateSubscription.unsubscribe(),
                            this._setVertexSubscription.unsubscribe();
                    }
                }
                class qy extends Yy {
                    get _create$() {
                        return this._tagCreator.createPoints$;
                    }
                    _addPoint(e, t) {
                        e.geometry.addPoint2d(t);
                    }
                    _getNameExtension() {
                        return "create-points";
                    }
                    _setVertex2d(e, t, i) {
                        e.geometry.setPoint2d(
                            e.geometry.points.length - 1,
                            t,
                            i
                        );
                    }
                }
                class Wy extends Yy {
                    get _create$() {
                        return this._tagCreator.createPolygon$;
                    }
                    _addPoint(e, t) {
                        e.addPoint(t);
                    }
                    _getNameExtension() {
                        return "create-polygon";
                    }
                    _setVertex2d(e, t, i) {
                        e.geometry.setVertex2d(
                            e.geometry.polygon.length - 2,
                            t,
                            i
                        );
                    }
                }
                class Qy extends Yy {
                    get _create$() {
                        return this._tagCreator.createRect$;
                    }
                    _addPoint(e, t) {
                        const i = e.geometry;
                        i.validate(t) || (t = i.getNonAdjustedVertex2d(3)),
                            e.addPoint(t);
                    }
                    _enable() {
                        super._enable(),
                            (this._initializeAnchorIndexingSubscription =
                                this._tagCreator.tag$
                                    .pipe(nt((e) => !!e))
                                    .subscribe((e) => {
                                        e.geometry.initializeAnchorIndexing();
                                    }));
                    }
                    _disable() {
                        super._disable(),
                            this._initializeAnchorIndexingSubscription.unsubscribe();
                    }
                    _getNameExtension() {
                        return "create-rect";
                    }
                    _setVertex2d(e, t, i) {
                        e.geometry.setOppositeVertex2d(t, i);
                    }
                }
                class Zy extends Gy {
                    _enableCreate() {
                        this._container.mouseService.claimMouse(this._name, 2),
                            (this._deleteSubscription =
                                this._navigator.stateService.currentTransform$
                                    .pipe(
                                        ke((e) => null),
                                        zt(1)
                                    )
                                    .subscribe(this._tagCreator.delete$)),
                            (this._createSubscription =
                                this._mouseEventToBasic$(
                                    this._container.mouseService.filtered$(
                                        this._name,
                                        this._container.mouseService
                                            .mouseDragStart$
                                    )
                                )
                                    .pipe(nt(this._validateBasic))
                                    .subscribe(this._tagCreator.createRect$)),
                            (this._initializeAnchorIndexingSubscription =
                                this._tagCreator.tag$
                                    .pipe(nt((e) => !!e))
                                    .subscribe((e) => {
                                        e.geometry.initializeAnchorIndexing();
                                    }));
                        const e = He(
                            tt(
                                this._container.mouseService.filtered$(
                                    this._name,
                                    this._container.mouseService.mouseMove$
                                ),
                                this._container.mouseService.filtered$(
                                    this._name,
                                    this._container.mouseService.domMouseMove$
                                )
                            ),
                            this._container.renderService.renderCamera$
                        ).pipe(
                            $t(this._navigator.stateService.currentTransform$),
                            ke(([[e, t], i]) =>
                                this._mouseEventToBasic(
                                    e,
                                    this._container.container,
                                    t,
                                    i
                                )
                            )
                        );
                        this._setVertexSubscription = this._tagCreator.tag$
                            .pipe(
                                kt((t) =>
                                    t
                                        ? He(
                                              Ce(t),
                                              e,
                                              this._navigator.stateService
                                                  .currentTransform$
                                          )
                                        : oe()
                                )
                            )
                            .subscribe(([e, t, i]) => {
                                e.geometry.setOppositeVertex2d(t, i);
                            });
                        const t =
                            this._container.mouseService.mouseDragEnd$.pipe(
                                $t(
                                    this._mouseEventToBasic$(
                                        this._container.mouseService.filtered$(
                                            this._name,
                                            this._container.mouseService
                                                .mouseDrag$
                                        )
                                    ).pipe(nt(this._validateBasic)),
                                    (e, t) => t
                                ),
                                Et()
                            );
                        (this._addPointSubscription = this._tagCreator.tag$
                            .pipe(kt((e) => (e ? He(Ce(e), t) : oe())))
                            .subscribe(([e, t]) => {
                                const i = e.geometry;
                                i.validate(t) ||
                                    (t = i.getNonAdjustedVertex2d(3)),
                                    e.addPoint(t);
                            })),
                            (this._geometryCreatedSubscription =
                                this._tagCreator.tag$
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? e.created$.pipe(
                                                      ke((e) => e.geometry)
                                                  )
                                                : oe()
                                        )
                                    )
                                    .subscribe(this._geometryCreated$));
                    }
                    _disableCreate() {
                        this._container.mouseService.unclaimMouse(this._name),
                            this._tagCreator.delete$.next(null),
                            this._addPointSubscription.unsubscribe(),
                            this._createSubscription.unsubscribe(),
                            this._deleteSubscription.unsubscribe(),
                            this._geometryCreatedSubscription.unsubscribe(),
                            this._initializeAnchorIndexingSubscription.unsubscribe(),
                            this._setVertexSubscription.unsubscribe();
                    }
                    _getNameExtension() {
                        return "create-rect-drag";
                    }
                }
                class Xy extends Hy {
                    constructor(e, t, i, n, r) {
                        super(e, t, i, n), (this._tagSet = r);
                    }
                    _enable() {
                        const e = this._tagSet.changed$.pipe(
                            ke((e) => e.getAll()),
                            kt((e) => ye(e).pipe(Ye((e) => e.interact$))),
                            kt((e) =>
                                We(
                                    Ce(e),
                                    this._container.mouseService.documentMouseUp$.pipe(
                                        ke(() => ({
                                            offsetX: 0,
                                            offsetY: 0,
                                            operation: Cy.None,
                                            tag: null,
                                        })),
                                        bt()
                                    )
                                )
                            ),
                            Et()
                        );
                        tt(
                            this._container.mouseService.mouseMove$,
                            this._container.mouseService.domMouseMove$
                        ).pipe(Et()),
                            (this._claimMouseSubscription = e
                                .pipe(
                                    kt((e) =>
                                        e.tag
                                            ? this._container.mouseService
                                                  .domMouseDragStart$
                                            : oe()
                                    )
                                )
                                .subscribe(() => {
                                    this._container.mouseService.claimMouse(
                                        this._name,
                                        3
                                    );
                                })),
                            (this._cursorSubscription = e
                                .pipe(
                                    ke((e) => e.cursor),
                                    ft()
                                )
                                .subscribe((e) => {
                                    const t = [
                                        "crosshair",
                                        "move",
                                        "nesw-resize",
                                        "nwse-resize",
                                    ];
                                    for (const e of t)
                                        this._container.container.classList.remove(
                                            `component-tag-edit-${e}`
                                        );
                                    e &&
                                        this._container.container.classList.add(
                                            `component-tag-edit-${e}`
                                        );
                                })),
                            (this._unclaimMouseSubscription =
                                this._container.mouseService
                                    .filtered$(
                                        this._name,
                                        this._container.mouseService
                                            .domMouseDragEnd$
                                    )
                                    .subscribe((e) => {
                                        this._container.mouseService.unclaimMouse(
                                            this._name
                                        );
                                    })),
                            (this._preventDefaultSubscription = e
                                .pipe(
                                    kt((e) =>
                                        e.tag
                                            ? this._container.mouseService
                                                  .documentMouseMove$
                                            : oe()
                                    )
                                )
                                .subscribe((e) => {
                                    e.preventDefault();
                                })),
                            (this._updateGeometrySubscription = e
                                .pipe(
                                    kt((e) =>
                                        e.operation !== Cy.None && e.tag
                                            ? He(
                                                  this._container.mouseService
                                                      .filtered$(
                                                          this._name,
                                                          this._container
                                                              .mouseService
                                                              .domMouseDrag$
                                                      )
                                                      .pipe(
                                                          nt((e) =>
                                                              this._viewportCoords.insideElement(
                                                                  e,
                                                                  this
                                                                      ._container
                                                                      .container
                                                              )
                                                          )
                                                      ),
                                                  this._container.renderService
                                                      .renderCamera$
                                              ).pipe(
                                                  $t(
                                                      Ce(e),
                                                      this._navigator
                                                          .stateService
                                                          .currentTransform$,
                                                      ([e, t], i, n) => [
                                                          e,
                                                          t,
                                                          i,
                                                          n,
                                                      ]
                                                  )
                                              )
                                            : oe()
                                    )
                                )
                                .subscribe(([e, t, i, n]) => {
                                    const r = this._mouseEventToBasic(
                                            e,
                                            this._container.container,
                                            t,
                                            n,
                                            i.offsetX,
                                            i.offsetY
                                        ),
                                        s = i.tag.geometry;
                                    i.operation === Cy.Centroid
                                        ? s.setCentroid2d(r, n)
                                        : i.operation === Cy.Vertex &&
                                          s.setVertex2d(i.vertexIndex, r, n);
                                }));
                    }
                    _disable() {
                        this._claimMouseSubscription.unsubscribe(),
                            this._cursorSubscription.unsubscribe(),
                            this._preventDefaultSubscription.unsubscribe(),
                            this._unclaimMouseSubscription.unsubscribe(),
                            this._updateGeometrySubscription.unsubscribe();
                    }
                    _getNameExtension() {
                        return "edit-vertex";
                    }
                }
                class Jy extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i),
                            (this._tagDomRenderer = new Ny()),
                            (this._tagScene = new Dy()),
                            (this._tagSet = new By()),
                            (this._tagCreator = new Sy(this, i)),
                            (this._viewportCoords = new l_()),
                            (this._createHandlers = {
                                CreatePoint: new Vy(
                                    this,
                                    t,
                                    i,
                                    this._viewportCoords,
                                    this._tagCreator
                                ),
                                CreatePoints: new qy(
                                    this,
                                    t,
                                    i,
                                    this._viewportCoords,
                                    this._tagCreator
                                ),
                                CreatePolygon: new Wy(
                                    this,
                                    t,
                                    i,
                                    this._viewportCoords,
                                    this._tagCreator
                                ),
                                CreateRect: new Qy(
                                    this,
                                    t,
                                    i,
                                    this._viewportCoords,
                                    this._tagCreator
                                ),
                                CreateRectDrag: new Zy(
                                    this,
                                    t,
                                    i,
                                    this._viewportCoords,
                                    this._tagCreator
                                ),
                                Default: void 0,
                            }),
                            (this._editVertexHandler = new Xy(
                                this,
                                t,
                                i,
                                this._viewportCoords,
                                this._tagSet
                            )),
                            (this._renderTags$ = this._tagSet.changed$.pipe(
                                ke((e) => {
                                    const t = e.getAll();
                                    return (
                                        t.sort((e, t) => {
                                            const i = e.tag.id,
                                                n = t.tag.id;
                                            return i < n ? -1 : i > n ? 1 : 0;
                                        }),
                                        t
                                    );
                                }),
                                Et()
                            )),
                            (this._tagChanged$ = this._renderTags$.pipe(
                                kt((e) =>
                                    ye(e).pipe(
                                        Ye((e) =>
                                            tt(
                                                e.tag.changed$,
                                                e.tag.geometryChanged$
                                            )
                                        )
                                    )
                                ),
                                Et()
                            )),
                            (this._renderTagGLChanged$ = this._renderTags$.pipe(
                                kt((e) =>
                                    ye(e).pipe(Ye((e) => e.glObjectsChanged$))
                                ),
                                Et()
                            )),
                            (this._createGeometryChanged$ =
                                this._tagCreator.tag$.pipe(
                                    kt((e) =>
                                        null != e ? e.geometryChanged$ : oe()
                                    ),
                                    Et()
                                )),
                            (this._createGLObjectsChanged$ =
                                this._tagCreator.tag$.pipe(
                                    kt((e) =>
                                        null != e ? e.glObjectsChanged$ : oe()
                                    ),
                                    Et()
                                )),
                            (this._creatingConfiguration$ =
                                this._configuration$.pipe(
                                    ft(
                                        (e, t) => e.mode === t.mode,
                                        (e) => ({
                                            createColor: e.createColor,
                                            mode: e.mode,
                                        })
                                    ),
                                    It(1),
                                    V()
                                )),
                            this._creatingConfiguration$.subscribe((e) => {
                                const t = "tagmode",
                                    i = { mode: e.mode, target: this, type: t };
                                this.fire(t, i);
                            });
                    }
                    add(e) {
                        this._activated
                            ? this._navigator.stateService.currentTransform$
                                  .pipe(bt())
                                  .subscribe((t) => {
                                      this._tagSet.add(e, t);
                                      const i = e.map((e) =>
                                          this._tagSet.get(e.id)
                                      );
                                      this._tagScene.add(i);
                                  })
                            : this._tagSet.addDeactivated(e);
                    }
                    calculateRect(e) {
                        return new Promise((t, i) => {
                            this._navigator.stateService.currentTransform$
                                .pipe(
                                    bt(),
                                    ke((t) => e.getRect2d(t))
                                )
                                .subscribe(
                                    (e) => {
                                        t(e);
                                    },
                                    (e) => {
                                        i(e);
                                    }
                                );
                        });
                    }
                    create() {
                        this._tagCreator.replayedTag$
                            .pipe(
                                bt(),
                                nt((e) => !!e)
                            )
                            .subscribe((e) => {
                                e.create();
                            });
                    }
                    changeMode(e) {
                        this.configure({ mode: e });
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    get(e) {
                        if (this._activated) {
                            const t = this._tagSet.get(e);
                            return void 0 !== t ? t.tag : void 0;
                        }
                        return this._tagSet.getDeactivated(e);
                    }
                    getAll() {
                        return this.activated
                            ? this._tagSet.getAll().map((e) => e.tag)
                            : this._tagSet.getAllDeactivated();
                    }
                    getTagIdsAt(e) {
                        return new Promise((t, i) => {
                            this._container.renderService.renderCamera$
                                .pipe(
                                    bt(),
                                    ke((t) => {
                                        const i =
                                            this._viewportCoords.canvasToViewport(
                                                e[0],
                                                e[1],
                                                this._container.container
                                            );
                                        return this._tagScene.intersectObjects(
                                            i,
                                            t.perspective
                                        );
                                    })
                                )
                                .subscribe(
                                    (e) => {
                                        t(e);
                                    },
                                    (e) => {
                                        i(e);
                                    }
                                );
                        });
                    }
                    has(e) {
                        return this._activated
                            ? this._tagSet.has(e)
                            : this._tagSet.hasDeactivated(e);
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                    remove(e) {
                        this._activated
                            ? (this._tagSet.remove(e), this._tagScene.remove(e))
                            : this._tagSet.removeDeactivated(e);
                    }
                    removeAll() {
                        this._activated
                            ? (this._tagSet.removeAll(),
                              this._tagScene.removeAll())
                            : this._tagSet.removeAllDeactivated();
                    }
                    _activate() {
                        this._editVertexHandler.enable();
                        const e = ye(Object.keys(this._createHandlers)).pipe(
                                ke((e) => this._createHandlers[e]),
                                nt((e) => !!e),
                                Ye((e) => e.geometryCreated$),
                                Et()
                            ),
                            t = this._subscriptions;
                        t.push(
                            e.subscribe((e) => {
                                const t = "geometrycreate",
                                    i = { geometry: e, target: this, type: t };
                                this.fire(t, i);
                            })
                        ),
                            t.push(
                                this._tagCreator.tag$
                                    .pipe(
                                        jt((e) => null == e),
                                        ft()
                                    )
                                    .subscribe((e) => {
                                        const t =
                                                null != e
                                                    ? "tagcreatestart"
                                                    : "tagcreateend",
                                            i = { target: this, type: t };
                                        this.fire(t, i);
                                    })
                            ),
                            t.push(
                                e.subscribe(() => {
                                    this.changeMode(Iy.Default);
                                })
                            ),
                            t.push(
                                this._creatingConfiguration$.subscribe((e) => {
                                    this._disableCreateHandlers();
                                    const t = Iy[e.mode],
                                        i = this._createHandlers[t];
                                    i && i.enable();
                                })
                            ),
                            t.push(
                                this._renderTags$.subscribe(() => {
                                    const e = "tags",
                                        t = { target: this, type: e };
                                    this.fire(e, t);
                                })
                            ),
                            t.push(
                                this._tagCreator.tag$
                                    .pipe(
                                        kt((e) =>
                                            null != e
                                                ? e.aborted$.pipe(
                                                      ke(() => null)
                                                  )
                                                : oe()
                                        )
                                    )
                                    .subscribe(() => {
                                        this.changeMode(Iy.Default);
                                    })
                            ),
                            t.push(
                                this._tagCreator.tag$.subscribe((e) => {
                                    this._tagScene.hasCreateTag() &&
                                        this._tagScene.removeCreateTag(),
                                        null != e &&
                                            this._tagScene.addCreateTag(e);
                                })
                            ),
                            t.push(
                                this._createGLObjectsChanged$.subscribe((e) => {
                                    this._tagScene.updateCreateTagObjects(e);
                                })
                            ),
                            t.push(
                                this._renderTagGLChanged$.subscribe((e) => {
                                    this._tagScene.updateObjects(e);
                                })
                            ),
                            t.push(
                                this._tagChanged$.subscribe(() => {
                                    this._tagScene.update();
                                })
                            ),
                            t.push(
                                He(
                                    this._renderTags$.pipe(
                                        Ot([]),
                                        Ut(() => {
                                            this._container.domRenderer.render$.next(
                                                {
                                                    name: this._name,
                                                    vNode: this._tagDomRenderer.clear(),
                                                }
                                            );
                                        })
                                    ),
                                    this._container.renderService.renderCamera$,
                                    this._container.spriteService.spriteAtlas$,
                                    this._container.renderService.size$,
                                    this._tagChanged$.pipe(Ot(null)),
                                    tt(
                                        this._tagCreator.tag$,
                                        this._createGeometryChanged$
                                    ).pipe(Ot(null))
                                )
                                    .pipe(
                                        ke(([e, t, i, n, , r]) => ({
                                            name: this._name,
                                            vNode: this._tagDomRenderer.render(
                                                e,
                                                r,
                                                i,
                                                t.perspective,
                                                n
                                            ),
                                        }))
                                    )
                                    .subscribe(
                                        this._container.domRenderer.render$
                                    )
                            ),
                            t.push(
                                this._navigator.stateService.currentState$
                                    .pipe(
                                        ke((e) => {
                                            const t = this._tagScene;
                                            return {
                                                name: this._name,
                                                renderer: {
                                                    frameId: e.id,
                                                    needsRender: t.needsRender,
                                                    render: t.render.bind(t),
                                                    pass: i_.Opaque,
                                                },
                                            };
                                        })
                                    )
                                    .subscribe(
                                        this._container.glRenderer.render$
                                    )
                            ),
                            this._navigator.stateService.currentTransform$
                                .pipe(bt())
                                .subscribe((e) => {
                                    this._tagSet.activate(e),
                                        this._tagScene.add(
                                            this._tagSet.getAll()
                                        );
                                });
                    }
                    _deactivate() {
                        this._editVertexHandler.disable(),
                            this._disableCreateHandlers(),
                            this._tagScene.clear(),
                            this._tagSet.deactivate(),
                            this._tagCreator.delete$.next(null),
                            this._subscriptions.unsubscribe(),
                            this._container.container.classList.remove(
                                "component-tag-create"
                            );
                    }
                    _getDefaultConfiguration() {
                        return {
                            createColor: 16777215,
                            indicatePointsCompleter: !0,
                            mode: Iy.Default,
                        };
                    }
                    _disableCreateHandlers() {
                        const e = this._createHandlers;
                        for (const t in e) {
                            if (!e.hasOwnProperty(t)) continue;
                            const i = e[t];
                            i && i.disable();
                        }
                    }
                }
                Jy.componentName = "tag";
                class Ky extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i),
                            (this._viewportCoords = new l_()),
                            (this._zoomDelta$ = new W());
                    }
                    _activate() {
                        const e = this._subscriptions;
                        e.push(
                            He(
                                this._navigator.stateService.currentState$,
                                this._navigator.stateService.state$,
                                this._configuration$,
                                this._container.renderService.size$
                            )
                                .pipe(
                                    ke(([e, t, i, n]) => {
                                        const r = e.state.zoom,
                                            s = n_.h(
                                                "div.mapillary-zoom-in-icon",
                                                []
                                            ),
                                            a =
                                                r >= 3 || t === j_.Waiting
                                                    ? n_.h(
                                                          "div.mapillary-zoom-in-button-inactive",
                                                          [s]
                                                      )
                                                    : n_.h(
                                                          "div.mapillary-zoom-in-button",
                                                          {
                                                              onclick: () => {
                                                                  this._zoomDelta$.next(
                                                                      1
                                                                  );
                                                              },
                                                          },
                                                          [s]
                                                      ),
                                            o = n_.h(
                                                "div.mapillary-zoom-out-icon",
                                                []
                                            ),
                                            c =
                                                r <= 0 || t === j_.Waiting
                                                    ? n_.h(
                                                          "div.mapillary-zoom-out-button-inactive",
                                                          [o]
                                                      )
                                                    : n_.h(
                                                          "div.mapillary-zoom-out-button",
                                                          {
                                                              onclick: () => {
                                                                  this._zoomDelta$.next(
                                                                      -1
                                                                  );
                                                              },
                                                          },
                                                          [o]
                                                      ),
                                            l =
                                                i.size === t_.Small ||
                                                (i.size === t_.Automatic &&
                                                    n.width < 640)
                                                    ? ".mapillary-zoom-compact"
                                                    : "";
                                        return {
                                            name: this._name,
                                            vNode: n_.h(
                                                "div.mapillary-zoom-container" +
                                                    l,
                                                {
                                                    oncontextmenu: (e) => {
                                                        e.preventDefault();
                                                    },
                                                },
                                                [a, c]
                                            ),
                                        };
                                    })
                                )
                                .subscribe(this._container.domRenderer.render$)
                        ),
                            e.push(
                                this._zoomDelta$
                                    .pipe(
                                        $t(
                                            this._container.renderService
                                                .renderCamera$,
                                            this._navigator.stateService
                                                .currentTransform$
                                        )
                                    )
                                    .subscribe(([e, t, i]) => {
                                        const n =
                                                this._viewportCoords.unprojectFromViewport(
                                                    0,
                                                    0,
                                                    t.perspective
                                                ),
                                            r = i.projectBasic(n.toArray());
                                        this._navigator.stateService.zoomIn(
                                            e,
                                            r
                                        );
                                    })
                            );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return { size: t_.Automatic };
                    }
                }
                Ky.componentName = "zoom";
                class ex extends a_ {
                    constructor(e, t, i, n) {
                        super(e, t, i),
                            (this._canvasId = `${t.id}-${this._name}`),
                            (this._dom = n || new uM());
                    }
                    _activate() {
                        const e = this._container.domRenderer.element$.pipe(
                            ke(() =>
                                this._dom.document.getElementById(
                                    this._canvasId
                                )
                            ),
                            nt((e) => !!e),
                            ke((e) => {
                                const t = e.parentElement,
                                    i = t.offsetWidth;
                                return [
                                    e,
                                    { height: t.offsetHeight, width: i },
                                ];
                            }),
                            ft(
                                (e, t) =>
                                    e.height === t.height &&
                                    e.width === t.width,
                                ([, e]) => e
                            )
                        );
                        this._subscriptions.push(
                            He(
                                e,
                                this._navigator.stateService.currentImage$
                            ).subscribe(([[e, t], i]) => {
                                (e.width = t.width),
                                    (e.height = t.height),
                                    e
                                        .getContext("2d")
                                        .drawImage(
                                            i.image,
                                            0,
                                            0,
                                            t.width,
                                            t.height
                                        );
                            })
                        ),
                            this._container.domRenderer.renderAdaptive$.next({
                                name: this._name,
                                vNode: n_.h(`canvas#${this._canvasId}`, []),
                            });
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return {};
                    }
                }
                ex.componentName = "imagefallback";
                class tx extends a_ {
                    constructor(e, t, i) {
                        super(e, t, i),
                            (this._seqNames = {}),
                            (this._seqNames[Dp[Dp.Prev]] = "-prev"),
                            (this._seqNames[Dp[Dp.Next]] = "-next"),
                            (this._spaTopNames = {}),
                            (this._spaTopNames[Dp[Dp.TurnLeft]] = "-turn-left"),
                            (this._spaTopNames[Dp[Dp.StepLeft]] = "-left"),
                            (this._spaTopNames[Dp[Dp.StepForward]] =
                                "-forward"),
                            (this._spaTopNames[Dp[Dp.StepRight]] = "-right"),
                            (this._spaTopNames[Dp[Dp.TurnRight]] =
                                "-turn-right"),
                            (this._spaBottomNames = {}),
                            (this._spaBottomNames[Dp[Dp.TurnU]] =
                                "-turn-around"),
                            (this._spaBottomNames[Dp[Dp.StepBackward]] =
                                "-backward");
                    }
                    _activate() {
                        this._subscriptions.push(
                            He(
                                this._navigator.stateService.currentImage$,
                                this._configuration$
                            )
                                .pipe(
                                    kt(([e, t]) =>
                                        He(
                                            t.sequence
                                                ? e.sequenceEdges$.pipe(
                                                      ke((e) =>
                                                          e.edges.map(
                                                              (e) =>
                                                                  e.data
                                                                      .direction
                                                          )
                                                      )
                                                  )
                                                : Ce([]),
                                            !jp(e.cameraType) && t.spatial
                                                ? e.spatialEdges$.pipe(
                                                      ke((e) =>
                                                          e.edges.map(
                                                              (e) =>
                                                                  e.data
                                                                      .direction
                                                          )
                                                      )
                                                  )
                                                : Ce([])
                                        ).pipe(ke(([e, t]) => e.concat(t)))
                                    ),
                                    ke((e) => {
                                        const t = this._createArrowRow(
                                                this._seqNames,
                                                e
                                            ),
                                            i = this._createArrowRow(
                                                this._spaTopNames,
                                                e
                                            ),
                                            n = this._createArrowRow(
                                                this._spaBottomNames,
                                                e
                                            ),
                                            r = n_.h(
                                                "div.mapillary-navigation-sequence",
                                                t
                                            ),
                                            s = n_.h(
                                                "div.NavigationSpatialTop",
                                                i
                                            ),
                                            a = n_.h(
                                                "div.mapillary-navigation-spatial-bottom",
                                                n
                                            ),
                                            o = n_.h(
                                                "div.mapillary-navigation-spatial",
                                                [s, a]
                                            );
                                        return {
                                            name: this._name,
                                            vNode: n_.h(
                                                "div.NavigationContainer",
                                                [r, o]
                                            ),
                                        };
                                    })
                                )
                                .subscribe(this._container.domRenderer.render$)
                        );
                    }
                    _deactivate() {
                        this._subscriptions.unsubscribe();
                    }
                    _getDefaultConfiguration() {
                        return { sequence: !0, spatial: !0 };
                    }
                    _createArrowRow(e, t) {
                        const i = [];
                        for (const n in e) {
                            if (!e.hasOwnProperty(n)) continue;
                            const r = Dp[n];
                            -1 !== t.indexOf(r)
                                ? i.push(this._createVNode(r, e[n], "visible"))
                                : i.push(this._createVNode(r, e[n], "hidden"));
                        }
                        return i;
                    }
                    _createVNode(e, t, i) {
                        return n_.h(
                            `span.mapillary-navigation-button.mapillary-navigation${t}`,
                            {
                                onclick: () => {
                                    this._navigator
                                        .moveDir$(e)
                                        .subscribe(void 0, (e) => {
                                            e instanceof d_ || console.error(e);
                                        });
                                },
                                style: { visibility: i },
                            },
                            []
                        );
                    }
                }
                function ix(e) {
                    let t = e.length;
                    for (; --t >= 0; ) e[t] = 0;
                }
                tx.componentName = "navigationfallback";
                const nx = new Uint8Array([
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3,
                        3, 4, 4, 4, 4, 5, 5, 5, 5, 0,
                    ]),
                    rx = new Uint8Array([
                        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8,
                        8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
                    ]),
                    sx = new Uint8Array([
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7,
                    ]),
                    ax = new Uint8Array([
                        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2,
                        14, 1, 15,
                    ]),
                    ox = new Array(576);
                ix(ox);
                const cx = new Array(60);
                ix(cx);
                const lx = new Array(512);
                ix(lx);
                const hx = new Array(256);
                ix(hx);
                const ux = new Array(29);
                ix(ux);
                const dx = new Array(30);
                function px(e, t, i, n, r) {
                    (this.static_tree = e),
                        (this.extra_bits = t),
                        (this.extra_base = i),
                        (this.elems = n),
                        (this.max_length = r),
                        (this.has_stree = e && e.length);
                }
                let gx, mx, fx;
                function _x(e, t) {
                    (this.dyn_tree = e),
                        (this.max_code = 0),
                        (this.stat_desc = t);
                }
                ix(dx);
                const Mx = (e) => (e < 256 ? lx[e] : lx[256 + (e >>> 7)]),
                    vx = (e, t) => {
                        (e.pending_buf[e.pending++] = 255 & t),
                            (e.pending_buf[e.pending++] = (t >>> 8) & 255);
                    },
                    yx = (e, t, i) => {
                        e.bi_valid > 16 - i
                            ? ((e.bi_buf |= (t << e.bi_valid) & 65535),
                              vx(e, e.bi_buf),
                              (e.bi_buf = t >> (16 - e.bi_valid)),
                              (e.bi_valid += i - 16))
                            : ((e.bi_buf |= (t << e.bi_valid) & 65535),
                              (e.bi_valid += i));
                    },
                    xx = (e, t, i) => {
                        yx(e, i[2 * t], i[2 * t + 1]);
                    },
                    bx = (e, t) => {
                        let i = 0;
                        do {
                            (i |= 1 & e), (e >>>= 1), (i <<= 1);
                        } while (--t > 0);
                        return i >>> 1;
                    },
                    wx = (e, t, i) => {
                        const n = new Array(16);
                        let r,
                            s,
                            a = 0;
                        for (r = 1; r <= 15; r++)
                            n[r] = a = (a + i[r - 1]) << 1;
                        for (s = 0; s <= t; s++) {
                            let t = e[2 * s + 1];
                            0 !== t && (e[2 * s] = bx(n[t]++, t));
                        }
                    },
                    Tx = (e) => {
                        let t;
                        for (t = 0; t < 286; t++) e.dyn_ltree[2 * t] = 0;
                        for (t = 0; t < 30; t++) e.dyn_dtree[2 * t] = 0;
                        for (t = 0; t < 19; t++) e.bl_tree[2 * t] = 0;
                        (e.dyn_ltree[512] = 1),
                            (e.opt_len = e.static_len = 0),
                            (e.last_lit = e.matches = 0);
                    },
                    Sx = (e) => {
                        e.bi_valid > 8
                            ? vx(e, e.bi_buf)
                            : e.bi_valid > 0 &&
                              (e.pending_buf[e.pending++] = e.bi_buf),
                            (e.bi_buf = 0),
                            (e.bi_valid = 0);
                    },
                    Nx = (e, t, i, n) => {
                        const r = 2 * t,
                            s = 2 * i;
                        return e[r] < e[s] || (e[r] === e[s] && n[t] <= n[i]);
                    },
                    Dx = (e, t, i) => {
                        const n = e.heap[i];
                        let r = i << 1;
                        for (
                            ;
                            r <= e.heap_len &&
                            (r < e.heap_len &&
                                Nx(t, e.heap[r + 1], e.heap[r], e.depth) &&
                                r++,
                            !Nx(t, n, e.heap[r], e.depth));

                        )
                            (e.heap[i] = e.heap[r]), (i = r), (r <<= 1);
                        e.heap[i] = n;
                    },
                    Ix = (e, t, i) => {
                        let n,
                            r,
                            s,
                            a,
                            o = 0;
                        if (0 !== e.last_lit)
                            do {
                                (n =
                                    (e.pending_buf[e.d_buf + 2 * o] << 8) |
                                    e.pending_buf[e.d_buf + 2 * o + 1]),
                                    (r = e.pending_buf[e.l_buf + o]),
                                    o++,
                                    0 === n
                                        ? xx(e, r, t)
                                        : ((s = hx[r]),
                                          xx(e, s + 256 + 1, t),
                                          (a = nx[s]),
                                          0 !== a &&
                                              ((r -= ux[s]), yx(e, r, a)),
                                          n--,
                                          (s = Mx(n)),
                                          xx(e, s, i),
                                          (a = rx[s]),
                                          0 !== a &&
                                              ((n -= dx[s]), yx(e, n, a)));
                            } while (o < e.last_lit);
                        xx(e, 256, t);
                    },
                    Cx = (e, t) => {
                        const i = t.dyn_tree,
                            n = t.stat_desc.static_tree,
                            r = t.stat_desc.has_stree,
                            s = t.stat_desc.elems;
                        let a,
                            o,
                            c,
                            l = -1;
                        for (
                            e.heap_len = 0, e.heap_max = 573, a = 0;
                            a < s;
                            a++
                        )
                            0 !== i[2 * a]
                                ? ((e.heap[++e.heap_len] = l = a),
                                  (e.depth[a] = 0))
                                : (i[2 * a + 1] = 0);
                        for (; e.heap_len < 2; )
                            (c = e.heap[++e.heap_len] = l < 2 ? ++l : 0),
                                (i[2 * c] = 1),
                                (e.depth[c] = 0),
                                e.opt_len--,
                                r && (e.static_len -= n[2 * c + 1]);
                        for (t.max_code = l, a = e.heap_len >> 1; a >= 1; a--)
                            Dx(e, i, a);
                        c = s;
                        do {
                            (a = e.heap[1]),
                                (e.heap[1] = e.heap[e.heap_len--]),
                                Dx(e, i, 1),
                                (o = e.heap[1]),
                                (e.heap[--e.heap_max] = a),
                                (e.heap[--e.heap_max] = o),
                                (i[2 * c] = i[2 * a] + i[2 * o]),
                                (e.depth[c] =
                                    (e.depth[a] >= e.depth[o]
                                        ? e.depth[a]
                                        : e.depth[o]) + 1),
                                (i[2 * a + 1] = i[2 * o + 1] = c),
                                (e.heap[1] = c++),
                                Dx(e, i, 1);
                        } while (e.heap_len >= 2);
                        (e.heap[--e.heap_max] = e.heap[1]),
                            ((e, t) => {
                                const i = t.dyn_tree,
                                    n = t.max_code,
                                    r = t.stat_desc.static_tree,
                                    s = t.stat_desc.has_stree,
                                    a = t.stat_desc.extra_bits,
                                    o = t.stat_desc.extra_base,
                                    c = t.stat_desc.max_length;
                                let l,
                                    h,
                                    u,
                                    d,
                                    p,
                                    g,
                                    m = 0;
                                for (d = 0; d <= 15; d++) e.bl_count[d] = 0;
                                for (
                                    i[2 * e.heap[e.heap_max] + 1] = 0,
                                        l = e.heap_max + 1;
                                    l < 573;
                                    l++
                                )
                                    (h = e.heap[l]),
                                        (d = i[2 * i[2 * h + 1] + 1] + 1),
                                        d > c && ((d = c), m++),
                                        (i[2 * h + 1] = d),
                                        h > n ||
                                            (e.bl_count[d]++,
                                            (p = 0),
                                            h >= o && (p = a[h - o]),
                                            (g = i[2 * h]),
                                            (e.opt_len += g * (d + p)),
                                            s &&
                                                (e.static_len +=
                                                    g * (r[2 * h + 1] + p)));
                                if (0 !== m) {
                                    do {
                                        for (d = c - 1; 0 === e.bl_count[d]; )
                                            d--;
                                        e.bl_count[d]--,
                                            (e.bl_count[d + 1] += 2),
                                            e.bl_count[c]--,
                                            (m -= 2);
                                    } while (m > 0);
                                    for (d = c; 0 !== d; d--)
                                        for (h = e.bl_count[d]; 0 !== h; )
                                            (u = e.heap[--l]),
                                                u > n ||
                                                    (i[2 * u + 1] !== d &&
                                                        ((e.opt_len +=
                                                            (d - i[2 * u + 1]) *
                                                            i[2 * u]),
                                                        (i[2 * u + 1] = d)),
                                                    h--);
                                }
                            })(e, t),
                            wx(i, l, e.bl_count);
                    },
                    Ax = (e, t, i) => {
                        let n,
                            r,
                            s = -1,
                            a = t[1],
                            o = 0,
                            c = 7,
                            l = 4;
                        for (
                            0 === a && ((c = 138), (l = 3)),
                                t[2 * (i + 1) + 1] = 65535,
                                n = 0;
                            n <= i;
                            n++
                        )
                            (r = a),
                                (a = t[2 * (n + 1) + 1]),
                                (++o < c && r === a) ||
                                    (o < l
                                        ? (e.bl_tree[2 * r] += o)
                                        : 0 !== r
                                        ? (r !== s && e.bl_tree[2 * r]++,
                                          e.bl_tree[32]++)
                                        : o <= 10
                                        ? e.bl_tree[34]++
                                        : e.bl_tree[36]++,
                                    (o = 0),
                                    (s = r),
                                    0 === a
                                        ? ((c = 138), (l = 3))
                                        : r === a
                                        ? ((c = 6), (l = 3))
                                        : ((c = 7), (l = 4)));
                    },
                    Ex = (e, t, i) => {
                        let n,
                            r,
                            s = -1,
                            a = t[1],
                            o = 0,
                            c = 7,
                            l = 4;
                        for (
                            0 === a && ((c = 138), (l = 3)), n = 0;
                            n <= i;
                            n++
                        )
                            if (
                                ((r = a),
                                (a = t[2 * (n + 1) + 1]),
                                !(++o < c && r === a))
                            ) {
                                if (o < l)
                                    do {
                                        xx(e, r, e.bl_tree);
                                    } while (0 != --o);
                                else
                                    0 !== r
                                        ? (r !== s &&
                                              (xx(e, r, e.bl_tree), o--),
                                          xx(e, 16, e.bl_tree),
                                          yx(e, o - 3, 2))
                                        : o <= 10
                                        ? (xx(e, 17, e.bl_tree),
                                          yx(e, o - 3, 3))
                                        : (xx(e, 18, e.bl_tree),
                                          yx(e, o - 11, 7));
                                (o = 0),
                                    (s = r),
                                    0 === a
                                        ? ((c = 138), (l = 3))
                                        : r === a
                                        ? ((c = 6), (l = 3))
                                        : ((c = 7), (l = 4));
                            }
                    };
                let Lx = !1;
                const zx = (e, t, i, n) => {
                    yx(e, 0 + (n ? 1 : 0), 3),
                        ((e, t, i, n) => {
                            Sx(e),
                                vx(e, i),
                                vx(e, ~i),
                                e.pending_buf.set(
                                    e.window.subarray(t, t + i),
                                    e.pending
                                ),
                                (e.pending += i);
                        })(e, t, i);
                };
                var jx = {
                        _tr_init: (e) => {
                            Lx ||
                                ((() => {
                                    let e, t, i, n, r;
                                    const s = new Array(16);
                                    for (i = 0, n = 0; n < 28; n++)
                                        for (
                                            ux[n] = i, e = 0;
                                            e < 1 << nx[n];
                                            e++
                                        )
                                            hx[i++] = n;
                                    for (
                                        hx[i - 1] = n, r = 0, n = 0;
                                        n < 16;
                                        n++
                                    )
                                        for (
                                            dx[n] = r, e = 0;
                                            e < 1 << rx[n];
                                            e++
                                        )
                                            lx[r++] = n;
                                    for (r >>= 7; n < 30; n++)
                                        for (
                                            dx[n] = r << 7, e = 0;
                                            e < 1 << (rx[n] - 7);
                                            e++
                                        )
                                            lx[256 + r++] = n;
                                    for (t = 0; t <= 15; t++) s[t] = 0;
                                    for (e = 0; e <= 143; )
                                        (ox[2 * e + 1] = 8), e++, s[8]++;
                                    for (; e <= 255; )
                                        (ox[2 * e + 1] = 9), e++, s[9]++;
                                    for (; e <= 279; )
                                        (ox[2 * e + 1] = 7), e++, s[7]++;
                                    for (; e <= 287; )
                                        (ox[2 * e + 1] = 8), e++, s[8]++;
                                    for (wx(ox, 287, s), e = 0; e < 30; e++)
                                        (cx[2 * e + 1] = 5),
                                            (cx[2 * e] = bx(e, 5));
                                    (gx = new px(ox, nx, 257, 286, 15)),
                                        (mx = new px(cx, rx, 0, 30, 15)),
                                        (fx = new px(
                                            new Array(0),
                                            sx,
                                            0,
                                            19,
                                            7
                                        ));
                                })(),
                                (Lx = !0)),
                                (e.l_desc = new _x(e.dyn_ltree, gx)),
                                (e.d_desc = new _x(e.dyn_dtree, mx)),
                                (e.bl_desc = new _x(e.bl_tree, fx)),
                                (e.bi_buf = 0),
                                (e.bi_valid = 0),
                                Tx(e);
                        },
                        _tr_stored_block: zx,
                        _tr_flush_block: (e, t, i, n) => {
                            let r,
                                s,
                                a = 0;
                            e.level > 0
                                ? (2 === e.strm.data_type &&
                                      (e.strm.data_type = ((e) => {
                                          let t,
                                              i = 4093624447;
                                          for (t = 0; t <= 31; t++, i >>>= 1)
                                              if (
                                                  1 & i &&
                                                  0 !== e.dyn_ltree[2 * t]
                                              )
                                                  return 0;
                                          if (
                                              0 !== e.dyn_ltree[18] ||
                                              0 !== e.dyn_ltree[20] ||
                                              0 !== e.dyn_ltree[26]
                                          )
                                              return 1;
                                          for (t = 32; t < 256; t++)
                                              if (0 !== e.dyn_ltree[2 * t])
                                                  return 1;
                                          return 0;
                                      })(e)),
                                  Cx(e, e.l_desc),
                                  Cx(e, e.d_desc),
                                  (a = ((e) => {
                                      let t;
                                      for (
                                          Ax(e, e.dyn_ltree, e.l_desc.max_code),
                                              Ax(
                                                  e,
                                                  e.dyn_dtree,
                                                  e.d_desc.max_code
                                              ),
                                              Cx(e, e.bl_desc),
                                              t = 18;
                                          t >= 3 &&
                                          0 === e.bl_tree[2 * ax[t] + 1];
                                          t--
                                      );
                                      return (
                                          (e.opt_len +=
                                              3 * (t + 1) + 5 + 5 + 4),
                                          t
                                      );
                                  })(e)),
                                  (r = (e.opt_len + 3 + 7) >>> 3),
                                  (s = (e.static_len + 3 + 7) >>> 3),
                                  s <= r && (r = s))
                                : (r = s = i + 5),
                                i + 4 <= r && -1 !== t
                                    ? zx(e, t, i, n)
                                    : 4 === e.strategy || s === r
                                    ? (yx(e, 2 + (n ? 1 : 0), 3), Ix(e, ox, cx))
                                    : (yx(e, 4 + (n ? 1 : 0), 3),
                                      ((e, t, i, n) => {
                                          let r;
                                          for (
                                              yx(e, t - 257, 5),
                                                  yx(e, i - 1, 5),
                                                  yx(e, n - 4, 4),
                                                  r = 0;
                                              r < n;
                                              r++
                                          )
                                              yx(
                                                  e,
                                                  e.bl_tree[2 * ax[r] + 1],
                                                  3
                                              );
                                          Ex(e, e.dyn_ltree, t - 1),
                                              Ex(e, e.dyn_dtree, i - 1);
                                      })(
                                          e,
                                          e.l_desc.max_code + 1,
                                          e.d_desc.max_code + 1,
                                          a + 1
                                      ),
                                      Ix(e, e.dyn_ltree, e.dyn_dtree)),
                                Tx(e),
                                n && Sx(e);
                        },
                        _tr_tally: (e, t, i) => (
                            (e.pending_buf[e.d_buf + 2 * e.last_lit] =
                                (t >>> 8) & 255),
                            (e.pending_buf[e.d_buf + 2 * e.last_lit + 1] =
                                255 & t),
                            (e.pending_buf[e.l_buf + e.last_lit] = 255 & i),
                            e.last_lit++,
                            0 === t
                                ? e.dyn_ltree[2 * i]++
                                : (e.matches++,
                                  t--,
                                  e.dyn_ltree[2 * (hx[i] + 256 + 1)]++,
                                  e.dyn_dtree[2 * Mx(t)]++),
                            e.last_lit === e.lit_bufsize - 1
                        ),
                        _tr_align: (e) => {
                            yx(e, 2, 3),
                                xx(e, 256, ox),
                                ((e) => {
                                    16 === e.bi_valid
                                        ? (vx(e, e.bi_buf),
                                          (e.bi_buf = 0),
                                          (e.bi_valid = 0))
                                        : e.bi_valid >= 8 &&
                                          ((e.pending_buf[e.pending++] =
                                              255 & e.bi_buf),
                                          (e.bi_buf >>= 8),
                                          (e.bi_valid -= 8));
                                })(e);
                        },
                    },
                    Ox = (e, t, i, n) => {
                        let r = 65535 & e,
                            s = (e >>> 16) & 65535,
                            a = 0;
                        for (; 0 !== i; ) {
                            (a = i > 2e3 ? 2e3 : i), (i -= a);
                            do {
                                (r = (r + t[n++]) | 0), (s = (s + r) | 0);
                            } while (--a);
                            (r %= 65521), (s %= 65521);
                        }
                        return r | (s << 16);
                    };
                const kx = new Uint32Array(
                    (() => {
                        let e,
                            t = [];
                        for (var i = 0; i < 256; i++) {
                            e = i;
                            for (var n = 0; n < 8; n++)
                                e = 1 & e ? 3988292384 ^ (e >>> 1) : e >>> 1;
                            t[i] = e;
                        }
                        return t;
                    })()
                );
                var Rx = (e, t, i, n) => {
                        const r = kx,
                            s = n + i;
                        e ^= -1;
                        for (let i = n; i < s; i++)
                            e = (e >>> 8) ^ r[255 & (e ^ t[i])];
                        return ~e;
                    },
                    Px = {
                        2: "need dictionary",
                        1: "stream end",
                        0: "",
                        "-1": "file error",
                        "-2": "stream error",
                        "-3": "data error",
                        "-4": "insufficient memory",
                        "-5": "buffer error",
                        "-6": "incompatible version",
                    },
                    Ux = {
                        Z_NO_FLUSH: 0,
                        Z_PARTIAL_FLUSH: 1,
                        Z_SYNC_FLUSH: 2,
                        Z_FULL_FLUSH: 3,
                        Z_FINISH: 4,
                        Z_BLOCK: 5,
                        Z_TREES: 6,
                        Z_OK: 0,
                        Z_STREAM_END: 1,
                        Z_NEED_DICT: 2,
                        Z_ERRNO: -1,
                        Z_STREAM_ERROR: -2,
                        Z_DATA_ERROR: -3,
                        Z_MEM_ERROR: -4,
                        Z_BUF_ERROR: -5,
                        Z_NO_COMPRESSION: 0,
                        Z_BEST_SPEED: 1,
                        Z_BEST_COMPRESSION: 9,
                        Z_DEFAULT_COMPRESSION: -1,
                        Z_FILTERED: 1,
                        Z_HUFFMAN_ONLY: 2,
                        Z_RLE: 3,
                        Z_FIXED: 4,
                        Z_DEFAULT_STRATEGY: 0,
                        Z_BINARY: 0,
                        Z_TEXT: 1,
                        Z_UNKNOWN: 2,
                        Z_DEFLATED: 8,
                    };
                const {
                        _tr_init: $x,
                        _tr_stored_block: Bx,
                        _tr_flush_block: Fx,
                        _tr_tally: Hx,
                        _tr_align: Gx,
                    } = jx,
                    {
                        Z_NO_FLUSH: Vx,
                        Z_PARTIAL_FLUSH: Yx,
                        Z_FULL_FLUSH: qx,
                        Z_FINISH: Wx,
                        Z_BLOCK: Qx,
                        Z_OK: Zx,
                        Z_STREAM_END: Xx,
                        Z_STREAM_ERROR: Jx,
                        Z_DATA_ERROR: Kx,
                        Z_BUF_ERROR: eb,
                        Z_DEFAULT_COMPRESSION: tb,
                        Z_FILTERED: ib,
                        Z_HUFFMAN_ONLY: nb,
                        Z_RLE: rb,
                        Z_FIXED: sb,
                        Z_DEFAULT_STRATEGY: ab,
                        Z_UNKNOWN: ob,
                        Z_DEFLATED: cb,
                    } = Ux,
                    lb = 258,
                    hb = 262,
                    ub = 103,
                    db = 113,
                    pb = 666,
                    gb = (e, t) => ((e.msg = Px[t]), t),
                    mb = (e) => (e << 1) - (e > 4 ? 9 : 0),
                    fb = (e) => {
                        let t = e.length;
                        for (; --t >= 0; ) e[t] = 0;
                    };
                let _b = (e, t, i) => ((t << e.hash_shift) ^ i) & e.hash_mask;
                const Mb = (e) => {
                        const t = e.state;
                        let i = t.pending;
                        i > e.avail_out && (i = e.avail_out),
                            0 !== i &&
                                (e.output.set(
                                    t.pending_buf.subarray(
                                        t.pending_out,
                                        t.pending_out + i
                                    ),
                                    e.next_out
                                ),
                                (e.next_out += i),
                                (t.pending_out += i),
                                (e.total_out += i),
                                (e.avail_out -= i),
                                (t.pending -= i),
                                0 === t.pending && (t.pending_out = 0));
                    },
                    vb = (e, t) => {
                        Fx(
                            e,
                            e.block_start >= 0 ? e.block_start : -1,
                            e.strstart - e.block_start,
                            t
                        ),
                            (e.block_start = e.strstart),
                            Mb(e.strm);
                    },
                    yb = (e, t) => {
                        e.pending_buf[e.pending++] = t;
                    },
                    xb = (e, t) => {
                        (e.pending_buf[e.pending++] = (t >>> 8) & 255),
                            (e.pending_buf[e.pending++] = 255 & t);
                    },
                    bb = (e, t, i, n) => {
                        let r = e.avail_in;
                        return (
                            r > n && (r = n),
                            0 === r
                                ? 0
                                : ((e.avail_in -= r),
                                  t.set(
                                      e.input.subarray(
                                          e.next_in,
                                          e.next_in + r
                                      ),
                                      i
                                  ),
                                  1 === e.state.wrap
                                      ? (e.adler = Ox(e.adler, t, r, i))
                                      : 2 === e.state.wrap &&
                                        (e.adler = Rx(e.adler, t, r, i)),
                                  (e.next_in += r),
                                  (e.total_in += r),
                                  r)
                        );
                    },
                    wb = (e, t) => {
                        let i,
                            n,
                            r = e.max_chain_length,
                            s = e.strstart,
                            a = e.prev_length,
                            o = e.nice_match;
                        const c =
                                e.strstart > e.w_size - hb
                                    ? e.strstart - (e.w_size - hb)
                                    : 0,
                            l = e.window,
                            h = e.w_mask,
                            u = e.prev,
                            d = e.strstart + lb;
                        let p = l[s + a - 1],
                            g = l[s + a];
                        e.prev_length >= e.good_match && (r >>= 2),
                            o > e.lookahead && (o = e.lookahead);
                        do {
                            if (
                                ((i = t),
                                l[i + a] === g &&
                                    l[i + a - 1] === p &&
                                    l[i] === l[s] &&
                                    l[++i] === l[s + 1])
                            ) {
                                (s += 2), i++;
                                do {} while (
                                    l[++s] === l[++i] &&
                                    l[++s] === l[++i] &&
                                    l[++s] === l[++i] &&
                                    l[++s] === l[++i] &&
                                    l[++s] === l[++i] &&
                                    l[++s] === l[++i] &&
                                    l[++s] === l[++i] &&
                                    l[++s] === l[++i] &&
                                    s < d
                                );
                                if (((n = lb - (d - s)), (s = d - lb), n > a)) {
                                    if (((e.match_start = t), (a = n), n >= o))
                                        break;
                                    (p = l[s + a - 1]), (g = l[s + a]);
                                }
                            }
                        } while ((t = u[t & h]) > c && 0 != --r);
                        return a <= e.lookahead ? a : e.lookahead;
                    },
                    Tb = (e) => {
                        const t = e.w_size;
                        let i, n, r, s, a;
                        do {
                            if (
                                ((s = e.window_size - e.lookahead - e.strstart),
                                e.strstart >= t + (t - hb))
                            ) {
                                e.window.set(e.window.subarray(t, t + t), 0),
                                    (e.match_start -= t),
                                    (e.strstart -= t),
                                    (e.block_start -= t),
                                    (n = e.hash_size),
                                    (i = n);
                                do {
                                    (r = e.head[--i]),
                                        (e.head[i] = r >= t ? r - t : 0);
                                } while (--n);
                                (n = t), (i = n);
                                do {
                                    (r = e.prev[--i]),
                                        (e.prev[i] = r >= t ? r - t : 0);
                                } while (--n);
                                s += t;
                            }
                            if (0 === e.strm.avail_in) break;
                            if (
                                ((n = bb(
                                    e.strm,
                                    e.window,
                                    e.strstart + e.lookahead,
                                    s
                                )),
                                (e.lookahead += n),
                                e.lookahead + e.insert >= 3)
                            )
                                for (
                                    a = e.strstart - e.insert,
                                        e.ins_h = e.window[a],
                                        e.ins_h = _b(
                                            e,
                                            e.ins_h,
                                            e.window[a + 1]
                                        );
                                    e.insert &&
                                    ((e.ins_h = _b(
                                        e,
                                        e.ins_h,
                                        e.window[a + 3 - 1]
                                    )),
                                    (e.prev[a & e.w_mask] = e.head[e.ins_h]),
                                    (e.head[e.ins_h] = a),
                                    a++,
                                    e.insert--,
                                    !(e.lookahead + e.insert < 3));

                                );
                        } while (e.lookahead < hb && 0 !== e.strm.avail_in);
                    },
                    Sb = (e, t) => {
                        let i, n;
                        for (;;) {
                            if (e.lookahead < hb) {
                                if ((Tb(e), e.lookahead < hb && t === Vx))
                                    return 1;
                                if (0 === e.lookahead) break;
                            }
                            if (
                                ((i = 0),
                                e.lookahead >= 3 &&
                                    ((e.ins_h = _b(
                                        e,
                                        e.ins_h,
                                        e.window[e.strstart + 3 - 1]
                                    )),
                                    (i = e.prev[e.strstart & e.w_mask] =
                                        e.head[e.ins_h]),
                                    (e.head[e.ins_h] = e.strstart)),
                                0 !== i &&
                                    e.strstart - i <= e.w_size - hb &&
                                    (e.match_length = wb(e, i)),
                                e.match_length >= 3)
                            )
                                if (
                                    ((n = Hx(
                                        e,
                                        e.strstart - e.match_start,
                                        e.match_length - 3
                                    )),
                                    (e.lookahead -= e.match_length),
                                    e.match_length <= e.max_lazy_match &&
                                        e.lookahead >= 3)
                                ) {
                                    e.match_length--;
                                    do {
                                        e.strstart++,
                                            (e.ins_h = _b(
                                                e,
                                                e.ins_h,
                                                e.window[e.strstart + 3 - 1]
                                            )),
                                            (i = e.prev[e.strstart & e.w_mask] =
                                                e.head[e.ins_h]),
                                            (e.head[e.ins_h] = e.strstart);
                                    } while (0 != --e.match_length);
                                    e.strstart++;
                                } else
                                    (e.strstart += e.match_length),
                                        (e.match_length = 0),
                                        (e.ins_h = e.window[e.strstart]),
                                        (e.ins_h = _b(
                                            e,
                                            e.ins_h,
                                            e.window[e.strstart + 1]
                                        ));
                            else
                                (n = Hx(e, 0, e.window[e.strstart])),
                                    e.lookahead--,
                                    e.strstart++;
                            if (n && (vb(e, !1), 0 === e.strm.avail_out))
                                return 1;
                        }
                        return (
                            (e.insert = e.strstart < 2 ? e.strstart : 2),
                            t === Wx
                                ? (vb(e, !0), 0 === e.strm.avail_out ? 3 : 4)
                                : e.last_lit &&
                                  (vb(e, !1), 0 === e.strm.avail_out)
                                ? 1
                                : 2
                        );
                    },
                    Nb = (e, t) => {
                        let i, n, r;
                        for (;;) {
                            if (e.lookahead < hb) {
                                if ((Tb(e), e.lookahead < hb && t === Vx))
                                    return 1;
                                if (0 === e.lookahead) break;
                            }
                            if (
                                ((i = 0),
                                e.lookahead >= 3 &&
                                    ((e.ins_h = _b(
                                        e,
                                        e.ins_h,
                                        e.window[e.strstart + 3 - 1]
                                    )),
                                    (i = e.prev[e.strstart & e.w_mask] =
                                        e.head[e.ins_h]),
                                    (e.head[e.ins_h] = e.strstart)),
                                (e.prev_length = e.match_length),
                                (e.prev_match = e.match_start),
                                (e.match_length = 2),
                                0 !== i &&
                                    e.prev_length < e.max_lazy_match &&
                                    e.strstart - i <= e.w_size - hb &&
                                    ((e.match_length = wb(e, i)),
                                    e.match_length <= 5 &&
                                        (e.strategy === ib ||
                                            (3 === e.match_length &&
                                                e.strstart - e.match_start >
                                                    4096)) &&
                                        (e.match_length = 2)),
                                e.prev_length >= 3 &&
                                    e.match_length <= e.prev_length)
                            ) {
                                (r = e.strstart + e.lookahead - 3),
                                    (n = Hx(
                                        e,
                                        e.strstart - 1 - e.prev_match,
                                        e.prev_length - 3
                                    )),
                                    (e.lookahead -= e.prev_length - 1),
                                    (e.prev_length -= 2);
                                do {
                                    ++e.strstart <= r &&
                                        ((e.ins_h = _b(
                                            e,
                                            e.ins_h,
                                            e.window[e.strstart + 3 - 1]
                                        )),
                                        (i = e.prev[e.strstart & e.w_mask] =
                                            e.head[e.ins_h]),
                                        (e.head[e.ins_h] = e.strstart));
                                } while (0 != --e.prev_length);
                                if (
                                    ((e.match_available = 0),
                                    (e.match_length = 2),
                                    e.strstart++,
                                    n && (vb(e, !1), 0 === e.strm.avail_out))
                                )
                                    return 1;
                            } else if (e.match_available) {
                                if (
                                    ((n = Hx(e, 0, e.window[e.strstart - 1])),
                                    n && vb(e, !1),
                                    e.strstart++,
                                    e.lookahead--,
                                    0 === e.strm.avail_out)
                                )
                                    return 1;
                            } else
                                (e.match_available = 1),
                                    e.strstart++,
                                    e.lookahead--;
                        }
                        return (
                            e.match_available &&
                                ((n = Hx(e, 0, e.window[e.strstart - 1])),
                                (e.match_available = 0)),
                            (e.insert = e.strstart < 2 ? e.strstart : 2),
                            t === Wx
                                ? (vb(e, !0), 0 === e.strm.avail_out ? 3 : 4)
                                : e.last_lit &&
                                  (vb(e, !1), 0 === e.strm.avail_out)
                                ? 1
                                : 2
                        );
                    };
                function Db(e, t, i, n, r) {
                    (this.good_length = e),
                        (this.max_lazy = t),
                        (this.nice_length = i),
                        (this.max_chain = n),
                        (this.func = r);
                }
                const Ib = [
                    new Db(0, 0, 0, 0, (e, t) => {
                        let i = 65535;
                        for (
                            i > e.pending_buf_size - 5 &&
                            (i = e.pending_buf_size - 5);
                            ;

                        ) {
                            if (e.lookahead <= 1) {
                                if ((Tb(e), 0 === e.lookahead && t === Vx))
                                    return 1;
                                if (0 === e.lookahead) break;
                            }
                            (e.strstart += e.lookahead), (e.lookahead = 0);
                            const n = e.block_start + i;
                            if (
                                (0 === e.strstart || e.strstart >= n) &&
                                ((e.lookahead = e.strstart - n),
                                (e.strstart = n),
                                vb(e, !1),
                                0 === e.strm.avail_out)
                            )
                                return 1;
                            if (
                                e.strstart - e.block_start >= e.w_size - hb &&
                                (vb(e, !1), 0 === e.strm.avail_out)
                            )
                                return 1;
                        }
                        return (
                            (e.insert = 0),
                            t === Wx
                                ? (vb(e, !0), 0 === e.strm.avail_out ? 3 : 4)
                                : (e.strstart > e.block_start &&
                                      (vb(e, !1), e.strm.avail_out),
                                  1)
                        );
                    }),
                    new Db(4, 4, 8, 4, Sb),
                    new Db(4, 5, 16, 8, Sb),
                    new Db(4, 6, 32, 32, Sb),
                    new Db(4, 4, 16, 16, Nb),
                    new Db(8, 16, 32, 32, Nb),
                    new Db(8, 16, 128, 128, Nb),
                    new Db(8, 32, 128, 256, Nb),
                    new Db(32, 128, 258, 1024, Nb),
                    new Db(32, 258, 258, 4096, Nb),
                ];
                function Cb() {
                    (this.strm = null),
                        (this.status = 0),
                        (this.pending_buf = null),
                        (this.pending_buf_size = 0),
                        (this.pending_out = 0),
                        (this.pending = 0),
                        (this.wrap = 0),
                        (this.gzhead = null),
                        (this.gzindex = 0),
                        (this.method = cb),
                        (this.last_flush = -1),
                        (this.w_size = 0),
                        (this.w_bits = 0),
                        (this.w_mask = 0),
                        (this.window = null),
                        (this.window_size = 0),
                        (this.prev = null),
                        (this.head = null),
                        (this.ins_h = 0),
                        (this.hash_size = 0),
                        (this.hash_bits = 0),
                        (this.hash_mask = 0),
                        (this.hash_shift = 0),
                        (this.block_start = 0),
                        (this.match_length = 0),
                        (this.prev_match = 0),
                        (this.match_available = 0),
                        (this.strstart = 0),
                        (this.match_start = 0),
                        (this.lookahead = 0),
                        (this.prev_length = 0),
                        (this.max_chain_length = 0),
                        (this.max_lazy_match = 0),
                        (this.level = 0),
                        (this.strategy = 0),
                        (this.good_match = 0),
                        (this.nice_match = 0),
                        (this.dyn_ltree = new Uint16Array(1146)),
                        (this.dyn_dtree = new Uint16Array(122)),
                        (this.bl_tree = new Uint16Array(78)),
                        fb(this.dyn_ltree),
                        fb(this.dyn_dtree),
                        fb(this.bl_tree),
                        (this.l_desc = null),
                        (this.d_desc = null),
                        (this.bl_desc = null),
                        (this.bl_count = new Uint16Array(16)),
                        (this.heap = new Uint16Array(573)),
                        fb(this.heap),
                        (this.heap_len = 0),
                        (this.heap_max = 0),
                        (this.depth = new Uint16Array(573)),
                        fb(this.depth),
                        (this.l_buf = 0),
                        (this.lit_bufsize = 0),
                        (this.last_lit = 0),
                        (this.d_buf = 0),
                        (this.opt_len = 0),
                        (this.static_len = 0),
                        (this.matches = 0),
                        (this.insert = 0),
                        (this.bi_buf = 0),
                        (this.bi_valid = 0);
                }
                const Ab = (e) => {
                        if (!e || !e.state) return gb(e, Jx);
                        (e.total_in = e.total_out = 0), (e.data_type = ob);
                        const t = e.state;
                        return (
                            (t.pending = 0),
                            (t.pending_out = 0),
                            t.wrap < 0 && (t.wrap = -t.wrap),
                            (t.status = t.wrap ? 42 : db),
                            (e.adler = 2 === t.wrap ? 0 : 1),
                            (t.last_flush = Vx),
                            $x(t),
                            Zx
                        );
                    },
                    Eb = (e) => {
                        const t = Ab(e);
                        var i;
                        return (
                            t === Zx &&
                                (((i = e.state).window_size = 2 * i.w_size),
                                fb(i.head),
                                (i.max_lazy_match = Ib[i.level].max_lazy),
                                (i.good_match = Ib[i.level].good_length),
                                (i.nice_match = Ib[i.level].nice_length),
                                (i.max_chain_length = Ib[i.level].max_chain),
                                (i.strstart = 0),
                                (i.block_start = 0),
                                (i.lookahead = 0),
                                (i.insert = 0),
                                (i.match_length = i.prev_length = 2),
                                (i.match_available = 0),
                                (i.ins_h = 0)),
                            t
                        );
                    },
                    Lb = (e, t, i, n, r, s) => {
                        if (!e) return Jx;
                        let a = 1;
                        if (
                            (t === tb && (t = 6),
                            n < 0
                                ? ((a = 0), (n = -n))
                                : n > 15 && ((a = 2), (n -= 16)),
                            r < 1 ||
                                r > 9 ||
                                i !== cb ||
                                n < 8 ||
                                n > 15 ||
                                t < 0 ||
                                t > 9 ||
                                s < 0 ||
                                s > sb)
                        )
                            return gb(e, Jx);
                        8 === n && (n = 9);
                        const o = new Cb();
                        return (
                            (e.state = o),
                            (o.strm = e),
                            (o.wrap = a),
                            (o.gzhead = null),
                            (o.w_bits = n),
                            (o.w_size = 1 << o.w_bits),
                            (o.w_mask = o.w_size - 1),
                            (o.hash_bits = r + 7),
                            (o.hash_size = 1 << o.hash_bits),
                            (o.hash_mask = o.hash_size - 1),
                            (o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3)),
                            (o.window = new Uint8Array(2 * o.w_size)),
                            (o.head = new Uint16Array(o.hash_size)),
                            (o.prev = new Uint16Array(o.w_size)),
                            (o.lit_bufsize = 1 << (r + 6)),
                            (o.pending_buf_size = 4 * o.lit_bufsize),
                            (o.pending_buf = new Uint8Array(
                                o.pending_buf_size
                            )),
                            (o.d_buf = 1 * o.lit_bufsize),
                            (o.l_buf = 3 * o.lit_bufsize),
                            (o.level = t),
                            (o.strategy = s),
                            (o.method = i),
                            Eb(e)
                        );
                    };
                var zb = Lb,
                    jb = (e, t) =>
                        e && e.state
                            ? 2 !== e.state.wrap
                                ? Jx
                                : ((e.state.gzhead = t), Zx)
                            : Jx,
                    Ob = (e, t) => {
                        let i, n;
                        if (!e || !e.state || t > Qx || t < 0)
                            return e ? gb(e, Jx) : Jx;
                        const r = e.state;
                        if (
                            !e.output ||
                            (!e.input && 0 !== e.avail_in) ||
                            (r.status === pb && t !== Wx)
                        )
                            return gb(e, 0 === e.avail_out ? eb : Jx);
                        r.strm = e;
                        const s = r.last_flush;
                        if (((r.last_flush = t), 42 === r.status))
                            if (2 === r.wrap)
                                (e.adler = 0),
                                    yb(r, 31),
                                    yb(r, 139),
                                    yb(r, 8),
                                    r.gzhead
                                        ? (yb(
                                              r,
                                              (r.gzhead.text ? 1 : 0) +
                                                  (r.gzhead.hcrc ? 2 : 0) +
                                                  (r.gzhead.extra ? 4 : 0) +
                                                  (r.gzhead.name ? 8 : 0) +
                                                  (r.gzhead.comment ? 16 : 0)
                                          ),
                                          yb(r, 255 & r.gzhead.time),
                                          yb(r, (r.gzhead.time >> 8) & 255),
                                          yb(r, (r.gzhead.time >> 16) & 255),
                                          yb(r, (r.gzhead.time >> 24) & 255),
                                          yb(
                                              r,
                                              9 === r.level
                                                  ? 2
                                                  : r.strategy >= nb ||
                                                    r.level < 2
                                                  ? 4
                                                  : 0
                                          ),
                                          yb(r, 255 & r.gzhead.os),
                                          r.gzhead.extra &&
                                              r.gzhead.extra.length &&
                                              (yb(
                                                  r,
                                                  255 & r.gzhead.extra.length
                                              ),
                                              yb(
                                                  r,
                                                  (r.gzhead.extra.length >> 8) &
                                                      255
                                              )),
                                          r.gzhead.hcrc &&
                                              (e.adler = Rx(
                                                  e.adler,
                                                  r.pending_buf,
                                                  r.pending,
                                                  0
                                              )),
                                          (r.gzindex = 0),
                                          (r.status = 69))
                                        : (yb(r, 0),
                                          yb(r, 0),
                                          yb(r, 0),
                                          yb(r, 0),
                                          yb(r, 0),
                                          yb(
                                              r,
                                              9 === r.level
                                                  ? 2
                                                  : r.strategy >= nb ||
                                                    r.level < 2
                                                  ? 4
                                                  : 0
                                          ),
                                          yb(r, 3),
                                          (r.status = db));
                            else {
                                let t = (cb + ((r.w_bits - 8) << 4)) << 8,
                                    i = -1;
                                (i =
                                    r.strategy >= nb || r.level < 2
                                        ? 0
                                        : r.level < 6
                                        ? 1
                                        : 6 === r.level
                                        ? 2
                                        : 3),
                                    (t |= i << 6),
                                    0 !== r.strstart && (t |= 32),
                                    (t += 31 - (t % 31)),
                                    (r.status = db),
                                    xb(r, t),
                                    0 !== r.strstart &&
                                        (xb(r, e.adler >>> 16),
                                        xb(r, 65535 & e.adler)),
                                    (e.adler = 1);
                            }
                        if (69 === r.status)
                            if (r.gzhead.extra) {
                                for (
                                    i = r.pending;
                                    r.gzindex <
                                        (65535 & r.gzhead.extra.length) &&
                                    (r.pending !== r.pending_buf_size ||
                                        (r.gzhead.hcrc &&
                                            r.pending > i &&
                                            (e.adler = Rx(
                                                e.adler,
                                                r.pending_buf,
                                                r.pending - i,
                                                i
                                            )),
                                        Mb(e),
                                        (i = r.pending),
                                        r.pending !== r.pending_buf_size));

                                )
                                    yb(r, 255 & r.gzhead.extra[r.gzindex]),
                                        r.gzindex++;
                                r.gzhead.hcrc &&
                                    r.pending > i &&
                                    (e.adler = Rx(
                                        e.adler,
                                        r.pending_buf,
                                        r.pending - i,
                                        i
                                    )),
                                    r.gzindex === r.gzhead.extra.length &&
                                        ((r.gzindex = 0), (r.status = 73));
                            } else r.status = 73;
                        if (73 === r.status)
                            if (r.gzhead.name) {
                                i = r.pending;
                                do {
                                    if (
                                        r.pending === r.pending_buf_size &&
                                        (r.gzhead.hcrc &&
                                            r.pending > i &&
                                            (e.adler = Rx(
                                                e.adler,
                                                r.pending_buf,
                                                r.pending - i,
                                                i
                                            )),
                                        Mb(e),
                                        (i = r.pending),
                                        r.pending === r.pending_buf_size)
                                    ) {
                                        n = 1;
                                        break;
                                    }
                                    (n =
                                        r.gzindex < r.gzhead.name.length
                                            ? 255 &
                                              r.gzhead.name.charCodeAt(
                                                  r.gzindex++
                                              )
                                            : 0),
                                        yb(r, n);
                                } while (0 !== n);
                                r.gzhead.hcrc &&
                                    r.pending > i &&
                                    (e.adler = Rx(
                                        e.adler,
                                        r.pending_buf,
                                        r.pending - i,
                                        i
                                    )),
                                    0 === n &&
                                        ((r.gzindex = 0), (r.status = 91));
                            } else r.status = 91;
                        if (91 === r.status)
                            if (r.gzhead.comment) {
                                i = r.pending;
                                do {
                                    if (
                                        r.pending === r.pending_buf_size &&
                                        (r.gzhead.hcrc &&
                                            r.pending > i &&
                                            (e.adler = Rx(
                                                e.adler,
                                                r.pending_buf,
                                                r.pending - i,
                                                i
                                            )),
                                        Mb(e),
                                        (i = r.pending),
                                        r.pending === r.pending_buf_size)
                                    ) {
                                        n = 1;
                                        break;
                                    }
                                    (n =
                                        r.gzindex < r.gzhead.comment.length
                                            ? 255 &
                                              r.gzhead.comment.charCodeAt(
                                                  r.gzindex++
                                              )
                                            : 0),
                                        yb(r, n);
                                } while (0 !== n);
                                r.gzhead.hcrc &&
                                    r.pending > i &&
                                    (e.adler = Rx(
                                        e.adler,
                                        r.pending_buf,
                                        r.pending - i,
                                        i
                                    )),
                                    0 === n && (r.status = ub);
                            } else r.status = ub;
                        if (
                            (r.status === ub &&
                                (r.gzhead.hcrc
                                    ? (r.pending + 2 > r.pending_buf_size &&
                                          Mb(e),
                                      r.pending + 2 <= r.pending_buf_size &&
                                          (yb(r, 255 & e.adler),
                                          yb(r, (e.adler >> 8) & 255),
                                          (e.adler = 0),
                                          (r.status = db)))
                                    : (r.status = db)),
                            0 !== r.pending)
                        ) {
                            if ((Mb(e), 0 === e.avail_out))
                                return (r.last_flush = -1), Zx;
                        } else if (
                            0 === e.avail_in &&
                            mb(t) <= mb(s) &&
                            t !== Wx
                        )
                            return gb(e, eb);
                        if (r.status === pb && 0 !== e.avail_in)
                            return gb(e, eb);
                        if (
                            0 !== e.avail_in ||
                            0 !== r.lookahead ||
                            (t !== Vx && r.status !== pb)
                        ) {
                            let i =
                                r.strategy === nb
                                    ? ((e, t) => {
                                          let i;
                                          for (;;) {
                                              if (
                                                  0 === e.lookahead &&
                                                  (Tb(e), 0 === e.lookahead)
                                              ) {
                                                  if (t === Vx) return 1;
                                                  break;
                                              }
                                              if (
                                                  ((e.match_length = 0),
                                                  (i = Hx(
                                                      e,
                                                      0,
                                                      e.window[e.strstart]
                                                  )),
                                                  e.lookahead--,
                                                  e.strstart++,
                                                  i &&
                                                      (vb(e, !1),
                                                      0 === e.strm.avail_out))
                                              )
                                                  return 1;
                                          }
                                          return (
                                              (e.insert = 0),
                                              t === Wx
                                                  ? (vb(e, !0),
                                                    0 === e.strm.avail_out
                                                        ? 3
                                                        : 4)
                                                  : e.last_lit &&
                                                    (vb(e, !1),
                                                    0 === e.strm.avail_out)
                                                  ? 1
                                                  : 2
                                          );
                                      })(r, t)
                                    : r.strategy === rb
                                    ? ((e, t) => {
                                          let i, n, r, s;
                                          const a = e.window;
                                          for (;;) {
                                              if (e.lookahead <= lb) {
                                                  if (
                                                      (Tb(e),
                                                      e.lookahead <= lb &&
                                                          t === Vx)
                                                  )
                                                      return 1;
                                                  if (0 === e.lookahead) break;
                                              }
                                              if (
                                                  ((e.match_length = 0),
                                                  e.lookahead >= 3 &&
                                                      e.strstart > 0 &&
                                                      ((r = e.strstart - 1),
                                                      (n = a[r]),
                                                      n === a[++r] &&
                                                          n === a[++r] &&
                                                          n === a[++r]))
                                              ) {
                                                  s = e.strstart + lb;
                                                  do {} while (
                                                      n === a[++r] &&
                                                      n === a[++r] &&
                                                      n === a[++r] &&
                                                      n === a[++r] &&
                                                      n === a[++r] &&
                                                      n === a[++r] &&
                                                      n === a[++r] &&
                                                      n === a[++r] &&
                                                      r < s
                                                  );
                                                  (e.match_length =
                                                      lb - (s - r)),
                                                      e.match_length >
                                                          e.lookahead &&
                                                          (e.match_length =
                                                              e.lookahead);
                                              }
                                              if (
                                                  (e.match_length >= 3
                                                      ? ((i = Hx(
                                                            e,
                                                            1,
                                                            e.match_length - 3
                                                        )),
                                                        (e.lookahead -=
                                                            e.match_length),
                                                        (e.strstart +=
                                                            e.match_length),
                                                        (e.match_length = 0))
                                                      : ((i = Hx(
                                                            e,
                                                            0,
                                                            e.window[e.strstart]
                                                        )),
                                                        e.lookahead--,
                                                        e.strstart++),
                                                  i &&
                                                      (vb(e, !1),
                                                      0 === e.strm.avail_out))
                                              )
                                                  return 1;
                                          }
                                          return (
                                              (e.insert = 0),
                                              t === Wx
                                                  ? (vb(e, !0),
                                                    0 === e.strm.avail_out
                                                        ? 3
                                                        : 4)
                                                  : e.last_lit &&
                                                    (vb(e, !1),
                                                    0 === e.strm.avail_out)
                                                  ? 1
                                                  : 2
                                          );
                                      })(r, t)
                                    : Ib[r.level].func(r, t);
                            if (
                                ((3 !== i && 4 !== i) || (r.status = pb),
                                1 === i || 3 === i)
                            )
                                return (
                                    0 === e.avail_out && (r.last_flush = -1), Zx
                                );
                            if (
                                2 === i &&
                                (t === Yx
                                    ? Gx(r)
                                    : t !== Qx &&
                                      (Bx(r, 0, 0, !1),
                                      t === qx &&
                                          (fb(r.head),
                                          0 === r.lookahead &&
                                              ((r.strstart = 0),
                                              (r.block_start = 0),
                                              (r.insert = 0)))),
                                Mb(e),
                                0 === e.avail_out)
                            )
                                return (r.last_flush = -1), Zx;
                        }
                        return t !== Wx
                            ? Zx
                            : r.wrap <= 0
                            ? Xx
                            : (2 === r.wrap
                                  ? (yb(r, 255 & e.adler),
                                    yb(r, (e.adler >> 8) & 255),
                                    yb(r, (e.adler >> 16) & 255),
                                    yb(r, (e.adler >> 24) & 255),
                                    yb(r, 255 & e.total_in),
                                    yb(r, (e.total_in >> 8) & 255),
                                    yb(r, (e.total_in >> 16) & 255),
                                    yb(r, (e.total_in >> 24) & 255))
                                  : (xb(r, e.adler >>> 16),
                                    xb(r, 65535 & e.adler)),
                              Mb(e),
                              r.wrap > 0 && (r.wrap = -r.wrap),
                              0 !== r.pending ? Zx : Xx);
                    },
                    kb = (e) => {
                        if (!e || !e.state) return Jx;
                        const t = e.state.status;
                        return 42 !== t &&
                            69 !== t &&
                            73 !== t &&
                            91 !== t &&
                            t !== ub &&
                            t !== db &&
                            t !== pb
                            ? gb(e, Jx)
                            : ((e.state = null), t === db ? gb(e, Kx) : Zx);
                    },
                    Rb = (e, t) => {
                        let i = t.length;
                        if (!e || !e.state) return Jx;
                        const n = e.state,
                            r = n.wrap;
                        if (
                            2 === r ||
                            (1 === r && 42 !== n.status) ||
                            n.lookahead
                        )
                            return Jx;
                        if (
                            (1 === r && (e.adler = Ox(e.adler, t, i, 0)),
                            (n.wrap = 0),
                            i >= n.w_size)
                        ) {
                            0 === r &&
                                (fb(n.head),
                                (n.strstart = 0),
                                (n.block_start = 0),
                                (n.insert = 0));
                            let e = new Uint8Array(n.w_size);
                            e.set(t.subarray(i - n.w_size, i), 0),
                                (t = e),
                                (i = n.w_size);
                        }
                        const s = e.avail_in,
                            a = e.next_in,
                            o = e.input;
                        for (
                            e.avail_in = i, e.next_in = 0, e.input = t, Tb(n);
                            n.lookahead >= 3;

                        ) {
                            let e = n.strstart,
                                t = n.lookahead - 2;
                            do {
                                (n.ins_h = _b(n, n.ins_h, n.window[e + 3 - 1])),
                                    (n.prev[e & n.w_mask] = n.head[n.ins_h]),
                                    (n.head[n.ins_h] = e),
                                    e++;
                            } while (--t);
                            (n.strstart = e), (n.lookahead = 2), Tb(n);
                        }
                        return (
                            (n.strstart += n.lookahead),
                            (n.block_start = n.strstart),
                            (n.insert = n.lookahead),
                            (n.lookahead = 0),
                            (n.match_length = n.prev_length = 2),
                            (n.match_available = 0),
                            (e.next_in = a),
                            (e.input = o),
                            (e.avail_in = s),
                            (n.wrap = r),
                            Zx
                        );
                    };
                const Pb = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
                var Ub = {
                    assign: function (e) {
                        const t = Array.prototype.slice.call(arguments, 1);
                        for (; t.length; ) {
                            const i = t.shift();
                            if (i) {
                                if ("object" != typeof i)
                                    throw new TypeError(
                                        i + "must be non-object"
                                    );
                                for (const t in i) Pb(i, t) && (e[t] = i[t]);
                            }
                        }
                        return e;
                    },
                    flattenChunks: (e) => {
                        let t = 0;
                        for (let i = 0, n = e.length; i < n; i++)
                            t += e[i].length;
                        const i = new Uint8Array(t);
                        for (let t = 0, n = 0, r = e.length; t < r; t++) {
                            let r = e[t];
                            i.set(r, n), (n += r.length);
                        }
                        return i;
                    },
                };
                let $b = !0;
                try {
                    String.fromCharCode.apply(null, new Uint8Array(1));
                } catch (e) {
                    $b = !1;
                }
                const Bb = new Uint8Array(256);
                for (let e = 0; e < 256; e++)
                    Bb[e] =
                        e >= 252
                            ? 6
                            : e >= 248
                            ? 5
                            : e >= 240
                            ? 4
                            : e >= 224
                            ? 3
                            : e >= 192
                            ? 2
                            : 1;
                Bb[254] = Bb[254] = 1;
                var Fb = {
                        string2buf: (e) => {
                            if (
                                "function" == typeof TextEncoder &&
                                TextEncoder.prototype.encode
                            )
                                return new TextEncoder().encode(e);
                            let t,
                                i,
                                n,
                                r,
                                s,
                                a = e.length,
                                o = 0;
                            for (r = 0; r < a; r++)
                                (i = e.charCodeAt(r)),
                                    55296 == (64512 & i) &&
                                        r + 1 < a &&
                                        ((n = e.charCodeAt(r + 1)),
                                        56320 == (64512 & n) &&
                                            ((i =
                                                65536 +
                                                ((i - 55296) << 10) +
                                                (n - 56320)),
                                            r++)),
                                    (o +=
                                        i < 128
                                            ? 1
                                            : i < 2048
                                            ? 2
                                            : i < 65536
                                            ? 3
                                            : 4);
                            for (
                                t = new Uint8Array(o), s = 0, r = 0;
                                s < o;
                                r++
                            )
                                (i = e.charCodeAt(r)),
                                    55296 == (64512 & i) &&
                                        r + 1 < a &&
                                        ((n = e.charCodeAt(r + 1)),
                                        56320 == (64512 & n) &&
                                            ((i =
                                                65536 +
                                                ((i - 55296) << 10) +
                                                (n - 56320)),
                                            r++)),
                                    i < 128
                                        ? (t[s++] = i)
                                        : i < 2048
                                        ? ((t[s++] = 192 | (i >>> 6)),
                                          (t[s++] = 128 | (63 & i)))
                                        : i < 65536
                                        ? ((t[s++] = 224 | (i >>> 12)),
                                          (t[s++] = 128 | ((i >>> 6) & 63)),
                                          (t[s++] = 128 | (63 & i)))
                                        : ((t[s++] = 240 | (i >>> 18)),
                                          (t[s++] = 128 | ((i >>> 12) & 63)),
                                          (t[s++] = 128 | ((i >>> 6) & 63)),
                                          (t[s++] = 128 | (63 & i)));
                            return t;
                        },
                        buf2string: (e, t) => {
                            const i = t || e.length;
                            if (
                                "function" == typeof TextDecoder &&
                                TextDecoder.prototype.decode
                            )
                                return new TextDecoder().decode(
                                    e.subarray(0, t)
                                );
                            let n, r;
                            const s = new Array(2 * i);
                            for (r = 0, n = 0; n < i; ) {
                                let t = e[n++];
                                if (t < 128) {
                                    s[r++] = t;
                                    continue;
                                }
                                let a = Bb[t];
                                if (a > 4) (s[r++] = 65533), (n += a - 1);
                                else {
                                    for (
                                        t &= 2 === a ? 31 : 3 === a ? 15 : 7;
                                        a > 1 && n < i;

                                    )
                                        (t = (t << 6) | (63 & e[n++])), a--;
                                    a > 1
                                        ? (s[r++] = 65533)
                                        : t < 65536
                                        ? (s[r++] = t)
                                        : ((t -= 65536),
                                          (s[r++] = 55296 | ((t >> 10) & 1023)),
                                          (s[r++] = 56320 | (1023 & t)));
                                }
                            }
                            return ((e, t) => {
                                if (t < 65534 && e.subarray && $b)
                                    return String.fromCharCode.apply(
                                        null,
                                        e.length === t ? e : e.subarray(0, t)
                                    );
                                let i = "";
                                for (let n = 0; n < t; n++)
                                    i += String.fromCharCode(e[n]);
                                return i;
                            })(s, r);
                        },
                        utf8border: (e, t) => {
                            (t = t || e.length) > e.length && (t = e.length);
                            let i = t - 1;
                            for (; i >= 0 && 128 == (192 & e[i]); ) i--;
                            return i < 0 || 0 === i
                                ? t
                                : i + Bb[e[i]] > t
                                ? i
                                : t;
                        },
                    },
                    Hb = function () {
                        (this.input = null),
                            (this.next_in = 0),
                            (this.avail_in = 0),
                            (this.total_in = 0),
                            (this.output = null),
                            (this.next_out = 0),
                            (this.avail_out = 0),
                            (this.total_out = 0),
                            (this.msg = ""),
                            (this.state = null),
                            (this.data_type = 2),
                            (this.adler = 0);
                    };
                const Gb = Object.prototype.toString,
                    {
                        Z_NO_FLUSH: Vb,
                        Z_SYNC_FLUSH: Yb,
                        Z_FULL_FLUSH: qb,
                        Z_FINISH: Wb,
                        Z_OK: Qb,
                        Z_STREAM_END: Zb,
                        Z_DEFAULT_COMPRESSION: Xb,
                        Z_DEFAULT_STRATEGY: Jb,
                        Z_DEFLATED: Kb,
                    } = Ux;
                function ew(e) {
                    this.options = Ub.assign(
                        {
                            level: Xb,
                            method: Kb,
                            chunkSize: 16384,
                            windowBits: 15,
                            memLevel: 8,
                            strategy: Jb,
                        },
                        e || {}
                    );
                    let t = this.options;
                    t.raw && t.windowBits > 0
                        ? (t.windowBits = -t.windowBits)
                        : t.gzip &&
                          t.windowBits > 0 &&
                          t.windowBits < 16 &&
                          (t.windowBits += 16),
                        (this.err = 0),
                        (this.msg = ""),
                        (this.ended = !1),
                        (this.chunks = []),
                        (this.strm = new Hb()),
                        (this.strm.avail_out = 0);
                    let i = zb(
                        this.strm,
                        t.level,
                        t.method,
                        t.windowBits,
                        t.memLevel,
                        t.strategy
                    );
                    if (i !== Qb) throw new Error(Px[i]);
                    if ((t.header && jb(this.strm, t.header), t.dictionary)) {
                        let e;
                        if (
                            ((e =
                                "string" == typeof t.dictionary
                                    ? Fb.string2buf(t.dictionary)
                                    : "[object ArrayBuffer]" ===
                                      Gb.call(t.dictionary)
                                    ? new Uint8Array(t.dictionary)
                                    : t.dictionary),
                            (i = Rb(this.strm, e)),
                            i !== Qb)
                        )
                            throw new Error(Px[i]);
                        this._dict_set = !0;
                    }
                }
                (ew.prototype.push = function (e, t) {
                    const i = this.strm,
                        n = this.options.chunkSize;
                    let r, s;
                    if (this.ended) return !1;
                    for (
                        s = t === ~~t ? t : !0 === t ? Wb : Vb,
                            "string" == typeof e
                                ? (i.input = Fb.string2buf(e))
                                : "[object ArrayBuffer]" === Gb.call(e)
                                ? (i.input = new Uint8Array(e))
                                : (i.input = e),
                            i.next_in = 0,
                            i.avail_in = i.input.length;
                        ;

                    )
                        if (
                            (0 === i.avail_out &&
                                ((i.output = new Uint8Array(n)),
                                (i.next_out = 0),
                                (i.avail_out = n)),
                            (s === Yb || s === qb) && i.avail_out <= 6)
                        )
                            this.onData(i.output.subarray(0, i.next_out)),
                                (i.avail_out = 0);
                        else {
                            if (((r = Ob(i, s)), r === Zb))
                                return (
                                    i.next_out > 0 &&
                                        this.onData(
                                            i.output.subarray(0, i.next_out)
                                        ),
                                    (r = kb(this.strm)),
                                    this.onEnd(r),
                                    (this.ended = !0),
                                    r === Qb
                                );
                            if (0 !== i.avail_out) {
                                if (s > 0 && i.next_out > 0)
                                    this.onData(
                                        i.output.subarray(0, i.next_out)
                                    ),
                                        (i.avail_out = 0);
                                else if (0 === i.avail_in) break;
                            } else this.onData(i.output);
                        }
                    return !0;
                }),
                    (ew.prototype.onData = function (e) {
                        this.chunks.push(e);
                    }),
                    (ew.prototype.onEnd = function (e) {
                        e === Qb &&
                            (this.result = Ub.flattenChunks(this.chunks)),
                            (this.chunks = []),
                            (this.err = e),
                            (this.msg = this.strm.msg);
                    });
                var tw = function (e, t) {
                    let i,
                        n,
                        r,
                        s,
                        a,
                        o,
                        c,
                        l,
                        h,
                        u,
                        d,
                        p,
                        g,
                        m,
                        f,
                        _,
                        M,
                        v,
                        y,
                        x,
                        b,
                        w,
                        T,
                        S;
                    const N = e.state;
                    (i = e.next_in),
                        (T = e.input),
                        (n = i + (e.avail_in - 5)),
                        (r = e.next_out),
                        (S = e.output),
                        (s = r - (t - e.avail_out)),
                        (a = r + (e.avail_out - 257)),
                        (o = N.dmax),
                        (c = N.wsize),
                        (l = N.whave),
                        (h = N.wnext),
                        (u = N.window),
                        (d = N.hold),
                        (p = N.bits),
                        (g = N.lencode),
                        (m = N.distcode),
                        (f = (1 << N.lenbits) - 1),
                        (_ = (1 << N.distbits) - 1);
                    e: do {
                        p < 15 &&
                            ((d += T[i++] << p),
                            (p += 8),
                            (d += T[i++] << p),
                            (p += 8)),
                            (M = g[d & f]);
                        t: for (;;) {
                            if (
                                ((v = M >>> 24),
                                (d >>>= v),
                                (p -= v),
                                (v = (M >>> 16) & 255),
                                0 === v)
                            )
                                S[r++] = 65535 & M;
                            else {
                                if (!(16 & v)) {
                                    if (64 & v) {
                                        if (32 & v) {
                                            N.mode = 12;
                                            break e;
                                        }
                                        (e.msg = "invalid literal/length code"),
                                            (N.mode = 30);
                                        break e;
                                    }
                                    M = g[(65535 & M) + (d & ((1 << v) - 1))];
                                    continue t;
                                }
                                for (
                                    y = 65535 & M,
                                        v &= 15,
                                        v &&
                                            (p < v &&
                                                ((d += T[i++] << p), (p += 8)),
                                            (y += d & ((1 << v) - 1)),
                                            (d >>>= v),
                                            (p -= v)),
                                        p < 15 &&
                                            ((d += T[i++] << p),
                                            (p += 8),
                                            (d += T[i++] << p),
                                            (p += 8)),
                                        M = m[d & _];
                                    ;

                                ) {
                                    if (
                                        ((v = M >>> 24),
                                        (d >>>= v),
                                        (p -= v),
                                        (v = (M >>> 16) & 255),
                                        16 & v)
                                    ) {
                                        if (
                                            ((x = 65535 & M),
                                            (v &= 15),
                                            p < v &&
                                                ((d += T[i++] << p),
                                                (p += 8),
                                                p < v &&
                                                    ((d += T[i++] << p),
                                                    (p += 8))),
                                            (x += d & ((1 << v) - 1)),
                                            x > o)
                                        ) {
                                            (e.msg =
                                                "invalid distance too far back"),
                                                (N.mode = 30);
                                            break e;
                                        }
                                        if (
                                            ((d >>>= v),
                                            (p -= v),
                                            (v = r - s),
                                            x > v)
                                        ) {
                                            if (
                                                ((v = x - v), v > l && N.sane)
                                            ) {
                                                (e.msg =
                                                    "invalid distance too far back"),
                                                    (N.mode = 30);
                                                break e;
                                            }
                                            if (((b = 0), (w = u), 0 === h)) {
                                                if (((b += c - v), v < y)) {
                                                    y -= v;
                                                    do {
                                                        S[r++] = u[b++];
                                                    } while (--v);
                                                    (b = r - x), (w = S);
                                                }
                                            } else if (h < v) {
                                                if (
                                                    ((b += c + h - v),
                                                    (v -= h),
                                                    v < y)
                                                ) {
                                                    y -= v;
                                                    do {
                                                        S[r++] = u[b++];
                                                    } while (--v);
                                                    if (((b = 0), h < y)) {
                                                        (v = h), (y -= v);
                                                        do {
                                                            S[r++] = u[b++];
                                                        } while (--v);
                                                        (b = r - x), (w = S);
                                                    }
                                                }
                                            } else if (((b += h - v), v < y)) {
                                                y -= v;
                                                do {
                                                    S[r++] = u[b++];
                                                } while (--v);
                                                (b = r - x), (w = S);
                                            }
                                            for (; y > 2; )
                                                (S[r++] = w[b++]),
                                                    (S[r++] = w[b++]),
                                                    (S[r++] = w[b++]),
                                                    (y -= 3);
                                            y &&
                                                ((S[r++] = w[b++]),
                                                y > 1 && (S[r++] = w[b++]));
                                        } else {
                                            b = r - x;
                                            do {
                                                (S[r++] = S[b++]),
                                                    (S[r++] = S[b++]),
                                                    (S[r++] = S[b++]),
                                                    (y -= 3);
                                            } while (y > 2);
                                            y &&
                                                ((S[r++] = S[b++]),
                                                y > 1 && (S[r++] = S[b++]));
                                        }
                                        break;
                                    }
                                    if (64 & v) {
                                        (e.msg = "invalid distance code"),
                                            (N.mode = 30);
                                        break e;
                                    }
                                    M = m[(65535 & M) + (d & ((1 << v) - 1))];
                                }
                            }
                            break;
                        }
                    } while (i < n && r < a);
                    (y = p >> 3),
                        (i -= y),
                        (p -= y << 3),
                        (d &= (1 << p) - 1),
                        (e.next_in = i),
                        (e.next_out = r),
                        (e.avail_in = i < n ? n - i + 5 : 5 - (i - n)),
                        (e.avail_out = r < a ? a - r + 257 : 257 - (r - a)),
                        (N.hold = d),
                        (N.bits = p);
                };
                const iw = new Uint16Array([
                        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
                        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227,
                        258, 0, 0,
                    ]),
                    nw = new Uint8Array([
                        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18,
                        18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,
                        16, 72, 78,
                    ]),
                    rw = new Uint16Array([
                        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129,
                        193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097,
                        6145, 8193, 12289, 16385, 24577, 0, 0,
                    ]),
                    sw = new Uint8Array([
                        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21,
                        22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28,
                        29, 29, 64, 64,
                    ]);
                var aw = (e, t, i, n, r, s, a, o) => {
                    const c = o.bits;
                    let l,
                        h,
                        u,
                        d,
                        p,
                        g,
                        m = 0,
                        f = 0,
                        _ = 0,
                        M = 0,
                        v = 0,
                        y = 0,
                        x = 0,
                        b = 0,
                        w = 0,
                        T = 0,
                        S = null,
                        N = 0;
                    const D = new Uint16Array(16),
                        I = new Uint16Array(16);
                    let C,
                        A,
                        E,
                        L = null,
                        z = 0;
                    for (m = 0; m <= 15; m++) D[m] = 0;
                    for (f = 0; f < n; f++) D[t[i + f]]++;
                    for (v = c, M = 15; M >= 1 && 0 === D[M]; M--);
                    if ((v > M && (v = M), 0 === M))
                        return (
                            (r[s++] = 20971520),
                            (r[s++] = 20971520),
                            (o.bits = 1),
                            0
                        );
                    for (_ = 1; _ < M && 0 === D[_]; _++);
                    for (v < _ && (v = _), b = 1, m = 1; m <= 15; m++)
                        if (((b <<= 1), (b -= D[m]), b < 0)) return -1;
                    if (b > 0 && (0 === e || 1 !== M)) return -1;
                    for (I[1] = 0, m = 1; m < 15; m++) I[m + 1] = I[m] + D[m];
                    for (f = 0; f < n; f++)
                        0 !== t[i + f] && (a[I[t[i + f]]++] = f);
                    if (
                        (0 === e
                            ? ((S = L = a), (g = 19))
                            : 1 === e
                            ? ((S = iw),
                              (N -= 257),
                              (L = nw),
                              (z -= 257),
                              (g = 256))
                            : ((S = rw), (L = sw), (g = -1)),
                        (T = 0),
                        (f = 0),
                        (m = _),
                        (p = s),
                        (y = v),
                        (x = 0),
                        (u = -1),
                        (w = 1 << v),
                        (d = w - 1),
                        (1 === e && w > 852) || (2 === e && w > 592))
                    )
                        return 1;
                    for (;;) {
                        (C = m - x),
                            a[f] < g
                                ? ((A = 0), (E = a[f]))
                                : a[f] > g
                                ? ((A = L[z + a[f]]), (E = S[N + a[f]]))
                                : ((A = 96), (E = 0)),
                            (l = 1 << (m - x)),
                            (h = 1 << y),
                            (_ = h);
                        do {
                            (h -= l),
                                (r[p + (T >> x) + h] =
                                    (C << 24) | (A << 16) | E);
                        } while (0 !== h);
                        for (l = 1 << (m - 1); T & l; ) l >>= 1;
                        if (
                            (0 !== l ? ((T &= l - 1), (T += l)) : (T = 0),
                            f++,
                            0 == --D[m])
                        ) {
                            if (m === M) break;
                            m = t[i + a[f]];
                        }
                        if (m > v && (T & d) !== u) {
                            for (
                                0 === x && (x = v),
                                    p += _,
                                    y = m - x,
                                    b = 1 << y;
                                y + x < M && ((b -= D[y + x]), !(b <= 0));

                            )
                                y++, (b <<= 1);
                            if (
                                ((w += 1 << y),
                                (1 === e && w > 852) || (2 === e && w > 592))
                            )
                                return 1;
                            (u = T & d),
                                (r[u] = (v << 24) | (y << 16) | (p - s));
                        }
                    }
                    return (
                        0 !== T && (r[p + T] = ((m - x) << 24) | (64 << 16)),
                        (o.bits = v),
                        0
                    );
                };
                const {
                        Z_FINISH: ow,
                        Z_BLOCK: cw,
                        Z_TREES: lw,
                        Z_OK: hw,
                        Z_STREAM_END: uw,
                        Z_NEED_DICT: dw,
                        Z_STREAM_ERROR: pw,
                        Z_DATA_ERROR: gw,
                        Z_MEM_ERROR: mw,
                        Z_BUF_ERROR: fw,
                        Z_DEFLATED: _w,
                    } = Ux,
                    Mw = 12,
                    vw = 30,
                    yw = (e) =>
                        ((e >>> 24) & 255) +
                        ((e >>> 8) & 65280) +
                        ((65280 & e) << 8) +
                        ((255 & e) << 24);
                function xw() {
                    (this.mode = 0),
                        (this.last = !1),
                        (this.wrap = 0),
                        (this.havedict = !1),
                        (this.flags = 0),
                        (this.dmax = 0),
                        (this.check = 0),
                        (this.total = 0),
                        (this.head = null),
                        (this.wbits = 0),
                        (this.wsize = 0),
                        (this.whave = 0),
                        (this.wnext = 0),
                        (this.window = null),
                        (this.hold = 0),
                        (this.bits = 0),
                        (this.length = 0),
                        (this.offset = 0),
                        (this.extra = 0),
                        (this.lencode = null),
                        (this.distcode = null),
                        (this.lenbits = 0),
                        (this.distbits = 0),
                        (this.ncode = 0),
                        (this.nlen = 0),
                        (this.ndist = 0),
                        (this.have = 0),
                        (this.next = null),
                        (this.lens = new Uint16Array(320)),
                        (this.work = new Uint16Array(288)),
                        (this.lendyn = null),
                        (this.distdyn = null),
                        (this.sane = 0),
                        (this.back = 0),
                        (this.was = 0);
                }
                const bw = (e) => {
                        if (!e || !e.state) return pw;
                        const t = e.state;
                        return (
                            (e.total_in = e.total_out = t.total = 0),
                            (e.msg = ""),
                            t.wrap && (e.adler = 1 & t.wrap),
                            (t.mode = 1),
                            (t.last = 0),
                            (t.havedict = 0),
                            (t.dmax = 32768),
                            (t.head = null),
                            (t.hold = 0),
                            (t.bits = 0),
                            (t.lencode = t.lendyn = new Int32Array(852)),
                            (t.distcode = t.distdyn = new Int32Array(592)),
                            (t.sane = 1),
                            (t.back = -1),
                            hw
                        );
                    },
                    ww = (e) => {
                        if (!e || !e.state) return pw;
                        const t = e.state;
                        return (
                            (t.wsize = 0), (t.whave = 0), (t.wnext = 0), bw(e)
                        );
                    },
                    Tw = (e, t) => {
                        let i;
                        if (!e || !e.state) return pw;
                        const n = e.state;
                        return (
                            t < 0
                                ? ((i = 0), (t = -t))
                                : ((i = 1 + (t >> 4)), t < 48 && (t &= 15)),
                            t && (t < 8 || t > 15)
                                ? pw
                                : (null !== n.window &&
                                      n.wbits !== t &&
                                      (n.window = null),
                                  (n.wrap = i),
                                  (n.wbits = t),
                                  ww(e))
                        );
                    },
                    Sw = (e, t) => {
                        if (!e) return pw;
                        const i = new xw();
                        (e.state = i), (i.window = null);
                        const n = Tw(e, t);
                        return n !== hw && (e.state = null), n;
                    };
                let Nw,
                    Dw,
                    Iw = !0;
                const Cw = (e) => {
                        if (Iw) {
                            (Nw = new Int32Array(512)),
                                (Dw = new Int32Array(32));
                            let t = 0;
                            for (; t < 144; ) e.lens[t++] = 8;
                            for (; t < 256; ) e.lens[t++] = 9;
                            for (; t < 280; ) e.lens[t++] = 7;
                            for (; t < 288; ) e.lens[t++] = 8;
                            for (
                                aw(1, e.lens, 0, 288, Nw, 0, e.work, {
                                    bits: 9,
                                }),
                                    t = 0;
                                t < 32;

                            )
                                e.lens[t++] = 5;
                            aw(2, e.lens, 0, 32, Dw, 0, e.work, { bits: 5 }),
                                (Iw = !1);
                        }
                        (e.lencode = Nw),
                            (e.lenbits = 9),
                            (e.distcode = Dw),
                            (e.distbits = 5);
                    },
                    Aw = (e, t, i, n) => {
                        let r;
                        const s = e.state;
                        return (
                            null === s.window &&
                                ((s.wsize = 1 << s.wbits),
                                (s.wnext = 0),
                                (s.whave = 0),
                                (s.window = new Uint8Array(s.wsize))),
                            n >= s.wsize
                                ? (s.window.set(t.subarray(i - s.wsize, i), 0),
                                  (s.wnext = 0),
                                  (s.whave = s.wsize))
                                : ((r = s.wsize - s.wnext),
                                  r > n && (r = n),
                                  s.window.set(
                                      t.subarray(i - n, i - n + r),
                                      s.wnext
                                  ),
                                  (n -= r)
                                      ? (s.window.set(t.subarray(i - n, i), 0),
                                        (s.wnext = n),
                                        (s.whave = s.wsize))
                                      : ((s.wnext += r),
                                        s.wnext === s.wsize && (s.wnext = 0),
                                        s.whave < s.wsize && (s.whave += r))),
                            0
                        );
                    };
                var Ew = {
                        inflateReset: ww,
                        inflateReset2: Tw,
                        inflateResetKeep: bw,
                        inflateInit: (e) => Sw(e, 15),
                        inflateInit2: Sw,
                        inflate: (e, t) => {
                            let i,
                                n,
                                r,
                                s,
                                a,
                                o,
                                c,
                                l,
                                h,
                                u,
                                d,
                                p,
                                g,
                                m,
                                f,
                                _,
                                M,
                                v,
                                y,
                                x,
                                b,
                                w,
                                T = 0;
                            const S = new Uint8Array(4);
                            let N, D;
                            const I = new Uint8Array([
                                16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3,
                                13, 2, 14, 1, 15,
                            ]);
                            if (
                                !e ||
                                !e.state ||
                                !e.output ||
                                (!e.input && 0 !== e.avail_in)
                            )
                                return pw;
                            (i = e.state),
                                i.mode === Mw && (i.mode = 13),
                                (a = e.next_out),
                                (r = e.output),
                                (c = e.avail_out),
                                (s = e.next_in),
                                (n = e.input),
                                (o = e.avail_in),
                                (l = i.hold),
                                (h = i.bits),
                                (u = o),
                                (d = c),
                                (w = hw);
                            e: for (;;)
                                switch (i.mode) {
                                    case 1:
                                        if (0 === i.wrap) {
                                            i.mode = 13;
                                            break;
                                        }
                                        for (; h < 16; ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        if (2 & i.wrap && 35615 === l) {
                                            (i.check = 0),
                                                (S[0] = 255 & l),
                                                (S[1] = (l >>> 8) & 255),
                                                (i.check = Rx(
                                                    i.check,
                                                    S,
                                                    2,
                                                    0
                                                )),
                                                (l = 0),
                                                (h = 0),
                                                (i.mode = 2);
                                            break;
                                        }
                                        if (
                                            ((i.flags = 0),
                                            i.head && (i.head.done = !1),
                                            !(1 & i.wrap) ||
                                                (((255 & l) << 8) + (l >> 8)) %
                                                    31)
                                        ) {
                                            (e.msg = "incorrect header check"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        if ((15 & l) !== _w) {
                                            (e.msg =
                                                "unknown compression method"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        if (
                                            ((l >>>= 4),
                                            (h -= 4),
                                            (b = 8 + (15 & l)),
                                            0 === i.wbits)
                                        )
                                            i.wbits = b;
                                        else if (b > i.wbits) {
                                            (e.msg = "invalid window size"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        (i.dmax = 1 << i.wbits),
                                            (e.adler = i.check = 1),
                                            (i.mode = 512 & l ? 10 : Mw),
                                            (l = 0),
                                            (h = 0);
                                        break;
                                    case 2:
                                        for (; h < 16; ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        if (
                                            ((i.flags = l),
                                            (255 & i.flags) !== _w)
                                        ) {
                                            (e.msg =
                                                "unknown compression method"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        if (57344 & i.flags) {
                                            (e.msg =
                                                "unknown header flags set"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        i.head && (i.head.text = (l >> 8) & 1),
                                            512 & i.flags &&
                                                ((S[0] = 255 & l),
                                                (S[1] = (l >>> 8) & 255),
                                                (i.check = Rx(
                                                    i.check,
                                                    S,
                                                    2,
                                                    0
                                                ))),
                                            (l = 0),
                                            (h = 0),
                                            (i.mode = 3);
                                    case 3:
                                        for (; h < 32; ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        i.head && (i.head.time = l),
                                            512 & i.flags &&
                                                ((S[0] = 255 & l),
                                                (S[1] = (l >>> 8) & 255),
                                                (S[2] = (l >>> 16) & 255),
                                                (S[3] = (l >>> 24) & 255),
                                                (i.check = Rx(
                                                    i.check,
                                                    S,
                                                    4,
                                                    0
                                                ))),
                                            (l = 0),
                                            (h = 0),
                                            (i.mode = 4);
                                    case 4:
                                        for (; h < 16; ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        i.head &&
                                            ((i.head.xflags = 255 & l),
                                            (i.head.os = l >> 8)),
                                            512 & i.flags &&
                                                ((S[0] = 255 & l),
                                                (S[1] = (l >>> 8) & 255),
                                                (i.check = Rx(
                                                    i.check,
                                                    S,
                                                    2,
                                                    0
                                                ))),
                                            (l = 0),
                                            (h = 0),
                                            (i.mode = 5);
                                    case 5:
                                        if (1024 & i.flags) {
                                            for (; h < 16; ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            (i.length = l),
                                                i.head &&
                                                    (i.head.extra_len = l),
                                                512 & i.flags &&
                                                    ((S[0] = 255 & l),
                                                    (S[1] = (l >>> 8) & 255),
                                                    (i.check = Rx(
                                                        i.check,
                                                        S,
                                                        2,
                                                        0
                                                    ))),
                                                (l = 0),
                                                (h = 0);
                                        } else i.head && (i.head.extra = null);
                                        i.mode = 6;
                                    case 6:
                                        if (
                                            1024 & i.flags &&
                                            ((p = i.length),
                                            p > o && (p = o),
                                            p &&
                                                (i.head &&
                                                    ((b =
                                                        i.head.extra_len -
                                                        i.length),
                                                    i.head.extra ||
                                                        (i.head.extra =
                                                            new Uint8Array(
                                                                i.head.extra_len
                                                            )),
                                                    i.head.extra.set(
                                                        n.subarray(s, s + p),
                                                        b
                                                    )),
                                                512 & i.flags &&
                                                    (i.check = Rx(
                                                        i.check,
                                                        n,
                                                        p,
                                                        s
                                                    )),
                                                (o -= p),
                                                (s += p),
                                                (i.length -= p)),
                                            i.length)
                                        )
                                            break e;
                                        (i.length = 0), (i.mode = 7);
                                    case 7:
                                        if (2048 & i.flags) {
                                            if (0 === o) break e;
                                            p = 0;
                                            do {
                                                (b = n[s + p++]),
                                                    i.head &&
                                                        b &&
                                                        i.length < 65536 &&
                                                        (i.head.name +=
                                                            String.fromCharCode(
                                                                b
                                                            ));
                                            } while (b && p < o);
                                            if (
                                                (512 & i.flags &&
                                                    (i.check = Rx(
                                                        i.check,
                                                        n,
                                                        p,
                                                        s
                                                    )),
                                                (o -= p),
                                                (s += p),
                                                b)
                                            )
                                                break e;
                                        } else i.head && (i.head.name = null);
                                        (i.length = 0), (i.mode = 8);
                                    case 8:
                                        if (4096 & i.flags) {
                                            if (0 === o) break e;
                                            p = 0;
                                            do {
                                                (b = n[s + p++]),
                                                    i.head &&
                                                        b &&
                                                        i.length < 65536 &&
                                                        (i.head.comment +=
                                                            String.fromCharCode(
                                                                b
                                                            ));
                                            } while (b && p < o);
                                            if (
                                                (512 & i.flags &&
                                                    (i.check = Rx(
                                                        i.check,
                                                        n,
                                                        p,
                                                        s
                                                    )),
                                                (o -= p),
                                                (s += p),
                                                b)
                                            )
                                                break e;
                                        } else
                                            i.head && (i.head.comment = null);
                                        i.mode = 9;
                                    case 9:
                                        if (512 & i.flags) {
                                            for (; h < 16; ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            if (l !== (65535 & i.check)) {
                                                (e.msg = "header crc mismatch"),
                                                    (i.mode = vw);
                                                break;
                                            }
                                            (l = 0), (h = 0);
                                        }
                                        i.head &&
                                            ((i.head.hcrc = (i.flags >> 9) & 1),
                                            (i.head.done = !0)),
                                            (e.adler = i.check = 0),
                                            (i.mode = Mw);
                                        break;
                                    case 10:
                                        for (; h < 32; ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        (e.adler = i.check = yw(l)),
                                            (l = 0),
                                            (h = 0),
                                            (i.mode = 11);
                                    case 11:
                                        if (0 === i.havedict)
                                            return (
                                                (e.next_out = a),
                                                (e.avail_out = c),
                                                (e.next_in = s),
                                                (e.avail_in = o),
                                                (i.hold = l),
                                                (i.bits = h),
                                                dw
                                            );
                                        (e.adler = i.check = 1), (i.mode = Mw);
                                    case Mw:
                                        if (t === cw || t === lw) break e;
                                    case 13:
                                        if (i.last) {
                                            (l >>>= 7 & h),
                                                (h -= 7 & h),
                                                (i.mode = 27);
                                            break;
                                        }
                                        for (; h < 3; ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        switch (
                                            ((i.last = 1 & l),
                                            (l >>>= 1),
                                            (h -= 1),
                                            3 & l)
                                        ) {
                                            case 0:
                                                i.mode = 14;
                                                break;
                                            case 1:
                                                if (
                                                    (Cw(i),
                                                    (i.mode = 20),
                                                    t === lw)
                                                ) {
                                                    (l >>>= 2), (h -= 2);
                                                    break e;
                                                }
                                                break;
                                            case 2:
                                                i.mode = 17;
                                                break;
                                            case 3:
                                                (e.msg = "invalid block type"),
                                                    (i.mode = vw);
                                        }
                                        (l >>>= 2), (h -= 2);
                                        break;
                                    case 14:
                                        for (
                                            l >>>= 7 & h, h -= 7 & h;
                                            h < 32;

                                        ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        if (
                                            (65535 & l) !=
                                            ((l >>> 16) ^ 65535)
                                        ) {
                                            (e.msg =
                                                "invalid stored block lengths"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        if (
                                            ((i.length = 65535 & l),
                                            (l = 0),
                                            (h = 0),
                                            (i.mode = 15),
                                            t === lw)
                                        )
                                            break e;
                                    case 15:
                                        i.mode = 16;
                                    case 16:
                                        if (((p = i.length), p)) {
                                            if (
                                                (p > o && (p = o),
                                                p > c && (p = c),
                                                0 === p)
                                            )
                                                break e;
                                            r.set(n.subarray(s, s + p), a),
                                                (o -= p),
                                                (s += p),
                                                (c -= p),
                                                (a += p),
                                                (i.length -= p);
                                            break;
                                        }
                                        i.mode = Mw;
                                        break;
                                    case 17:
                                        for (; h < 14; ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        if (
                                            ((i.nlen = 257 + (31 & l)),
                                            (l >>>= 5),
                                            (h -= 5),
                                            (i.ndist = 1 + (31 & l)),
                                            (l >>>= 5),
                                            (h -= 5),
                                            (i.ncode = 4 + (15 & l)),
                                            (l >>>= 4),
                                            (h -= 4),
                                            i.nlen > 286 || i.ndist > 30)
                                        ) {
                                            (e.msg =
                                                "too many length or distance symbols"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        (i.have = 0), (i.mode = 18);
                                    case 18:
                                        for (; i.have < i.ncode; ) {
                                            for (; h < 3; ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            (i.lens[I[i.have++]] = 7 & l),
                                                (l >>>= 3),
                                                (h -= 3);
                                        }
                                        for (; i.have < 19; )
                                            i.lens[I[i.have++]] = 0;
                                        if (
                                            ((i.lencode = i.lendyn),
                                            (i.lenbits = 7),
                                            (N = { bits: i.lenbits }),
                                            (w = aw(
                                                0,
                                                i.lens,
                                                0,
                                                19,
                                                i.lencode,
                                                0,
                                                i.work,
                                                N
                                            )),
                                            (i.lenbits = N.bits),
                                            w)
                                        ) {
                                            (e.msg =
                                                "invalid code lengths set"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        (i.have = 0), (i.mode = 19);
                                    case 19:
                                        for (; i.have < i.nlen + i.ndist; ) {
                                            for (
                                                ;
                                                (T =
                                                    i.lencode[
                                                        l &
                                                            ((1 << i.lenbits) -
                                                                1)
                                                    ]),
                                                    (f = T >>> 24),
                                                    (_ = (T >>> 16) & 255),
                                                    (M = 65535 & T),
                                                    !(f <= h);

                                            ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            if (M < 16)
                                                (l >>>= f),
                                                    (h -= f),
                                                    (i.lens[i.have++] = M);
                                            else {
                                                if (16 === M) {
                                                    for (D = f + 2; h < D; ) {
                                                        if (0 === o) break e;
                                                        o--,
                                                            (l += n[s++] << h),
                                                            (h += 8);
                                                    }
                                                    if (
                                                        ((l >>>= f),
                                                        (h -= f),
                                                        0 === i.have)
                                                    ) {
                                                        (e.msg =
                                                            "invalid bit length repeat"),
                                                            (i.mode = vw);
                                                        break;
                                                    }
                                                    (b = i.lens[i.have - 1]),
                                                        (p = 3 + (3 & l)),
                                                        (l >>>= 2),
                                                        (h -= 2);
                                                } else if (17 === M) {
                                                    for (D = f + 3; h < D; ) {
                                                        if (0 === o) break e;
                                                        o--,
                                                            (l += n[s++] << h),
                                                            (h += 8);
                                                    }
                                                    (l >>>= f),
                                                        (h -= f),
                                                        (b = 0),
                                                        (p = 3 + (7 & l)),
                                                        (l >>>= 3),
                                                        (h -= 3);
                                                } else {
                                                    for (D = f + 7; h < D; ) {
                                                        if (0 === o) break e;
                                                        o--,
                                                            (l += n[s++] << h),
                                                            (h += 8);
                                                    }
                                                    (l >>>= f),
                                                        (h -= f),
                                                        (b = 0),
                                                        (p = 11 + (127 & l)),
                                                        (l >>>= 7),
                                                        (h -= 7);
                                                }
                                                if (
                                                    i.have + p >
                                                    i.nlen + i.ndist
                                                ) {
                                                    (e.msg =
                                                        "invalid bit length repeat"),
                                                        (i.mode = vw);
                                                    break;
                                                }
                                                for (; p--; )
                                                    i.lens[i.have++] = b;
                                            }
                                        }
                                        if (i.mode === vw) break;
                                        if (0 === i.lens[256]) {
                                            (e.msg =
                                                "invalid code -- missing end-of-block"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        if (
                                            ((i.lenbits = 9),
                                            (N = { bits: i.lenbits }),
                                            (w = aw(
                                                1,
                                                i.lens,
                                                0,
                                                i.nlen,
                                                i.lencode,
                                                0,
                                                i.work,
                                                N
                                            )),
                                            (i.lenbits = N.bits),
                                            w)
                                        ) {
                                            (e.msg =
                                                "invalid literal/lengths set"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        if (
                                            ((i.distbits = 6),
                                            (i.distcode = i.distdyn),
                                            (N = { bits: i.distbits }),
                                            (w = aw(
                                                2,
                                                i.lens,
                                                i.nlen,
                                                i.ndist,
                                                i.distcode,
                                                0,
                                                i.work,
                                                N
                                            )),
                                            (i.distbits = N.bits),
                                            w)
                                        ) {
                                            (e.msg = "invalid distances set"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        if (((i.mode = 20), t === lw)) break e;
                                    case 20:
                                        i.mode = 21;
                                    case 21:
                                        if (o >= 6 && c >= 258) {
                                            (e.next_out = a),
                                                (e.avail_out = c),
                                                (e.next_in = s),
                                                (e.avail_in = o),
                                                (i.hold = l),
                                                (i.bits = h),
                                                tw(e, d),
                                                (a = e.next_out),
                                                (r = e.output),
                                                (c = e.avail_out),
                                                (s = e.next_in),
                                                (n = e.input),
                                                (o = e.avail_in),
                                                (l = i.hold),
                                                (h = i.bits),
                                                i.mode === Mw && (i.back = -1);
                                            break;
                                        }
                                        for (
                                            i.back = 0;
                                            (T =
                                                i.lencode[
                                                    l & ((1 << i.lenbits) - 1)
                                                ]),
                                                (f = T >>> 24),
                                                (_ = (T >>> 16) & 255),
                                                (M = 65535 & T),
                                                !(f <= h);

                                        ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        if (_ && !(240 & _)) {
                                            for (
                                                v = f, y = _, x = M;
                                                (T =
                                                    i.lencode[
                                                        x +
                                                            ((l &
                                                                ((1 <<
                                                                    (v + y)) -
                                                                    1)) >>
                                                                v)
                                                    ]),
                                                    (f = T >>> 24),
                                                    (_ = (T >>> 16) & 255),
                                                    (M = 65535 & T),
                                                    !(v + f <= h);

                                            ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            (l >>>= v), (h -= v), (i.back += v);
                                        }
                                        if (
                                            ((l >>>= f),
                                            (h -= f),
                                            (i.back += f),
                                            (i.length = M),
                                            0 === _)
                                        ) {
                                            i.mode = 26;
                                            break;
                                        }
                                        if (32 & _) {
                                            (i.back = -1), (i.mode = Mw);
                                            break;
                                        }
                                        if (64 & _) {
                                            (e.msg =
                                                "invalid literal/length code"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        (i.extra = 15 & _), (i.mode = 22);
                                    case 22:
                                        if (i.extra) {
                                            for (D = i.extra; h < D; ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            (i.length +=
                                                l & ((1 << i.extra) - 1)),
                                                (l >>>= i.extra),
                                                (h -= i.extra),
                                                (i.back += i.extra);
                                        }
                                        (i.was = i.length), (i.mode = 23);
                                    case 23:
                                        for (
                                            ;
                                            (T =
                                                i.distcode[
                                                    l & ((1 << i.distbits) - 1)
                                                ]),
                                                (f = T >>> 24),
                                                (_ = (T >>> 16) & 255),
                                                (M = 65535 & T),
                                                !(f <= h);

                                        ) {
                                            if (0 === o) break e;
                                            o--, (l += n[s++] << h), (h += 8);
                                        }
                                        if (!(240 & _)) {
                                            for (
                                                v = f, y = _, x = M;
                                                (T =
                                                    i.distcode[
                                                        x +
                                                            ((l &
                                                                ((1 <<
                                                                    (v + y)) -
                                                                    1)) >>
                                                                v)
                                                    ]),
                                                    (f = T >>> 24),
                                                    (_ = (T >>> 16) & 255),
                                                    (M = 65535 & T),
                                                    !(v + f <= h);

                                            ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            (l >>>= v), (h -= v), (i.back += v);
                                        }
                                        if (
                                            ((l >>>= f),
                                            (h -= f),
                                            (i.back += f),
                                            64 & _)
                                        ) {
                                            (e.msg = "invalid distance code"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        (i.offset = M),
                                            (i.extra = 15 & _),
                                            (i.mode = 24);
                                    case 24:
                                        if (i.extra) {
                                            for (D = i.extra; h < D; ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            (i.offset +=
                                                l & ((1 << i.extra) - 1)),
                                                (l >>>= i.extra),
                                                (h -= i.extra),
                                                (i.back += i.extra);
                                        }
                                        if (i.offset > i.dmax) {
                                            (e.msg =
                                                "invalid distance too far back"),
                                                (i.mode = vw);
                                            break;
                                        }
                                        i.mode = 25;
                                    case 25:
                                        if (0 === c) break e;
                                        if (((p = d - c), i.offset > p)) {
                                            if (
                                                ((p = i.offset - p),
                                                p > i.whave && i.sane)
                                            ) {
                                                (e.msg =
                                                    "invalid distance too far back"),
                                                    (i.mode = vw);
                                                break;
                                            }
                                            p > i.wnext
                                                ? ((p -= i.wnext),
                                                  (g = i.wsize - p))
                                                : (g = i.wnext - p),
                                                p > i.length && (p = i.length),
                                                (m = i.window);
                                        } else
                                            (m = r),
                                                (g = a - i.offset),
                                                (p = i.length);
                                        p > c && (p = c),
                                            (c -= p),
                                            (i.length -= p);
                                        do {
                                            r[a++] = m[g++];
                                        } while (--p);
                                        0 === i.length && (i.mode = 21);
                                        break;
                                    case 26:
                                        if (0 === c) break e;
                                        (r[a++] = i.length), c--, (i.mode = 21);
                                        break;
                                    case 27:
                                        if (i.wrap) {
                                            for (; h < 32; ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l |= n[s++] << h),
                                                    (h += 8);
                                            }
                                            if (
                                                ((d -= c),
                                                (e.total_out += d),
                                                (i.total += d),
                                                d &&
                                                    (e.adler = i.check =
                                                        i.flags
                                                            ? Rx(
                                                                  i.check,
                                                                  r,
                                                                  d,
                                                                  a - d
                                                              )
                                                            : Ox(
                                                                  i.check,
                                                                  r,
                                                                  d,
                                                                  a - d
                                                              )),
                                                (d = c),
                                                (i.flags ? l : yw(l)) !==
                                                    i.check)
                                            ) {
                                                (e.msg =
                                                    "incorrect data check"),
                                                    (i.mode = vw);
                                                break;
                                            }
                                            (l = 0), (h = 0);
                                        }
                                        i.mode = 28;
                                    case 28:
                                        if (i.wrap && i.flags) {
                                            for (; h < 32; ) {
                                                if (0 === o) break e;
                                                o--,
                                                    (l += n[s++] << h),
                                                    (h += 8);
                                            }
                                            if (l !== (4294967295 & i.total)) {
                                                (e.msg =
                                                    "incorrect length check"),
                                                    (i.mode = vw);
                                                break;
                                            }
                                            (l = 0), (h = 0);
                                        }
                                        i.mode = 29;
                                    case 29:
                                        w = uw;
                                        break e;
                                    case vw:
                                        w = gw;
                                        break e;
                                    case 31:
                                        return mw;
                                    default:
                                        return pw;
                                }
                            return (
                                (e.next_out = a),
                                (e.avail_out = c),
                                (e.next_in = s),
                                (e.avail_in = o),
                                (i.hold = l),
                                (i.bits = h),
                                (i.wsize ||
                                    (d !== e.avail_out &&
                                        i.mode < vw &&
                                        (i.mode < 27 || t !== ow))) &&
                                    Aw(
                                        e,
                                        e.output,
                                        e.next_out,
                                        d - e.avail_out
                                    ),
                                (u -= e.avail_in),
                                (d -= e.avail_out),
                                (e.total_in += u),
                                (e.total_out += d),
                                (i.total += d),
                                i.wrap &&
                                    d &&
                                    (e.adler = i.check =
                                        i.flags
                                            ? Rx(i.check, r, d, e.next_out - d)
                                            : Ox(
                                                  i.check,
                                                  r,
                                                  d,
                                                  e.next_out - d
                                              )),
                                (e.data_type =
                                    i.bits +
                                    (i.last ? 64 : 0) +
                                    (i.mode === Mw ? 128 : 0) +
                                    (20 === i.mode || 15 === i.mode ? 256 : 0)),
                                ((0 === u && 0 === d) || t === ow) &&
                                    w === hw &&
                                    (w = fw),
                                w
                            );
                        },
                        inflateEnd: (e) => {
                            if (!e || !e.state) return pw;
                            let t = e.state;
                            return (
                                t.window && (t.window = null),
                                (e.state = null),
                                hw
                            );
                        },
                        inflateGetHeader: (e, t) => {
                            if (!e || !e.state) return pw;
                            const i = e.state;
                            return 2 & i.wrap
                                ? ((i.head = t), (t.done = !1), hw)
                                : pw;
                        },
                        inflateSetDictionary: (e, t) => {
                            const i = t.length;
                            let n, r, s;
                            return e && e.state
                                ? ((n = e.state),
                                  0 !== n.wrap && 11 !== n.mode
                                      ? pw
                                      : 11 === n.mode &&
                                        ((r = 1),
                                        (r = Ox(r, t, i, 0)),
                                        r !== n.check)
                                      ? gw
                                      : ((s = Aw(e, t, i, i)),
                                        s
                                            ? ((n.mode = 31), mw)
                                            : ((n.havedict = 1), hw)))
                                : pw;
                        },
                        inflateInfo: "pako inflate (from Nodeca project)",
                    },
                    Lw = function () {
                        (this.text = 0),
                            (this.time = 0),
                            (this.xflags = 0),
                            (this.os = 0),
                            (this.extra = null),
                            (this.extra_len = 0),
                            (this.name = ""),
                            (this.comment = ""),
                            (this.hcrc = 0),
                            (this.done = !1);
                    };
                const zw = Object.prototype.toString,
                    {
                        Z_NO_FLUSH: jw,
                        Z_FINISH: Ow,
                        Z_OK: kw,
                        Z_STREAM_END: Rw,
                        Z_NEED_DICT: Pw,
                        Z_STREAM_ERROR: Uw,
                        Z_DATA_ERROR: $w,
                        Z_MEM_ERROR: Bw,
                    } = Ux;
                function Fw(e) {
                    this.options = Ub.assign(
                        { chunkSize: 65536, windowBits: 15, to: "" },
                        e || {}
                    );
                    const t = this.options;
                    t.raw &&
                        t.windowBits >= 0 &&
                        t.windowBits < 16 &&
                        ((t.windowBits = -t.windowBits),
                        0 === t.windowBits && (t.windowBits = -15)),
                        !(t.windowBits >= 0 && t.windowBits < 16) ||
                            (e && e.windowBits) ||
                            (t.windowBits += 32),
                        t.windowBits > 15 &&
                            t.windowBits < 48 &&
                            (15 & t.windowBits || (t.windowBits |= 15)),
                        (this.err = 0),
                        (this.msg = ""),
                        (this.ended = !1),
                        (this.chunks = []),
                        (this.strm = new Hb()),
                        (this.strm.avail_out = 0);
                    let i = Ew.inflateInit2(this.strm, t.windowBits);
                    if (i !== kw) throw new Error(Px[i]);
                    if (
                        ((this.header = new Lw()),
                        Ew.inflateGetHeader(this.strm, this.header),
                        t.dictionary &&
                            ("string" == typeof t.dictionary
                                ? (t.dictionary = Fb.string2buf(t.dictionary))
                                : "[object ArrayBuffer]" ===
                                      zw.call(t.dictionary) &&
                                  (t.dictionary = new Uint8Array(t.dictionary)),
                            t.raw &&
                                ((i = Ew.inflateSetDictionary(
                                    this.strm,
                                    t.dictionary
                                )),
                                i !== kw)))
                    )
                        throw new Error(Px[i]);
                }
                function Hw(e, t) {
                    const i = new Fw(t);
                    if ((i.push(e), i.err)) throw i.msg || Px[i.err];
                    return i.result;
                }
                (Fw.prototype.push = function (e, t) {
                    const i = this.strm,
                        n = this.options.chunkSize,
                        r = this.options.dictionary;
                    let s, a, o;
                    if (this.ended) return !1;
                    for (
                        a = t === ~~t ? t : !0 === t ? Ow : jw,
                            "[object ArrayBuffer]" === zw.call(e)
                                ? (i.input = new Uint8Array(e))
                                : (i.input = e),
                            i.next_in = 0,
                            i.avail_in = i.input.length;
                        ;

                    ) {
                        for (
                            0 === i.avail_out &&
                                ((i.output = new Uint8Array(n)),
                                (i.next_out = 0),
                                (i.avail_out = n)),
                                s = Ew.inflate(i, a),
                                s === Pw &&
                                    r &&
                                    ((s = Ew.inflateSetDictionary(i, r)),
                                    s === kw
                                        ? (s = Ew.inflate(i, a))
                                        : s === $w && (s = Pw));
                            i.avail_in > 0 &&
                            s === Rw &&
                            i.state.wrap > 0 &&
                            0 !== e[i.next_in];

                        )
                            Ew.inflateReset(i), (s = Ew.inflate(i, a));
                        switch (s) {
                            case Uw:
                            case $w:
                            case Pw:
                            case Bw:
                                return this.onEnd(s), (this.ended = !0), !1;
                        }
                        if (
                            ((o = i.avail_out),
                            i.next_out && (0 === i.avail_out || s === Rw))
                        )
                            if ("string" === this.options.to) {
                                let e = Fb.utf8border(i.output, i.next_out),
                                    t = i.next_out - e,
                                    r = Fb.buf2string(i.output, e);
                                (i.next_out = t),
                                    (i.avail_out = n - t),
                                    t &&
                                        i.output.set(
                                            i.output.subarray(e, e + t),
                                            0
                                        ),
                                    this.onData(r);
                            } else
                                this.onData(
                                    i.output.length === i.next_out
                                        ? i.output
                                        : i.output.subarray(0, i.next_out)
                                );
                        if (s !== kw || 0 !== o) {
                            if (s === Rw)
                                return (
                                    (s = Ew.inflateEnd(this.strm)),
                                    this.onEnd(s),
                                    (this.ended = !0),
                                    !0
                                );
                            if (0 === i.avail_in) break;
                        }
                    }
                    return !0;
                }),
                    (Fw.prototype.onData = function (e) {
                        this.chunks.push(e);
                    }),
                    (Fw.prototype.onEnd = function (e) {
                        e === kw &&
                            ("string" === this.options.to
                                ? (this.result = this.chunks.join(""))
                                : (this.result = Ub.flattenChunks(
                                      this.chunks
                                  ))),
                            (this.chunks = []),
                            (this.err = e),
                            (this.msg = this.strm.msg);
                    });
                var Gw = {
                    Inflate: Fw,
                    inflate: Hw,
                    inflateRaw: function (e, t) {
                        return ((t = t || {}).raw = !0), Hw(e, t);
                    },
                    ungzip: Hw,
                    constants: Ux,
                };
                const {
                    Inflate: Vw,
                    inflate: Yw,
                    inflateRaw: qw,
                    ungzip: Ww,
                } = Gw;
                var Qw = Yw,
                    Zw = Jw,
                    Xw = {
                        read: function (e, t, i, n, r) {
                            var s,
                                a,
                                o = 8 * r - n - 1,
                                c = (1 << o) - 1,
                                l = c >> 1,
                                h = -7,
                                u = i ? r - 1 : 0,
                                d = i ? -1 : 1,
                                p = e[t + u];
                            for (
                                u += d,
                                    s = p & ((1 << -h) - 1),
                                    p >>= -h,
                                    h += o;
                                h > 0;
                                s = 256 * s + e[t + u], u += d, h -= 8
                            );
                            for (
                                a = s & ((1 << -h) - 1), s >>= -h, h += n;
                                h > 0;
                                a = 256 * a + e[t + u], u += d, h -= 8
                            );
                            if (0 === s) s = 1 - l;
                            else {
                                if (s === c)
                                    return a ? NaN : (1 / 0) * (p ? -1 : 1);
                                (a += Math.pow(2, n)), (s -= l);
                            }
                            return (p ? -1 : 1) * a * Math.pow(2, s - n);
                        },
                        write: function (e, t, i, n, r, s) {
                            var a,
                                o,
                                c,
                                l = 8 * s - r - 1,
                                h = (1 << l) - 1,
                                u = h >> 1,
                                d =
                                    23 === r
                                        ? Math.pow(2, -24) - Math.pow(2, -77)
                                        : 0,
                                p = n ? 0 : s - 1,
                                g = n ? 1 : -1,
                                m = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
                            for (
                                t = Math.abs(t),
                                    isNaN(t) || t === 1 / 0
                                        ? ((o = isNaN(t) ? 1 : 0), (a = h))
                                        : ((a = Math.floor(
                                              Math.log(t) / Math.LN2
                                          )),
                                          t * (c = Math.pow(2, -a)) < 1 &&
                                              (a--, (c *= 2)),
                                          (t +=
                                              a + u >= 1
                                                  ? d / c
                                                  : d * Math.pow(2, 1 - u)) *
                                              c >=
                                              2 && (a++, (c /= 2)),
                                          a + u >= h
                                              ? ((o = 0), (a = h))
                                              : a + u >= 1
                                              ? ((o =
                                                    (t * c - 1) *
                                                    Math.pow(2, r)),
                                                (a += u))
                                              : ((o =
                                                    t *
                                                    Math.pow(2, u - 1) *
                                                    Math.pow(2, r)),
                                                (a = 0)));
                                r >= 8;
                                e[i + p] = 255 & o, p += g, o /= 256, r -= 8
                            );
                            for (
                                a = (a << r) | o, l += r;
                                l > 0;
                                e[i + p] = 255 & a, p += g, a /= 256, l -= 8
                            );
                            e[i + p - g] |= 128 * m;
                        },
                    };
                function Jw(e) {
                    (this.buf =
                        ArrayBuffer.isView && ArrayBuffer.isView(e)
                            ? e
                            : new Uint8Array(e || 0)),
                        (this.pos = 0),
                        (this.type = 0),
                        (this.length = this.buf.length);
                }
                (Jw.Varint = 0),
                    (Jw.Fixed64 = 1),
                    (Jw.Bytes = 2),
                    (Jw.Fixed32 = 5);
                var Kw = 4294967296,
                    eT = 1 / Kw,
                    tT =
                        "undefined" == typeof TextDecoder
                            ? null
                            : new TextDecoder("utf8");
                function iT(e) {
                    return e.type === Jw.Bytes
                        ? e.readVarint() + e.pos
                        : e.pos + 1;
                }
                function nT(e, t, i) {
                    return i
                        ? 4294967296 * t + (e >>> 0)
                        : 4294967296 * (t >>> 0) + (e >>> 0);
                }
                function rT(e, t, i) {
                    var n =
                        t <= 16383
                            ? 1
                            : t <= 2097151
                            ? 2
                            : t <= 268435455
                            ? 3
                            : Math.floor(Math.log(t) / (7 * Math.LN2));
                    i.realloc(n);
                    for (var r = i.pos - 1; r >= e; r--)
                        i.buf[r + n] = i.buf[r];
                }
                function sT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeVarint(e[i]);
                }
                function aT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeSVarint(e[i]);
                }
                function oT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeFloat(e[i]);
                }
                function cT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeDouble(e[i]);
                }
                function lT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeBoolean(e[i]);
                }
                function hT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeFixed32(e[i]);
                }
                function uT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeSFixed32(e[i]);
                }
                function dT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeFixed64(e[i]);
                }
                function pT(e, t) {
                    for (var i = 0; i < e.length; i++) t.writeSFixed64(e[i]);
                }
                function gT(e, t) {
                    return (
                        (e[t] | (e[t + 1] << 8) | (e[t + 2] << 16)) +
                        16777216 * e[t + 3]
                    );
                }
                function mT(e, t, i) {
                    (e[i] = t),
                        (e[i + 1] = t >>> 8),
                        (e[i + 2] = t >>> 16),
                        (e[i + 3] = t >>> 24);
                }
                function fT(e, t) {
                    return (
                        (e[t] | (e[t + 1] << 8) | (e[t + 2] << 16)) +
                        (e[t + 3] << 24)
                    );
                }
                function _T(e, t) {
                    return MT(e, "GET", "arraybuffer", [], null, t);
                }
                function MT(e, t, i, n, r, s) {
                    const a = new XMLHttpRequest(),
                        o = new Promise((s, o) => {
                            a.open(t, e, !0);
                            for (const e of n)
                                a.setRequestHeader(e.name, e.value);
                            (a.responseType = i),
                                (a.timeout = 15e3),
                                (a.onload = () => {
                                    var t;
                                    if (200 !== a.status) {
                                        const i =
                                            null !== (t = a.response) &&
                                            void 0 !== t
                                                ? t
                                                : new Ap(
                                                      `Response status error: ${e}`
                                                  );
                                        o(i);
                                    }
                                    a.response ||
                                        o(new Ap(`Response empty: ${e}`)),
                                        s(a.response);
                                }),
                                (a.onerror = () => {
                                    o(new Ap(`Request error: ${e}`));
                                }),
                                (a.ontimeout = () => {
                                    o(new Ap(`Request timeout: ${e}`));
                                }),
                                (a.onabort = () => {
                                    o(new Ap(`Request aborted: ${e}`));
                                }),
                                a.send("POST" === t ? r : null);
                        });
                    return (
                        s &&
                            s.catch(() => {
                                a.abort();
                            }),
                        o
                    );
                }
                function vT(e, t, i) {
                    1 === e
                        ? t.vertices.push(i.readFloat())
                        : 2 === e
                        ? t.faces.push(i.readVarint())
                        : console.warn(`Unsupported pbf tag (${e})`);
                }
                Jw.prototype = {
                    destroy: function () {
                        this.buf = null;
                    },
                    readFields: function (e, t, i) {
                        for (i = i || this.length; this.pos < i; ) {
                            var n = this.readVarint(),
                                r = n >> 3,
                                s = this.pos;
                            (this.type = 7 & n),
                                e(r, t, this),
                                this.pos === s && this.skip(n);
                        }
                        return t;
                    },
                    readMessage: function (e, t) {
                        return this.readFields(
                            e,
                            t,
                            this.readVarint() + this.pos
                        );
                    },
                    readFixed32: function () {
                        var e = gT(this.buf, this.pos);
                        return (this.pos += 4), e;
                    },
                    readSFixed32: function () {
                        var e = fT(this.buf, this.pos);
                        return (this.pos += 4), e;
                    },
                    readFixed64: function () {
                        var e =
                            gT(this.buf, this.pos) +
                            gT(this.buf, this.pos + 4) * Kw;
                        return (this.pos += 8), e;
                    },
                    readSFixed64: function () {
                        var e =
                            gT(this.buf, this.pos) +
                            fT(this.buf, this.pos + 4) * Kw;
                        return (this.pos += 8), e;
                    },
                    readFloat: function () {
                        var e = Xw.read(this.buf, this.pos, !0, 23, 4);
                        return (this.pos += 4), e;
                    },
                    readDouble: function () {
                        var e = Xw.read(this.buf, this.pos, !0, 52, 8);
                        return (this.pos += 8), e;
                    },
                    readVarint: function (e) {
                        var t,
                            i,
                            n = this.buf;
                        return (
                            (t = 127 & (i = n[this.pos++])),
                            i < 128
                                ? t
                                : ((t |= (127 & (i = n[this.pos++])) << 7),
                                  i < 128
                                      ? t
                                      : ((t |=
                                            (127 & (i = n[this.pos++])) << 14),
                                        i < 128
                                            ? t
                                            : ((t |=
                                                  (127 & (i = n[this.pos++])) <<
                                                  21),
                                              i < 128
                                                  ? t
                                                  : (function (e, t, i) {
                                                        var n,
                                                            r,
                                                            s = i.buf;
                                                        if (
                                                            ((n =
                                                                (112 &
                                                                    (r =
                                                                        s[
                                                                            i.pos++
                                                                        ])) >>
                                                                4),
                                                            r < 128)
                                                        )
                                                            return nT(e, n, t);
                                                        if (
                                                            ((n |=
                                                                (127 &
                                                                    (r =
                                                                        s[
                                                                            i.pos++
                                                                        ])) <<
                                                                3),
                                                            r < 128)
                                                        )
                                                            return nT(e, n, t);
                                                        if (
                                                            ((n |=
                                                                (127 &
                                                                    (r =
                                                                        s[
                                                                            i.pos++
                                                                        ])) <<
                                                                10),
                                                            r < 128)
                                                        )
                                                            return nT(e, n, t);
                                                        if (
                                                            ((n |=
                                                                (127 &
                                                                    (r =
                                                                        s[
                                                                            i.pos++
                                                                        ])) <<
                                                                17),
                                                            r < 128)
                                                        )
                                                            return nT(e, n, t);
                                                        if (
                                                            ((n |=
                                                                (127 &
                                                                    (r =
                                                                        s[
                                                                            i.pos++
                                                                        ])) <<
                                                                24),
                                                            r < 128)
                                                        )
                                                            return nT(e, n, t);
                                                        if (
                                                            ((n |=
                                                                (1 &
                                                                    (r =
                                                                        s[
                                                                            i.pos++
                                                                        ])) <<
                                                                31),
                                                            r < 128)
                                                        )
                                                            return nT(e, n, t);
                                                        throw new Error(
                                                            "Expected varint not more than 10 bytes"
                                                        );
                                                    })(
                                                        (t |=
                                                            (15 &
                                                                (i =
                                                                    n[
                                                                        this.pos
                                                                    ])) <<
                                                            28),
                                                        e,
                                                        this
                                                    ))))
                        );
                    },
                    readVarint64: function () {
                        return this.readVarint(!0);
                    },
                    readSVarint: function () {
                        var e = this.readVarint();
                        return e % 2 == 1 ? (e + 1) / -2 : e / 2;
                    },
                    readBoolean: function () {
                        return Boolean(this.readVarint());
                    },
                    readString: function () {
                        var e = this.readVarint() + this.pos,
                            t = this.pos;
                        return (
                            (this.pos = e),
                            e - t >= 12 && tT
                                ? (function (e, t, i) {
                                      return tT.decode(e.subarray(t, i));
                                  })(this.buf, t, e)
                                : (function (e, t, i) {
                                      for (var n = "", r = t; r < i; ) {
                                          var s,
                                              a,
                                              o,
                                              c = e[r],
                                              l = null,
                                              h =
                                                  c > 239
                                                      ? 4
                                                      : c > 223
                                                      ? 3
                                                      : c > 191
                                                      ? 2
                                                      : 1;
                                          if (r + h > i) break;
                                          1 === h
                                              ? c < 128 && (l = c)
                                              : 2 === h
                                              ? 128 == (192 & (s = e[r + 1])) &&
                                                (l =
                                                    ((31 & c) << 6) |
                                                    (63 & s)) <= 127 &&
                                                (l = null)
                                              : 3 === h
                                              ? ((s = e[r + 1]),
                                                (a = e[r + 2]),
                                                128 == (192 & s) &&
                                                    128 == (192 & a) &&
                                                    ((l =
                                                        ((15 & c) << 12) |
                                                        ((63 & s) << 6) |
                                                        (63 & a)) <= 2047 ||
                                                        (l >= 55296 &&
                                                            l <= 57343)) &&
                                                    (l = null))
                                              : 4 === h &&
                                                ((s = e[r + 1]),
                                                (a = e[r + 2]),
                                                (o = e[r + 3]),
                                                128 == (192 & s) &&
                                                    128 == (192 & a) &&
                                                    128 == (192 & o) &&
                                                    ((l =
                                                        ((15 & c) << 18) |
                                                        ((63 & s) << 12) |
                                                        ((63 & a) << 6) |
                                                        (63 & o)) <= 65535 ||
                                                        l >= 1114112) &&
                                                    (l = null)),
                                              null === l
                                                  ? ((l = 65533), (h = 1))
                                                  : l > 65535 &&
                                                    ((l -= 65536),
                                                    (n += String.fromCharCode(
                                                        ((l >>> 10) & 1023) |
                                                            55296
                                                    )),
                                                    (l = 56320 | (1023 & l))),
                                              (n += String.fromCharCode(l)),
                                              (r += h);
                                      }
                                      return n;
                                  })(this.buf, t, e)
                        );
                    },
                    readBytes: function () {
                        var e = this.readVarint() + this.pos,
                            t = this.buf.subarray(this.pos, e);
                        return (this.pos = e), t;
                    },
                    readPackedVarint: function (e, t) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readVarint(t));
                        var i = iT(this);
                        for (e = e || []; this.pos < i; )
                            e.push(this.readVarint(t));
                        return e;
                    },
                    readPackedSVarint: function (e) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readSVarint());
                        var t = iT(this);
                        for (e = e || []; this.pos < t; )
                            e.push(this.readSVarint());
                        return e;
                    },
                    readPackedBoolean: function (e) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readBoolean());
                        var t = iT(this);
                        for (e = e || []; this.pos < t; )
                            e.push(this.readBoolean());
                        return e;
                    },
                    readPackedFloat: function (e) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readFloat());
                        var t = iT(this);
                        for (e = e || []; this.pos < t; )
                            e.push(this.readFloat());
                        return e;
                    },
                    readPackedDouble: function (e) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readDouble());
                        var t = iT(this);
                        for (e = e || []; this.pos < t; )
                            e.push(this.readDouble());
                        return e;
                    },
                    readPackedFixed32: function (e) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readFixed32());
                        var t = iT(this);
                        for (e = e || []; this.pos < t; )
                            e.push(this.readFixed32());
                        return e;
                    },
                    readPackedSFixed32: function (e) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readSFixed32());
                        var t = iT(this);
                        for (e = e || []; this.pos < t; )
                            e.push(this.readSFixed32());
                        return e;
                    },
                    readPackedFixed64: function (e) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readFixed64());
                        var t = iT(this);
                        for (e = e || []; this.pos < t; )
                            e.push(this.readFixed64());
                        return e;
                    },
                    readPackedSFixed64: function (e) {
                        if (this.type !== Jw.Bytes)
                            return e.push(this.readSFixed64());
                        var t = iT(this);
                        for (e = e || []; this.pos < t; )
                            e.push(this.readSFixed64());
                        return e;
                    },
                    skip: function (e) {
                        var t = 7 & e;
                        if (t === Jw.Varint)
                            for (; this.buf[this.pos++] > 127; );
                        else if (t === Jw.Bytes)
                            this.pos = this.readVarint() + this.pos;
                        else if (t === Jw.Fixed32) this.pos += 4;
                        else {
                            if (t !== Jw.Fixed64)
                                throw new Error("Unimplemented type: " + t);
                            this.pos += 8;
                        }
                    },
                    writeTag: function (e, t) {
                        this.writeVarint((e << 3) | t);
                    },
                    realloc: function (e) {
                        for (var t = this.length || 16; t < this.pos + e; )
                            t *= 2;
                        if (t !== this.length) {
                            var i = new Uint8Array(t);
                            i.set(this.buf), (this.buf = i), (this.length = t);
                        }
                    },
                    finish: function () {
                        return (
                            (this.length = this.pos),
                            (this.pos = 0),
                            this.buf.subarray(0, this.length)
                        );
                    },
                    writeFixed32: function (e) {
                        this.realloc(4),
                            mT(this.buf, e, this.pos),
                            (this.pos += 4);
                    },
                    writeSFixed32: function (e) {
                        this.realloc(4),
                            mT(this.buf, e, this.pos),
                            (this.pos += 4);
                    },
                    writeFixed64: function (e) {
                        this.realloc(8),
                            mT(this.buf, -1 & e, this.pos),
                            mT(this.buf, Math.floor(e * eT), this.pos + 4),
                            (this.pos += 8);
                    },
                    writeSFixed64: function (e) {
                        this.realloc(8),
                            mT(this.buf, -1 & e, this.pos),
                            mT(this.buf, Math.floor(e * eT), this.pos + 4),
                            (this.pos += 8);
                    },
                    writeVarint: function (e) {
                        (e = +e || 0) > 268435455 || e < 0
                            ? (function (e, t) {
                                  var i, n;
                                  if (
                                      (e >= 0
                                          ? ((i = e % 4294967296 | 0),
                                            (n = (e / 4294967296) | 0))
                                          : ((n = ~(-e / 4294967296)),
                                            4294967295 ^
                                            (i = ~(-e % 4294967296))
                                                ? (i = (i + 1) | 0)
                                                : ((i = 0), (n = (n + 1) | 0))),
                                      e >= 0x10000000000000000 ||
                                          e < -0x10000000000000000)
                                  )
                                      throw new Error(
                                          "Given varint doesn't fit into 10 bytes"
                                      );
                                  t.realloc(10),
                                      (function (e, t, i) {
                                          (i.buf[i.pos++] = (127 & e) | 128),
                                              (e >>>= 7),
                                              (i.buf[i.pos++] =
                                                  (127 & e) | 128),
                                              (e >>>= 7),
                                              (i.buf[i.pos++] =
                                                  (127 & e) | 128),
                                              (e >>>= 7),
                                              (i.buf[i.pos++] =
                                                  (127 & e) | 128),
                                              (e >>>= 7),
                                              (i.buf[i.pos] = 127 & e);
                                      })(i, 0, t),
                                      (function (e, t) {
                                          var i = (7 & e) << 4;
                                          (t.buf[t.pos++] |=
                                              i | ((e >>>= 3) ? 128 : 0)),
                                              e &&
                                                  ((t.buf[t.pos++] =
                                                      (127 & e) |
                                                      ((e >>>= 7) ? 128 : 0)),
                                                  e &&
                                                      ((t.buf[t.pos++] =
                                                          (127 & e) |
                                                          ((e >>>= 7)
                                                              ? 128
                                                              : 0)),
                                                      e &&
                                                          ((t.buf[t.pos++] =
                                                              (127 & e) |
                                                              ((e >>>= 7)
                                                                  ? 128
                                                                  : 0)),
                                                          e &&
                                                              ((t.buf[t.pos++] =
                                                                  (127 & e) |
                                                                  ((e >>>= 7)
                                                                      ? 128
                                                                      : 0)),
                                                              e &&
                                                                  (t.buf[
                                                                      t.pos++
                                                                  ] =
                                                                      127 &
                                                                      e)))));
                                      })(n, t);
                              })(e, this)
                            : (this.realloc(4),
                              (this.buf[this.pos++] =
                                  (127 & e) | (e > 127 ? 128 : 0)),
                              e <= 127 ||
                                  ((this.buf[this.pos++] =
                                      (127 & (e >>>= 7)) | (e > 127 ? 128 : 0)),
                                  e <= 127 ||
                                      ((this.buf[this.pos++] =
                                          (127 & (e >>>= 7)) |
                                          (e > 127 ? 128 : 0)),
                                      e <= 127 ||
                                          (this.buf[this.pos++] =
                                              (e >>> 7) & 127))));
                    },
                    writeSVarint: function (e) {
                        this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
                    },
                    writeBoolean: function (e) {
                        this.writeVarint(Boolean(e));
                    },
                    writeString: function (e) {
                        (e = String(e)), this.realloc(4 * e.length), this.pos++;
                        var t = this.pos;
                        this.pos = (function (e, t, i) {
                            for (var n, r, s = 0; s < t.length; s++) {
                                if (
                                    (n = t.charCodeAt(s)) > 55295 &&
                                    n < 57344
                                ) {
                                    if (!r) {
                                        n > 56319 || s + 1 === t.length
                                            ? ((e[i++] = 239),
                                              (e[i++] = 191),
                                              (e[i++] = 189))
                                            : (r = n);
                                        continue;
                                    }
                                    if (n < 56320) {
                                        (e[i++] = 239),
                                            (e[i++] = 191),
                                            (e[i++] = 189),
                                            (r = n);
                                        continue;
                                    }
                                    (n =
                                        ((r - 55296) << 10) |
                                        (n - 56320) |
                                        65536),
                                        (r = null);
                                } else
                                    r &&
                                        ((e[i++] = 239),
                                        (e[i++] = 191),
                                        (e[i++] = 189),
                                        (r = null));
                                n < 128
                                    ? (e[i++] = n)
                                    : (n < 2048
                                          ? (e[i++] = (n >> 6) | 192)
                                          : (n < 65536
                                                ? (e[i++] = (n >> 12) | 224)
                                                : ((e[i++] = (n >> 18) | 240),
                                                  (e[i++] =
                                                      ((n >> 12) & 63) | 128)),
                                            (e[i++] = ((n >> 6) & 63) | 128)),
                                      (e[i++] = (63 & n) | 128));
                            }
                            return i;
                        })(this.buf, e, this.pos);
                        var i = this.pos - t;
                        i >= 128 && rT(t, i, this),
                            (this.pos = t - 1),
                            this.writeVarint(i),
                            (this.pos += i);
                    },
                    writeFloat: function (e) {
                        this.realloc(4),
                            Xw.write(this.buf, e, this.pos, !0, 23, 4),
                            (this.pos += 4);
                    },
                    writeDouble: function (e) {
                        this.realloc(8),
                            Xw.write(this.buf, e, this.pos, !0, 52, 8),
                            (this.pos += 8);
                    },
                    writeBytes: function (e) {
                        var t = e.length;
                        this.writeVarint(t), this.realloc(t);
                        for (var i = 0; i < t; i++) this.buf[this.pos++] = e[i];
                    },
                    writeRawMessage: function (e, t) {
                        this.pos++;
                        var i = this.pos;
                        e(t, this);
                        var n = this.pos - i;
                        n >= 128 && rT(i, n, this),
                            (this.pos = i - 1),
                            this.writeVarint(n),
                            (this.pos += n);
                    },
                    writeMessage: function (e, t, i) {
                        this.writeTag(e, Jw.Bytes), this.writeRawMessage(t, i);
                    },
                    writePackedVarint: function (e, t) {
                        t.length && this.writeMessage(e, sT, t);
                    },
                    writePackedSVarint: function (e, t) {
                        t.length && this.writeMessage(e, aT, t);
                    },
                    writePackedBoolean: function (e, t) {
                        t.length && this.writeMessage(e, lT, t);
                    },
                    writePackedFloat: function (e, t) {
                        t.length && this.writeMessage(e, oT, t);
                    },
                    writePackedDouble: function (e, t) {
                        t.length && this.writeMessage(e, cT, t);
                    },
                    writePackedFixed32: function (e, t) {
                        t.length && this.writeMessage(e, hT, t);
                    },
                    writePackedSFixed32: function (e, t) {
                        t.length && this.writeMessage(e, uT, t);
                    },
                    writePackedFixed64: function (e, t) {
                        t.length && this.writeMessage(e, dT, t);
                    },
                    writePackedSFixed64: function (e, t) {
                        t.length && this.writeMessage(e, pT, t);
                    },
                    writeBytesField: function (e, t) {
                        this.writeTag(e, Jw.Bytes), this.writeBytes(t);
                    },
                    writeFixed32Field: function (e, t) {
                        this.writeTag(e, Jw.Fixed32), this.writeFixed32(t);
                    },
                    writeSFixed32Field: function (e, t) {
                        this.writeTag(e, Jw.Fixed32), this.writeSFixed32(t);
                    },
                    writeFixed64Field: function (e, t) {
                        this.writeTag(e, Jw.Fixed64), this.writeFixed64(t);
                    },
                    writeSFixed64Field: function (e, t) {
                        this.writeTag(e, Jw.Fixed64), this.writeSFixed64(t);
                    },
                    writeVarintField: function (e, t) {
                        this.writeTag(e, Jw.Varint), this.writeVarint(t);
                    },
                    writeSVarintField: function (e, t) {
                        this.writeTag(e, Jw.Varint), this.writeSVarint(t);
                    },
                    writeStringField: function (e, t) {
                        this.writeTag(e, Jw.Bytes), this.writeString(t);
                    },
                    writeFloatField: function (e, t) {
                        this.writeTag(e, Jw.Fixed32), this.writeFloat(t);
                    },
                    writeDoubleField: function (e, t) {
                        this.writeTag(e, Jw.Fixed64), this.writeDouble(t);
                    },
                    writeBooleanField: function (e, t) {
                        this.writeVarintField(e, Boolean(t));
                    },
                };
                class yT extends r_ {
                    constructor(e) {
                        super(), (this._geometry = e);
                    }
                    get geometry() {
                        return this._geometry;
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    getCoreImages(e) {
                        return Promise.reject(new Ap("Not implemented"));
                    }
                    getCluster(e, t) {
                        return Promise.reject(new Ap("Not implemented"));
                    }
                    getSpatialImages(e) {
                        return Promise.reject(new Ap("Not implemented"));
                    }
                    getImages(e) {
                        return Promise.reject(new Ap("Not implemented"));
                    }
                    getImageBuffer(e, t) {
                        return Promise.reject(new Ap("Not implemented"));
                    }
                    getImageTiles(e) {
                        return Promise.reject(new Ap("Not implemented"));
                    }
                    getMesh(e, t) {
                        return Promise.reject(new Ap("Not implemented"));
                    }
                    getSequence(e) {
                        return Promise.reject(new Ap("Not implemented"));
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                    setAccessToken(e) {
                        throw new Ap("Not implemented");
                    }
                }
                class xT {
                    constructor() {}
                    bboxToCellIds(e, t) {
                        throw new Ap("Not implemented");
                    }
                    getAdjacent(e) {
                        throw new Ap("Not implemented");
                    }
                    getVertices(e) {
                        throw new Ap("Not implemented");
                    }
                    lngLatToCellId(e) {
                        throw new Ap("Not implemented");
                    }
                    _approxBboxToCellIds(e, t) {
                        if (t.lat <= e.lat || t.lng <= e.lng)
                            throw new Ap(
                                "North east needs to be top right of south west"
                            );
                        const i = (e.lat + t.lat) / 2,
                            n = (e.lng + t.lng) / 2,
                            r = vp(t.lng, t.lat, 0, n, i, 0),
                            s = Math.max(r[0], r[1]);
                        return this._lngLatToCellIds({ lat: i, lng: n }, s);
                    }
                    _enuToGeodetic(e, t) {
                        const [i, n] = yp(e[0], e[1], e[2], t.lng, t.lat, 0);
                        return { lat: n, lng: i };
                    }
                    _getLngLatBoundingBoxCorners(e, t) {
                        return [
                            [-t, t, 0],
                            [t, t, 0],
                            [t, -t, 0],
                            [-t, -t, 0],
                        ].map((t) => this._enuToGeodetic(t, e));
                    }
                    _lngLatToCellIds(e, t) {
                        const i = this.lngLatToCellId(e),
                            n = this._getLngLatBoundingBoxCorners(e, t);
                        for (const e of n)
                            if (this.lngLatToCellId(e) !== i)
                                return [i, ...this.getAdjacent(i)];
                        return [i];
                    }
                }
                var bT,
                    wT,
                    TT,
                    ST,
                    NT,
                    DT = { exports: {} },
                    IT = { exports: {} };
                (bT = IT),
                    (function (e, t) {
                        bT && bT.exports
                            ? (bT.exports = t())
                            : ((e.dcodeIO = e.dcodeIO || {}).Long = t());
                    })(cg, function () {
                        function e(e, t, i) {
                            (this.low = 0 | e),
                                (this.high = 0 | t),
                                (this.unsigned = !!i);
                        }
                        function t(e) {
                            return !0 === (e && e.__isLong__);
                        }
                        e.prototype.__isLong__,
                            Object.defineProperty(e.prototype, "__isLong__", {
                                value: !0,
                                enumerable: !1,
                                configurable: !1,
                            }),
                            (e.isLong = t);
                        var i = {},
                            n = {};
                        function r(e, t) {
                            var r, s, o;
                            return t
                                ? (o = 0 <= (e >>>= 0) && e < 256) && (s = n[e])
                                    ? s
                                    : ((r = a(e, (0 | e) < 0 ? -1 : 0, !0)),
                                      o && (n[e] = r),
                                      r)
                                : (o = -128 <= (e |= 0) && e < 128) &&
                                  (s = i[e])
                                ? s
                                : ((r = a(e, e < 0 ? -1 : 0, !1)),
                                  o && (i[e] = r),
                                  r);
                        }
                        function s(e, t) {
                            if (isNaN(e) || !isFinite(e)) return t ? m : g;
                            if (t) {
                                if (e < 0) return m;
                                if (e >= u) return y;
                            } else {
                                if (e <= -d) return x;
                                if (e + 1 >= d) return v;
                            }
                            return e < 0
                                ? s(-e, t).neg()
                                : a(e % h | 0, (e / h) | 0, t);
                        }
                        function a(t, i, n) {
                            return new e(t, i, n);
                        }
                        (e.fromInt = r), (e.fromNumber = s), (e.fromBits = a);
                        var o = Math.pow;
                        function c(e, t, i) {
                            if (0 === e.length) throw Error("empty string");
                            if (
                                "NaN" === e ||
                                "Infinity" === e ||
                                "+Infinity" === e ||
                                "-Infinity" === e
                            )
                                return g;
                            if (
                                ("number" == typeof t
                                    ? ((i = t), (t = !1))
                                    : (t = !!t),
                                (i = i || 10) < 2 || 36 < i)
                            )
                                throw RangeError("radix");
                            var n;
                            if ((n = e.indexOf("-")) > 0)
                                throw Error("interior hyphen");
                            if (0 === n) return c(e.substring(1), t, i).neg();
                            for (
                                var r = s(o(i, 8)), a = g, l = 0;
                                l < e.length;
                                l += 8
                            ) {
                                var h = Math.min(8, e.length - l),
                                    u = parseInt(e.substring(l, l + h), i);
                                if (h < 8) {
                                    var d = s(o(i, h));
                                    a = a.mul(d).add(s(u));
                                } else a = (a = a.mul(r)).add(s(u));
                            }
                            return (a.unsigned = t), a;
                        }
                        function l(t) {
                            return t instanceof e
                                ? t
                                : "number" == typeof t
                                ? s(t)
                                : "string" == typeof t
                                ? c(t)
                                : a(t.low, t.high, t.unsigned);
                        }
                        (e.fromString = c), (e.fromValue = l);
                        var h = 4294967296,
                            u = h * h,
                            d = u / 2,
                            p = r(1 << 24),
                            g = r(0);
                        e.ZERO = g;
                        var m = r(0, !0);
                        e.UZERO = m;
                        var f = r(1);
                        e.ONE = f;
                        var _ = r(1, !0);
                        e.UONE = _;
                        var M = r(-1);
                        e.NEG_ONE = M;
                        var v = a(-1, 2147483647, !1);
                        e.MAX_VALUE = v;
                        var y = a(-1, -1, !0);
                        e.MAX_UNSIGNED_VALUE = y;
                        var x = a(0, -2147483648, !1);
                        e.MIN_VALUE = x;
                        var b = e.prototype;
                        return (
                            (b.toInt = function () {
                                return this.unsigned
                                    ? this.low >>> 0
                                    : this.low;
                            }),
                            (b.toNumber = function () {
                                return this.unsigned
                                    ? (this.high >>> 0) * h + (this.low >>> 0)
                                    : this.high * h + (this.low >>> 0);
                            }),
                            (b.toString = function (e) {
                                if ((e = e || 10) < 2 || 36 < e)
                                    throw RangeError("radix");
                                if (this.isZero()) return "0";
                                if (this.isNegative()) {
                                    if (this.eq(x)) {
                                        var t = s(e),
                                            i = this.div(t),
                                            n = i.mul(t).sub(this);
                                        return (
                                            i.toString(e) +
                                            n.toInt().toString(e)
                                        );
                                    }
                                    return "-" + this.neg().toString(e);
                                }
                                for (
                                    var r = s(o(e, 6), this.unsigned),
                                        a = this,
                                        c = "";
                                    ;

                                ) {
                                    var l = a.div(r),
                                        h = (
                                            a.sub(l.mul(r)).toInt() >>> 0
                                        ).toString(e);
                                    if ((a = l).isZero()) return h + c;
                                    for (; h.length < 6; ) h = "0" + h;
                                    c = "" + h + c;
                                }
                            }),
                            (b.getHighBits = function () {
                                return this.high;
                            }),
                            (b.getHighBitsUnsigned = function () {
                                return this.high >>> 0;
                            }),
                            (b.getLowBits = function () {
                                return this.low;
                            }),
                            (b.getLowBitsUnsigned = function () {
                                return this.low >>> 0;
                            }),
                            (b.getNumBitsAbs = function () {
                                if (this.isNegative())
                                    return this.eq(x)
                                        ? 64
                                        : this.neg().getNumBitsAbs();
                                for (
                                    var e =
                                            0 != this.high
                                                ? this.high
                                                : this.low,
                                        t = 31;
                                    t > 0 && !(e & (1 << t));
                                    t--
                                );
                                return 0 != this.high ? t + 33 : t + 1;
                            }),
                            (b.isZero = function () {
                                return 0 === this.high && 0 === this.low;
                            }),
                            (b.isNegative = function () {
                                return !this.unsigned && this.high < 0;
                            }),
                            (b.isPositive = function () {
                                return this.unsigned || this.high >= 0;
                            }),
                            (b.isOdd = function () {
                                return !(1 & ~this.low);
                            }),
                            (b.isEven = function () {
                                return !(1 & this.low);
                            }),
                            (b.equals = function (e) {
                                return (
                                    t(e) || (e = l(e)),
                                    (this.unsigned === e.unsigned ||
                                        this.high >>> 31 != 1 ||
                                        e.high >>> 31 != 1) &&
                                        this.high === e.high &&
                                        this.low === e.low
                                );
                            }),
                            (b.eq = b.equals),
                            (b.notEquals = function (e) {
                                return !this.eq(e);
                            }),
                            (b.neq = b.notEquals),
                            (b.lessThan = function (e) {
                                return this.comp(e) < 0;
                            }),
                            (b.lt = b.lessThan),
                            (b.lessThanOrEqual = function (e) {
                                return this.comp(e) <= 0;
                            }),
                            (b.lte = b.lessThanOrEqual),
                            (b.greaterThan = function (e) {
                                return this.comp(e) > 0;
                            }),
                            (b.gt = b.greaterThan),
                            (b.greaterThanOrEqual = function (e) {
                                return this.comp(e) >= 0;
                            }),
                            (b.gte = b.greaterThanOrEqual),
                            (b.compare = function (e) {
                                if ((t(e) || (e = l(e)), this.eq(e))) return 0;
                                var i = this.isNegative(),
                                    n = e.isNegative();
                                return i && !n
                                    ? -1
                                    : !i && n
                                    ? 1
                                    : this.unsigned
                                    ? e.high >>> 0 > this.high >>> 0 ||
                                      (e.high === this.high &&
                                          e.low >>> 0 > this.low >>> 0)
                                        ? -1
                                        : 1
                                    : this.sub(e).isNegative()
                                    ? -1
                                    : 1;
                            }),
                            (b.comp = b.compare),
                            (b.negate = function () {
                                return !this.unsigned && this.eq(x)
                                    ? x
                                    : this.not().add(f);
                            }),
                            (b.neg = b.negate),
                            (b.add = function (e) {
                                t(e) || (e = l(e));
                                var i = this.high >>> 16,
                                    n = 65535 & this.high,
                                    r = this.low >>> 16,
                                    s = 65535 & this.low,
                                    o = e.high >>> 16,
                                    c = 65535 & e.high,
                                    h = e.low >>> 16,
                                    u = 0,
                                    d = 0,
                                    p = 0,
                                    g = 0;
                                return (
                                    (p += (g += s + (65535 & e.low)) >>> 16),
                                    (d += (p += r + h) >>> 16),
                                    (u += (d += n + c) >>> 16),
                                    (u += i + o),
                                    a(
                                        ((p &= 65535) << 16) | (g &= 65535),
                                        ((u &= 65535) << 16) | (d &= 65535),
                                        this.unsigned
                                    )
                                );
                            }),
                            (b.subtract = function (e) {
                                return t(e) || (e = l(e)), this.add(e.neg());
                            }),
                            (b.sub = b.subtract),
                            (b.multiply = function (e) {
                                if (this.isZero()) return g;
                                if ((t(e) || (e = l(e)), e.isZero())) return g;
                                if (this.eq(x)) return e.isOdd() ? x : g;
                                if (e.eq(x)) return this.isOdd() ? x : g;
                                if (this.isNegative())
                                    return e.isNegative()
                                        ? this.neg().mul(e.neg())
                                        : this.neg().mul(e).neg();
                                if (e.isNegative())
                                    return this.mul(e.neg()).neg();
                                if (this.lt(p) && e.lt(p))
                                    return s(
                                        this.toNumber() * e.toNumber(),
                                        this.unsigned
                                    );
                                var i = this.high >>> 16,
                                    n = 65535 & this.high,
                                    r = this.low >>> 16,
                                    o = 65535 & this.low,
                                    c = e.high >>> 16,
                                    h = 65535 & e.high,
                                    u = e.low >>> 16,
                                    d = 65535 & e.low,
                                    m = 0,
                                    f = 0,
                                    _ = 0,
                                    M = 0;
                                return (
                                    (_ += (M += o * d) >>> 16),
                                    (f += (_ += r * d) >>> 16),
                                    (_ &= 65535),
                                    (f += (_ += o * u) >>> 16),
                                    (m += (f += n * d) >>> 16),
                                    (f &= 65535),
                                    (m += (f += r * u) >>> 16),
                                    (f &= 65535),
                                    (m += (f += o * h) >>> 16),
                                    (m += i * d + n * u + r * h + o * c),
                                    a(
                                        ((_ &= 65535) << 16) | (M &= 65535),
                                        ((m &= 65535) << 16) | (f &= 65535),
                                        this.unsigned
                                    )
                                );
                            }),
                            (b.mul = b.multiply),
                            (b.divide = function (e) {
                                if ((t(e) || (e = l(e)), e.isZero()))
                                    throw Error("division by zero");
                                if (this.isZero()) return this.unsigned ? m : g;
                                var i, n, r;
                                if (this.unsigned) {
                                    if (
                                        (e.unsigned || (e = e.toUnsigned()),
                                        e.gt(this))
                                    )
                                        return m;
                                    if (e.gt(this.shru(1))) return _;
                                    r = m;
                                } else {
                                    if (this.eq(x))
                                        return e.eq(f) || e.eq(M)
                                            ? x
                                            : e.eq(x)
                                            ? f
                                            : (i = this.shr(1)
                                                  .div(e)
                                                  .shl(1)).eq(g)
                                            ? e.isNegative()
                                                ? f
                                                : M
                                            : ((n = this.sub(e.mul(i))),
                                              (r = i.add(n.div(e))));
                                    if (e.eq(x)) return this.unsigned ? m : g;
                                    if (this.isNegative())
                                        return e.isNegative()
                                            ? this.neg().div(e.neg())
                                            : this.neg().div(e).neg();
                                    if (e.isNegative())
                                        return this.div(e.neg()).neg();
                                    r = g;
                                }
                                for (n = this; n.gte(e); ) {
                                    i = Math.max(
                                        1,
                                        Math.floor(n.toNumber() / e.toNumber())
                                    );
                                    for (
                                        var a = Math.ceil(
                                                Math.log(i) / Math.LN2
                                            ),
                                            c = a <= 48 ? 1 : o(2, a - 48),
                                            h = s(i),
                                            u = h.mul(e);
                                        u.isNegative() || u.gt(n);

                                    )
                                        u = (h = s(
                                            (i -= c),
                                            this.unsigned
                                        )).mul(e);
                                    h.isZero() && (h = f),
                                        (r = r.add(h)),
                                        (n = n.sub(u));
                                }
                                return r;
                            }),
                            (b.div = b.divide),
                            (b.modulo = function (e) {
                                return (
                                    t(e) || (e = l(e)),
                                    this.sub(this.div(e).mul(e))
                                );
                            }),
                            (b.mod = b.modulo),
                            (b.not = function () {
                                return a(~this.low, ~this.high, this.unsigned);
                            }),
                            (b.and = function (e) {
                                return (
                                    t(e) || (e = l(e)),
                                    a(
                                        this.low & e.low,
                                        this.high & e.high,
                                        this.unsigned
                                    )
                                );
                            }),
                            (b.or = function (e) {
                                return (
                                    t(e) || (e = l(e)),
                                    a(
                                        this.low | e.low,
                                        this.high | e.high,
                                        this.unsigned
                                    )
                                );
                            }),
                            (b.xor = function (e) {
                                return (
                                    t(e) || (e = l(e)),
                                    a(
                                        this.low ^ e.low,
                                        this.high ^ e.high,
                                        this.unsigned
                                    )
                                );
                            }),
                            (b.shiftLeft = function (e) {
                                return (
                                    t(e) && (e = e.toInt()),
                                    0 == (e &= 63)
                                        ? this
                                        : e < 32
                                        ? a(
                                              this.low << e,
                                              (this.high << e) |
                                                  (this.low >>> (32 - e)),
                                              this.unsigned
                                          )
                                        : a(
                                              0,
                                              this.low << (e - 32),
                                              this.unsigned
                                          )
                                );
                            }),
                            (b.shl = b.shiftLeft),
                            (b.shiftRight = function (e) {
                                return (
                                    t(e) && (e = e.toInt()),
                                    0 == (e &= 63)
                                        ? this
                                        : e < 32
                                        ? a(
                                              (this.low >>> e) |
                                                  (this.high << (32 - e)),
                                              this.high >> e,
                                              this.unsigned
                                          )
                                        : a(
                                              this.high >> (e - 32),
                                              this.high >= 0 ? 0 : -1,
                                              this.unsigned
                                          )
                                );
                            }),
                            (b.shr = b.shiftRight),
                            (b.shiftRightUnsigned = function (e) {
                                if ((t(e) && (e = e.toInt()), 0 == (e &= 63)))
                                    return this;
                                var i = this.high;
                                return e < 32
                                    ? a(
                                          (this.low >>> e) | (i << (32 - e)),
                                          i >>> e,
                                          this.unsigned
                                      )
                                    : a(
                                          32 === e ? i : i >>> (e - 32),
                                          0,
                                          this.unsigned
                                      );
                            }),
                            (b.shru = b.shiftRightUnsigned),
                            (b.toSigned = function () {
                                return this.unsigned
                                    ? a(this.low, this.high, !1)
                                    : this;
                            }),
                            (b.toUnsigned = function () {
                                return this.unsigned
                                    ? this
                                    : a(this.low, this.high, !0);
                            }),
                            (b.toBytes = function (e) {
                                return e ? this.toBytesLE() : this.toBytesBE();
                            }),
                            (b.toBytesLE = function () {
                                var e = this.high,
                                    t = this.low;
                                return [
                                    255 & t,
                                    (t >>> 8) & 255,
                                    (t >>> 16) & 255,
                                    (t >>> 24) & 255,
                                    255 & e,
                                    (e >>> 8) & 255,
                                    (e >>> 16) & 255,
                                    (e >>> 24) & 255,
                                ];
                            }),
                            (b.toBytesBE = function () {
                                var e = this.high,
                                    t = this.low;
                                return [
                                    (e >>> 24) & 255,
                                    (e >>> 16) & 255,
                                    (e >>> 8) & 255,
                                    255 & e,
                                    (t >>> 24) & 255,
                                    (t >>> 16) & 255,
                                    (t >>> 8) & 255,
                                    255 & t,
                                ];
                            }),
                            e
                        );
                    }),
                    (function (e) {
                        !(function (e) {
                            var t = (e.S2 = { L: {} });
                            (t.L.LatLng = function (e, t, i) {
                                var n = parseFloat(e, 10),
                                    r = parseFloat(t, 10);
                                if (isNaN(n) || isNaN(r))
                                    throw new Error(
                                        "Invalid LatLng object: (" +
                                            e +
                                            ", " +
                                            t +
                                            ")"
                                    );
                                return (
                                    !0 !== i &&
                                        ((n = Math.max(Math.min(n, 90), -90)),
                                        (r =
                                            ((r + 180) % 360) +
                                            (r < -180 || 180 === r
                                                ? 180
                                                : -180))),
                                    { lat: n, lng: r }
                                );
                            }),
                                (t.L.LatLng.DEG_TO_RAD = Math.PI / 180),
                                (t.L.LatLng.RAD_TO_DEG = 180 / Math.PI),
                                (t.LatLngToXYZ = function (e) {
                                    var i = t.L.LatLng.DEG_TO_RAD,
                                        n = e.lat * i,
                                        r = e.lng * i,
                                        s = Math.cos(n);
                                    return [
                                        Math.cos(r) * s,
                                        Math.sin(r) * s,
                                        Math.sin(n),
                                    ];
                                }),
                                (t.XYZToLatLng = function (e) {
                                    var i = t.L.LatLng.RAD_TO_DEG,
                                        n = Math.atan2(
                                            e[2],
                                            Math.sqrt(e[0] * e[0] + e[1] * e[1])
                                        ),
                                        r = Math.atan2(e[1], e[0]);
                                    return t.L.LatLng(n * i, r * i);
                                }),
                                (t.XYZToFaceUV = function (e) {
                                    var t = (function (e) {
                                        var t = [
                                            Math.abs(e[0]),
                                            Math.abs(e[1]),
                                            Math.abs(e[2]),
                                        ];
                                        return t[0] > t[1]
                                            ? t[0] > t[2]
                                                ? 0
                                                : 2
                                            : t[1] > t[2]
                                            ? 1
                                            : 2;
                                    })(e);
                                    e[t] < 0 && (t += 3);
                                    var i = (function (e, t) {
                                        var i, n;
                                        switch (e) {
                                            case 0:
                                                (i = t[1] / t[0]),
                                                    (n = t[2] / t[0]);
                                                break;
                                            case 1:
                                                (i = -t[0] / t[1]),
                                                    (n = t[2] / t[1]);
                                                break;
                                            case 2:
                                                (i = -t[0] / t[2]),
                                                    (n = -t[1] / t[2]);
                                                break;
                                            case 3:
                                                (i = t[2] / t[0]),
                                                    (n = t[1] / t[0]);
                                                break;
                                            case 4:
                                                (i = t[2] / t[1]),
                                                    (n = -t[0] / t[1]);
                                                break;
                                            case 5:
                                                (i = -t[1] / t[2]),
                                                    (n = -t[0] / t[2]);
                                                break;
                                            default:
                                                throw { error: "Invalid face" };
                                        }
                                        return [i, n];
                                    })(t, e);
                                    return [t, i];
                                }),
                                (t.FaceUVToXYZ = function (e, t) {
                                    var i = t[0],
                                        n = t[1];
                                    switch (e) {
                                        case 0:
                                            return [1, i, n];
                                        case 1:
                                            return [-i, 1, n];
                                        case 2:
                                            return [-i, -n, 1];
                                        case 3:
                                            return [-1, -n, -i];
                                        case 4:
                                            return [n, -1, -i];
                                        case 5:
                                            return [n, i, -1];
                                        default:
                                            throw { error: "Invalid face" };
                                    }
                                });
                            var i = function (e) {
                                return e >= 0.5
                                    ? (1 / 3) * (4 * e * e - 1)
                                    : (1 / 3) * (1 - 4 * (1 - e) * (1 - e));
                            };
                            t.STToUV = function (e) {
                                return [i(e[0]), i(e[1])];
                            };
                            var n = function (e) {
                                return e >= 0
                                    ? 0.5 * Math.sqrt(1 + 3 * e)
                                    : 1 - 0.5 * Math.sqrt(1 - 3 * e);
                            };
                            (t.UVToST = function (e) {
                                return [n(e[0]), n(e[1])];
                            }),
                                (t.STToIJ = function (e, t) {
                                    var i = 1 << t,
                                        n = function (e) {
                                            var t = Math.floor(e * i);
                                            return Math.max(
                                                0,
                                                Math.min(i - 1, t)
                                            );
                                        };
                                    return [n(e[0]), n(e[1])];
                                }),
                                (t.IJToST = function (e, t, i) {
                                    var n = 1 << t;
                                    return [
                                        (e[0] + i[0]) / n,
                                        (e[1] + i[1]) / n,
                                    ];
                                });
                            var r = function (e, t, i, n) {
                                    if (0 == n) {
                                        1 == i &&
                                            ((t.x = e - 1 - t.x),
                                            (t.y = e - 1 - t.y));
                                        var r = t.x;
                                        (t.x = t.y), (t.y = r);
                                    }
                                },
                                s = function (e, t, i, n) {
                                    var r = {
                                        a: [
                                            [0, "d"],
                                            [1, "a"],
                                            [3, "b"],
                                            [2, "a"],
                                        ],
                                        b: [
                                            [2, "b"],
                                            [1, "b"],
                                            [3, "a"],
                                            [0, "c"],
                                        ],
                                        c: [
                                            [2, "c"],
                                            [3, "d"],
                                            [1, "c"],
                                            [0, "b"],
                                        ],
                                        d: [
                                            [0, "a"],
                                            [3, "c"],
                                            [1, "d"],
                                            [2, "d"],
                                        ],
                                    };
                                    "number" != typeof n &&
                                        console.warn(
                                            new Error(
                                                "called pointToHilbertQuadList without face value, defaulting to '0'"
                                            ).stack
                                        );
                                    for (
                                        var s = n % 2 ? "d" : "a",
                                            a = [],
                                            o = i - 1;
                                        o >= 0;
                                        o--
                                    ) {
                                        var c = 1 << o,
                                            l =
                                                r[s][
                                                    2 * (e & c ? 1 : 0) +
                                                        (t & c ? 1 : 0)
                                                ];
                                        a.push(l[0]), (s = l[1]);
                                    }
                                    return a;
                                };
                            (t.S2Cell = function () {}),
                                (t.S2Cell.FromHilbertQuadKey = function (e) {
                                    var i,
                                        n,
                                        s,
                                        a,
                                        o,
                                        c,
                                        l = e.split("/"),
                                        h = parseInt(l[0]),
                                        u = l[1],
                                        d = u.length,
                                        p = { x: 0, y: 0 };
                                    for (i = d - 1; i >= 0; i--)
                                        (n = d - i),
                                            (a = 0),
                                            (o = 0),
                                            "1" === (s = u[i])
                                                ? (o = 1)
                                                : "2" === s
                                                ? ((a = 1), (o = 1))
                                                : "3" === s && (a = 1),
                                            (c = Math.pow(2, n - 1)),
                                            r(c, p, a, o),
                                            (p.x += c * a),
                                            (p.y += c * o);
                                    if (h % 2 == 1) {
                                        var g = p.x;
                                        (p.x = p.y), (p.y = g);
                                    }
                                    return t.S2Cell.FromFaceIJ(
                                        parseInt(h),
                                        [p.x, p.y],
                                        n
                                    );
                                }),
                                (t.S2Cell.FromLatLng = function (e, i) {
                                    if (
                                        (!e.lat && 0 !== e.lat) ||
                                        (!e.lng && 0 !== e.lng)
                                    )
                                        throw new Error(
                                            "Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng"
                                        );
                                    var n = t.LatLngToXYZ(e),
                                        r = t.XYZToFaceUV(n),
                                        s = t.UVToST(r[1]),
                                        a = t.STToIJ(s, i);
                                    return t.S2Cell.FromFaceIJ(r[0], a, i);
                                }),
                                (t.S2Cell.FromFaceIJ = function (e, i, n) {
                                    var r = new t.S2Cell();
                                    return (
                                        (r.face = e),
                                        (r.ij = i),
                                        (r.level = n),
                                        r
                                    );
                                }),
                                (t.S2Cell.prototype.toString = function () {
                                    return (
                                        "F" +
                                        this.face +
                                        "ij[" +
                                        this.ij[0] +
                                        "," +
                                        this.ij[1] +
                                        "]@" +
                                        this.level
                                    );
                                }),
                                (t.S2Cell.prototype.getLatLng = function () {
                                    var e = t.IJToST(
                                            this.ij,
                                            this.level,
                                            [0.5, 0.5]
                                        ),
                                        i = t.STToUV(e),
                                        n = t.FaceUVToXYZ(this.face, i);
                                    return t.XYZToLatLng(n);
                                }),
                                (t.S2Cell.prototype.getCornerLatLngs =
                                    function () {
                                        for (
                                            var e = [],
                                                i = [
                                                    [0, 0],
                                                    [0, 1],
                                                    [1, 1],
                                                    [1, 0],
                                                ],
                                                n = 0;
                                            n < 4;
                                            n++
                                        ) {
                                            var r = t.IJToST(
                                                    this.ij,
                                                    this.level,
                                                    i[n]
                                                ),
                                                s = t.STToUV(r),
                                                a = t.FaceUVToXYZ(this.face, s);
                                            e.push(t.XYZToLatLng(a));
                                        }
                                        return e;
                                    }),
                                (t.S2Cell.prototype.getFaceAndQuads =
                                    function () {
                                        var e = s(
                                            this.ij[0],
                                            this.ij[1],
                                            this.level,
                                            this.face
                                        );
                                        return [this.face, e];
                                    }),
                                (t.S2Cell.prototype.toHilbertQuadkey =
                                    function () {
                                        var e = s(
                                            this.ij[0],
                                            this.ij[1],
                                            this.level,
                                            this.face
                                        );
                                        return (
                                            this.face.toString(10) +
                                            "/" +
                                            e.join("")
                                        );
                                    }),
                                (t.latLngToNeighborKeys =
                                    t.S2Cell.latLngToNeighborKeys =
                                        function (e, i, n) {
                                            return t.S2Cell.FromLatLng(
                                                { lat: e, lng: i },
                                                n
                                            )
                                                .getNeighbors()
                                                .map(function (e) {
                                                    return e.toHilbertQuadkey();
                                                });
                                        }),
                                (t.S2Cell.prototype.getNeighbors = function () {
                                    var e = function (e, i, n) {
                                            var r = 1 << n;
                                            if (
                                                i[0] >= 0 &&
                                                i[1] >= 0 &&
                                                i[0] < r &&
                                                i[1] < r
                                            )
                                                return t.S2Cell.FromFaceIJ(
                                                    e,
                                                    i,
                                                    n
                                                );
                                            var s = t.IJToST(i, n, [0.5, 0.5]),
                                                a = t.STToUV(s),
                                                o = t.FaceUVToXYZ(e, a),
                                                c = t.XYZToFaceUV(o);
                                            return (
                                                (e = c[0]),
                                                (a = c[1]),
                                                (s = t.UVToST(a)),
                                                (i = t.STToIJ(s, n)),
                                                t.S2Cell.FromFaceIJ(e, i, n)
                                            );
                                        },
                                        i = this.face,
                                        n = this.ij[0],
                                        r = this.ij[1],
                                        s = this.level;
                                    return [
                                        e(i, [n - 1, r], s),
                                        e(i, [n, r - 1], s),
                                        e(i, [n + 1, r], s),
                                        e(i, [n, r + 1], s),
                                    ];
                                }),
                                (t.FACE_BITS = 3),
                                (t.MAX_LEVEL = 30),
                                (t.POS_BITS = 2 * t.MAX_LEVEL + 1),
                                (t.facePosLevelToId =
                                    t.S2Cell.facePosLevelToId =
                                    t.fromFacePosLevel =
                                        function (i, n, r) {
                                            var s,
                                                a,
                                                o,
                                                c =
                                                    (e.dcodeIO &&
                                                        e.dcodeIO.Long) ||
                                                    IT.exports;
                                            for (
                                                r || (r = n.length),
                                                    n.length > r &&
                                                        (n = n.substr(0, r)),
                                                    s = c
                                                        .fromString(
                                                            i.toString(10),
                                                            !0,
                                                            10
                                                        )
                                                        .toString(2);
                                                s.length < t.FACE_BITS;

                                            )
                                                s = "0" + s;
                                            for (
                                                a = c
                                                    .fromString(n, !0, 4)
                                                    .toString(2);
                                                a.length < 2 * r;

                                            )
                                                a = "0" + a;
                                            for (
                                                o = s + a, o += "1";
                                                o.length <
                                                t.FACE_BITS + t.POS_BITS;

                                            )
                                                o += "0";
                                            return c
                                                .fromString(o, !0, 2)
                                                .toString(10);
                                        }),
                                (t.keyToId =
                                    t.S2Cell.keyToId =
                                    t.toId =
                                    t.toCellId =
                                    t.fromKey =
                                        function (e) {
                                            var i = e.split("/");
                                            return t.fromFacePosLevel(
                                                i[0],
                                                i[1],
                                                i[1].length
                                            );
                                        }),
                                (t.idToKey =
                                    t.S2Cell.idToKey =
                                    t.S2Cell.toKey =
                                    t.toKey =
                                    t.fromId =
                                    t.fromCellId =
                                    t.S2Cell.toHilbertQuadkey =
                                    t.toHilbertQuadkey =
                                        function (i) {
                                            for (
                                                var n =
                                                        (e.dcodeIO &&
                                                            e.dcodeIO.Long) ||
                                                        IT.exports,
                                                    r = n
                                                        .fromString(i, !0, 10)
                                                        .toString(2);
                                                r.length <
                                                t.FACE_BITS + t.POS_BITS;

                                            )
                                                r = "0" + r;
                                            for (
                                                var s = r.lastIndexOf("1"),
                                                    a = r.substring(0, 3),
                                                    o = r.substring(3, s),
                                                    c = o.length / 2,
                                                    l = n
                                                        .fromString(a, !0, 2)
                                                        .toString(10),
                                                    h = n
                                                        .fromString(o, !0, 2)
                                                        .toString(4);
                                                h.length < c;

                                            )
                                                h = "0" + h;
                                            return l + "/" + h;
                                        }),
                                (t.keyToLatLng = t.S2Cell.keyToLatLng =
                                    function (e) {
                                        return t.S2Cell.FromHilbertQuadKey(
                                            e
                                        ).getLatLng();
                                    }),
                                (t.idToLatLng = t.S2Cell.idToLatLng =
                                    function (e) {
                                        var i = t.idToKey(e);
                                        return t.keyToLatLng(i);
                                    }),
                                (t.S2Cell.latLngToKey =
                                    t.latLngToKey =
                                    t.latLngToQuadkey =
                                        function (e, i, n) {
                                            if (isNaN(n) || n < 1 || n > 30)
                                                throw new Error(
                                                    "'level' is not a number between 1 and 30 (but it should be)"
                                                );
                                            return t.S2Cell.FromLatLng(
                                                { lat: e, lng: i },
                                                n
                                            ).toHilbertQuadkey();
                                        }),
                                (t.stepKey = function (t, i) {
                                    var n,
                                        r =
                                            (e.dcodeIO && e.dcodeIO.Long) ||
                                            IT.exports,
                                        s = t.split("/"),
                                        a = s[0],
                                        o = s[1],
                                        c = s[1].length,
                                        l = r.fromString(o, !0, 4);
                                    i > 0
                                        ? (n = l.add(Math.abs(i)))
                                        : i < 0 &&
                                          (n = l.subtract(Math.abs(i)));
                                    var h = n.toString(4);
                                    for (
                                        "0" === h &&
                                        console.warning(
                                            new Error(
                                                "face/position wrapping is not yet supported"
                                            )
                                        );
                                        h.length < c;

                                    )
                                        h = "0" + h;
                                    return a + "/" + h;
                                }),
                                (t.S2Cell.prevKey = t.prevKey =
                                    function (e) {
                                        return t.stepKey(e, -1);
                                    }),
                                (t.S2Cell.nextKey = t.nextKey =
                                    function (e) {
                                        return t.stepKey(e, 1);
                                    });
                        })(e.exports);
                    })(DT);
                class CT extends xT {
                    constructor(e = 17) {
                        super(), (this._level = e);
                    }
                    bboxToCellIds(e, t) {
                        return this._approxBboxToCellIds(e, t);
                    }
                    getAdjacent(e) {
                        const t = DT.exports.S2.idToKey(e),
                            i = t.split("/")[1].length,
                            [n, r, s, a] = this._getNeighbors(t, i),
                            o = [t, n, r, s, a],
                            c = Array.from(
                                new Set(
                                    [
                                        ...this._getNeighbors(n, i),
                                        ...this._getNeighbors(r, i),
                                        ...this._getNeighbors(s, i),
                                        ...this._getNeighbors(a, i),
                                    ].filter((e) => !o.includes(e))
                                )
                            ),
                            l = [n, r, s, a];
                        for (const e of c) {
                            let t = 0;
                            for (const n of this._getNeighbors(e, i))
                                o.includes(n) && t++;
                            2 === t && l.push(e);
                        }
                        return l.map((e) => DT.exports.S2.keyToId(e));
                    }
                    getVertices(e) {
                        const t = DT.exports.S2.idToKey(e);
                        return DT.exports.S2.S2Cell.FromHilbertQuadKey(t)
                            .getCornerLatLngs()
                            .map((e) => ({ lat: e.lat, lng: e.lng }));
                    }
                    lngLatToCellId(e) {
                        return this._lngLatToId(e, this._level);
                    }
                    _getNeighbors(e, t) {
                        const i = DT.exports.S2.keyToLatLng(e);
                        return DT.exports.S2.latLngToNeighborKeys(
                            i.lat,
                            i.lng,
                            t
                        );
                    }
                    _lngLatToId(e, t) {
                        const i = DT.exports.S2.latLngToKey(e.lat, e.lng, t);
                        return DT.exports.S2.keyToId(i);
                    }
                }
                class AT {
                    clusterReconstruction(e) {
                        const t = e.points,
                            i = 1 / 255;
                        for (const e in t) {
                            if (!t.hasOwnProperty(e)) continue;
                            const n = t[e].color;
                            (n[0] *= i), (n[1] *= i), (n[2] *= i);
                        }
                        const n = e.reference_lla;
                        return {
                            id: null,
                            points: t,
                            reference: {
                                alt: n.altitude,
                                lat: n.latitude,
                                lng: n.longitude,
                            },
                        };
                    }
                    coreImage(e) {
                        const t = this._geometry(e.geometry),
                            i = this._geometry(e.computed_geometry),
                            n = { id: e.sequence };
                        return {
                            computed_geometry: i,
                            geometry: t,
                            id: e.id,
                            sequence: n,
                        };
                    }
                    spatialImage(e) {
                        var t, i, n, r, s;
                        (e.camera_type = (function (e) {
                            switch (e) {
                                case "equirectangular":
                                case "spherical":
                                    return "spherical";
                                case "fisheye":
                                    return "fisheye";
                                default:
                                    return "perspective";
                            }
                        })(e.camera_type)),
                            (e.merge_id = e.merge_cc
                                ? e.merge_cc.toString()
                                : null),
                            (e.private = null);
                        const a =
                            "spherical" === e.camera_type
                                ? e.thumb_2048_url
                                : e.thumb_1024_url;
                        return (
                            (e.thumb =
                                null !== (t = e.thumb) && void 0 !== t
                                    ? t
                                    : { id: null, url: a }),
                            (e.cluster =
                                null !== (i = e.sfm_cluster) && void 0 !== i
                                    ? i
                                    : { id: null, url: null }),
                            (e.creator =
                                null !== (n = e.creator) && void 0 !== n
                                    ? n
                                    : { id: null, username: null }),
                            (e.owner =
                                null !== (r = e.organization) && void 0 !== r
                                    ? r
                                    : { id: null }),
                            (e.mesh =
                                null !== (s = e.mesh) && void 0 !== s
                                    ? s
                                    : { id: null, url: null }),
                            e
                        );
                    }
                    _geometry(e) {
                        const t = null == e ? void 0 : e.coordinates;
                        return t ? { lat: t[1], lng: t[0] } : null;
                    }
                }
                class ET {
                    constructor() {
                        (this.imagesPath = "images"),
                            (this.sequencePath = "image_ids"),
                            (this._imageTilesPath = "tiles"),
                            (this.coreFields = [
                                "computed_geometry",
                                "geometry",
                                "sequence",
                            ]),
                            (this.idFields = ["id"]),
                            (this.spatialFields = [
                                "altitude",
                                "atomic_scale",
                                "camera_parameters",
                                "camera_type",
                                "captured_at",
                                "compass_angle",
                                "computed_altitude",
                                "computed_compass_angle",
                                "computed_rotation",
                                "creator",
                                "exif_orientation",
                                "height",
                                "merge_cc",
                                "mesh",
                                "organization",
                                "quality_score",
                                "sfm_cluster",
                                "thumb_1024_url",
                                "thumb_2048_url",
                                "width",
                            ]),
                            (this.imageTileFields = ["url", "z", "x", "y"]);
                    }
                    images(e, t) {
                        return `image_ids=${e.join(",")}&fields=${t.join(",")}`;
                    }
                    imagesS2(e, t) {
                        return `s2=${e}&fields=${t.join(",")}`;
                    }
                    imageTiles(e, t) {
                        return `z=${e}&fields=${t.join(",")}`;
                    }
                    imageTilesPath(e) {
                        return `${e}/${this._imageTilesPath}`;
                    }
                    sequence(e) {
                        return `sequence_id=${e}`;
                    }
                }
                class LT extends yT {
                    constructor(e, t, i, n) {
                        var r;
                        super(null != t ? t : new CT()),
                            (this._convert = null != i ? i : new AT()),
                            (this._query = null != n ? n : new ET()),
                            (this._method = "GET");
                        const s = null != e ? e : {};
                        (this._endpoint =
                            null !== (r = s.endpoint) && void 0 !== r
                                ? r
                                : "https://graph.mapillary.com"),
                            (this._accessToken = s.accessToken);
                    }
                    getCluster(e, t) {
                        return _T(e, t).then((e) => {
                            const t = (function (e) {
                                const t = Qw(e, { to: "string" });
                                return JSON.parse(t);
                            })(e);
                            if (t.length < 1)
                                throw new Error("Cluster reconstruction empty");
                            return this._convert.clusterReconstruction(t[0]);
                        });
                    }
                    getCoreImages(e) {
                        const t = [
                                ...this._query.idFields,
                                ...this._query.coreFields,
                            ],
                            i = this._query.imagesS2(e, t),
                            n = new URL(this._query.imagesPath, this._endpoint)
                                .href;
                        return this._fetchGraphContract(i, n).then((t) => {
                            const i = { cell_id: e, images: [] },
                                n = t.data;
                            for (const e of n) {
                                const t = this._convert.coreImage(e);
                                i.images.push(t);
                            }
                            return i;
                        });
                    }
                    getImageBuffer(e, t) {
                        return _T(e, t);
                    }
                    getImages(e) {
                        const t = [
                                ...this._query.idFields,
                                ...this._query.coreFields,
                                ...this._query.spatialFields,
                            ],
                            i = this._query.images(e, t),
                            n = new URL(this._query.imagesPath, this._endpoint)
                                .href;
                        return this._fetchGraphContract(i, n).then((e) => {
                            const t = [],
                                i = e.data;
                            for (const e of i) {
                                const i = this._convert.coreImage(e),
                                    n = this._convert.spatialImage(e),
                                    r = {
                                        node: Object.assign({}, n, i),
                                        node_id: e.id,
                                    };
                                t.push(r);
                            }
                            return t;
                        });
                    }
                    getImageTiles(e) {
                        const t = [...this._query.imageTileFields],
                            i = this._query.imageTiles(e.z, t),
                            n = new URL(
                                this._query.imageTilesPath(e.imageId),
                                this._endpoint
                            ).href;
                        return this._fetchGraphContract(i, n).then((t) => ({
                            node: t.data,
                            node_id: e.imageId,
                        }));
                    }
                    getMesh(e, t) {
                        return _T(e, t).then((e) =>
                            (function (e) {
                                return new Zw(e).readFields(vT, {
                                    faces: [],
                                    vertices: [],
                                });
                            })(e)
                        );
                    }
                    getSequence(e) {
                        const t = this._query.sequence(e),
                            i = new URL(
                                this._query.sequencePath,
                                this._endpoint
                            ).href;
                        return this._fetchGraphContract(t, i).then((t) => ({
                            id: e,
                            image_ids: t.data.map((e) => e.id),
                        }));
                    }
                    getSpatialImages(e) {
                        const t = [
                                ...this._query.idFields,
                                ...this._query.coreFields,
                                ...this._query.spatialFields,
                            ],
                            i = this._query.images(e, t),
                            n = new URL(this._query.imagesPath, this._endpoint)
                                .href;
                        return this._fetchGraphContract(i, n).then((e) => {
                            const t = [],
                                i = e.data;
                            for (const e of i) {
                                const i = {
                                    node: this._convert.spatialImage(e),
                                    node_id: e.id,
                                };
                                t.push(i);
                            }
                            return t;
                        });
                    }
                    setAccessToken(e) {
                        this._accessToken = e;
                    }
                    _createHeaders() {
                        const e = [
                            { name: "Accept", value: "application/json" },
                            {
                                name: "Content-Type",
                                value: "application/x-www-form-urlencoded",
                            },
                        ];
                        return (
                            this._accessToken &&
                                e.push({
                                    name: "Authorization",
                                    value: `OAuth ${this._accessToken}`,
                                }),
                            e
                        );
                    }
                    _fetchGraphContract(e, t) {
                        return MT(
                            `${t}?${e}`,
                            this._method,
                            "json",
                            this._createHeaders(),
                            null,
                            null
                        ).catch((e) => {
                            const t = this._makeErrorMessage(e);
                            throw new Ap(t);
                        });
                    }
                    _makeErrorMessage(e) {
                        const t = e.error;
                        return t
                            ? `${t.code} (${t.type}, ${t.fbtrace_id}): ${t.message}`
                            : "Failed to fetch data";
                    }
                }
                !(function (e) {
                    (e[(e.Custom = 0)] = "Custom"),
                        (e[(e.Earth = 1)] = "Earth"),
                        (e[(e.Street = 2)] = "Street");
                })(wT || (wT = {})),
                    (function (e) {
                        (e[(e.Letterbox = 0)] = "Letterbox"),
                            (e[(e.Fill = 1)] = "Fill");
                    })(TT || (TT = {})),
                    (function (e) {
                        e[(e.Opaque = 0)] = "Opaque";
                    })(ST || (ST = {})),
                    (function (e) {
                        (e[(e.Default = 0)] = "Default"),
                            (e[(e.Instantaneous = 1)] = "Instantaneous");
                    })(NT || (NT = {}));
                class zT {
                    constructor(e, t, i, n, r, s) {
                        (this._container = e),
                            (this._observer = i),
                            (this._navigator = t),
                            (this._options = null != r ? r : {}),
                            (this._key = n),
                            (this._navigable = null == n),
                            (this._componentService =
                                s || new og(this._container, this._navigator)),
                            (this._coverComponent =
                                this._componentService.getCover()),
                            this._initializeComponents(),
                            n
                                ? (this._initilizeCoverComponent(),
                                  this._subscribeCoverComponent())
                                : this._navigator.movedToId$
                                      .pipe(bt((e) => null != e))
                                      .subscribe((e) => {
                                          (this._key = e),
                                              this._componentService.deactivateCover(),
                                              this._coverComponent.configure({
                                                  id: this._key,
                                                  state: e_.Hidden,
                                              }),
                                              this._subscribeCoverComponent(),
                                              this._navigator.stateService.start(),
                                              this._navigator.cacheService.start(),
                                              this._navigator.panService.start(),
                                              this._observer.startEmit();
                                      });
                    }
                    get navigable() {
                        return this._navigable;
                    }
                    get(e) {
                        return this._componentService.get(e);
                    }
                    activate(e) {
                        this._componentService.activate(e);
                    }
                    activateCover() {
                        this._coverComponent.configure({ state: e_.Visible });
                    }
                    deactivate(e) {
                        this._componentService.deactivate(e);
                    }
                    deactivateCover() {
                        this._coverComponent.configure({ state: e_.Loading });
                    }
                    remove() {
                        this._componentService.remove(),
                            null != this._configurationSubscription &&
                                this._configurationSubscription.unsubscribe();
                    }
                    _initializeComponents() {
                        var e, t;
                        const i = this._options;
                        this._uFalse(
                            null === (e = i.fallback) || void 0 === e
                                ? void 0
                                : e.image,
                            "imagefallback"
                        ),
                            this._uFalse(
                                null === (t = i.fallback) || void 0 === t
                                    ? void 0
                                    : t.navigation,
                                "navigationfallback"
                            ),
                            this._uFalse(i.marker, "marker"),
                            this._uFalse(i.popup, "popup"),
                            this._uFalse(i.slider, "slider"),
                            this._uFalse(i.spatial, "spatial"),
                            this._uFalse(i.tag, "tag"),
                            this._uTrue(i.attribution, "attribution"),
                            this._uTrue(i.bearing, "bearing"),
                            this._uTrue(i.cache, "cache"),
                            this._uTrue(i.direction, "direction"),
                            this._uTrue(i.image, "image"),
                            this._uTrue(i.keyboard, "keyboard"),
                            this._uTrue(i.pointer, "pointer"),
                            this._uTrue(i.sequence, "sequence"),
                            this._uTrue(i.zoom, "zoom");
                    }
                    _initilizeCoverComponent() {
                        let e = this._options;
                        this._coverComponent.configure({ id: this._key }),
                            void 0 === e.cover || e.cover
                                ? this.activateCover()
                                : this.deactivateCover();
                    }
                    _setNavigable(e) {
                        this._navigable !== e &&
                            ((this._navigable = e),
                            this._observer.navigable$.next(e));
                    }
                    _subscribeCoverComponent() {
                        this._configurationSubscription =
                            this._coverComponent.configuration$
                                .pipe(ft(void 0, (e) => e.state))
                                .subscribe((e) => {
                                    e.state === e_.Loading
                                        ? this._navigator.stateService.currentId$
                                              .pipe(
                                                  bt(),
                                                  kt((t) => {
                                                      const i =
                                                          null == t ||
                                                          t !== e.id;
                                                      return (
                                                          i &&
                                                              this._setNavigable(
                                                                  !1
                                                              ),
                                                          i
                                                              ? this._navigator.moveTo$(
                                                                    e.id
                                                                )
                                                              : this._navigator.stateService.currentImage$.pipe(
                                                                    bt()
                                                                )
                                                      );
                                                  })
                                              )
                                              .subscribe(
                                                  () => {
                                                      this._navigator.stateService.start(),
                                                          this._navigator.cacheService.start(),
                                                          this._navigator.panService.start(),
                                                          this._observer.startEmit(),
                                                          this._coverComponent.configure(
                                                              {
                                                                  state: e_.Hidden,
                                                              }
                                                          ),
                                                          this._componentService.deactivateCover(),
                                                          this._setNavigable(
                                                              !0
                                                          );
                                                  },
                                                  (e) => {
                                                      console.error(
                                                          "Failed to deactivate cover.",
                                                          e
                                                      ),
                                                          this._coverComponent.configure(
                                                              {
                                                                  state: e_.Visible,
                                                              }
                                                          );
                                                  }
                                              )
                                        : e.state === e_.Visible &&
                                          (this._observer.stopEmit(),
                                          this._navigator.stateService.stop(),
                                          this._navigator.cacheService.stop(),
                                          this._navigator.playService.stop(),
                                          this._navigator.panService.stop(),
                                          this._componentService.activateCover(),
                                          this._setNavigable(null == e.id));
                                });
                    }
                    _uFalse(e, t) {
                        void 0 !== e
                            ? "boolean" != typeof e
                                ? (this._componentService.configure(t, e),
                                  this._componentService.activate(t))
                                : e
                                ? this._componentService.activate(t)
                                : this._componentService.deactivate(t)
                            : this._componentService.deactivate(t);
                    }
                    _uTrue(e, t) {
                        void 0 !== e
                            ? "boolean" != typeof e
                                ? (this._componentService.configure(t, e),
                                  this._componentService.activate(t))
                                : e
                                ? this._componentService.activate(t)
                                : this._componentService.deactivate(t)
                            : this._componentService.activate(t);
                    }
                }
                class jT {
                    constructor(e, t, i) {
                        (this._adaptiveOperation$ = new W()),
                            (this._render$ = new W()),
                            (this._renderAdaptive$ = new W()),
                            (this._subscriptions = new s_()),
                            (this._renderService = t),
                            (this._currentFrame$ = i);
                        const n = this._subscriptions,
                            r = n_.create(
                                n_.h("div.mapillary-dom-renderer", [])
                            );
                        e.appendChild(r),
                            (this._offset$ = this._adaptiveOperation$.pipe(
                                At((e, t) => t(e), {
                                    elementHeight: e.offsetHeight,
                                    elementWidth: e.offsetWidth,
                                    imageAspect: 0,
                                    renderMode: TT.Fill,
                                }),
                                nt(
                                    (e) =>
                                        e.imageAspect > 0 &&
                                        e.elementWidth > 0 &&
                                        e.elementHeight > 0
                                ),
                                ke((e) => {
                                    const t = e.elementWidth / e.elementHeight,
                                        i = e.imageAspect / t;
                                    let n = 0,
                                        r = 0;
                                    return (
                                        e.renderMode === TT.Letterbox
                                            ? e.imageAspect > t
                                                ? (n =
                                                      (e.elementHeight *
                                                          (1 - 1 / i)) /
                                                      2)
                                                : (r =
                                                      (e.elementWidth *
                                                          (1 - i)) /
                                                      2)
                                            : e.imageAspect > t
                                            ? (r =
                                                  (-e.elementWidth * (i - 1)) /
                                                  2)
                                            : (n =
                                                  (-e.elementHeight *
                                                      (1 / i - 1)) /
                                                  2),
                                        { bottom: n, left: r, right: r, top: n }
                                    );
                                })
                            ));
                        const s = this._currentFrame$
                                .pipe(
                                    nt((e) => null != e.state.currentImage),
                                    ft(
                                        (e, t) => e === t,
                                        (e) => e.state.currentImage.id
                                    ),
                                    ke(
                                        (e) =>
                                            e.state.currentTransform.basicAspect
                                    ),
                                    ke((e) => (t) => ((t.imageAspect = e), t))
                                )
                                .subscribe(this._adaptiveOperation$),
                            a = He(
                                this._renderAdaptive$.pipe(
                                    At(
                                        (e, t) => (
                                            null == t.vNode
                                                ? delete e[t.name]
                                                : (e[t.name] = t.vNode),
                                            e
                                        ),
                                        {}
                                    )
                                ),
                                this._offset$
                            )
                                .pipe(
                                    ke((e) => {
                                        const t = [],
                                            i = e[0];
                                        for (const e in i)
                                            i.hasOwnProperty(e) && t.push(i[e]);
                                        const n = e[1],
                                            r = {
                                                style: {
                                                    bottom: n.bottom + "px",
                                                    left: n.left + "px",
                                                    "pointer-events": "none",
                                                    position: "absolute",
                                                    right: n.right + "px",
                                                    top: n.top + "px",
                                                },
                                            };
                                        return {
                                            name: "mapillary-dom-adaptive-renderer",
                                            vNode: n_.h(
                                                "div.mapillary-dom-adaptive-renderer",
                                                r,
                                                t
                                            ),
                                        };
                                    })
                                )
                                .subscribe(this._render$);
                        (this._vNode$ = this._render$.pipe(
                            At(
                                (e, t) => (
                                    null == t.vNode
                                        ? delete e[t.name]
                                        : (e[t.name] = t.vNode),
                                    e
                                ),
                                {}
                            ),
                            ke((e) => {
                                const t = [];
                                for (const i in e)
                                    e.hasOwnProperty(i) && t.push(e[i]);
                                return n_.h("div.mapillary-dom-renderer", t);
                            })
                        )),
                            (this._vPatch$ = this._vNode$.pipe(
                                At(
                                    (e, t) => (
                                        (e.vpatch = n_.diff(e.vNode, t)),
                                        (e.vNode = t),
                                        e
                                    ),
                                    {
                                        vNode: n_.h(
                                            "div.mapillary-dom-renderer",
                                            []
                                        ),
                                        vpatch: null,
                                    }
                                ),
                                (function () {
                                    for (
                                        var e = [], t = 0;
                                        t < arguments.length;
                                        t++
                                    )
                                        e[t] = arguments[t];
                                    var i = e.length;
                                    if (0 === i)
                                        throw new Error(
                                            "list of properties cannot be empty."
                                        );
                                    return ke(function (t) {
                                        for (var n = t, r = 0; r < i; r++) {
                                            var s =
                                                null == n ? void 0 : n[e[r]];
                                            if (void 0 === s) return;
                                            n = s;
                                        }
                                        return n;
                                    });
                                })("vpatch")
                            )),
                            (this._element$ = this._vPatch$.pipe(
                                At((e, t) => n_.patch(e, t), r),
                                It(1),
                                V()
                            )),
                            n.push(s),
                            n.push(a),
                            n.push(this._element$.subscribe(() => {})),
                            n.push(
                                this._renderService.size$
                                    .pipe(
                                        ke(
                                            (e) => (t) => (
                                                (t.elementWidth = e.width),
                                                (t.elementHeight = e.height),
                                                t
                                            )
                                        )
                                    )
                                    .subscribe(this._adaptiveOperation$)
                            ),
                            n.push(
                                this._renderService.renderMode$
                                    .pipe(
                                        ke(
                                            (e) => (t) => (
                                                (t.renderMode = e), t
                                            )
                                        )
                                    )
                                    .subscribe(this._adaptiveOperation$)
                            );
                    }
                    get element$() {
                        return this._element$;
                    }
                    get render$() {
                        return this._render$;
                    }
                    get renderAdaptive$() {
                        return this._renderAdaptive$;
                    }
                    clear(e) {
                        this._renderAdaptive$.next({ name: e, vNode: null }),
                            this._render$.next({ name: e, vNode: null });
                    }
                    remove() {
                        this._subscriptions.unsubscribe();
                    }
                }
                class OT {
                    constructor(e, t, i) {
                        (this._renderFrame$ = new W()),
                            (this._renderCameraOperation$ = new W()),
                            (this._render$ = new W()),
                            (this._clear$ = new W()),
                            (this._renderOperation$ = new W()),
                            (this._rendererOperation$ = new W()),
                            (this._eraserOperation$ = new W()),
                            (this._triggerOperation$ = new W()),
                            (this._subscriptions = new s_()),
                            (this._opaqueRender$ = new W()),
                            (this._renderService = i);
                        const n = this._subscriptions;
                        (this._renderer$ = this._rendererOperation$.pipe(
                            At((e, t) => t(e), {
                                needsRender: !1,
                                renderer: null,
                            }),
                            nt((e) => !!e.renderer)
                        )),
                            (this._renderCollection$ =
                                this._renderOperation$.pipe(
                                    At((e, t) => t(e), {}),
                                    Et()
                                )),
                            (this._renderCamera$ =
                                this._renderCameraOperation$.pipe(
                                    At((e, t) => t(e), {
                                        frameId: -1,
                                        needsRender: !1,
                                        perspective: null,
                                    })
                                )),
                            (this._eraser$ = this._eraserOperation$.pipe(
                                Ot((e) => e),
                                At((e, t) => t(e), { needsRender: !1 })
                            ));
                        const r = this._triggerOperation$.pipe(
                                Ot((e) => e),
                                At((e, t) => t(e), { needsRender: !1 })
                            ),
                            s = new Na(986895),
                            a = He(
                                this._renderer$,
                                this._renderCollection$,
                                this._renderCamera$,
                                this._eraser$,
                                r
                            )
                                .pipe(
                                    ke(([e, t, i, n, r]) => ({
                                        camera: i,
                                        eraser: n,
                                        trigger: r,
                                        renderer: e,
                                        renders: Object.keys(t).map(
                                            (e) => t[e]
                                        ),
                                    })),
                                    nt((e) => {
                                        let t =
                                            e.renderer.needsRender ||
                                            e.camera.needsRender ||
                                            e.eraser.needsRender ||
                                            e.trigger.needsRender;
                                        const i = e.camera.frameId;
                                        for (const n of e.renders) {
                                            if (n.frameId !== i) return !1;
                                            t = t || n.needsRender;
                                        }
                                        return t;
                                    }),
                                    ft(
                                        (e, t) => e === t,
                                        (e) =>
                                            e.eraser.needsRender ||
                                            e.trigger.needsRender
                                                ? -e.camera.frameId
                                                : e.camera.frameId
                                    )
                                )
                                .subscribe((e) => {
                                    (e.renderer.needsRender = !1),
                                        (e.camera.needsRender = !1),
                                        (e.eraser.needsRender = !1),
                                        (e.trigger.needsRender = !1);
                                    const t = e.camera.perspective,
                                        i = [],
                                        n = [];
                                    for (const t of e.renders)
                                        t.pass === i_.Background
                                            ? i.push(t.render)
                                            : t.pass === i_.Opaque &&
                                              n.push(t.render);
                                    const r = e.renderer.renderer;
                                    r.resetState(),
                                        r.setClearColor(s, 1),
                                        r.clear();
                                    for (const e of i) e(t, r);
                                    r.clearDepth();
                                    for (const e of n) e(t, r);
                                    r.resetState(), this._opaqueRender$.next();
                                });
                        n.push(a),
                            n.push(
                                this._renderFrame$
                                    .pipe(
                                        ke(
                                            (e) => (t) => (
                                                (t.frameId = e.frameId),
                                                (t.perspective = e.perspective),
                                                !0 === e.changed &&
                                                    (t.needsRender = !0),
                                                t
                                            )
                                        )
                                    )
                                    .subscribe(this._renderCameraOperation$)
                            ),
                            this._renderFrameSubscribe();
                        const o = this._render$.pipe(
                                ke((e) => (t) => ((t[e.name] = e.renderer), t))
                            ),
                            c = this._clear$.pipe(
                                ke((e) => (t) => (delete t[e], t))
                            );
                        n.push(tt(o, c).subscribe(this._renderOperation$)),
                            (this._webGLRenderer$ = this._render$.pipe(
                                bt(),
                                ke(() => {
                                    t.appendChild(e);
                                    const n = i.element,
                                        r = new dh({ canvas: e });
                                    return (
                                        r.setPixelRatio(
                                            window.devicePixelRatio
                                        ),
                                        r.setSize(
                                            n.offsetWidth,
                                            n.offsetHeight
                                        ),
                                        (r.autoClear = !1),
                                        r
                                    );
                                }),
                                It(1),
                                V()
                            )),
                            n.push(this._webGLRenderer$.subscribe(() => {}));
                        const l = this._webGLRenderer$.pipe(
                                bt(),
                                ke(
                                    (e) => (t) => (
                                        (t.needsRender = !0),
                                        (t.renderer = e),
                                        t
                                    )
                                )
                            ),
                            h = this._renderService.size$.pipe(
                                ke(
                                    (e) => (t) => (
                                        null == t.renderer ||
                                            (t.renderer.setSize(
                                                e.width,
                                                e.height
                                            ),
                                            (t.needsRender = !0)),
                                        t
                                    )
                                )
                            ),
                            u = this._clear$.pipe(
                                ke(
                                    () => (e) => (
                                        null == e.renderer ||
                                            (e.needsRender = !0),
                                        e
                                    )
                                )
                            );
                        n.push(tt(l, h, u).subscribe(this._rendererOperation$));
                        const d = this._renderCollection$.pipe(
                            nt((e) => 0 === Object.keys(e).length),
                            Et()
                        );
                        n.push(
                            d.subscribe(() => {
                                null != this._renderFrameSubscription &&
                                    (this._renderFrameSubscription.unsubscribe(),
                                    (this._renderFrameSubscription = null),
                                    this._renderFrameSubscribe());
                            })
                        ),
                            n.push(
                                d
                                    .pipe(
                                        ke(
                                            () => (e) => (
                                                (e.needsRender = !0), e
                                            )
                                        )
                                    )
                                    .subscribe(this._eraserOperation$)
                            );
                    }
                    get render$() {
                        return this._render$;
                    }
                    get opaqueRender$() {
                        return this._opaqueRender$;
                    }
                    get webGLRenderer$() {
                        return this._webGLRenderer$;
                    }
                    clear(e) {
                        this._clear$.next(e);
                    }
                    remove() {
                        this._rendererOperation$.next((e) => {
                            if (null != e.renderer) {
                                const t = e.renderer
                                    .getContext()
                                    .getExtension("WEBGL_lose_context");
                                t && t.loseContext(), (e.renderer = null);
                            }
                            return e;
                        }),
                            null != this._renderFrameSubscription &&
                                this._renderFrameSubscription.unsubscribe(),
                            this._subscriptions.unsubscribe();
                    }
                    triggerRerender() {
                        this._renderService.renderCameraFrame$
                            .pipe(zt(1), bt())
                            .subscribe(() => {
                                this._triggerOperation$.next(
                                    (e) => ((e.needsRender = !0), e)
                                );
                            });
                    }
                    _renderFrameSubscribe() {
                        this._render$
                            .pipe(
                                bt(),
                                ke(() => (e) => ((e.needsRender = !0), e))
                            )
                            .subscribe((e) => {
                                this._renderCameraOperation$.next(e);
                            }),
                            (this._renderFrameSubscription = this._render$
                                .pipe(
                                    bt(),
                                    Ye(
                                        () =>
                                            this._renderService
                                                .renderCameraFrame$
                                    )
                                )
                                .subscribe(this._renderFrame$));
                    }
                }
                class kT {
                    constructor(e) {
                        null != e
                            ? ((this._position = new rs().fromArray(
                                  e.unprojectSfM([0, 0], 0)
                              )),
                              (this._lookat = new rs().fromArray(
                                  e.unprojectSfM([0, 0], 10)
                              )),
                              (this._up = e.upVector()),
                              (this._focal = this._getFocal(e)))
                            : ((this._position = new rs(0, 0, 0)),
                              (this._lookat = new rs(1, 0, 0)),
                              (this._up = new rs(0, 0, 1)),
                              (this._focal = 1));
                    }
                    get position() {
                        return this._position;
                    }
                    get lookat() {
                        return this._lookat;
                    }
                    get up() {
                        return this._up;
                    }
                    get focal() {
                        return this._focal;
                    }
                    set focal(e) {
                        this._focal = e;
                    }
                    lerpCameras(e, t, i) {
                        this._position
                            .subVectors(t.position, e.position)
                            .multiplyScalar(i)
                            .add(e.position),
                            this._lookat
                                .subVectors(t.lookat, e.lookat)
                                .multiplyScalar(i)
                                .add(e.lookat),
                            this._up
                                .subVectors(t.up, e.up)
                                .multiplyScalar(i)
                                .add(e.up),
                            (this._focal = (1 - i) * e.focal + i * t.focal);
                    }
                    copy(e) {
                        this._position.copy(e.position),
                            this._lookat.copy(e.lookat),
                            this._up.copy(e.up),
                            (this._focal = e.focal);
                    }
                    clone() {
                        let e = new kT();
                        return (
                            e.position.copy(this._position),
                            e.lookat.copy(this._lookat),
                            e.up.copy(this._up),
                            (e.focal = this._focal),
                            e
                        );
                    }
                    diff(e) {
                        let t = this._position.distanceToSquared(e.position),
                            i = this._lookat.distanceToSquared(e.lookat),
                            n = this._up.distanceToSquared(e.up),
                            r = 100 * Math.abs(this._focal - e.focal);
                        return Math.max(t, i, n, r);
                    }
                    _getFocal(e) {
                        return jp(e.cameraType)
                            ? 0.5 / Math.tan(Math.PI / 2)
                            : e.focal;
                    }
                }
                class RT {
                    constructor(e, t, i) {
                        (this._spatial = new Lp()),
                            (this._viewportCoords = new l_()),
                            (this._size = { width: e, height: t }),
                            (this._initialFov = 60),
                            (this._alpha = -1),
                            (this._stateTransitionAlpha = -1),
                            (this._stateTransitionFov = -1),
                            (this._renderMode = i),
                            (this._zoom = 0),
                            (this._frameId = -1),
                            (this._changed = !1),
                            (this._changedForFrame = -1),
                            (this._currentImageId = null),
                            (this._previousImageId = null),
                            (this._currentSpherical = !1),
                            (this._previousSpherical = !1),
                            (this._state = null),
                            (this._currentProjectedPoints = []),
                            (this._previousProjectedPoints = []),
                            (this._currentFov = this._initialFov),
                            (this._previousFov = this._initialFov),
                            (this._camera = new kT()),
                            (this._perspective = new go(
                                this._initialFov,
                                this._computeAspect(e, t),
                                0.1,
                                1e4
                            )),
                            this._perspective.position.copy(
                                this._camera.position
                            ),
                            this._perspective.up.copy(this._camera.up),
                            this._perspective.lookAt(this._camera.lookat),
                            this._perspective.updateMatrixWorld(!0),
                            (this._perspective.matrixAutoUpdate = !1),
                            (this._rotation = { phi: 0, theta: 0 });
                    }
                    get alpha() {
                        return this._alpha;
                    }
                    get camera() {
                        return this._camera;
                    }
                    get changed() {
                        return this._frameId === this._changedForFrame;
                    }
                    get frameId() {
                        return this._frameId;
                    }
                    get perspective() {
                        return this._perspective;
                    }
                    get renderMode() {
                        return this._renderMode;
                    }
                    get rotation() {
                        return this._rotation;
                    }
                    get zoom() {
                        return this._zoom;
                    }
                    get size() {
                        return this._size;
                    }
                    getTilt() {
                        return (
                            90 - this._spatial.radToDeg(this._rotation.theta)
                        );
                    }
                    fovToZoom(e) {
                        e = Math.min(90, Math.max(0, e));
                        const t = this._computeCurrentFov(0),
                            i =
                                1 === this._alpha
                                    ? t
                                    : this._interpolateFov(
                                          t,
                                          this._computePreviousFov(0),
                                          this._alpha
                                      ),
                            n = Math.tan(((i / 2) * Math.PI) / 180),
                            r = Math.tan(((e / 2) * Math.PI) / 180);
                        return Math.log(n / r) / Math.log(2);
                    }
                    setFrame(e) {
                        const t = e.state;
                        if (t.state !== this._state) {
                            if (
                                ((this._state = t.state),
                                this._state !== j_.Custom &&
                                    (this.setRenderMode(this._renderMode),
                                    this.setSize(this._size)),
                                this._state === j_.Earth)
                            ) {
                                const e = this._fovToY(
                                    this._perspective.fov,
                                    this._zoom
                                );
                                this._stateTransitionFov = this._yToFov(e, 0);
                            }
                            this._changed = !0;
                        }
                        const i = t.currentImage.id,
                            n = t.previousImage ? t.previousImage.id : null;
                        i !== this._currentImageId &&
                            ((this._currentImageId = i),
                            (this._currentSpherical = jp(
                                t.currentTransform.cameraType
                            )),
                            (this._currentProjectedPoints =
                                this._computeProjectedPoints(
                                    t.currentTransform
                                )),
                            (this._changed = !0)),
                            n !== this._previousImageId &&
                                ((this._previousImageId = n),
                                (this._previousSpherical = jp(
                                    t.previousTransform.cameraType
                                )),
                                (this._previousProjectedPoints =
                                    this._computeProjectedPoints(
                                        t.previousTransform
                                    )),
                                (this._changed = !0));
                        const r = t.zoom;
                        r !== this._zoom && (this._changed = !0),
                            this._changed &&
                                ((this._currentFov =
                                    this._computeCurrentFov(r)),
                                (this._previousFov =
                                    this._computePreviousFov(r)));
                        const s = t.alpha,
                            a = t.stateTransitionAlpha;
                        if (
                            this._changed ||
                            s !== this._alpha ||
                            a !== this._stateTransitionAlpha
                        ) {
                            switch (
                                ((this._alpha = s),
                                (this._stateTransitionAlpha = a),
                                this._state)
                            ) {
                                case j_.Earth: {
                                    const e = this._stateTransitionFov,
                                        i = this._focalToFov(t.camera.focal),
                                        n = Hr.lerp(e, i, a),
                                        s = this._fovToY(n, 0);
                                    this._perspective.fov = this._yToFov(s, r);
                                    break;
                                }
                                case j_.Custom:
                                    break;
                                default:
                                    (this._perspective.fov =
                                        this._interpolateFov(
                                            this._currentFov,
                                            this._previousFov,
                                            this._alpha
                                        )),
                                        (this._changed = !0);
                            }
                            (this._zoom = r),
                                this._state !== j_.Custom &&
                                    this._perspective.updateProjectionMatrix();
                        }
                        const o = t.camera;
                        this._camera.diff(o) > 1e-9 &&
                            (this._camera.copy(o),
                            (this._rotation = this._computeRotation(o)),
                            this._perspective.up.copy(o.up),
                            this._perspective.position.copy(o.position),
                            (this._perspective.matrixAutoUpdate = !0),
                            this._perspective.lookAt(o.lookat),
                            (this._perspective.matrixAutoUpdate = !1),
                            this._perspective.updateMatrix(),
                            this._perspective.updateMatrixWorld(!1),
                            (this._changed = !0)),
                            this._setFrameId(e.id);
                    }
                    setProjectionMatrix(e) {
                        (this._perspective.fov = this._focalToFov(e[5] / 2)),
                            this._perspective.projectionMatrix.fromArray(e),
                            this._perspective.projectionMatrixInverse
                                .copy(this._perspective.projectionMatrix)
                                .invert(),
                            (this._changed = !0);
                    }
                    setRenderMode(e) {
                        (this._renderMode = e),
                            this._state !== j_.Custom &&
                                ((this._perspective.fov = this._computeFov()),
                                this._perspective.updateProjectionMatrix(),
                                (this._changed = !0));
                    }
                    setSize(e) {
                        (this._size = e),
                            this._state !== j_.Custom &&
                                ((this._perspective.aspect =
                                    this._computeAspect(e.width, e.height)),
                                (this._perspective.fov = this._computeFov()),
                                this._perspective.updateProjectionMatrix(),
                                (this._changed = !0));
                    }
                    _computeAspect(e, t) {
                        return 0 === e ? 0 : e / t;
                    }
                    _computeCurrentFov(e) {
                        return 0 === this._perspective.aspect
                            ? 0
                            : this._currentImageId
                            ? this._currentSpherical
                                ? this._yToFov(1, e)
                                : this._computeVerticalFov(
                                      this._currentProjectedPoints,
                                      this._renderMode,
                                      e,
                                      this.perspective.aspect
                                  )
                            : this._initialFov;
                    }
                    _computeFov() {
                        return (
                            (this._currentFov = this._computeCurrentFov(
                                this._zoom
                            )),
                            (this._previousFov = this._computePreviousFov(
                                this._zoom
                            )),
                            this._interpolateFov(
                                this._currentFov,
                                this._previousFov,
                                this._alpha
                            )
                        );
                    }
                    _computePreviousFov(e) {
                        return 0 === this._perspective.aspect
                            ? 0
                            : this._currentImageId
                            ? this._previousImageId
                                ? this._previousSpherical
                                    ? this._yToFov(1, e)
                                    : this._computeVerticalFov(
                                          this._previousProjectedPoints,
                                          this._renderMode,
                                          e,
                                          this.perspective.aspect
                                      )
                                : this._currentFov
                            : this._initialFov;
                    }
                    _computeProjectedPoints(e) {
                        return Rp(
                            e,
                            [
                                [0.5, 0],
                                [1, 0],
                            ],
                            [
                                [0.5, 0],
                                [0, 0.5],
                            ],
                            100,
                            this._viewportCoords
                        );
                    }
                    _computeRequiredVerticalFov(e, t, i) {
                        const n = Math.max(e[0] / i, e[1]);
                        return this._yToFov(n, t);
                    }
                    _computeRotation(e) {
                        let t = e.lookat.clone().sub(e.position),
                            i = e.up.clone();
                        return {
                            phi: this._spatial.azimuthal(
                                t.toArray(),
                                i.toArray()
                            ),
                            theta:
                                Math.PI / 2 -
                                this._spatial.angleToPlane(
                                    t.toArray(),
                                    [0, 0, 1]
                                ),
                        };
                    }
                    _computeVerticalFov(e, t, i, n) {
                        const r = e.map((e) =>
                            this._computeRequiredVerticalFov(e, i, n)
                        );
                        return t === TT.Fill
                            ? 0.995 * Math.min(...r)
                            : Math.max(...r);
                    }
                    _yToFov(e, t) {
                        return (
                            (2 * Math.atan(e / Math.pow(2, t)) * 180) / Math.PI
                        );
                    }
                    _focalToFov(e) {
                        return (2 * Math.atan2(1, 2 * e) * 180) / Math.PI;
                    }
                    _fovToY(e, t) {
                        return Math.pow(2, t) * Math.tan((Math.PI * e) / 360);
                    }
                    _interpolateFov(e, t, i) {
                        return i * e + (1 - i) * t;
                    }
                    _setFrameId(e) {
                        (this._frameId = e),
                            this._changed &&
                                ((this._changed = !1),
                                (this._changedForFrame = e));
                    }
                }
                class PT {
                    constructor(e, t, i, n) {
                        (this._subscriptions = new s_()),
                            (this._element = e),
                            (this._currentFrame$ = t),
                            (this._spatial = new Lp()),
                            (i = null != i ? i : TT.Fill),
                            (this._resize$ = new W()),
                            (this._projectionMatrix$ = new W()),
                            (this._renderCameraOperation$ = new W()),
                            (this._size$ = new Z({
                                height: this._element.offsetHeight,
                                width: this._element.offsetWidth,
                            }));
                        const r = this._subscriptions;
                        r.push(
                            this._resize$
                                .pipe(
                                    ke(() => ({
                                        height: this._element.offsetHeight,
                                        width: this._element.offsetWidth,
                                    }))
                                )
                                .subscribe(this._size$)
                        ),
                            (this._renderMode$ = new Z(i)),
                            (this._renderCameraHolder$ =
                                this._renderCameraOperation$.pipe(
                                    Ot((e) => e),
                                    At(
                                        (e, t) => t(e),
                                        null != n
                                            ? n
                                            : new RT(
                                                  this._element.offsetWidth,
                                                  this._element.offsetHeight,
                                                  i
                                              )
                                    ),
                                    It(1),
                                    V()
                                )),
                            (this._renderCameraFrame$ =
                                this._currentFrame$.pipe(
                                    $t(this._renderCameraHolder$),
                                    Ut(([e, t]) => {
                                        t.setFrame(e);
                                    }),
                                    ke((e) => e[1]),
                                    It(1),
                                    V()
                                )),
                            (this._renderCamera$ =
                                this._renderCameraFrame$.pipe(
                                    nt((e) => e.changed),
                                    It(1),
                                    V()
                                )),
                            (this._bearing$ = this._renderCamera$.pipe(
                                ke((e) => {
                                    let t = this._spatial.radToDeg(
                                        this._spatial.azimuthalToBearing(
                                            e.rotation.phi
                                        )
                                    );
                                    return this._spatial.wrap(t, 0, 360);
                                }),
                                It(1),
                                V()
                            )),
                            r.push(
                                this._size$
                                    .pipe(
                                        zt(1),
                                        ke((e) => (t) => (t.setSize(e), t))
                                    )
                                    .subscribe(this._renderCameraOperation$)
                            ),
                            r.push(
                                this._renderMode$
                                    .pipe(
                                        zt(1),
                                        ke(
                                            (e) => (t) => (
                                                t.setRenderMode(e), t
                                            )
                                        )
                                    )
                                    .subscribe(this._renderCameraOperation$)
                            ),
                            r.push(
                                this._projectionMatrix$
                                    .pipe(
                                        ke(
                                            (e) => (t) => (
                                                t.setProjectionMatrix(e), t
                                            )
                                        )
                                    )
                                    .subscribe(this._renderCameraOperation$)
                            ),
                            r.push(this._bearing$.subscribe(() => {})),
                            r.push(
                                this._renderCameraHolder$.subscribe(() => {})
                            ),
                            r.push(this._size$.subscribe(() => {})),
                            r.push(this._renderMode$.subscribe(() => {})),
                            r.push(this._renderCamera$.subscribe(() => {})),
                            r.push(
                                this._renderCameraFrame$.subscribe(() => {})
                            );
                    }
                    get bearing$() {
                        return this._bearing$;
                    }
                    get element() {
                        return this._element;
                    }
                    get projectionMatrix$() {
                        return this._projectionMatrix$;
                    }
                    get renderCamera$() {
                        return this._renderCamera$;
                    }
                    get renderCameraFrame$() {
                        return this._renderCameraFrame$;
                    }
                    get renderMode$() {
                        return this._renderMode$;
                    }
                    get resize$() {
                        return this._resize$;
                    }
                    get size$() {
                        return this._size$;
                    }
                    dispose() {
                        this._subscriptions.unsubscribe();
                    }
                }
                class UT {
                    constructor(e) {
                        (this._keyDown$ = Je(e, "keydown")),
                            (this._keyUp$ = Je(e, "keyup"));
                    }
                    get keyDown$() {
                        return this._keyDown$;
                    }
                    get keyUp$() {
                        return this._keyUp$;
                    }
                }
                const $T = 0,
                    BT = 2,
                    FT = { [$T]: 1, [BT]: 2 };
                class HT {
                    constructor(e, t, i, n) {
                        this._subscriptions = new s_();
                        const r = this._subscriptions;
                        (this._activeSubject$ = new Z(!1)),
                            (this._active$ = this._activeSubject$.pipe(
                                ft(),
                                It(1),
                                V()
                            )),
                            (this._claimMouse$ = new W()),
                            (this._claimWheel$ = new W()),
                            (this._deferPixelClaims$ = new W()),
                            (this._deferPixels$ = this._deferPixelClaims$.pipe(
                                At(
                                    (e, t) => (
                                        null == t.deferPixels
                                            ? delete e[t.name]
                                            : (e[t.name] = t.deferPixels),
                                        e
                                    ),
                                    {}
                                ),
                                ke((e) => {
                                    let t = -1;
                                    for (const i in e) {
                                        if (!e.hasOwnProperty(i)) continue;
                                        const n = e[i];
                                        n > t && (t = n);
                                    }
                                    return t;
                                }),
                                Ot(-1),
                                It(1),
                                V()
                            )),
                            r.push(this._deferPixels$.subscribe(() => {})),
                            (this._documentMouseMove$ = Je(
                                n,
                                "pointermove"
                            ).pipe(nt(this._isMousePen))),
                            (this._documentMouseUp$ = Je(n, "pointerup").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._mouseDown$ = Je(t, "pointerdown").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._mouseEnter$ = Je(t, "pointerenter").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._mouseLeave$ = Je(t, "pointerleave").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._mouseMove$ = Je(t, "pointermove").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._mouseUp$ = Je(t, "pointerup").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._mouseOut$ = Je(t, "pointerout").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._mouseOver$ = Je(t, "pointerover").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._domMouseDown$ = Je(i, "pointerdown").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._domMouseMove$ = Je(i, "pointermove").pipe(
                                nt(this._isMousePen)
                            )),
                            (this._click$ = Je(t, "click")),
                            (this._contextMenu$ = Je(t, "contextmenu")),
                            (this._windowBlur$ = Je(window, "blur")),
                            (this._dblClick$ = tt(
                                Je(e, "click"),
                                Je(t, "dblclick")
                            ).pipe(
                                at(3, 1),
                                nt((e) => {
                                    const i = e[0],
                                        n = e[1],
                                        r = e[2];
                                    return (
                                        "click" === i.type &&
                                        "click" === n.type &&
                                        "dblclick" === r.type &&
                                        i.target.parentNode === t &&
                                        n.target.parentNode === t
                                    );
                                }),
                                ke((e) => e[2]),
                                Et()
                            )),
                            r.push(
                                tt(
                                    this._domMouseDown$,
                                    this._domMouseMove$,
                                    this._dblClick$,
                                    this._contextMenu$
                                ).subscribe((e) => {
                                    e.preventDefault();
                                })
                            ),
                            (this._mouseWheel$ = tt(
                                Je(t, "wheel"),
                                Je(i, "wheel")
                            ).pipe(Et())),
                            (this._consistentContextMenu$ = tt(
                                this._mouseDown$,
                                this._mouseMove$,
                                this._mouseOut$,
                                this._mouseUp$,
                                this._contextMenu$
                            ).pipe(
                                at(3, 1),
                                nt(
                                    (e) =>
                                        "pointerdown" === e[0].type &&
                                        "contextmenu" === e[1].type &&
                                        "pointerup" === e[2].type
                                ),
                                ke((e) => e[1]),
                                Et()
                            ));
                        const s = tt(
                                this._windowBlur$,
                                this._documentMouseMove$.pipe(
                                    nt((e) => this._buttonReleased(e, 0))
                                ),
                                this._documentMouseUp$.pipe(
                                    nt((e) => 0 === this._mouseButton(e))
                                )
                            ).pipe(Et()),
                            a = this._createMouseDragInitiate$(
                                0,
                                this._mouseDown$,
                                s,
                                !0
                            ).pipe(Et());
                        (this._mouseDragStart$ = this._createMouseDragStart$(
                            a
                        ).pipe(Et())),
                            (this._mouseDrag$ = this._createMouseDrag$(
                                a,
                                s
                            ).pipe(Et())),
                            (this._mouseDragEnd$ = this._createMouseDragEnd$(
                                this._mouseDragStart$,
                                s
                            ).pipe(Et()));
                        const o = this._createMouseDragInitiate$(
                            0,
                            this._domMouseDown$,
                            s,
                            !1
                        ).pipe(Et());
                        (this._domMouseDragStart$ = this._createMouseDragStart$(
                            o
                        ).pipe(Et())),
                            (this._domMouseDrag$ = this._createMouseDrag$(
                                o,
                                s
                            ).pipe(Et())),
                            (this._domMouseDragEnd$ = this._createMouseDragEnd$(
                                this._domMouseDragStart$,
                                s
                            ).pipe(Et()));
                        const c = tt(
                                this._windowBlur$,
                                this._documentMouseMove$.pipe(
                                    nt((e) => this._buttonReleased(e, 2))
                                ),
                                this._documentMouseUp$.pipe(
                                    nt((e) => 2 === this._mouseButton(e))
                                )
                            ).pipe(Et()),
                            l = this._createMouseDragInitiate$(
                                2,
                                this._mouseDown$,
                                c,
                                !0
                            ).pipe(Et());
                        (this._mouseRightDragStart$ =
                            this._createMouseDragStart$(l).pipe(Et())),
                            (this._mouseRightDrag$ = this._createMouseDrag$(
                                l,
                                c
                            ).pipe(Et())),
                            (this._mouseRightDragEnd$ =
                                this._createMouseDragEnd$(
                                    this._mouseRightDragStart$,
                                    c
                                ).pipe(Et())),
                            (this._proximateClick$ = this._mouseDown$.pipe(
                                kt((e) =>
                                    this._click$.pipe(
                                        Rt(
                                            this._createDeferredMouseMove$(
                                                e,
                                                this._documentMouseMove$
                                            )
                                        ),
                                        mt(1)
                                    )
                                ),
                                Et()
                            )),
                            (this._staticClick$ = this._mouseDown$.pipe(
                                kt(() =>
                                    this._click$.pipe(
                                        Rt(this._documentMouseMove$),
                                        mt(1)
                                    )
                                ),
                                Et()
                            )),
                            r.push(this._mouseDragStart$.subscribe()),
                            r.push(this._mouseDrag$.subscribe()),
                            r.push(this._mouseDragEnd$.subscribe()),
                            r.push(this._domMouseDragStart$.subscribe()),
                            r.push(this._domMouseDrag$.subscribe()),
                            r.push(this._domMouseDragEnd$.subscribe()),
                            r.push(this._mouseRightDragStart$.subscribe()),
                            r.push(this._mouseRightDrag$.subscribe()),
                            r.push(this._mouseRightDragEnd$.subscribe()),
                            r.push(this._staticClick$.subscribe()),
                            (this._mouseOwner$ = this._createOwner$(
                                this._claimMouse$
                            ).pipe(It(1), V())),
                            (this._wheelOwner$ = this._createOwner$(
                                this._claimWheel$
                            ).pipe(It(1), V())),
                            r.push(this._mouseOwner$.subscribe(() => {})),
                            r.push(this._wheelOwner$.subscribe(() => {}));
                    }
                    get active$() {
                        return this._active$;
                    }
                    get activate$() {
                        return this._activeSubject$;
                    }
                    get documentMouseMove$() {
                        return this._documentMouseMove$;
                    }
                    get documentMouseUp$() {
                        return this._documentMouseUp$;
                    }
                    get domMouseDragStart$() {
                        return this._domMouseDragStart$;
                    }
                    get domMouseDrag$() {
                        return this._domMouseDrag$;
                    }
                    get domMouseDragEnd$() {
                        return this._domMouseDragEnd$;
                    }
                    get domMouseDown$() {
                        return this._domMouseDown$;
                    }
                    get domMouseMove$() {
                        return this._domMouseMove$;
                    }
                    get mouseOwner$() {
                        return this._mouseOwner$;
                    }
                    get mouseDown$() {
                        return this._mouseDown$;
                    }
                    get mouseEnter$() {
                        return this._mouseEnter$;
                    }
                    get mouseMove$() {
                        return this._mouseMove$;
                    }
                    get mouseLeave$() {
                        return this._mouseLeave$;
                    }
                    get mouseOut$() {
                        return this._mouseOut$;
                    }
                    get mouseOver$() {
                        return this._mouseOver$;
                    }
                    get mouseUp$() {
                        return this._mouseUp$;
                    }
                    get click$() {
                        return this._click$;
                    }
                    get dblClick$() {
                        return this._dblClick$;
                    }
                    get contextMenu$() {
                        return this._consistentContextMenu$;
                    }
                    get mouseWheel$() {
                        return this._mouseWheel$;
                    }
                    get mouseDragStart$() {
                        return this._mouseDragStart$;
                    }
                    get mouseDrag$() {
                        return this._mouseDrag$;
                    }
                    get mouseDragEnd$() {
                        return this._mouseDragEnd$;
                    }
                    get mouseRightDragStart$() {
                        return this._mouseRightDragStart$;
                    }
                    get mouseRightDrag$() {
                        return this._mouseRightDrag$;
                    }
                    get mouseRightDragEnd$() {
                        return this._mouseRightDragEnd$;
                    }
                    get proximateClick$() {
                        return this._proximateClick$;
                    }
                    get staticClick$() {
                        return this._staticClick$;
                    }
                    get windowBlur$() {
                        return this._windowBlur$;
                    }
                    dispose() {
                        this._subscriptions.unsubscribe();
                    }
                    claimMouse(e, t) {
                        this._claimMouse$.next({ name: e, zindex: t });
                    }
                    unclaimMouse(e) {
                        this._claimMouse$.next({ name: e, zindex: null });
                    }
                    deferPixels(e, t) {
                        this._deferPixelClaims$.next({
                            name: e,
                            deferPixels: t,
                        });
                    }
                    undeferPixels(e) {
                        this._deferPixelClaims$.next({
                            name: e,
                            deferPixels: null,
                        });
                    }
                    claimWheel(e, t) {
                        this._claimWheel$.next({ name: e, zindex: t });
                    }
                    unclaimWheel(e) {
                        this._claimWheel$.next({ name: e, zindex: null });
                    }
                    filtered$(e, t) {
                        return this._filtered(e, t, this._mouseOwner$);
                    }
                    filteredWheel$(e, t) {
                        return this._filtered(e, t, this._wheelOwner$);
                    }
                    _createDeferredMouseMove$(e, t) {
                        return t.pipe(
                            ke((t) => {
                                const i = t.clientX - e.clientX,
                                    n = t.clientY - e.clientY;
                                return [t, Math.sqrt(i * i + n * n)];
                            }),
                            $t(this._deferPixels$),
                            nt(([[, e], t]) => e > t),
                            ke(([[e]]) => e)
                        );
                    }
                    _createMouseDrag$(e, t) {
                        return e.pipe(
                            ke(([, e]) => e),
                            kt((e) =>
                                We(Ce(e), this._documentMouseMove$).pipe(Rt(t))
                            )
                        );
                    }
                    _createMouseDragEnd$(e, t) {
                        return e.pipe(kt(() => t.pipe(bt())));
                    }
                    _createMouseDragStart$(e) {
                        return e.pipe(ke(([e]) => e));
                    }
                    _createMouseDragInitiate$(e, t, i, n) {
                        return t.pipe(
                            nt((t) => this._mouseButton(t) === e),
                            kt((e) =>
                                He(
                                    Ce(e),
                                    n
                                        ? this._createDeferredMouseMove$(
                                              e,
                                              this._documentMouseMove$
                                          )
                                        : this._documentMouseMove$
                                ).pipe(Rt(i), mt(1))
                            )
                        );
                    }
                    _createOwner$(e) {
                        return e.pipe(
                            At(
                                (e, t) => (
                                    null == t.zindex
                                        ? delete e[t.name]
                                        : (e[t.name] = t.zindex),
                                    e
                                ),
                                {}
                            ),
                            ke((e) => {
                                let t = null,
                                    i = -1;
                                for (const n in e)
                                    e.hasOwnProperty(n) &&
                                        e[n] > i &&
                                        ((i = e[n]), (t = n));
                                return t;
                            }),
                            Ot(null)
                        );
                    }
                    _filtered(e, t, i) {
                        return t.pipe(
                            $t(i),
                            nt(([, t]) => t === e),
                            ke(([e]) => e)
                        );
                    }
                    _mouseButton(e) {
                        const t =
                                "pointerdown" === e.type ||
                                "pointerup" === e.type,
                            i = window.InstallTrigger;
                        return t &&
                            void 0 !== i &&
                            2 === e.button &&
                            e.ctrlKey &&
                            window.navigator.platform
                                .toUpperCase()
                                .indexOf("MAC") >= 0
                            ? 0
                            : e.button;
                    }
                    _buttonReleased(e, t) {
                        const i = FT[t];
                        return void 0 === e.buttons || (e.buttons & i) !== i;
                    }
                    _isMousePen(e) {
                        const t = e.pointerType;
                        return "mouse" === t || "pen" === t;
                    }
                }
                class GT {
                    set json(e) {
                        this._json = e;
                    }
                    set image(e) {
                        (this._image = e),
                            (this._texture = new Jr(this._image)),
                            (this._texture.minFilter = Vi);
                    }
                    get loaded() {
                        return !(!this._image || !this._json);
                    }
                    getGLSprite(e) {
                        if (!this.loaded)
                            throw new Error(
                                "Sprites cannot be retrieved before the atlas is loaded."
                            );
                        let t = this._json[e];
                        if (!t)
                            return (
                                console.warn(
                                    "Sprite with key" +
                                        e +
                                        "does not exist in sprite definition."
                                ),
                                new aa()
                            );
                        let i = this._texture.clone();
                        i.needsUpdate = !0;
                        let n = this._image.width,
                            r = this._image.height;
                        (i.offset.x = t.x / n),
                            (i.offset.y = (r - t.y - t.height) / r),
                            (i.repeat.x = t.width / n),
                            (i.repeat.y = t.height / r);
                        let s = new _h({ map: i });
                        return new Eh(s);
                    }
                    getDOMSprite(e, t) {
                        if (!this.loaded)
                            throw new Error(
                                "Sprites cannot be retrieved before the atlas is loaded."
                            );
                        null == t && (t = Ey.Center);
                        let i = this._json[e];
                        if (!i)
                            return (
                                console.warn(
                                    "Sprite with key" +
                                        e +
                                        "does not exist in sprite definition."
                                ),
                                n_.h("div", {}, [])
                            );
                        let n = i.y,
                            r = i.x + i.width,
                            s = i.y + i.height,
                            a = i.x,
                            o = -i.x,
                            c = -i.y,
                            l = this._image.height,
                            h = this._image.width;
                        switch (t) {
                            case Ey.Bottom:
                            case Ey.Center:
                            case Ey.Top:
                                o -= i.width / 2;
                                break;
                            case Ey.BottomLeft:
                            case Ey.Left:
                            case Ey.TopLeft:
                                o -= i.width;
                            case Ey.BottomRight:
                            case Ey.Right:
                            case Ey.TopRight:
                        }
                        switch (t) {
                            case Ey.Center:
                            case Ey.Left:
                            case Ey.Right:
                                c -= i.height / 2;
                                break;
                            case Ey.Top:
                            case Ey.TopLeft:
                            case Ey.TopRight:
                                c -= i.height;
                            case Ey.Bottom:
                            case Ey.BottomLeft:
                            case Ey.BottomRight:
                        }
                        let u = 1 / i.pixelRatio;
                        (n *= u),
                            (r *= u),
                            (s *= u),
                            (a *= u),
                            (o *= u),
                            (c *= u),
                            (l *= u),
                            (h *= u);
                        let d = {
                            src: this._image.src,
                            style: {
                                clip: `rect(${n}px, ${r}px, ${s}px, ${a}px)`,
                                height: `${l}px`,
                                left: `${o}px`,
                                position: "absolute",
                                top: `${c}px`,
                                width: `${h}px`,
                            },
                        };
                        return n_.h("img", d, []);
                    }
                }
                class VT {
                    constructor(e) {
                        if (
                            ((this._retina = window.devicePixelRatio > 1),
                            (this._spriteAtlasOperation$ = new W()),
                            (this._spriteAtlas$ =
                                this._spriteAtlasOperation$.pipe(
                                    Ot((e) => e),
                                    At((e, t) => t(e), new GT()),
                                    It(1),
                                    V()
                                )),
                            (this._atlasSubscription =
                                this._spriteAtlas$.subscribe(() => {})),
                            null == e)
                        )
                            return;
                        let t = this._retina ? "@2x" : "",
                            i = new XMLHttpRequest();
                        i.open("GET", e + t + ".png", !0),
                            (i.responseType = "arraybuffer"),
                            (i.onload = () => {
                                let e = new Image();
                                e.onload = () => {
                                    this._spriteAtlasOperation$.next(
                                        (t) => ((t.image = e), t)
                                    );
                                };
                                let t = new Blob([i.response]);
                                e.src = window.URL.createObjectURL(t);
                            }),
                            (i.onerror = (i) => {
                                console.error(
                                    new Error(
                                        `Failed to fetch sprite sheet (${e}${t}.png)`
                                    )
                                );
                            }),
                            i.send();
                        let n = new XMLHttpRequest();
                        n.open("GET", e + t + ".json", !0),
                            (n.responseType = "text"),
                            (n.onload = () => {
                                let e = JSON.parse(n.response);
                                this._spriteAtlasOperation$.next(
                                    (t) => ((t.json = e), t)
                                );
                            }),
                            (n.onerror = (i) => {
                                console.error(
                                    new Error(
                                        `Failed to fetch sheet (${e}${t}.json)`
                                    )
                                );
                            }),
                            n.send();
                    }
                    get spriteAtlas$() {
                        return this._spriteAtlas$;
                    }
                    dispose() {
                        this._atlasSubscription.unsubscribe();
                    }
                }
                class YT {
                    constructor(e, t) {
                        this._subscriptions = new s_();
                        const i = this._subscriptions;
                        (this._activeSubject$ = new Z(!1)),
                            (this._active$ = this._activeSubject$.pipe(
                                ft(),
                                It(1),
                                V()
                            )),
                            i.push(
                                Je(t, "touchmove").subscribe((e) => {
                                    e.preventDefault();
                                })
                            ),
                            (this._touchStart$ = Je(e, "touchstart")),
                            (this._touchMove$ = Je(e, "touchmove")),
                            (this._touchEnd$ = Je(e, "touchend")),
                            (this._touchCancel$ = Je(e, "touchcancel"));
                        const n = this._touchStart$.pipe(
                            nt(
                                (e) =>
                                    1 === e.touches.length &&
                                    1 === e.targetTouches.length
                            ),
                            Et()
                        );
                        var r;
                        (this._doubleTap$ = n.pipe(
                            ((r = () =>
                                n.pipe(
                                    bt(),
                                    kt(() => tt(et(300), n).pipe(mt(1)))
                                )),
                            H(function (e, t) {
                                var i = null,
                                    n = null,
                                    s = function () {
                                        null == n || n.unsubscribe();
                                        var e = i;
                                        (i = []),
                                            e && t.next(e),
                                            xe(r()).subscribe(
                                                (n = new G(t, s, D))
                                            );
                                    };
                                s(),
                                    e.subscribe(
                                        new G(
                                            t,
                                            function (e) {
                                                return null == i
                                                    ? void 0
                                                    : i.push(e);
                                            },
                                            function () {
                                                i && t.next(i), t.complete();
                                            },
                                            void 0,
                                            function () {
                                                return (i = n = null);
                                            }
                                        )
                                    );
                            })),
                            nt((e) => 2 === e.length),
                            ke((e) => e[e.length - 1]),
                            Et()
                        )),
                            i.push(
                                this._doubleTap$.subscribe((e) => {
                                    e.preventDefault();
                                })
                            ),
                            (this._singleTouchMove$ = this._touchMove$.pipe(
                                nt(
                                    (e) =>
                                        1 === e.touches.length &&
                                        1 === e.targetTouches.length
                                ),
                                Et()
                            ));
                        let s = tt(
                                this._touchStart$,
                                this._touchEnd$,
                                this._touchCancel$
                            ).pipe(
                                nt(
                                    (e) =>
                                        1 === e.touches.length &&
                                        1 === e.targetTouches.length
                                )
                            ),
                            a = tt(
                                this._touchStart$,
                                this._touchEnd$,
                                this._touchCancel$
                            ).pipe(nt((e) => e.touches.length >= 1)),
                            o = tt(this._touchEnd$, this._touchCancel$).pipe(
                                nt((e) => 0 === e.touches.length)
                            );
                        (this._singleTouchDragStart$ = s.pipe(
                            Ye(() =>
                                this._singleTouchMove$.pipe(Rt(tt(o, a)), mt(1))
                            )
                        )),
                            (this._singleTouchDragEnd$ = s.pipe(
                                Ye(() => tt(o, a).pipe(bt()))
                            )),
                            (this._singleTouchDrag$ = s.pipe(
                                kt(() =>
                                    this._singleTouchMove$.pipe(
                                        zt(1),
                                        Rt(tt(a, o))
                                    )
                                )
                            ));
                        let c = tt(
                            this._touchStart$,
                            this._touchEnd$,
                            this._touchCancel$
                        );
                        (this._pinchStart$ = c.pipe(
                            nt(
                                (e) =>
                                    2 === e.touches.length &&
                                    2 === e.targetTouches.length
                            )
                        )),
                            (this._pinchEnd$ = c.pipe(
                                nt(
                                    (e) =>
                                        2 !== e.touches.length ||
                                        2 !== e.targetTouches.length
                                )
                            )),
                            (this._pinchOperation$ = new W()),
                            (this._pinch$ = this._pinchOperation$.pipe(
                                At((e, t) => t(e), {
                                    changeX: 0,
                                    changeY: 0,
                                    clientX: 0,
                                    clientY: 0,
                                    distance: 0,
                                    distanceChange: 0,
                                    distanceX: 0,
                                    distanceY: 0,
                                    originalEvent: null,
                                    pageX: 0,
                                    pageY: 0,
                                    screenX: 0,
                                    screenY: 0,
                                    touch1: null,
                                    touch2: null,
                                })
                            ));
                        const l = this._touchMove$
                            .pipe(
                                nt(
                                    (e) =>
                                        2 === e.touches.length &&
                                        2 === e.targetTouches.length
                                ),
                                ke((e) => (t) => {
                                    let i = e.touches[0],
                                        n = e.touches[1],
                                        r = Math.min(i.clientX, n.clientX),
                                        s = Math.max(i.clientX, n.clientX),
                                        a = Math.min(i.clientY, n.clientY),
                                        o = r + (s - r) / 2,
                                        c =
                                            a +
                                            (Math.max(i.clientY, n.clientY) -
                                                a) /
                                                2,
                                        l = o + i.pageX - i.clientX,
                                        h = c + i.pageY - i.clientY,
                                        u = o + i.screenX - i.clientX,
                                        d = c + i.screenY - i.clientY,
                                        p = Math.abs(i.clientX - n.clientX),
                                        g = Math.abs(i.clientY - n.clientY),
                                        m = Math.sqrt(p * p + g * g),
                                        f = m - t.distance;
                                    return {
                                        changeX: p - t.distanceX,
                                        changeY: g - t.distanceY,
                                        clientX: o,
                                        clientY: c,
                                        distance: m,
                                        distanceChange: f,
                                        distanceX: p,
                                        distanceY: g,
                                        originalEvent: e,
                                        pageX: l,
                                        pageY: h,
                                        screenX: u,
                                        screenY: d,
                                        touch1: i,
                                        touch2: n,
                                    };
                                })
                            )
                            .subscribe(this._pinchOperation$);
                        i.push(l),
                            (this._pinchChange$ = this._pinchStart$.pipe(
                                kt(() =>
                                    this._pinch$.pipe(
                                        zt(1),
                                        Rt(this._pinchEnd$)
                                    )
                                )
                            ));
                    }
                    get active$() {
                        return this._active$;
                    }
                    get activate$() {
                        return this._activeSubject$;
                    }
                    get doubleTap$() {
                        return this._doubleTap$;
                    }
                    get touchStart$() {
                        return this._touchStart$;
                    }
                    get touchMove$() {
                        return this._touchMove$;
                    }
                    get touchEnd$() {
                        return this._touchEnd$;
                    }
                    get touchCancel$() {
                        return this._touchCancel$;
                    }
                    get singleTouchDragStart$() {
                        return this._singleTouchDragStart$;
                    }
                    get singleTouchDrag$() {
                        return this._singleTouchDrag$;
                    }
                    get singleTouchDragEnd$() {
                        return this._singleTouchDragEnd$;
                    }
                    get pinch$() {
                        return this._pinchChange$;
                    }
                    get pinchStart$() {
                        return this._pinchStart$;
                    }
                    get pinchEnd$() {
                        return this._pinchEnd$;
                    }
                    dispose() {
                        this._subscriptions.unsubscribe();
                    }
                }
                class qT {
                    constructor(e) {
                        var t, i, n, r;
                        const s =
                                null !==
                                    (i =
                                        null ===
                                            (t = null == e ? void 0 : e.url) ||
                                        void 0 === t
                                            ? void 0
                                            : t.exploreHost) && void 0 !== i
                                    ? i
                                    : "www.mapillary.com",
                            a = `${
                                null !==
                                    (r =
                                        null ===
                                            (n = null == e ? void 0 : e.url) ||
                                        void 0 === n
                                            ? void 0
                                            : n.scheme) && void 0 !== r
                                    ? r
                                    : "https"
                            }://${s}`;
                        this._exploreUrl$ = Ce(a);
                        const o = !1 !== (null == e ? void 0 : e.imageTiling);
                        this._imageTiling$ = Ce(o);
                    }
                    get exploreUrl$() {
                        return this._exploreUrl$;
                    }
                    get imageTiling$() {
                        return this._imageTiling$;
                    }
                }
                class WT {
                    constructor(e, t, i) {
                        var n;
                        if (
                            ((this._onWindowResize = () => {
                                this._trackResize &&
                                    this.renderService.resize$.next();
                            }),
                            (this._dom = null != i ? i : new uM()),
                            "string" == typeof e.container)
                        ) {
                            if (
                                ((this._container =
                                    this._dom.document.getElementById(
                                        e.container
                                    )),
                                !this._container)
                            )
                                throw new Error(
                                    `Container "${e.container}" not found.`
                                );
                        } else {
                            if (!(e.container instanceof HTMLElement))
                                throw new Error(
                                    'Invalid type: "container" must be a String or HTMLElement.'
                                );
                            this._container = e.container;
                        }
                        (this._trackResize = !1 !== e.trackResize),
                            (this.id =
                                null !== (n = this._container.id) &&
                                void 0 !== n
                                    ? n
                                    : "mapillary-fallback-container-id"),
                            this._container.classList.add("mapillary-viewer"),
                            (this._canvasContainer = this._dom.createElement(
                                "div",
                                "mapillary-interactive",
                                this._container
                            )),
                            (this._canvas = this._dom.createElement(
                                "canvas",
                                "mapillary-canvas"
                            )),
                            (this._canvas.style.position = "absolute"),
                            this._canvas.setAttribute("tabindex", "0"),
                            (this._domContainer = this._dom.createElement(
                                "div",
                                "mapillary-dom",
                                this._container
                            )),
                            (this.configurationService = new qT(e)),
                            (this.renderService = new PT(
                                this._container,
                                t.currentState$,
                                e.renderMode
                            )),
                            (this.glRenderer = new OT(
                                this._canvas,
                                this._canvasContainer,
                                this.renderService
                            )),
                            (this.domRenderer = new jT(
                                this._domContainer,
                                this.renderService,
                                t.currentState$
                            )),
                            (this.keyboardService = new UT(
                                this._canvasContainer
                            )),
                            (this.mouseService = new HT(
                                this._container,
                                this._canvasContainer,
                                this._domContainer,
                                document
                            )),
                            (this.touchService = new YT(
                                this._canvasContainer,
                                this._domContainer
                            )),
                            (this.spriteService = new VT(e.sprite)),
                            window.addEventListener(
                                "resize",
                                this._onWindowResize,
                                !1
                            );
                    }
                    get canvas() {
                        return this._canvas.parentNode ? this._canvas : null;
                    }
                    get canvasContainer() {
                        return this._canvasContainer;
                    }
                    get container() {
                        return this._container;
                    }
                    get domContainer() {
                        return this._domContainer;
                    }
                    remove() {
                        window.removeEventListener(
                            "resize",
                            this._onWindowResize,
                            !1
                        ),
                            this.spriteService.dispose(),
                            this.touchService.dispose(),
                            this.mouseService.dispose(),
                            this.glRenderer.remove(),
                            this.domRenderer.remove(),
                            this.renderService.dispose(),
                            this._removeNode(this._canvasContainer),
                            this._removeNode(this._domContainer),
                            this._container.classList.remove(
                                "mapillary-viewer"
                            );
                    }
                    _removeNode(e) {
                        e.parentNode && e.parentNode.removeChild(e);
                    }
                }
                class QT {
                    constructor(e, t, i) {
                        (this._graphService = e),
                            (this._stateService = t),
                            (this._api = i),
                            (this._subscriptions = new s_()),
                            (this._started = !1),
                            (this._cellDepth = 1);
                    }
                    get started() {
                        return this._started;
                    }
                    configure(e) {
                        this._cellDepth = e
                            ? Math.max(1, Math.min(3, e.cellDepth))
                            : 1;
                    }
                    start() {
                        if (this._started) return;
                        const e = this._subscriptions;
                        e.push(
                            this._stateService.currentState$
                                .pipe(
                                    ft(void 0, (e) => e.state.currentImage.id),
                                    ke((e) => {
                                        const t = e.state,
                                            i = t.trajectory,
                                            n = i.map((e) => e.id),
                                            r = i[i.length - 1].sequenceId;
                                        return [
                                            n,
                                            t.currentImage.originalLngLat,
                                            r,
                                        ];
                                    }),
                                    at(1, 5),
                                    $t(this._graphService.graphMode$),
                                    kt(([e, t]) => {
                                        const i = e[0][0],
                                            n = e[0][1],
                                            r = this._api.data.geometry,
                                            s = kM(
                                                r.lngLatToCellId(n),
                                                this._cellDepth,
                                                r
                                            ),
                                            a =
                                                t === O_.Sequence
                                                    ? e[0][2]
                                                    : void 0;
                                        return this._graphService.uncache$(
                                            i,
                                            s,
                                            a
                                        );
                                    })
                                )
                                .subscribe(() => {})
                        ),
                            e.push(
                                this._graphService.graphMode$
                                    .pipe(
                                        zt(1),
                                        $t(this._stateService.currentState$),
                                        kt(([e, t]) =>
                                            e === O_.Sequence
                                                ? this._keyToEdges(
                                                      t.state.currentImage.id,
                                                      (e) => e.sequenceEdges$
                                                  )
                                                : ye(
                                                      t.state.trajectory
                                                          .map((e) => e.id)
                                                          .slice(
                                                              t.state
                                                                  .currentIndex
                                                          )
                                                  ).pipe(
                                                      Ye(
                                                          (e) =>
                                                              this._keyToEdges(
                                                                  e,
                                                                  (e) =>
                                                                      e.spatialEdges$
                                                              ),
                                                          6
                                                      )
                                                  )
                                        )
                                    )
                                    .subscribe(() => {})
                            ),
                            e.push(
                                this._graphService.dataAdded$
                                    .pipe(
                                        $t(this._stateService.currentId$),
                                        kt(([e, t]) =>
                                            this._graphService.cacheImage$(t)
                                        )
                                    )
                                    .subscribe(() => {})
                            ),
                            (this._started = !0);
                    }
                    stop() {
                        this._started &&
                            (this._subscriptions.unsubscribe(),
                            (this._started = !1));
                    }
                    _keyToEdges(e, t) {
                        return this._graphService.cacheImage$(e).pipe(
                            kt(t),
                            bt((e) => e.cached),
                            je(15e3),
                            ot(
                                (t) => (
                                    console.error(
                                        `Failed to cache edges (${e}).`,
                                        t
                                    ),
                                    oe()
                                )
                            )
                        );
                    }
                }
                class ZT {
                    constructor() {
                        (this._loadersSubject$ = new W()),
                            (this._loaders$ = this._loadersSubject$.pipe(
                                At(
                                    (e, t) => (
                                        void 0 !== t.task &&
                                            (e[t.task] = t.loading),
                                        e
                                    ),
                                    {}
                                ),
                                Ot({}),
                                It(1),
                                V()
                            ));
                    }
                    get loading$() {
                        return this._loaders$.pipe(
                            ke((e) => {
                                for (const t in e)
                                    if (e.hasOwnProperty(t) && e[t]) return !0;
                                return !1;
                            }),
                            pt(100),
                            ft()
                        );
                    }
                    taskLoading$(e) {
                        return this._loaders$.pipe(
                            ke((t) => !!t[e]),
                            pt(100),
                            ft()
                        );
                    }
                    startLoading(e) {
                        this._loadersSubject$.next({ loading: !0, task: e });
                    }
                    stopLoading(e) {
                        this._loadersSubject$.next({ loading: !1, task: e });
                    }
                }
                var XT;
                !(function (e) {
                    (e[(e.Disabled = 0)] = "Disabled"),
                        (e[(e.Enabled = 1)] = "Enabled"),
                        (e[(e.Started = 2)] = "Started");
                })(XT || (XT = {}));
                class JT {
                    constructor(e, t, i, n, r, s) {
                        (this._subscriptions = new s_()),
                            (this._graphService = e),
                            (this._stateService = t),
                            (this._graphCalculator = null != n ? n : new bp()),
                            (this._spatial = null != r ? r : new Lp()),
                            (this._viewportCoords = null != s ? s : new l_()),
                            (this._mode = !1 !== i ? XT.Enabled : XT.Disabled),
                            (this._panImagesSubject$ = new W()),
                            (this._panImages$ = this._panImagesSubject$.pipe(
                                Ot([]),
                                It(1),
                                V()
                            )),
                            this._subscriptions.push(
                                this._panImages$.subscribe()
                            );
                    }
                    get panImages$() {
                        return this._panImages$;
                    }
                    dispose() {
                        this.stop(),
                            null != this._panImagesSubscription &&
                                this._panImagesSubscription.unsubscribe(),
                            this._subscriptions.unsubscribe();
                    }
                    enable() {
                        this._mode === XT.Disabled &&
                            ((this._mode = XT.Enabled), this.start());
                    }
                    disable() {
                        this._mode !== XT.Disabled &&
                            (this.stop(), (this._mode = XT.Disabled));
                    }
                    start() {
                        if (this._mode !== XT.Enabled) return;
                        const e = this._stateService.currentImage$.pipe(
                            kt((e) => {
                                if (!e.merged || jp(e.cameraType))
                                    return Ce([]);
                                const t = Ce(e),
                                    i =
                                        this._graphCalculator.boundingBoxCorners(
                                            e.lngLat,
                                            20
                                        );
                                return He(
                                    t,
                                    this._graphService
                                        .cacheBoundingBox$(i[0], i[1])
                                        .pipe(
                                            ot(
                                                (t) => (
                                                    console.error(
                                                        `Failed to cache periphery bounding box (${e.id})`,
                                                        t
                                                    ),
                                                    oe()
                                                )
                                            ),
                                            ke((t) => {
                                                if (jp(e.cameraType)) return [];
                                                const i = [];
                                                for (const n of t)
                                                    n.id !== e.id &&
                                                        n.mergeId ===
                                                            e.mergeId &&
                                                        (jp(n.cameraType) ||
                                                            this._distance(
                                                                n,
                                                                e
                                                            ) > 4 ||
                                                            i.push(n));
                                                return i;
                                            })
                                        )
                                ).pipe(
                                    $t(this._stateService.reference$),
                                    ke(([[e, t], i]) => {
                                        const n =
                                                this._spatial.viewingDirection(
                                                    e.rotation
                                                ),
                                            r = kp(
                                                {
                                                    lat: e.lngLat.lat,
                                                    lng: e.lngLat.lng,
                                                    alt: e.computedAltitude,
                                                },
                                                e.rotation,
                                                i
                                            ),
                                            s = this._createTransform(e, r),
                                            a = this._spatial.wrap(
                                                this._spatial.azimuthal(
                                                    n.toArray(),
                                                    s.upVector().toArray()
                                                ),
                                                0,
                                                2 * Math.PI
                                            ),
                                            o = this._computeProjectedPoints(s),
                                            c =
                                                (this._computeHorizontalFov(o) /
                                                    180) *
                                                Math.PI,
                                            l = Math.PI / 8;
                                        let h, u;
                                        for (const r of t) {
                                            const t = kp(
                                                    {
                                                        lat: r.lngLat.lat,
                                                        lng: r.lngLat.lng,
                                                        alt: r.computedAltitude,
                                                    },
                                                    r.rotation,
                                                    i
                                                ),
                                                s = this._createTransform(r, t),
                                                o =
                                                    this._computeProjectedPoints(
                                                        s
                                                    ),
                                                d =
                                                    (this._computeHorizontalFov(
                                                        o
                                                    ) /
                                                        180) *
                                                    Math.PI,
                                                p =
                                                    this._spatial.viewingDirection(
                                                        r.rotation
                                                    ),
                                                g = this._spatial.wrap(
                                                    this._spatial.azimuthal(
                                                        p.toArray(),
                                                        s.upVector().toArray()
                                                    ),
                                                    0,
                                                    2 * Math.PI
                                                ),
                                                m =
                                                    this._spatial.angleBetweenVector2(
                                                        n.x,
                                                        n.y,
                                                        p.x,
                                                        p.y
                                                    );
                                            let f = Number.NEGATIVE_INFINITY;
                                            f =
                                                m > 0
                                                    ? a > g
                                                        ? a -
                                                          2 * Math.PI +
                                                          c / 2 -
                                                          (g - d / 2)
                                                        : a +
                                                          c / 2 -
                                                          (g - d / 2)
                                                    : a < g
                                                    ? g +
                                                      d / 2 -
                                                      (a + 2 * Math.PI - c / 2)
                                                    : g + d / 2 - (a - c / 2);
                                            const _ = Math.abs(d - f),
                                                M =
                                                    this._distance(r, e) +
                                                    Math.min(
                                                        this._timeDifference(
                                                            r,
                                                            e
                                                        ),
                                                        4
                                                    ) +
                                                    20 * Math.abs(f - l) +
                                                    Math.min(
                                                        5,
                                                        1 / Math.min(d / c, 1)
                                                    ) +
                                                    (f > 0 ? -2 * _ : 0);
                                            f > 0 &&
                                                f < 0.5 * c &&
                                                f < 0.5 * d &&
                                                _ > 0.5 * c &&
                                                (m > 0
                                                    ? h
                                                        ? M < h[0] &&
                                                          (h = [M, r, s, d])
                                                        : (h = [M, r, s, d])
                                                    : u
                                                    ? M < u[0] &&
                                                      (u = [M, r, s, d])
                                                    : (u = [M, r, s, d]));
                                        }
                                        const d = [];
                                        return (
                                            h && d.push([h[1], h[2], h[3]]),
                                            u && d.push([u[1], u[2], u[3]]),
                                            d
                                        );
                                    }),
                                    Ot([])
                                );
                            })
                        );
                        (this._panImagesSubscription =
                            this._stateService.currentState$
                                .pipe(
                                    ke((e) => e.state.imagesAhead > 0),
                                    ft(),
                                    kt((t) => (t ? Ce([]) : e))
                                )
                                .subscribe((e) => {
                                    this._panImagesSubject$.next(e);
                                })),
                            (this._mode = XT.Started);
                    }
                    stop() {
                        this._mode === XT.Started &&
                            (this._panImagesSubscription.unsubscribe(),
                            this._panImagesSubject$.next([]),
                            (this._mode = XT.Enabled));
                    }
                    _distance(e, t) {
                        const [i, n, r] = vp(
                            e.lngLat.lng,
                            e.lngLat.lat,
                            e.computedAltitude,
                            t.lngLat.lng,
                            t.lngLat.lat,
                            t.computedAltitude
                        );
                        return Math.sqrt(i * i + n * n + r * r);
                    }
                    _timeDifference(e, t) {
                        return Math.abs(e.capturedAt - t.capturedAt) / 2592e6;
                    }
                    _createTransform(e, t) {
                        return new mM(
                            e.exifOrientation,
                            e.width,
                            e.height,
                            e.scale,
                            e.rotation,
                            t,
                            e.assetsCached ? e.image : void 0,
                            void 0,
                            e.cameraParameters,
                            e.cameraType
                        );
                    }
                    _computeProjectedPoints(e) {
                        return Rp(
                            e,
                            [[1, 0]],
                            [[0, 0.5]],
                            20,
                            this._viewportCoords
                        );
                    }
                    _computeHorizontalFov(e) {
                        const t = e.map((e) => this._coordToFov(e[0]));
                        return Math.min(...t);
                    }
                    _coordToFov(e) {
                        return (2 * Math.atan(e) * 180) / Math.PI;
                    }
                }
                class KT {
                    constructor(e) {
                        this._data = e;
                    }
                    get data() {
                        return this._data;
                    }
                    getCoreImages$(e) {
                        return this._wrap$(this._data.getCoreImages(e));
                    }
                    getImages$(e) {
                        return this._wrap$(this._data.getImages(e));
                    }
                    getImageTiles$(e) {
                        return this._wrap$(this._data.getImageTiles(e));
                    }
                    getSequence$(e) {
                        return this._wrap$(this._data.getSequence(e));
                    }
                    getSpatialImages$(e) {
                        return this._wrap$(this._data.getSpatialImages(e));
                    }
                    setAccessToken(e) {
                        this._data.setAccessToken(e);
                    }
                    _wrap$(e) {
                        return $.create((t) => {
                            e.then(
                                (e) => {
                                    t.next(e), t.complete();
                                },
                                (e) => {
                                    t.error(e);
                                }
                            );
                        });
                    }
                }
                class eS {
                    constructor(e) {
                        (this._dataAdded$ = new W()),
                            (this._subscriptions = new s_()),
                            (this._onDataAdded = (e) => {
                                this._graph$
                                    .pipe(
                                        bt(),
                                        Ye((t) =>
                                            t.updateCells$(e.cellIds).pipe(
                                                Ut(() => {
                                                    t.resetSpatialEdges();
                                                })
                                            )
                                        )
                                    )
                                    .subscribe((e) => {
                                        this._dataAdded$.next(e);
                                    });
                            });
                        const t = this._subscriptions;
                        (this._graph$ = We(Ce(e), e.changed$).pipe(It(1), V())),
                            t.push(this._graph$.subscribe(() => {})),
                            (this._graphMode = O_.Spatial),
                            (this._graphModeSubject$ = new W()),
                            (this._graphMode$ = this._graphModeSubject$.pipe(
                                Ot(this._graphMode),
                                It(1),
                                V()
                            )),
                            t.push(this._graphMode$.subscribe(() => {})),
                            (this._firstGraphSubjects$ = []),
                            (this._initializeCacheSubscriptions = []),
                            (this._sequenceSubscriptions = []),
                            (this._spatialSubscriptions = []),
                            e.api.data.on("datacreate", this._onDataAdded);
                    }
                    get dataAdded$() {
                        return this._dataAdded$;
                    }
                    get filter$() {
                        return this._graph$.pipe(
                            bt(),
                            Ye((e) => e.filter$)
                        );
                    }
                    get graphMode$() {
                        return this._graphMode$;
                    }
                    cacheBoundingBox$(e, t) {
                        return this._graph$.pipe(
                            bt(),
                            Ye((i) => i.cacheBoundingBox$(e, t))
                        );
                    }
                    cacheCell$(e) {
                        return this._graph$.pipe(
                            bt(),
                            Ye((t) => t.cacheCell$(e))
                        );
                    }
                    cacheImage$(e) {
                        const t = new W();
                        this._firstGraphSubjects$.push(t);
                        const i = t.pipe(It(1), V()),
                            n = i.pipe(
                                ke((t) => t.getNode(e)),
                                Ye((e) =>
                                    e.assetsCached ? Ce(e) : e.cacheAssets$()
                                ),
                                It(1),
                                V()
                            );
                        let r;
                        n.subscribe(void 0, (t) => {
                            console.error(`Failed to cache image (${e}).`, t);
                        }),
                            (r = this._graph$
                                .pipe(
                                    bt(),
                                    Ye((t) =>
                                        t.isCachingFull(e) || !t.hasNode(e)
                                            ? t.cacheFull$(e)
                                            : t.isCachingFill(e) ||
                                              !t.getNode(e).complete
                                            ? t.cacheFill$(e)
                                            : Ce(t)
                                    ),
                                    Ut((t) => {
                                        if (!t.hasNode(e))
                                            throw new Up(
                                                `Failed to cache image (${e})`
                                            );
                                        t.hasInitializedCache(e) ||
                                            t.initializeCache(e);
                                    }),
                                    xt(() => {
                                        null != r &&
                                            (this._removeFromArray(
                                                r,
                                                this
                                                    ._initializeCacheSubscriptions
                                            ),
                                            this._removeFromArray(
                                                t,
                                                this._firstGraphSubjects$
                                            ));
                                    })
                                )
                                .subscribe(
                                    (e) => {
                                        t.next(e), t.complete();
                                    },
                                    (e) => {
                                        t.error(e);
                                    }
                                )),
                            r.closed ||
                                this._initializeCacheSubscriptions.push(r);
                        const s = i.pipe(
                            ot(() => oe()),
                            Ye((t) =>
                                t.isCachingNodeSequence(e) ||
                                !t.hasNodeSequence(e)
                                    ? t.cacheNodeSequence$(e)
                                    : Ce(t)
                            ),
                            It(1),
                            V()
                        );
                        let a;
                        if (
                            ((a = s
                                .pipe(
                                    Ut((t) => {
                                        t.getNode(e).sequenceEdges.cached ||
                                            t.cacheSequenceEdges(e);
                                    }),
                                    xt(() => {
                                        null != a &&
                                            this._removeFromArray(
                                                a,
                                                this._sequenceSubscriptions
                                            );
                                    })
                                )
                                .subscribe(
                                    () => {},
                                    (t) => {
                                        console.error(
                                            `Failed to cache sequence edges (${e}).`,
                                            t
                                        );
                                    }
                                )),
                            a.closed || this._sequenceSubscriptions.push(a),
                            this._graphMode === O_.Spatial)
                        ) {
                            let t;
                            (t = i
                                .pipe(
                                    ot(() => oe()),
                                    yt((t) =>
                                        t.hasTiles(e)
                                            ? oe()
                                            : ye(t.cacheTiles$(e)).pipe(
                                                  Ye((t) =>
                                                      t.pipe(
                                                          Ye((t) =>
                                                              t.isCachingTiles(
                                                                  e
                                                              )
                                                                  ? oe()
                                                                  : Ce(t)
                                                          ),
                                                          ot(
                                                              (t) => (
                                                                  console.error(
                                                                      `Failed to cache tile data (${e}).`,
                                                                      t
                                                                  ),
                                                                  oe()
                                                              )
                                                          )
                                                      )
                                                  )
                                              )
                                    ),
                                    wt(1),
                                    Ye((t) =>
                                        t.hasSpatialArea(e)
                                            ? Ce(t)
                                            : ye(t.cacheSpatialArea$(e)).pipe(
                                                  Ye((t) =>
                                                      t.pipe(
                                                          ot(
                                                              (t) => (
                                                                  console.error(
                                                                      `Failed to cache spatial images (${e}).`,
                                                                      t
                                                                  ),
                                                                  oe()
                                                              )
                                                          )
                                                      )
                                                  )
                                              )
                                    ),
                                    wt(1),
                                    Ye((t) =>
                                        t.hasNodeSequence(e)
                                            ? Ce(t)
                                            : t.cacheNodeSequence$(e)
                                    ),
                                    Ut((t) => {
                                        t.getNode(e).spatialEdges.cached ||
                                            t.cacheSpatialEdges(e);
                                    }),
                                    xt(() => {
                                        null != t &&
                                            this._removeFromArray(
                                                t,
                                                this._spatialSubscriptions
                                            );
                                    })
                                )
                                .subscribe(
                                    () => {},
                                    (t) => {
                                        const i = `Failed to cache spatial edges (${e}).`;
                                        console.error(i, t);
                                    }
                                )),
                                t.closed || this._spatialSubscriptions.push(t);
                        }
                        return n.pipe(bt((e) => e.assetsCached));
                    }
                    cacheSequence$(e) {
                        return this._graph$.pipe(
                            bt(),
                            Ye((t) =>
                                t.isCachingSequence(e) || !t.hasSequence(e)
                                    ? t.cacheSequence$(e)
                                    : Ce(t)
                            ),
                            ke((t) => t.getSequence(e))
                        );
                    }
                    cacheSequenceImages$(e, t) {
                        return this._graph$.pipe(
                            bt(),
                            Ye((t) =>
                                t.isCachingSequence(e) || !t.hasSequence(e)
                                    ? t.cacheSequence$(e)
                                    : Ce(t)
                            ),
                            Ye((i) =>
                                i.isCachingSequenceNodes(e) ||
                                !i.hasSequenceNodes(e)
                                    ? i.cacheSequenceNodes$(e, t)
                                    : Ce(i)
                            ),
                            ke((t) => t.getSequence(e))
                        );
                    }
                    dispose() {
                        this._graph$.pipe(bt()).subscribe((e) => {
                            e.unsubscribe();
                        }),
                            this._subscriptions.unsubscribe();
                    }
                    setFilter$(e) {
                        return (
                            this._resetSubscriptions(
                                this._spatialSubscriptions
                            ),
                            this._graph$.pipe(
                                bt(),
                                Ut((t) => {
                                    t.resetSpatialEdges(), t.setFilter(e);
                                }),
                                ke(() => {})
                            )
                        );
                    }
                    setGraphMode(e) {
                        this._graphMode !== e &&
                            (e === O_.Sequence &&
                                this._resetSubscriptions(
                                    this._spatialSubscriptions
                                ),
                            (this._graphMode = e),
                            this._graphModeSubject$.next(this._graphMode));
                    }
                    reset$(e) {
                        return (
                            this._abortSubjects(this._firstGraphSubjects$),
                            this._resetSubscriptions(
                                this._initializeCacheSubscriptions
                            ),
                            this._resetSubscriptions(
                                this._sequenceSubscriptions
                            ),
                            this._resetSubscriptions(
                                this._spatialSubscriptions
                            ),
                            this._graph$.pipe(
                                bt(),
                                Ut((t) => {
                                    t.reset(e);
                                }),
                                ke(() => {})
                            )
                        );
                    }
                    uncache$(e, t, i) {
                        return this._graph$.pipe(
                            bt(),
                            Ut((n) => {
                                n.uncache(e, t, i);
                            }),
                            ke(() => {})
                        );
                    }
                    _abortSubjects(e) {
                        for (const t of e.slice())
                            this._removeFromArray(t, e),
                                t.error(
                                    new Error(
                                        "Cache image request was aborted."
                                    )
                                );
                    }
                    _removeFromArray(e, t) {
                        const i = t.indexOf(e);
                        -1 !== i && t.splice(i, 1);
                    }
                    _resetSubscriptions(e) {
                        for (const t of e.slice())
                            this._removeFromArray(t, e),
                                t.closed || t.unsubscribe();
                    }
                }
                class tS {
                    constructor(e) {
                        e.requestAnimationFrame
                            ? ((this._cancelAnimationFrame =
                                  e.cancelAnimationFrame.bind(e)),
                              (this._requestAnimationFrame =
                                  e.requestAnimationFrame.bind(e)))
                            : e.mozRequestAnimationFrame
                            ? ((this._cancelAnimationFrame =
                                  e.mozCancelAnimationFrame.bind(e)),
                              (this._requestAnimationFrame =
                                  e.mozRequestAnimationFrame.bind(e)))
                            : e.webkitRequestAnimationFrame
                            ? ((this._cancelAnimationFrame =
                                  e.webkitCancelAnimationFrame.bind(e)),
                              (this._requestAnimationFrame =
                                  e.webkitRequestAnimationFrame.bind(e)))
                            : e.msRequestAnimationFrame
                            ? ((this._cancelAnimationFrame =
                                  e.msCancelAnimationFrame.bind(e)),
                              (this._requestAnimationFrame =
                                  e.msRequestAnimationFrame.bind(e)))
                            : e.oRequestAnimationFrame
                            ? ((this._cancelAnimationFrame =
                                  e.oCancelAnimationFrame.bind(e)),
                              (this._requestAnimationFrame =
                                  e.oRequestAnimationFrame.bind(e)))
                            : ((this._cancelAnimationFrame =
                                  e.clearTimeout.bind(e)),
                              (this._requestAnimationFrame = (t) =>
                                  e.setTimeout(t, 1e3 / 60)));
                    }
                    get cancelAnimationFrame() {
                        return this._cancelAnimationFrame;
                    }
                    get requestAnimationFrame() {
                        return this._requestAnimationFrame;
                    }
                }
                class iS {
                    constructor(e) {
                        (this._spatial = new Lp()),
                            (this._referenceThreshold = 0.01),
                            (this._transitionMode = e.transitionMode),
                            (this._reference = e.reference),
                            (this._alpha = e.alpha),
                            (this._stateTransitionAlpha = 0),
                            (this._camera = e.camera.clone()),
                            (this._zoom = e.zoom),
                            (this._currentIndex = e.currentIndex),
                            (this._trajectory = e.trajectory.slice()),
                            (this._trajectoryTransforms = []),
                            (this._trajectoryCameras = []);
                        for (let e of this._trajectory) {
                            let t = this._imageToTranslation(
                                    e,
                                    this._reference
                                ),
                                i = new mM(
                                    e.exifOrientation,
                                    e.width,
                                    e.height,
                                    e.scale,
                                    e.rotation,
                                    t,
                                    e.image,
                                    void 0,
                                    e.cameraParameters,
                                    e.cameraType
                                );
                            this._trajectoryTransforms.push(i),
                                this._trajectoryCameras.push(new kT(i));
                        }
                        (this._currentImage =
                            this._trajectory.length > 0
                                ? this._trajectory[this._currentIndex]
                                : null),
                            (this._previousImage =
                                this._trajectory.length > 1 &&
                                this.currentIndex > 0
                                    ? this._trajectory[this._currentIndex - 1]
                                    : null),
                            (this._currentCamera =
                                this._trajectoryCameras.length > 0
                                    ? this._trajectoryCameras[
                                          this._currentIndex
                                      ].clone()
                                    : new kT()),
                            (this._previousCamera =
                                this._trajectoryCameras.length > 1 &&
                                this.currentIndex > 0
                                    ? this._trajectoryCameras[
                                          this._currentIndex - 1
                                      ].clone()
                                    : this._currentCamera.clone());
                    }
                    get reference() {
                        return this._reference;
                    }
                    get alpha() {
                        return this._getAlpha();
                    }
                    get stateTransitionAlpha() {
                        return this._getStateTransitionAlpha();
                    }
                    get camera() {
                        return this._camera;
                    }
                    get zoom() {
                        return this._zoom;
                    }
                    get trajectory() {
                        return this._trajectory;
                    }
                    get currentIndex() {
                        return this._currentIndex;
                    }
                    get currentImage() {
                        return this._currentImage;
                    }
                    get previousImage() {
                        return this._previousImage;
                    }
                    get currentCamera() {
                        return this._currentCamera;
                    }
                    get currentTransform() {
                        return this._trajectoryTransforms.length > 0
                            ? this._trajectoryTransforms[this.currentIndex]
                            : null;
                    }
                    get previousTransform() {
                        return this._trajectoryTransforms.length > 1 &&
                            this.currentIndex > 0
                            ? this._trajectoryTransforms[this.currentIndex - 1]
                            : null;
                    }
                    get motionless() {
                        return this._motionless;
                    }
                    get transitionMode() {
                        return this._transitionMode;
                    }
                    move(e) {}
                    moveTo(e) {}
                    rotate(e) {}
                    rotateUnbounded(e) {}
                    rotateWithoutInertia(e) {}
                    rotateBasic(e) {}
                    rotateBasicUnbounded(e) {}
                    rotateBasicWithoutInertia(e) {}
                    rotateToBasic(e) {}
                    setSpeed(e) {}
                    zoomIn(e, t) {}
                    update(e) {}
                    setCenter(e) {}
                    setZoom(e) {}
                    dolly(e) {}
                    orbit(e) {}
                    setViewMatrix(e) {}
                    truck(e) {}
                    append(e) {
                        if (e.length < 1)
                            throw Error("Trajectory can not be empty");
                        this._currentIndex < 0
                            ? this.set(e)
                            : ((this._trajectory = this._trajectory.concat(e)),
                              this._appendToTrajectories(e));
                    }
                    prepend(e) {
                        if (e.length < 1)
                            throw Error("Trajectory can not be empty");
                        (this._trajectory = e.slice().concat(this._trajectory)),
                            (this._currentIndex += e.length),
                            this._setCurrentImage(),
                            this._setReference(this._currentImage)
                                ? this._setTrajectories()
                                : this._prependToTrajectories(e),
                            this._setCurrentCamera();
                    }
                    remove(e) {
                        if (e < 0) throw Error("n must be a positive integer");
                        if (this._currentIndex - 1 < e)
                            throw Error(
                                "Current and previous images can not be removed"
                            );
                        for (let t = 0; t < e; t++)
                            this._trajectory.shift(),
                                this._trajectoryTransforms.shift(),
                                this._trajectoryCameras.shift(),
                                this._currentIndex--;
                        this._setCurrentImage();
                    }
                    clearPrior() {
                        this._currentIndex > 0 &&
                            this.remove(this._currentIndex - 1);
                    }
                    clear() {
                        this.cut(),
                            this._currentIndex > 0 &&
                                this.remove(this._currentIndex - 1);
                    }
                    cut() {
                        for (
                            ;
                            this._trajectory.length - 1 > this._currentIndex;

                        )
                            this._trajectory.pop(),
                                this._trajectoryTransforms.pop(),
                                this._trajectoryCameras.pop();
                    }
                    set(e) {
                        this._setTrajectory(e),
                            this._setCurrentImage(),
                            this._setReference(this._currentImage),
                            this._setTrajectories(),
                            this._setCurrentCamera();
                    }
                    getCenter() {
                        return null != this._currentImage
                            ? this.currentTransform.projectBasic(
                                  this._camera.lookat.toArray()
                              )
                            : [0.5, 0.5];
                    }
                    setTransitionMode(e) {
                        this._transitionMode = e;
                    }
                    _getAlpha() {
                        return 1;
                    }
                    _getStateTransitionAlpha() {
                        return 1;
                    }
                    _setCurrent() {
                        this._setCurrentImage(),
                            this._setReference(this._currentImage) &&
                                this._setTrajectories(),
                            this._setCurrentCamera();
                    }
                    _setCurrentCamera() {
                        (this._currentCamera =
                            this._trajectoryCameras[
                                this._currentIndex
                            ].clone()),
                            (this._previousCamera =
                                this._currentIndex > 0
                                    ? this._trajectoryCameras[
                                          this._currentIndex - 1
                                      ].clone()
                                    : this._currentCamera.clone());
                    }
                    _motionlessTransition() {
                        return (
                            null != this._currentImage &&
                            null != this._previousImage &&
                            (this._transitionMode === NT.Instantaneous ||
                                !(
                                    this._currentImage.merged &&
                                    this._previousImage.merged &&
                                    this._withinOriginalDistance() &&
                                    this._sameConnectedComponent()
                                ))
                        );
                    }
                    _setReference(e) {
                        return !(
                            (Math.abs(e.lngLat.lat - this.reference.lat) <
                                this._referenceThreshold &&
                                Math.abs(e.lngLat.lng - this.reference.lng) <
                                    this._referenceThreshold) ||
                            (null != this._previousImage &&
                                !this._motionlessTransition()) ||
                            ((this._reference.lat = e.lngLat.lat),
                            (this._reference.lng = e.lngLat.lng),
                            (this._reference.alt = e.computedAltitude),
                            0)
                        );
                    }
                    _setCurrentImage() {
                        (this._currentImage =
                            this._trajectory.length > 0
                                ? this._trajectory[this._currentIndex]
                                : null),
                            (this._previousImage =
                                this._currentIndex > 0
                                    ? this._trajectory[this._currentIndex - 1]
                                    : null);
                    }
                    _setTrajectory(e) {
                        if (e.length < 1)
                            throw new Ep("Trajectory can not be empty");
                        null != this._currentImage
                            ? ((this._trajectory = [this._currentImage].concat(
                                  e
                              )),
                              (this._currentIndex = 1))
                            : ((this._trajectory = e.slice()),
                              (this._currentIndex = 0));
                    }
                    _setTrajectories() {
                        (this._trajectoryTransforms.length = 0),
                            (this._trajectoryCameras.length = 0),
                            this._appendToTrajectories(this._trajectory);
                    }
                    _appendToTrajectories(e) {
                        for (let t of e) {
                            if (!t.assetsCached)
                                throw new Ep(
                                    "Assets must be cached when image is added to trajectory"
                                );
                            let e = this._imageToTranslation(t, this.reference),
                                i = new mM(
                                    t.exifOrientation,
                                    t.width,
                                    t.height,
                                    t.scale,
                                    t.rotation,
                                    e,
                                    t.image,
                                    void 0,
                                    t.cameraParameters,
                                    t.cameraType
                                );
                            this._trajectoryTransforms.push(i),
                                this._trajectoryCameras.push(new kT(i));
                        }
                    }
                    _prependToTrajectories(e) {
                        for (let t of e.reverse()) {
                            if (!t.assetsCached)
                                throw new Ep(
                                    "Assets must be cached when added to trajectory"
                                );
                            let e = this._imageToTranslation(t, this.reference),
                                i = new mM(
                                    t.exifOrientation,
                                    t.width,
                                    t.height,
                                    t.scale,
                                    t.rotation,
                                    e,
                                    t.image,
                                    void 0,
                                    t.cameraParameters,
                                    t.cameraType
                                );
                            this._trajectoryTransforms.unshift(i),
                                this._trajectoryCameras.unshift(new kT(i));
                        }
                    }
                    _imageToTranslation(e, t) {
                        return kp(
                            {
                                alt: e.computedAltitude,
                                lat: e.lngLat.lat,
                                lng: e.lngLat.lng,
                            },
                            e.rotation,
                            t
                        );
                    }
                    _sameConnectedComponent() {
                        let e = this._currentImage,
                            t = this._previousImage;
                        return !!e && !!t && e.mergeId === t.mergeId;
                    }
                    _withinOriginalDistance() {
                        let e = this._currentImage,
                            t = this._previousImage;
                        return (
                            !e ||
                            !t ||
                            this._spatial.distanceFromLngLat(
                                e.originalLngLat.lng,
                                e.originalLngLat.lat,
                                t.originalLngLat.lng,
                                t.originalLngLat.lat
                            ) < 25
                        );
                    }
                }
                class nS extends iS {
                    constructor(e) {
                        super(e);
                    }
                    setViewMatrix(e) {
                        const t = new Os().fromArray(e).invert().elements,
                            i = new rs(t[12], t[13], t[14]),
                            n = new rs(-t[8], -t[9], -t[10]),
                            r = new rs(t[4], t[5], t[6]),
                            s = this._camera;
                        s.position.copy(i),
                            s.lookat.copy(i.clone().add(n)),
                            s.up.copy(r);
                        const a = 0.5 / Math.tan(Math.PI / 3);
                        s.focal = a;
                    }
                }
                class rS extends iS {
                    constructor(e) {
                        super(e), (this._transition = 0);
                        const t = this._camera.position.clone(),
                            i = this._camera.lookat.clone().sub(t).normalize(),
                            n = Math.sqrt(i.x * i.x + i.y * i.y),
                            r = Math.atan2(i.z, n),
                            s = new rs();
                        if (r > -Math.PI / 45)
                            s.copy(t),
                                t.add(new rs(i.x, i.y, 0).multiplyScalar(-50)),
                                (t.z = 30);
                        else {
                            const e = t.clone(),
                                n = new rs(0, 0, 1),
                                r = new rs(0, 0, -2),
                                a = new rs().subVectors(r, e).dot(n) / i.dot(n),
                                o = 1e4,
                                c = e
                                    .clone()
                                    .add(
                                        i.clone().multiplyScalar(Math.min(o, a))
                                    );
                            s.copy(c);
                            const l = t.clone().sub(c).normalize();
                            t.copy(
                                c.add(
                                    l.multiplyScalar(Math.max(50, l.length()))
                                )
                            );
                        }
                        const a = this._camera.position.clone(),
                            o = a
                                .clone()
                                .add(i.clone().normalize().multiplyScalar(10)),
                            c = this._camera.up.clone(),
                            l = o.clone(),
                            h = l
                                .clone()
                                .add(i.clone().normalize().multiplyScalar(10)),
                            u = c.clone(),
                            d = t.clone(),
                            p = s.clone(),
                            g = new rs(0, 0, 1),
                            m = t
                                .clone()
                                .add(
                                    p
                                        .clone()
                                        .sub(d)
                                        .normalize()
                                        .multiplyScalar(-10)
                                ),
                            f = p.clone(),
                            _ = g.clone();
                        (this._curveE = new mu([l, a, d, m])),
                            (this._curveL = new mu([h, o, p, f])),
                            (this._curveU = new mu([u, c, g, _])),
                            (this._zoom0 = this._zoom),
                            (this._zoom1 = 0),
                            (this._camera.focal = 0.5 / Math.tan(Math.PI / 4));
                    }
                    get _isTransitioning() {
                        return this._transition < 1;
                    }
                    dolly(e) {
                        if (this._isTransitioning) return;
                        const t = this._camera,
                            i = t.position.clone().sub(t.lookat),
                            n = i.length() * Math.pow(2, -e),
                            r = Math.max(1, Math.min(n, 4e3));
                        i.normalize(),
                            i.multiplyScalar(r),
                            t.position.copy(t.lookat).add(i);
                    }
                    orbit(e) {
                        if (this._isTransitioning) return;
                        const t = this._camera,
                            i = new ns().setFromUnitVectors(
                                t.up,
                                new rs(0, 0, 1)
                            ),
                            n = i.clone().invert(),
                            r = t.position.clone().sub(t.lookat);
                        r.applyQuaternion(i);
                        const s = r.length();
                        let a = Math.atan2(r.y, r.x);
                        a += e.phi;
                        let o = Math.atan2(
                            Math.sqrt(r.x * r.x + r.y * r.y),
                            r.z
                        );
                        o += e.theta;
                        const c = Math.PI / 36;
                        (o = Math.max(c, Math.min(Math.PI / 2 - c, o))),
                            (r.x = Math.sin(o) * Math.cos(a)),
                            (r.y = Math.sin(o) * Math.sin(a)),
                            (r.z = Math.cos(o)),
                            r.applyQuaternion(n),
                            t.position.copy(t.lookat).add(r.multiplyScalar(s));
                    }
                    truck(e) {
                        if (this._isTransitioning) return;
                        const t = this._camera;
                        t.position.add(new rs().fromArray(e)),
                            t.lookat.add(new rs().fromArray(e));
                    }
                    update(e) {
                        if (!this._isTransitioning) return;
                        this._transition = Math.min(
                            this._transition + (2 * e) / 3,
                            1
                        );
                        const t = Hr.smootherstep(this._transition, 0, 1),
                            i = (t + 1) / 3,
                            n = this._curveE.getPoint(i),
                            r = this._curveL.getPoint(i),
                            s = this._curveU.getPoint(i);
                        this._camera.position.copy(n),
                            this._camera.lookat.copy(r),
                            this._camera.up.copy(s),
                            (this._zoom = Hr.lerp(this._zoom0, this._zoom1, t)),
                            (this._stateTransitionAlpha = t);
                    }
                    _getStateTransitionAlpha() {
                        return this._stateTransitionAlpha;
                    }
                }
                class sS {
                    constructor(e, t) {
                        (this._phi = e), (this._theta = t);
                    }
                    get phi() {
                        return this._phi;
                    }
                    set phi(e) {
                        this._phi = e;
                    }
                    get theta() {
                        return this._theta;
                    }
                    set theta(e) {
                        this._theta = e;
                    }
                    get isZero() {
                        return 0 === this._phi && 0 === this._theta;
                    }
                    copy(e) {
                        (this._phi = e.phi), (this._theta = e.theta);
                    }
                    lerp(e, t) {
                        (this._phi = (1 - t) * this._phi + t * e.phi),
                            (this._theta = (1 - t) * this._theta + t * e.theta);
                    }
                    multiply(e) {
                        (this._phi *= e), (this._theta *= e);
                    }
                    threshold(e) {
                        (this._phi = Math.abs(this._phi) > e ? this._phi : 0),
                            (this._theta =
                                Math.abs(this._theta) > e ? this._theta : 0);
                    }
                    lengthSquared() {
                        return (
                            this._phi * this._phi + this._theta * this._theta
                        );
                    }
                    reset() {
                        (this._phi = 0), (this._theta = 0);
                    }
                }
                class aS extends iS {
                    constructor(e) {
                        super(e),
                            (this._animationSpeed = 1 / 40),
                            (this._rotationDelta = new sS(0, 0)),
                            (this._requestedRotationDelta = null),
                            (this._basicRotation = [0, 0]),
                            (this._requestedBasicRotation = null),
                            (this._requestedBasicRotationUnbounded = null),
                            (this._rotationAcceleration = 0.86),
                            (this._rotationIncreaseAlpha = 0.97),
                            (this._rotationDecreaseAlpha = 0.9),
                            (this._rotationThreshold = 0.001),
                            (this._unboundedRotationAlpha = 0.8),
                            (this._desiredZoom = e.zoom),
                            (this._minZoom = 0),
                            (this._maxZoom = 3),
                            (this._lookatDepth = 10),
                            (this._desiredLookat = null),
                            (this._desiredCenter = null);
                    }
                    rotate(e) {
                        null != this._currentImage &&
                            ((0 === e.phi && 0 === e.theta) ||
                                ((this._desiredZoom = this._zoom),
                                (this._desiredLookat = null),
                                (this._requestedBasicRotation = null),
                                null != this._requestedRotationDelta
                                    ? ((this._requestedRotationDelta.phi =
                                          this._requestedRotationDelta.phi +
                                          e.phi),
                                      (this._requestedRotationDelta.theta =
                                          this._requestedRotationDelta.theta +
                                          e.theta))
                                    : (this._requestedRotationDelta = new sS(
                                          e.phi,
                                          e.theta
                                      ))));
                    }
                    rotateUnbounded(e) {
                        if (null == this._currentImage) return;
                        if (
                            ((this._requestedBasicRotation = null),
                            (this._requestedRotationDelta = null),
                            this._applyRotation(e, this._currentCamera),
                            this._applyRotation(e, this._previousCamera),
                            !this._desiredLookat)
                        )
                            return;
                        const t = new ns().setFromUnitVectors(
                                this._currentCamera.up,
                                new rs(0, 0, 1)
                            ),
                            i = t.clone().invert(),
                            n = new rs()
                                .copy(this._desiredLookat)
                                .sub(this._camera.position)
                                .applyQuaternion(t),
                            r = n.length();
                        let s = Math.atan2(n.y, n.x);
                        s += e.phi;
                        let a = Math.atan2(
                            Math.sqrt(n.x * n.x + n.y * n.y),
                            n.z
                        );
                        (a += e.theta),
                            (a = Math.max(0.1, Math.min(Math.PI - 0.1, a))),
                            (n.x = Math.sin(a) * Math.cos(s)),
                            (n.y = Math.sin(a) * Math.sin(s)),
                            (n.z = Math.cos(a)),
                            n.applyQuaternion(i),
                            this._desiredLookat
                                .copy(this._camera.position)
                                .add(n.multiplyScalar(r));
                    }
                    rotateWithoutInertia(e) {
                        if (null == this._currentImage) return;
                        (this._desiredZoom = this._zoom),
                            (this._desiredLookat = null),
                            (this._requestedBasicRotation = null),
                            (this._requestedRotationDelta = null);
                        const t = Math.PI / (10 * Math.pow(2, this._zoom)),
                            i = {
                                phi: this._spatial.clamp(e.phi, -t, t),
                                theta: this._spatial.clamp(e.theta, -t, t),
                            };
                        this._applyRotation(i, this._currentCamera),
                            this._applyRotation(i, this._previousCamera);
                    }
                    rotateBasic(e) {
                        if (null != this._currentImage)
                            if (
                                ((this._desiredZoom = this._zoom),
                                (this._desiredLookat = null),
                                (this._requestedRotationDelta = null),
                                null != this._requestedBasicRotation)
                            ) {
                                (this._requestedBasicRotation[0] += e[0]),
                                    (this._requestedBasicRotation[1] += e[1]);
                                let t = 0.05 / Math.pow(2, this._zoom);
                                (this._requestedBasicRotation[0] =
                                    this._spatial.clamp(
                                        this._requestedBasicRotation[0],
                                        -t,
                                        t
                                    )),
                                    (this._requestedBasicRotation[1] =
                                        this._spatial.clamp(
                                            this._requestedBasicRotation[1],
                                            -t,
                                            t
                                        ));
                            } else this._requestedBasicRotation = e.slice();
                    }
                    rotateBasicUnbounded(e) {
                        null != this._currentImage &&
                            (null != this._requestedBasicRotationUnbounded
                                ? ((this._requestedBasicRotationUnbounded[0] +=
                                      e[0]),
                                  (this._requestedBasicRotationUnbounded[1] +=
                                      e[1]))
                                : (this._requestedBasicRotationUnbounded =
                                      e.slice()));
                    }
                    rotateBasicWithoutInertia(e) {
                        if (null == this._currentImage) return;
                        (this._desiredZoom = this._zoom),
                            (this._desiredLookat = null),
                            (this._requestedRotationDelta = null),
                            (this._requestedBasicRotation = null);
                        const t = 0.05 / Math.pow(2, this._zoom),
                            i = e.slice();
                        (i[0] = this._spatial.clamp(i[0], -t, t)),
                            (i[1] = this._spatial.clamp(i[1], -t, t)),
                            this._applyRotationBasic(i);
                    }
                    rotateToBasic(e) {
                        if (null == this._currentImage) return;
                        (this._desiredZoom = this._zoom),
                            (this._desiredLookat = null),
                            (e[0] = this._spatial.clamp(e[0], 0, 1)),
                            (e[1] = this._spatial.clamp(e[1], 0, 1));
                        let t = this.currentTransform.unprojectBasic(
                            e,
                            this._lookatDepth
                        );
                        this._currentCamera.lookat.fromArray(t);
                    }
                    zoomIn(e, t) {
                        if (null == this._currentImage) return;
                        this._desiredZoom = Math.max(
                            this._minZoom,
                            Math.min(this._maxZoom, this._desiredZoom + e)
                        );
                        let i = this.currentTransform.projectBasic(
                                this._currentCamera.lookat.toArray()
                            ),
                            n = i[0],
                            r = i[1],
                            s = Math.pow(2, this._zoom),
                            a = Math.pow(2, this._desiredZoom),
                            o = t[0],
                            c = t[1];
                        jp(this.currentTransform.cameraType) &&
                            (o - n > 0.5
                                ? (o -= 1)
                                : n - o > 0.5 && (o = 1 + o));
                        let l = o - (s / a) * (o - n),
                            h = c - (s / a) * (c - r);
                        jp(this._currentImage.cameraType)
                            ? ((l = this._spatial.wrap(
                                  l + this._basicRotation[0],
                                  0,
                                  1
                              )),
                              (h = this._spatial.clamp(
                                  h + this._basicRotation[1],
                                  0.05,
                                  0.95
                              )))
                            : ((l = this._spatial.clamp(l, 0, 1)),
                              (h = this._spatial.clamp(h, 0, 1))),
                            (this._desiredLookat = new rs().fromArray(
                                this.currentTransform.unprojectBasic(
                                    [l, h],
                                    this._lookatDepth
                                )
                            ));
                    }
                    setCenter(e) {
                        (this._desiredLookat = null),
                            (this._requestedRotationDelta = null),
                            (this._requestedBasicRotation = null),
                            (this._desiredZoom = this._zoom);
                        let t = [
                            this._spatial.clamp(e[0], 0, 1),
                            this._spatial.clamp(e[1], 0, 1),
                        ];
                        if (null == this._currentImage)
                            return void (this._desiredCenter = t);
                        this._desiredCenter = null;
                        let i = new rs().fromArray(
                                this.currentTransform.unprojectBasic(
                                    t,
                                    this._lookatDepth
                                )
                            ),
                            n =
                                null != this.previousTransform
                                    ? this.previousTransform
                                    : this.currentTransform,
                            r = new rs().fromArray(
                                n.unprojectBasic(t, this._lookatDepth)
                            );
                        this._currentCamera.lookat.copy(i),
                            this._previousCamera.lookat.copy(r);
                    }
                    setZoom(e) {
                        (this._desiredLookat = null),
                            (this._requestedRotationDelta = null),
                            (this._requestedBasicRotation = null),
                            (this._zoom = this._spatial.clamp(
                                e,
                                this._minZoom,
                                this._maxZoom
                            )),
                            (this._desiredZoom = this._zoom);
                    }
                    _applyRotation(e, t) {
                        if (null == t) return;
                        let i = new ns().setFromUnitVectors(
                                t.up,
                                new rs(0, 0, 1)
                            ),
                            n = i.clone().invert(),
                            r = new rs();
                        r.copy(t.lookat).sub(t.position), r.applyQuaternion(i);
                        let s = r.length(),
                            a = Math.atan2(r.y, r.x);
                        a += e.phi;
                        let o = Math.atan2(
                            Math.sqrt(r.x * r.x + r.y * r.y),
                            r.z
                        );
                        (o += e.theta),
                            (o = Math.max(0.1, Math.min(Math.PI - 0.1, o))),
                            (r.x = Math.sin(o) * Math.cos(a)),
                            (r.y = Math.sin(o) * Math.sin(a)),
                            (r.z = Math.cos(o)),
                            r.applyQuaternion(n),
                            t.lookat.copy(t.position).add(r.multiplyScalar(s));
                    }
                    _applyRotationBasic(e) {
                        let t = this._currentImage,
                            i =
                                null != this._previousImage
                                    ? this.previousImage
                                    : this.currentImage,
                            n = this._currentCamera,
                            r = this._previousCamera,
                            s = this.currentTransform,
                            a =
                                null != this.previousTransform
                                    ? this.previousTransform
                                    : this.currentTransform,
                            o = s.projectBasic(n.lookat.toArray()),
                            c = a.projectBasic(r.lookat.toArray());
                        jp(t.cameraType)
                            ? ((o[0] = this._spatial.wrap(o[0] + e[0], 0, 1)),
                              (o[1] = this._spatial.clamp(
                                  o[1] + e[1],
                                  0.05,
                                  0.95
                              )))
                            : ((o[0] = this._spatial.clamp(o[0] + e[0], 0, 1)),
                              (o[1] = this._spatial.clamp(o[1] + e[1], 0, 1))),
                            jp(i.cameraType)
                                ? ((c[0] = this._spatial.wrap(
                                      c[0] + e[0],
                                      0,
                                      1
                                  )),
                                  (c[1] = this._spatial.clamp(
                                      c[1] + e[1],
                                      0.05,
                                      0.95
                                  )))
                                : ((c[0] = this._spatial.clamp(
                                      c[0] + e[0],
                                      0,
                                      1
                                  )),
                                  (c[1] = this._spatial.clamp(
                                      o[1] + e[1],
                                      0,
                                      1
                                  )));
                        let l = s.unprojectBasic(o, this._lookatDepth);
                        n.lookat.fromArray(l);
                        let h = a.unprojectBasic(c, this._lookatDepth);
                        r.lookat.fromArray(h);
                    }
                    _updateZoom(e) {
                        let t = this._desiredZoom - this._zoom,
                            i = t > 0 ? 1 : t < 0 ? -1 : 0;
                        0 !== t &&
                            (Math.abs(t) < 0.002
                                ? ((this._zoom = this._desiredZoom),
                                  null != this._desiredLookat &&
                                      (this._desiredLookat = null))
                                : (this._zoom +=
                                      i *
                                      Math.max(Math.abs(5 * e * t), 0.002)));
                    }
                    _updateLookat(e) {
                        if (null === this._desiredLookat) return;
                        let t = this._desiredLookat.distanceToSquared(
                            this._currentCamera.lookat
                        );
                        Math.abs(t) < 1e-6
                            ? (this._currentCamera.lookat.copy(
                                  this._desiredLookat
                              ),
                              (this._desiredLookat = null))
                            : this._currentCamera.lookat.lerp(
                                  this._desiredLookat,
                                  5 * e
                              );
                    }
                    _updateRotation() {
                        if (null != this._requestedRotationDelta) {
                            let e = this._rotationDelta.lengthSquared();
                            return (
                                this._requestedRotationDelta.lengthSquared() > e
                                    ? this._rotationDelta.lerp(
                                          this._requestedRotationDelta,
                                          this._rotationIncreaseAlpha
                                      )
                                    : this._rotationDelta.lerp(
                                          this._requestedRotationDelta,
                                          this._rotationDecreaseAlpha
                                      ),
                                void (this._requestedRotationDelta = null)
                            );
                        }
                        if (this._rotationDelta.isZero) return;
                        const e = jp(this.currentImage.cameraType)
                            ? 1
                            : this._alpha;
                        this._rotationDelta.multiply(
                            this._rotationAcceleration * e
                        ),
                            this._rotationDelta.threshold(
                                this._rotationThreshold
                            );
                    }
                    _updateRotationBasic() {
                        if (null != this._requestedBasicRotation) {
                            let e = this._basicRotation[0],
                                t = this._basicRotation[1],
                                i = this._requestedBasicRotation[0],
                                n = this._requestedBasicRotation[1];
                            return (
                                Math.abs(i) > Math.abs(e)
                                    ? (this._basicRotation[0] =
                                          (1 - this._rotationIncreaseAlpha) *
                                              e +
                                          this._rotationIncreaseAlpha * i)
                                    : (this._basicRotation[0] =
                                          (1 - this._rotationDecreaseAlpha) *
                                              e +
                                          this._rotationDecreaseAlpha * i),
                                Math.abs(n) > Math.abs(t)
                                    ? (this._basicRotation[1] =
                                          (1 - this._rotationIncreaseAlpha) *
                                              t +
                                          this._rotationIncreaseAlpha * n)
                                    : (this._basicRotation[1] =
                                          (1 - this._rotationDecreaseAlpha) *
                                              t +
                                          this._rotationDecreaseAlpha * n),
                                void (this._requestedBasicRotation = null)
                            );
                        }
                        if (null != this._requestedBasicRotationUnbounded) {
                            let e = this._requestedBasicRotationUnbounded[0],
                                t = this._requestedBasicRotationUnbounded[1];
                            if (
                                (Math.abs(e) > 0 &&
                                    (this._basicRotation[0] =
                                        (1 - this._unboundedRotationAlpha) *
                                            this._basicRotation[0] +
                                        this._unboundedRotationAlpha * e),
                                Math.abs(t) > 0 &&
                                    (this._basicRotation[1] =
                                        (1 - this._unboundedRotationAlpha) *
                                            this._basicRotation[1] +
                                        this._unboundedRotationAlpha * t),
                                null != this._desiredLookat)
                            ) {
                                let i = this.currentTransform.projectBasic(
                                    this._desiredLookat.toArray()
                                );
                                (i[0] += e),
                                    (i[1] += t),
                                    (this._desiredLookat = new rs().fromArray(
                                        this.currentTransform.unprojectBasic(
                                            i,
                                            this._lookatDepth
                                        )
                                    ));
                            }
                            this._requestedBasicRotationUnbounded = null;
                        }
                        (0 === this._basicRotation[0] &&
                            0 === this._basicRotation[1]) ||
                            ((this._basicRotation[0] =
                                this._rotationAcceleration *
                                this._basicRotation[0]),
                            (this._basicRotation[1] =
                                this._rotationAcceleration *
                                this._basicRotation[1]),
                            Math.abs(this._basicRotation[0]) <
                                this._rotationThreshold /
                                    Math.pow(2, this._zoom) &&
                                Math.abs(this._basicRotation[1]) <
                                    this._rotationThreshold /
                                        Math.pow(2, this._zoom) &&
                                (this._basicRotation = [0, 0]));
                    }
                    _clearRotation() {
                        jp(this._currentImage.cameraType) ||
                            (null != this._requestedRotationDelta &&
                                (this._requestedRotationDelta = null),
                            this._rotationDelta.isZero ||
                                this._rotationDelta.reset(),
                            null != this._requestedBasicRotation &&
                                (this._requestedBasicRotation = null),
                            (this._basicRotation[0] > 0 ||
                                this._basicRotation[1] > 0) &&
                                (this._basicRotation = [0, 0]));
                    }
                    _setDesiredCenter() {
                        if (null == this._desiredCenter) return;
                        let e = new rs()
                            .fromArray(
                                this.currentTransform.unprojectBasic(
                                    this._desiredCenter,
                                    this._lookatDepth
                                )
                            )
                            .sub(this._currentCamera.position);
                        this._currentCamera.lookat.copy(
                            this._currentCamera.position.clone().add(e)
                        ),
                            this._previousCamera.lookat.copy(
                                this._previousCamera.position.clone().add(e)
                            ),
                            (this._desiredCenter = null);
                    }
                    _setDesiredZoom() {
                        this._desiredZoom =
                            jp(this._currentImage.cameraType) ||
                            null == this._previousImage
                                ? this._zoom
                                : 0;
                    }
                }
                class oS extends aS {
                    constructor(e) {
                        super(e),
                            this._adjustCameras(),
                            (this._motionless = this._motionlessTransition());
                    }
                    prepend(e) {
                        super.prepend(e),
                            (this._motionless = this._motionlessTransition());
                    }
                    set(e) {
                        super.set(e),
                            (this._motionless = this._motionlessTransition());
                    }
                    move(e) {
                        this._alpha = Math.max(0, Math.min(1, this._alpha + e));
                    }
                    moveTo(e) {
                        this._alpha = Math.max(0, Math.min(1, e));
                    }
                    update(e) {
                        this._updateRotation(),
                            this._rotationDelta.isZero ||
                                (this._applyRotation(
                                    this._rotationDelta,
                                    this._previousCamera
                                ),
                                this._applyRotation(
                                    this._rotationDelta,
                                    this._currentCamera
                                )),
                            this._updateRotationBasic(),
                            (0 === this._basicRotation[0] &&
                                0 === this._basicRotation[1]) ||
                                this._applyRotationBasic(this._basicRotation);
                        let t = ((this._animationSpeed * e) / 0.1) * 6;
                        this._updateZoom(t),
                            this._updateLookat(t),
                            this._camera.lerpCameras(
                                this._previousCamera,
                                this._currentCamera,
                                this.alpha
                            );
                    }
                    _getAlpha() {
                        return this._motionless
                            ? Math.round(this._alpha)
                            : this._alpha;
                    }
                    _setCurrentCamera() {
                        super._setCurrentCamera(), this._adjustCameras();
                    }
                    _adjustCameras() {
                        if (null != this._previousImage) {
                            if (jp(this._currentImage.cameraType)) {
                                let e = this._camera.lookat
                                    .clone()
                                    .sub(this._camera.position);
                                this._currentCamera.lookat.copy(
                                    e.clone().add(this._currentCamera.position)
                                );
                            }
                            if (jp(this._previousImage.cameraType)) {
                                let e = this._currentCamera.lookat
                                    .clone()
                                    .sub(this._currentCamera.position);
                                this._previousCamera.lookat.copy(
                                    e.clone().add(this._previousCamera.position)
                                );
                            }
                        }
                    }
                }
                class cS extends aS {
                    constructor(e) {
                        super(e),
                            this._adjustCameras(),
                            (this._motionless = this._motionlessTransition()),
                            (this._baseAlpha = this._alpha),
                            (this._speedCoefficient = 1),
                            (this._smoothing = !1);
                    }
                    append(e) {
                        let t = 0 === this._trajectory.length;
                        t && this._resetTransition(),
                            super.append(e),
                            t &&
                                (this._setDesiredCenter(),
                                this._setDesiredZoom());
                    }
                    prepend(e) {
                        let t = 0 === this._trajectory.length;
                        t && this._resetTransition(),
                            super.prepend(e),
                            t &&
                                (this._setDesiredCenter(),
                                this._setDesiredZoom());
                    }
                    set(e) {
                        super.set(e),
                            (this._desiredLookat = null),
                            this._resetTransition(),
                            this._clearRotation(),
                            this._setDesiredCenter(),
                            this._setDesiredZoom(),
                            this._trajectory.length < 3 &&
                                (this._smoothing = !0);
                    }
                    setSpeed(e) {
                        this._speedCoefficient = this._spatial.clamp(e, 0, 10);
                    }
                    update(e) {
                        1 === this._alpha &&
                            this._currentIndex + this._alpha <
                                this._trajectory.length &&
                            ((this._currentIndex += 1),
                            (this._smoothing =
                                this._trajectory.length < 3 &&
                                this._currentIndex + 1 ===
                                    this._trajectory.length),
                            this._setCurrent(),
                            this._resetTransition(),
                            this._clearRotation(),
                            (this._desiredZoom = jp(
                                this._currentImage.cameraType
                            )
                                ? this._zoom
                                : 0),
                            (this._desiredLookat = null));
                        let t = ((this._animationSpeed * e) / 0.1) * 6;
                        (this._baseAlpha = Math.min(
                            1,
                            this._baseAlpha + this._speedCoefficient * t
                        )),
                            this._smoothing
                                ? (this._alpha = Hr.smootherstep(
                                      this._baseAlpha,
                                      0,
                                      1
                                  ))
                                : (this._alpha = this._baseAlpha),
                            this._updateRotation(),
                            this._rotationDelta.isZero ||
                                (this._applyRotation(
                                    this._rotationDelta,
                                    this._previousCamera
                                ),
                                this._applyRotation(
                                    this._rotationDelta,
                                    this._currentCamera
                                )),
                            this._updateRotationBasic(),
                            (0 === this._basicRotation[0] &&
                                0 === this._basicRotation[1]) ||
                                this._applyRotationBasic(this._basicRotation),
                            this._updateZoom(t),
                            this._updateLookat(t),
                            this._camera.lerpCameras(
                                this._previousCamera,
                                this._currentCamera,
                                this.alpha
                            );
                    }
                    _getAlpha() {
                        return this._motionless
                            ? Math.ceil(this._alpha)
                            : this._alpha;
                    }
                    _setCurrentCamera() {
                        super._setCurrentCamera(), this._adjustCameras();
                    }
                    _adjustCameras() {
                        if (null == this._previousImage) return;
                        let e = this._camera.lookat
                            .clone()
                            .sub(this._camera.position);
                        this._previousCamera.lookat.copy(
                            e.clone().add(this._previousCamera.position)
                        ),
                            jp(this._currentImage.cameraType) &&
                                this._currentCamera.lookat.copy(
                                    e.clone().add(this._currentCamera.position)
                                );
                    }
                    _resetTransition() {
                        (this._alpha = 0),
                            (this._baseAlpha = 0),
                            (this._motionless = this._motionlessTransition());
                    }
                }
                class lS extends iS {
                    constructor(e) {
                        super(e),
                            (this._zoom = 0),
                            this._adjustCameras(),
                            (this._motionless = this._motionlessTransition());
                    }
                    prepend(e) {
                        super.prepend(e),
                            (this._motionless = this._motionlessTransition());
                    }
                    set(e) {
                        super.set(e),
                            (this._motionless = this._motionlessTransition());
                    }
                    move(e) {
                        this._alpha = Math.max(0, Math.min(1, this._alpha + e));
                    }
                    moveTo(e) {
                        this._alpha = Math.max(0, Math.min(1, e));
                    }
                    update() {
                        this._camera.lerpCameras(
                            this._previousCamera,
                            this._currentCamera,
                            this.alpha
                        );
                    }
                    _getAlpha() {
                        return this._motionless
                            ? Math.round(this._alpha)
                            : this._alpha;
                    }
                    _setCurrentCamera() {
                        super._setCurrentCamera(), this._adjustCameras();
                    }
                    _adjustCameras() {
                        if (null != this._previousImage) {
                            if (jp(this._currentImage.cameraType)) {
                                let e = this._camera.lookat
                                    .clone()
                                    .sub(this._camera.position);
                                this._currentCamera.lookat.copy(
                                    e.clone().add(this._currentCamera.position)
                                );
                            }
                            if (jp(this._previousImage.cameraType)) {
                                let e = this._currentCamera.lookat
                                    .clone()
                                    .sub(this._currentCamera.position);
                                this._previousCamera.lookat.copy(
                                    e.clone().add(this._previousCamera.position)
                                );
                            }
                        }
                    }
                }
                class hS {
                    constructor() {
                        const e = j_[j_.Custom],
                            t = j_[j_.Earth],
                            i = j_[j_.Traversing],
                            n = j_[j_.Waiting],
                            r = j_[j_.WaitingInteractively];
                        this._creators = new Map();
                        const s = this._creators;
                        s.set(e, nS),
                            s.set(t, rS),
                            s.set(i, cS),
                            s.set(n, lS),
                            s.set(r, oS),
                            (this._transitions = new Map());
                        const a = this._transitions;
                        a.set(e, [t, i]),
                            a.set(t, [e, i]),
                            a.set(i, [e, t, n, r]),
                            a.set(n, [i, r]),
                            a.set(r, [i, n]);
                    }
                    getState(e) {
                        if (e instanceof nS) return j_.Custom;
                        if (e instanceof rS) return j_.Earth;
                        if (e instanceof cS) return j_.Traversing;
                        if (e instanceof lS) return j_.Waiting;
                        if (e instanceof oS) return j_.WaitingInteractively;
                        throw new Error("Invalid state instance");
                    }
                    generate(e, t) {
                        return new (this._creators.get(j_[e]))(t);
                    }
                    transition(e, t) {
                        if (!this.validate(e, t))
                            throw new Error("Invalid transition");
                        return this.generate(t, e);
                    }
                    validate(e, t) {
                        const i = j_[this.getState(e)],
                            n = j_[t],
                            r = this._transitions;
                        return r.has(i) && r.get(i).includes(n);
                    }
                }
                class uS {
                    constructor(e, t) {
                        (this._transitions = new hS()),
                            (this._state = this._transitions.generate(e, {
                                alpha: 1,
                                camera: new kT(),
                                currentIndex: -1,
                                reference: { alt: 0, lat: 0, lng: 0 },
                                trajectory: [],
                                transitionMode: null == t ? NT.Default : t,
                                zoom: 0,
                            }));
                    }
                    get state() {
                        return this._transitions.getState(this._state);
                    }
                    get reference() {
                        return this._state.reference;
                    }
                    get alpha() {
                        return this._state.alpha;
                    }
                    get stateTransitionAlpha() {
                        return this._state.stateTransitionAlpha;
                    }
                    get camera() {
                        return this._state.camera;
                    }
                    get zoom() {
                        return this._state.zoom;
                    }
                    get currentImage() {
                        return this._state.currentImage;
                    }
                    get previousImage() {
                        return this._state.previousImage;
                    }
                    get currentCamera() {
                        return this._state.currentCamera;
                    }
                    get currentTransform() {
                        return this._state.currentTransform;
                    }
                    get previousTransform() {
                        return this._state.previousTransform;
                    }
                    get trajectory() {
                        return this._state.trajectory;
                    }
                    get currentIndex() {
                        return this._state.currentIndex;
                    }
                    get lastImage() {
                        return this._state.trajectory[
                            this._state.trajectory.length - 1
                        ];
                    }
                    get imagesAhead() {
                        return (
                            this._state.trajectory.length -
                            1 -
                            this._state.currentIndex
                        );
                    }
                    get motionless() {
                        return this._state.motionless;
                    }
                    custom() {
                        this._transition(j_.Custom);
                    }
                    earth() {
                        this._transition(j_.Earth);
                    }
                    traverse() {
                        this._transition(j_.Traversing);
                    }
                    wait() {
                        this._transition(j_.Waiting);
                    }
                    waitInteractively() {
                        this._transition(j_.WaitingInteractively);
                    }
                    getCenter() {
                        return this._state.getCenter();
                    }
                    setCenter(e) {
                        this._state.setCenter(e);
                    }
                    setZoom(e) {
                        this._state.setZoom(e);
                    }
                    update(e) {
                        this._state.update(e);
                    }
                    append(e) {
                        this._state.append(e);
                    }
                    prepend(e) {
                        this._state.prepend(e);
                    }
                    remove(e) {
                        this._state.remove(e);
                    }
                    clear() {
                        this._state.clear();
                    }
                    clearPrior() {
                        this._state.clearPrior();
                    }
                    cut() {
                        this._state.cut();
                    }
                    set(e) {
                        this._state.set(e);
                    }
                    setViewMatrix(e) {
                        this._state.setViewMatrix(e);
                    }
                    rotate(e) {
                        this._state.rotate(e);
                    }
                    rotateUnbounded(e) {
                        this._state.rotateUnbounded(e);
                    }
                    rotateWithoutInertia(e) {
                        this._state.rotateWithoutInertia(e);
                    }
                    rotateBasic(e) {
                        this._state.rotateBasic(e);
                    }
                    rotateBasicUnbounded(e) {
                        this._state.rotateBasicUnbounded(e);
                    }
                    rotateBasicWithoutInertia(e) {
                        this._state.rotateBasicWithoutInertia(e);
                    }
                    rotateToBasic(e) {
                        this._state.rotateToBasic(e);
                    }
                    move(e) {
                        this._state.move(e);
                    }
                    moveTo(e) {
                        this._state.moveTo(e);
                    }
                    zoomIn(e, t) {
                        this._state.zoomIn(e, t);
                    }
                    setSpeed(e) {
                        this._state.setSpeed(e);
                    }
                    setTransitionMode(e) {
                        this._state.setTransitionMode(e);
                    }
                    dolly(e) {
                        this._state.dolly(e);
                    }
                    orbit(e) {
                        this._state.orbit(e);
                    }
                    truck(e) {
                        this._state.truck(e);
                    }
                    _transition(e) {
                        if (!this._transitions.validate(this._state, e)) {
                            const t = this._transitions.getState(this._state);
                            return void console.warn(
                                `Transition not valid (${j_[t]} - ${j_[e]})`
                            );
                        }
                        const t = this._transitions.transition(this._state, e);
                        this._state = t;
                    }
                }
                class dS {
                    constructor(e, t) {
                        (this._appendImage$ = new W()),
                            (this._clock = new Yd()),
                            (this._subscriptions = new s_());
                        const i = this._subscriptions;
                        (this._start$ = new W()),
                            (this._frame$ = new W()),
                            (this._contextOperation$ = new Z((e) => e)),
                            (this._context$ = this._contextOperation$.pipe(
                                At((e, t) => t(e), new uS(e, t)),
                                It(1),
                                V()
                            )),
                            (this._state$ = this._context$.pipe(
                                ke((e) => e.state),
                                ft(),
                                It(1),
                                V()
                            )),
                            (this._currentState$ = this._frame$.pipe(
                                $t(this._context$, (e, t) => [e, t]),
                                nt((e) => null != e[1].currentImage),
                                Ut((e) => {
                                    e[1].update(this._clock.getDelta());
                                }),
                                ke((e) => ({ fps: 60, id: e[0], state: e[1] })),
                                Et()
                            )),
                            (this._lastState$ = this._currentState$.pipe(
                                It(1),
                                V()
                            ));
                        let n = this._currentState$.pipe(
                                ft(void 0, (e) => e.state.currentImage.id),
                                It(1),
                                V()
                            ),
                            r = new W();
                        i.push(n.subscribe(r)),
                            (this._currentId$ = new Z(null)),
                            i.push(
                                r
                                    .pipe(ke((e) => e.state.currentImage.id))
                                    .subscribe(this._currentId$)
                            ),
                            (this._currentImage$ = r.pipe(
                                ke((e) => e.state.currentImage),
                                It(1),
                                V()
                            )),
                            (this._currentCamera$ = r.pipe(
                                ke((e) => e.state.currentCamera),
                                It(1),
                                V()
                            )),
                            (this._currentTransform$ = r.pipe(
                                ke((e) => e.state.currentTransform),
                                It(1),
                                V()
                            )),
                            (this._reference$ = r.pipe(
                                ke((e) => e.state.reference),
                                ft(
                                    (e, t) =>
                                        e.lat === t.lat && e.lng === t.lng,
                                    (e) => ({ lat: e.lat, lng: e.lng })
                                ),
                                It(1),
                                V()
                            )),
                            (this._currentImageExternal$ = n.pipe(
                                ke((e) => e.state.currentImage),
                                It(1),
                                V()
                            )),
                            i.push(
                                this._appendImage$
                                    .pipe(ke((e) => (t) => (t.append([e]), t)))
                                    .subscribe(this._contextOperation$)
                            ),
                            (this._inMotionOperation$ = new W()),
                            i.push(
                                n
                                    .pipe(ke(() => !0))
                                    .subscribe(this._inMotionOperation$)
                            ),
                            i.push(
                                this._inMotionOperation$
                                    .pipe(
                                        ft(),
                                        nt((e) => e),
                                        kt(() =>
                                            this._currentState$.pipe(
                                                nt(
                                                    (e) =>
                                                        0 ===
                                                        e.state.imagesAhead
                                                ),
                                                ke((e) => [
                                                    e.state.camera.clone(),
                                                    e.state.zoom,
                                                ]),
                                                Nt(),
                                                ke((e) => {
                                                    let t = e[0][0],
                                                        i = e[1][0],
                                                        n = e[0][1],
                                                        r = e[1][1];
                                                    return (
                                                        t.diff(i) > 1e-5 ||
                                                        Math.abs(n - r) > 1e-5
                                                    );
                                                }),
                                                bt((e) => !e)
                                            )
                                        )
                                    )
                                    .subscribe(this._inMotionOperation$)
                            ),
                            (this._inMotion$ = this._inMotionOperation$.pipe(
                                ft(),
                                It(1),
                                V()
                            )),
                            (this._inTranslationOperation$ = new W()),
                            i.push(
                                n
                                    .pipe(ke(() => !0))
                                    .subscribe(this._inTranslationOperation$)
                            ),
                            i.push(
                                this._inTranslationOperation$
                                    .pipe(
                                        ft(),
                                        nt((e) => e),
                                        kt(() =>
                                            this._currentState$.pipe(
                                                nt(
                                                    (e) =>
                                                        0 ===
                                                        e.state.imagesAhead
                                                ),
                                                ke((e) =>
                                                    e.state.camera.position.clone()
                                                ),
                                                Nt(),
                                                ke(
                                                    (e) =>
                                                        0 !==
                                                        e[0].distanceToSquared(
                                                            e[1]
                                                        )
                                                ),
                                                bt((e) => !e)
                                            )
                                        )
                                    )
                                    .subscribe(this._inTranslationOperation$)
                            ),
                            (this._inTranslation$ =
                                this._inTranslationOperation$.pipe(
                                    ft(),
                                    It(1),
                                    V()
                                )),
                            i.push(this._state$.subscribe(() => {})),
                            i.push(this._currentImage$.subscribe(() => {})),
                            i.push(this._currentCamera$.subscribe(() => {})),
                            i.push(this._currentTransform$.subscribe(() => {})),
                            i.push(this._reference$.subscribe(() => {})),
                            i.push(
                                this._currentImageExternal$.subscribe(() => {})
                            ),
                            i.push(this._lastState$.subscribe(() => {})),
                            i.push(this._inMotion$.subscribe(() => {})),
                            i.push(this._inTranslation$.subscribe(() => {})),
                            (this._frameId = null),
                            (this._frameGenerator = new tS(window));
                    }
                    get currentState$() {
                        return this._currentState$;
                    }
                    get currentImage$() {
                        return this._currentImage$;
                    }
                    get currentId$() {
                        return this._currentId$;
                    }
                    get currentImageExternal$() {
                        return this._currentImageExternal$;
                    }
                    get currentCamera$() {
                        return this._currentCamera$;
                    }
                    get currentTransform$() {
                        return this._currentTransform$;
                    }
                    get state$() {
                        return this._state$;
                    }
                    get reference$() {
                        return this._reference$;
                    }
                    get inMotion$() {
                        return this._inMotion$;
                    }
                    get inTranslation$() {
                        return this._inTranslation$;
                    }
                    get appendImage$() {
                        return this._appendImage$;
                    }
                    dispose() {
                        this.stop(), this._subscriptions.unsubscribe();
                    }
                    custom() {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((e) => {
                                e.custom();
                            });
                    }
                    earth() {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((e) => {
                                e.earth();
                            });
                    }
                    traverse() {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((e) => {
                                e.traverse();
                            });
                    }
                    wait() {
                        this._invokeContextOperation((e) => {
                            e.wait();
                        });
                    }
                    waitInteractively() {
                        this._invokeContextOperation((e) => {
                            e.waitInteractively();
                        });
                    }
                    appendImagess(e) {
                        this._invokeContextOperation((t) => {
                            t.append(e);
                        });
                    }
                    prependImages(e) {
                        this._invokeContextOperation((t) => {
                            t.prepend(e);
                        });
                    }
                    removeImages(e) {
                        this._invokeContextOperation((t) => {
                            t.remove(e);
                        });
                    }
                    clearImages() {
                        this._invokeContextOperation((e) => {
                            e.clear();
                        });
                    }
                    clearPriorImages() {
                        this._invokeContextOperation((e) => {
                            e.clearPrior();
                        });
                    }
                    cutImages() {
                        this._invokeContextOperation((e) => {
                            e.cut();
                        });
                    }
                    setImages(e) {
                        this._invokeContextOperation((t) => {
                            t.set(e);
                        });
                    }
                    setViewMatrix(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.setViewMatrix(e);
                            });
                    }
                    rotate(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.rotate(e);
                            });
                    }
                    rotateUnbounded(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.rotateUnbounded(e);
                            });
                    }
                    rotateWithoutInertia(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.rotateWithoutInertia(e);
                            });
                    }
                    rotateBasic(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.rotateBasic(e);
                            });
                    }
                    rotateBasicUnbounded(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.rotateBasicUnbounded(e);
                            });
                    }
                    rotateBasicWithoutInertia(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.rotateBasicWithoutInertia(e);
                            });
                    }
                    rotateToBasic(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.rotateToBasic(e);
                            });
                    }
                    move(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.move(e);
                            });
                    }
                    moveTo(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.moveTo(e);
                            });
                    }
                    dolly(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.dolly(e);
                            });
                    }
                    orbit(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.orbit(e);
                            });
                    }
                    truck(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.truck(e);
                            });
                    }
                    zoomIn(e, t) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((i) => {
                                i.zoomIn(e, t);
                            });
                    }
                    getCenter() {
                        return this._lastState$.pipe(
                            bt(),
                            ke((e) => e.state.getCenter())
                        );
                    }
                    getZoom() {
                        return this._lastState$.pipe(
                            bt(),
                            ke((e) => e.state.zoom)
                        );
                    }
                    setCenter(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.setCenter(e);
                            });
                    }
                    setSpeed(e) {
                        this._invokeContextOperation((t) => {
                            t.setSpeed(e);
                        });
                    }
                    setTransitionMode(e) {
                        this._invokeContextOperation((t) => {
                            t.setTransitionMode(e);
                        });
                    }
                    setZoom(e) {
                        this._inMotionOperation$.next(!0),
                            this._invokeContextOperation((t) => {
                                t.setZoom(e);
                            });
                    }
                    start() {
                        this._clock.start(),
                            null == this._frameId &&
                                (this._start$.next(null),
                                (this._frameId =
                                    this._frameGenerator.requestAnimationFrame(
                                        this._frame.bind(this)
                                    )),
                                this._frame$.next(this._frameId));
                    }
                    stop() {
                        this._clock.stop(),
                            null != this._frameId &&
                                (this._frameGenerator.cancelAnimationFrame(
                                    this._frameId
                                ),
                                (this._frameId = null));
                    }
                    _invokeContextOperation(e) {
                        this._contextOperation$.next((t) => (e(t), t));
                    }
                    _frame() {
                        (this._frameId =
                            this._frameGenerator.requestAnimationFrame(
                                this._frame.bind(this)
                            )),
                            this._frame$.next(this._frameId);
                    }
                }
                function pS(e) {
                    switch (e) {
                        case wT.Custom:
                            return j_.Custom;
                        case wT.Earth:
                            return j_.Earth;
                        case wT.Street:
                            return j_.Traversing;
                        default:
                            return null;
                    }
                }
                class gS {
                    constructor(e, t, i, n, r, s, a, o) {
                        var c;
                        t
                            ? (this._api = t)
                            : e.dataProvider
                            ? (this._api = new KT(e.dataProvider))
                            : (this._api = new KT(
                                  new LT({ accessToken: e.accessToken })
                              )),
                            (this._graphService =
                                null != i ? i : new eS(new $p(this.api))),
                            (this._loadingName = "navigator"),
                            (this._loadingService = null != n ? n : new ZT());
                        const l =
                            null !== (c = e.cameraControls) && void 0 !== c
                                ? c
                                : wT.Street;
                        (this._stateService =
                            null != r ? r : new dS(pS(l), e.transitionMode)),
                            (this._cacheService =
                                null != s
                                    ? s
                                    : new QT(
                                          this._graphService,
                                          this._stateService,
                                          this._api
                                      )),
                            (this._playService =
                                null != a
                                    ? a
                                    : new vM(
                                          this._graphService,
                                          this._stateService
                                      )),
                            (this._panService =
                                null != o
                                    ? o
                                    : new JT(
                                          this._graphService,
                                          this._stateService,
                                          e.combinedPanning
                                      )),
                            (this._idRequested$ = new Z(null)),
                            (this._movedToId$ = new Z(null)),
                            (this._request$ = null),
                            (this._requestSubscription = null),
                            (this._imageRequestSubscription = null);
                    }
                    get api() {
                        return this._api;
                    }
                    get cacheService() {
                        return this._cacheService;
                    }
                    get graphService() {
                        return this._graphService;
                    }
                    get loadingService() {
                        return this._loadingService;
                    }
                    get movedToId$() {
                        return this._movedToId$;
                    }
                    get panService() {
                        return this._panService;
                    }
                    get playService() {
                        return this._playService;
                    }
                    get stateService() {
                        return this._stateService;
                    }
                    dispose() {
                        this._abortRequest("viewer removed"),
                            this._cacheService.stop(),
                            this._graphService.dispose(),
                            this._panService.dispose(),
                            this._playService.dispose(),
                            this._stateService.dispose();
                    }
                    moveTo$(e) {
                        this._abortRequest(`to id ${e}`),
                            this._loadingService.startLoading(
                                this._loadingName
                            );
                        const t = this._moveTo$(e);
                        return this._makeRequest$(t);
                    }
                    moveDir$(e) {
                        this._abortRequest(`in dir ${Dp[e]}`),
                            this._loadingService.startLoading(
                                this._loadingName
                            );
                        const t = this.stateService.currentImage$.pipe(
                            bt(),
                            Ye((t) =>
                                ([Dp.Next, Dp.Prev].indexOf(e) > -1
                                    ? t.sequenceEdges$
                                    : t.spatialEdges$
                                ).pipe(
                                    bt(),
                                    ke((t) => {
                                        for (let i of t.edges)
                                            if (i.data.direction === e)
                                                return i.target;
                                        return null;
                                    })
                                )
                            ),
                            Ye((t) =>
                                null == t
                                    ? (this._loadingService.stopLoading(
                                          this._loadingName
                                      ),
                                      Ae(
                                          new Error(
                                              `Direction (${e}) does not exist for current image.`
                                          )
                                      ))
                                    : this._moveTo$(t)
                            )
                        );
                        return this._makeRequest$(t);
                    }
                    setFilter$(e) {
                        return (
                            this._stateService.clearImages(),
                            this._movedToId$.pipe(
                                bt(),
                                Ye((t) =>
                                    null != t
                                        ? this._trajectoryIds$().pipe(
                                              Ye((t) =>
                                                  this._graphService
                                                      .setFilter$(e)
                                                      .pipe(
                                                          Ye(() =>
                                                              this._cacheIds$(t)
                                                          )
                                                      )
                                              ),
                                              Tt()
                                          )
                                        : this._idRequested$.pipe(
                                              bt(),
                                              Ye((t) =>
                                                  null != t
                                                      ? this._graphService
                                                            .setFilter$(e)
                                                            .pipe(
                                                                Ye(() =>
                                                                    this._graphService.cacheImage$(
                                                                        t
                                                                    )
                                                                )
                                                            )
                                                      : this._graphService
                                                            .setFilter$(e)
                                                            .pipe(ke(() => {}))
                                              )
                                          )
                                ),
                                ke(() => {})
                            )
                        );
                    }
                    setAccessToken$(e) {
                        return (
                            this._abortRequest("to set user token"),
                            this._stateService.clearImages(),
                            this._movedToId$.pipe(
                                bt(),
                                Ut(() => {
                                    this._api.setAccessToken(e);
                                }),
                                Ye((e) =>
                                    null == e
                                        ? this._graphService.reset$([])
                                        : this._trajectoryIds$().pipe(
                                              Ye((e) =>
                                                  this._graphService
                                                      .reset$(e)
                                                      .pipe(
                                                          Ye(() =>
                                                              this._cacheIds$(e)
                                                          )
                                                      )
                                              ),
                                              Tt(),
                                              ke(() => {})
                                          )
                                )
                            )
                        );
                    }
                    _cacheIds$(e) {
                        return ye(
                            e.map((e) => this._graphService.cacheImage$(e))
                        ).pipe(qe());
                    }
                    _abortRequest(e) {
                        null != this._requestSubscription &&
                            (this._requestSubscription.unsubscribe(),
                            (this._requestSubscription = null)),
                            null != this._imageRequestSubscription &&
                                (this._imageRequestSubscription.unsubscribe(),
                                (this._imageRequestSubscription = null)),
                            null != this._request$ &&
                                (this._request$.isStopped ||
                                    this._request$.hasError ||
                                    this._request$.error(
                                        new d_(
                                            `Request aborted by a subsequent request ${e}.`
                                        )
                                    ),
                                (this._request$ = null));
                    }
                    _makeRequest$(e) {
                        const t = new J(1);
                        return (
                            (this._requestSubscription = t.subscribe(
                                void 0,
                                () => {}
                            )),
                            (this._request$ = t),
                            (this._imageRequestSubscription = e.subscribe(
                                (e) => {
                                    (this._request$ = null),
                                        t.next(e),
                                        t.complete();
                                },
                                (e) => {
                                    (this._request$ = null), t.error(e);
                                }
                            )),
                            t
                        );
                    }
                    _moveTo$(e) {
                        return (
                            this._idRequested$.next(e),
                            this._graphService.cacheImage$(e).pipe(
                                Ut((e) => {
                                    this._stateService.setImages([e]),
                                        this._movedToId$.next(e.id);
                                }),
                                xt(() => {
                                    this._loadingService.stopLoading(
                                        this._loadingName
                                    );
                                })
                            )
                        );
                    }
                    _trajectoryIds$() {
                        return this._stateService.currentState$.pipe(
                            bt(),
                            ke((e) => e.state.trajectory.map((e) => e.id))
                        );
                    }
                }
                class mS {
                    constructor(e, t) {
                        (this._spatial = null != t ? t : new Lp()),
                            (this._viewportCoords = null != e ? e : new l_());
                    }
                    basicToCanvas(e, t, i, n) {
                        return this._viewportCoords.basicToCanvasSafe(
                            e[0],
                            e[1],
                            t,
                            n,
                            i.perspective
                        );
                    }
                    canvasToBasic(e, t, i, n) {
                        let r = this._viewportCoords.canvasToBasic(
                            e[0],
                            e[1],
                            t,
                            n,
                            i.perspective
                        );
                        return (
                            (r[0] < 0 || r[0] > 1 || r[1] < 0 || r[1] > 1) &&
                                (r = null),
                            r
                        );
                    }
                    eventToUnprojection(e, t, i, n, r) {
                        const s = this._viewportCoords.canvasPosition(e, t);
                        return this.canvasToUnprojection(s, t, i, n, r);
                    }
                    canvasToUnprojection(e, t, i, n, r) {
                        const s = e[0],
                            a = e[1],
                            [o, c] = this._viewportCoords.canvasToViewport(
                                s,
                                a,
                                t
                            ),
                            l = new rs(o, c, 1).unproject(i.perspective);
                        let h = r.projectBasic(l.toArray());
                        (h[0] < 0 || h[0] > 1 || h[1] < 0 || h[1] > 1) &&
                            (h = null);
                        const u = l.clone().sub(i.camera.position).normalize(),
                            d = -2 / u.z;
                        let p = null;
                        if (d > 0 && d < 100 && h) {
                            const e = u
                                    .clone()
                                    .multiplyScalar(d)
                                    .add(i.camera.position),
                                [t, r] = yp(e.x, e.y, e.z, n.lng, n.lat, n.alt);
                            p = { lat: r, lng: t };
                        }
                        return { basicPoint: h, lngLat: p, pixelPoint: [s, a] };
                    }
                    cameraToLngLat(e, t) {
                        const i = e.camera.position,
                            [n, r] = yp(i.x, i.y, i.z, t.lng, t.lat, t.alt);
                        return { lat: r, lng: n };
                    }
                    lngLatToCanvas(e, t, i, n) {
                        const r = vp(e.lng, e.lat, 0, n.lng, n.lat, n.alt);
                        return this._viewportCoords.projectToCanvasSafe(
                            r,
                            t,
                            i.perspective
                        );
                    }
                    distanceBetweenLngLats(e, t) {
                        return this._spatial.distanceFromLngLat(
                            e.lng,
                            e.lat,
                            t.lng,
                            t.lat
                        );
                    }
                }
                class fS {
                    constructor(e, t, i) {
                        (this._subscriptions = new s_()),
                            (this._emitSubscriptions = new s_()),
                            (this._container = i),
                            (this._viewer = e),
                            (this._navigator = t),
                            (this._projection = new mS()),
                            (this._started = !1),
                            (this._navigable$ = new W());
                        const n = this._subscriptions;
                        n.push(
                            this._navigable$.subscribe((e) => {
                                const t = "navigable",
                                    i = {
                                        navigable: e,
                                        target: this._viewer,
                                        type: t,
                                    };
                                this._viewer.fire(t, i);
                            })
                        ),
                            n.push(
                                this._navigator.loadingService.loading$.subscribe(
                                    (e) => {
                                        const t = "dataloading",
                                            i = {
                                                loading: e,
                                                target: this._viewer,
                                                type: t,
                                            };
                                        this._viewer.fire(t, i);
                                    }
                                )
                            ),
                            n.push(
                                this._container.glRenderer.opaqueRender$
                                    .pipe(bt())
                                    .subscribe(() => {
                                        const e = "load",
                                            t = {
                                                target: this._viewer,
                                                type: e,
                                            };
                                        this._viewer.fire(e, t);
                                    })
                            );
                    }
                    get started() {
                        return this._started;
                    }
                    get navigable$() {
                        return this._navigable$;
                    }
                    get projection() {
                        return this._projection;
                    }
                    dispose() {
                        this.stopEmit(), this._subscriptions.unsubscribe();
                    }
                    project$(e) {
                        return He(
                            this._container.renderService.renderCamera$,
                            this._navigator.stateService.currentImage$,
                            this._navigator.stateService.reference$
                        ).pipe(
                            bt(),
                            ke(([t, i, n]) => {
                                if (
                                    this._projection.distanceBetweenLngLats(
                                        e,
                                        i.lngLat
                                    ) > 1e3
                                )
                                    return null;
                                const r = this._projection.lngLatToCanvas(
                                    e,
                                    this._container.container,
                                    t,
                                    n
                                );
                                return r
                                    ? [Math.round(r[0]), Math.round(r[1])]
                                    : null;
                            })
                        );
                    }
                    projectBasic$(e) {
                        return He(
                            this._container.renderService.renderCamera$,
                            this._navigator.stateService.currentTransform$
                        ).pipe(
                            bt(),
                            ke(([t, i]) => {
                                const n = this._projection.basicToCanvas(
                                    e,
                                    this._container.container,
                                    t,
                                    i
                                );
                                return n
                                    ? [Math.round(n[0]), Math.round(n[1])]
                                    : null;
                            })
                        );
                    }
                    startEmit() {
                        if (this._started) return;
                        this._started = !0;
                        const e = this._emitSubscriptions;
                        e.push(
                            this._navigator.stateService.currentImageExternal$.subscribe(
                                (e) => {
                                    const t = "image",
                                        i = {
                                            image: e,
                                            target: this._viewer,
                                            type: t,
                                        };
                                    this._viewer.fire(t, i);
                                }
                            )
                        ),
                            e.push(
                                this._navigator.stateService.currentImageExternal$
                                    .pipe(kt((e) => e.sequenceEdges$))
                                    .subscribe((e) => {
                                        const t = "sequenceedges",
                                            i = {
                                                status: e,
                                                target: this._viewer,
                                                type: t,
                                            };
                                        this._viewer.fire(t, i);
                                    })
                            ),
                            e.push(
                                this._navigator.stateService.currentImageExternal$
                                    .pipe(kt((e) => e.spatialEdges$))
                                    .subscribe((e) => {
                                        const t = "spatialedges",
                                            i = {
                                                status: e,
                                                target: this._viewer,
                                                type: t,
                                            };
                                        this._viewer.fire(t, i);
                                    })
                            ),
                            e.push(
                                this._navigator.stateService.reference$.subscribe(
                                    (e) => {
                                        const t = "reference",
                                            i = {
                                                reference: e,
                                                target: this._viewer,
                                                type: t,
                                            };
                                        this._viewer.fire(t, i);
                                    }
                                )
                            ),
                            e.push(
                                He(
                                    this._navigator.stateService.inMotion$,
                                    this._container.mouseService.active$,
                                    this._container.touchService.active$
                                )
                                    .pipe(
                                        ke((e) => e[0] || e[1] || e[2]),
                                        ft()
                                    )
                                    .subscribe((e) => {
                                        const t = e ? "movestart" : "moveend",
                                            i = {
                                                target: this._viewer,
                                                type: t,
                                            };
                                        this._viewer.fire(t, i);
                                    })
                            ),
                            e.push(
                                this._container.renderService.bearing$
                                    .pipe(
                                        st(100),
                                        ft((e, t) => Math.abs(t - e) < 1)
                                    )
                                    .subscribe((e) => {
                                        const t = "bearing",
                                            i = {
                                                bearing: e,
                                                target: this._viewer,
                                                type: t,
                                            };
                                        this._viewer.fire(t, i);
                                    })
                            );
                        const t = this._container.mouseService.active$.pipe(
                            kt((e) =>
                                e
                                    ? oe()
                                    : this._container.mouseService.mouseMove$
                            )
                        );
                        e.push(
                            tt(
                                this._mapMouseEvent$(
                                    "click",
                                    this._container.mouseService.staticClick$
                                ),
                                this._mapMouseEvent$(
                                    "contextmenu",
                                    this._container.mouseService.contextMenu$
                                ),
                                this._mapMouseEvent$(
                                    "dblclick",
                                    this._container.mouseService.dblClick$
                                ),
                                this._mapMouseEvent$(
                                    "mousedown",
                                    this._container.mouseService.mouseDown$
                                ),
                                this._mapMouseEvent$("mousemove", t),
                                this._mapMouseEvent$(
                                    "mouseout",
                                    this._container.mouseService.mouseOut$
                                ),
                                this._mapMouseEvent$(
                                    "mouseover",
                                    this._container.mouseService.mouseOver$
                                ),
                                this._mapMouseEvent$(
                                    "mouseup",
                                    this._container.mouseService.mouseUp$
                                )
                            )
                                .pipe(
                                    $t(
                                        this._container.renderService
                                            .renderCamera$,
                                        this._navigator.stateService.reference$,
                                        this._navigator.stateService
                                            .currentTransform$,
                                        this._navigator.stateService.state$
                                    ),
                                    ke(([[e, t], i, n, r, s]) => {
                                        const a =
                                            this._projection.eventToUnprojection(
                                                t,
                                                this._container.container,
                                                i,
                                                n,
                                                r
                                            );
                                        return {
                                            basicPoint:
                                                s === j_.Traversing
                                                    ? a.basicPoint
                                                    : null,
                                            lngLat: a.lngLat,
                                            originalEvent: t,
                                            pixelPoint: a.pixelPoint,
                                            target: this._viewer,
                                            type: e,
                                        };
                                    })
                                )
                                .subscribe((e) => {
                                    this._viewer.fire(e.type, e);
                                })
                        ),
                            e.push(
                                this._container.renderService.renderCamera$
                                    .pipe(
                                        ft(
                                            ([e, t], [i, n]) =>
                                                this._closeTo(e, i, 0.01) &&
                                                this._closeTo(t, n, 0.01),
                                            (e) => e.camera.position.toArray()
                                        )
                                    )
                                    .subscribe(() => {
                                        const e = "position",
                                            t = {
                                                target: this._viewer,
                                                type: e,
                                            };
                                        this._viewer.fire(e, t);
                                    })
                            ),
                            e.push(
                                this._container.renderService.renderCamera$
                                    .pipe(
                                        ft(
                                            ([e, t], [i, n]) =>
                                                this._closeTo(e, i, 0.001) &&
                                                this._closeTo(t, n, 0.001),
                                            (e) => [
                                                e.rotation.phi,
                                                e.rotation.theta,
                                            ]
                                        )
                                    )
                                    .subscribe(() => {
                                        const e = {
                                            target: this._viewer,
                                            type: "pov",
                                        };
                                        this._viewer.fire("pov", e);
                                    })
                            ),
                            e.push(
                                this._container.renderService.renderCamera$
                                    .pipe(
                                        ft(
                                            (e, t) => this._closeTo(e, t, 0.01),
                                            (e) => e.perspective.fov
                                        )
                                    )
                                    .subscribe(() => {
                                        const e = {
                                            target: this._viewer,
                                            type: "fov",
                                        };
                                        this._viewer.fire("fov", e);
                                    })
                            );
                    }
                    stopEmit() {
                        this.started &&
                            (this._emitSubscriptions.unsubscribe(),
                            (this._started = !1));
                    }
                    unproject$(e) {
                        return He(
                            this._container.renderService.renderCamera$,
                            this._navigator.stateService.reference$,
                            this._navigator.stateService.currentTransform$
                        ).pipe(
                            bt(),
                            ke(
                                ([t, i, n]) =>
                                    this._projection.canvasToUnprojection(
                                        e,
                                        this._container.container,
                                        t,
                                        i,
                                        n
                                    ).lngLat
                            )
                        );
                    }
                    unprojectBasic$(e) {
                        return He(
                            this._container.renderService.renderCamera$,
                            this._navigator.stateService.currentTransform$
                        ).pipe(
                            bt(),
                            ke(([t, i]) =>
                                this._projection.canvasToBasic(
                                    e,
                                    this._container.container,
                                    t,
                                    i
                                )
                            )
                        );
                    }
                    _closeTo(e, t, i) {
                        return Math.abs(e - t) <= i;
                    }
                    _mapMouseEvent$(e, t) {
                        return t.pipe(ke((t) => [e, t]));
                    }
                }
                class _S {
                    constructor(e, t) {
                        (this._container = e),
                            (this._navigator = t),
                            (this._renderers = {});
                    }
                    add(e, t) {
                        const i = new s_();
                        (this._renderers[e.id] = { subs: i, renderer: e }),
                            i.push(
                                He([
                                    this._container.glRenderer.webGLRenderer$,
                                    this._navigator.stateService.reference$,
                                ])
                                    .pipe(mt(1))
                                    .subscribe(([i, n]) => {
                                        e.onAdd(t, n, i.getContext());
                                    })
                            ),
                            i.push(
                                this._container.glRenderer.opaqueRender$
                                    .pipe(
                                        $t(
                                            this._container.renderService
                                                .renderCamera$,
                                            this._container.glRenderer
                                                .webGLRenderer$
                                        )
                                    )
                                    .subscribe(([, t, i]) => {
                                        const n = i.getContext(),
                                            r =
                                                t.perspective
                                                    .matrixWorldInverse,
                                            s = t.perspective.projectionMatrix;
                                        e.render(n, r.toArray(), s.toArray());
                                    })
                            ),
                            i.push(
                                this._navigator.stateService.reference$
                                    .pipe(zt(1))
                                    .subscribe((i) => {
                                        e.onReference(t, i);
                                    })
                            );
                    }
                    dispose(e) {
                        for (const t of Object.keys(this._renderers))
                            this.remove(t, e);
                    }
                    has(e) {
                        return e in this._renderers;
                    }
                    remove(e, t) {
                        this._renderers[e].subs.unsubscribe();
                        const i = this._renderers[e].renderer;
                        delete this._renderers[e],
                            this._container.glRenderer.webGLRenderer$.subscribe(
                                (e) => {
                                    i.onRemove(t, e.getContext());
                                }
                            );
                    }
                }
                class MS {
                    constructor(e, t) {
                        (this._container = e),
                            (this._navigator = t),
                            (this._controls = null),
                            (this._subscriptions = new s_());
                    }
                    attach(e, t) {
                        if (this._controls)
                            throw new Ap(
                                "Custom camera controls already attached"
                            );
                        this._controls = e;
                        const i = new W(),
                            n = i.pipe(
                                kt(() => this._navigator.stateService.state$),
                                ke((e) => e === j_.Custom),
                                ft()
                            ),
                            r = this._subscriptions;
                        r.push(
                            n
                                .pipe(
                                    Ot(!1),
                                    Nt(),
                                    $t(
                                        this._navigator.stateService.reference$,
                                        this._container.renderService
                                            .renderCamera$
                                    )
                                )
                                .subscribe(([[i, n], r, s]) => {
                                    n
                                        ? e.onActivate(
                                              t,
                                              s.perspective.matrixWorldInverse.toArray(),
                                              s.perspective.projectionMatrix.toArray(),
                                              r
                                          )
                                        : i && e.onDeactivate(t);
                                })
                        ),
                            r.push(
                                n
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? this._navigator.stateService.currentState$.pipe(
                                                      zt(1)
                                                  )
                                                : oe()
                                        )
                                    )
                                    .subscribe((i) => {
                                        e.onAnimationFrame(t, i.id);
                                    })
                            ),
                            r.push(
                                n
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? this._navigator.stateService.reference$.pipe(
                                                      zt(1)
                                                  )
                                                : oe()
                                        )
                                    )
                                    .subscribe((i) => e.onReference(t, i))
                            ),
                            r.push(
                                n
                                    .pipe(
                                        kt((e) =>
                                            e
                                                ? this._container.renderService.size$.pipe(
                                                      zt(1)
                                                  )
                                                : oe()
                                        )
                                    )
                                    .subscribe(() => e.onResize(t))
                            ),
                            r.push(
                                He([
                                    this._container.glRenderer.webGLRenderer$,
                                    this._container.renderService.renderCamera$,
                                    this._navigator.stateService.reference$,
                                    this._navigator.stateService.state$,
                                ])
                                    .pipe(bt())
                                    .subscribe(() => {
                                        e.onAttach(
                                            t,
                                            (t) => {
                                                this._controls &&
                                                    e === this._controls &&
                                                    this._updateViewMatrix(t);
                                            },
                                            (t) => {
                                                this._controls &&
                                                    e === this._controls &&
                                                    this._updateProjectionMatrix(
                                                        t
                                                    );
                                            }
                                        ),
                                            i.next(),
                                            i.complete();
                                    })
                            );
                    }
                    detach(e) {
                        const t = this._controls;
                        return (
                            (this._controls = null),
                            this._subscriptions.unsubscribe(),
                            new Promise((i) => {
                                this._navigator.stateService.state$
                                    .pipe(mt(1))
                                    .subscribe((n) => {
                                        t
                                            ? (n === j_.Custom &&
                                                  t.onDeactivate(e),
                                              t.onDetach(e),
                                              i(t))
                                            : i(null);
                                    });
                            })
                        );
                    }
                    dispose(e) {
                        this.detach(e);
                    }
                    has(e) {
                        return !!this._controls && e === this._controls;
                    }
                    _updateProjectionMatrix(e) {
                        this._navigator.stateService.state$
                            .pipe(bt())
                            .subscribe((t) => {
                                if (t === j_.Custom)
                                    this._container.renderService.projectionMatrix$.next(
                                        e
                                    );
                                else {
                                    const e =
                                        "Incorrect camera control mode for projection matrix update";
                                    console.warn(e);
                                }
                            });
                    }
                    _updateViewMatrix(e) {
                        this._navigator.stateService.state$
                            .pipe(bt())
                            .subscribe((t) => {
                                if (t === j_.Custom)
                                    this._navigator.stateService.setViewMatrix(
                                        e
                                    );
                                else {
                                    const e =
                                        "Incorrect camera control mode for view matrix update";
                                    console.warn(e);
                                }
                            });
                    }
                }
                class vS extends r_ {
                    constructor(e) {
                        super(),
                            (this._navigator = new gS(e)),
                            (this._container = new WT(
                                e,
                                this._navigator.stateService
                            )),
                            (this._observer = new fS(
                                this,
                                this._navigator,
                                this._container
                            )),
                            (this._componentController = new zT(
                                this._container,
                                this._navigator,
                                this._observer,
                                e.imageId,
                                e.component
                            )),
                            (this._customRenderer = new _S(
                                this._container,
                                this._navigator
                            )),
                            (this._customCameraControls = new MS(
                                this._container,
                                this._navigator
                            ));
                    }
                    get dataProvider() {
                        return this._navigator.api.data;
                    }
                    get isNavigable() {
                        return this._componentController.navigable;
                    }
                    activateCombinedPanning() {
                        this._navigator.panService.enable();
                    }
                    activateComponent(e) {
                        this._componentController.activate(e);
                    }
                    activateCover() {
                        this._componentController.activateCover();
                    }
                    addCustomRenderer(e) {
                        this._customRenderer.add(e, this);
                    }
                    attachCustomCameraControls(e) {
                        this._customCameraControls.attach(e, this);
                    }
                    deactivateCombinedPanning() {
                        this._navigator.panService.disable();
                    }
                    deactivateComponent(e) {
                        this._componentController.deactivate(e);
                    }
                    deactivateCover() {
                        this._componentController.deactivateCover();
                    }
                    detachCustomCameraControls() {
                        return this._customCameraControls.detach(this);
                    }
                    fire(e, t) {
                        super.fire(e, t);
                    }
                    getBearing() {
                        return new Promise((e, t) => {
                            this._container.renderService.bearing$
                                .pipe(bt())
                                .subscribe(
                                    (t) => {
                                        e(t);
                                    },
                                    (e) => {
                                        t(e);
                                    }
                                );
                        });
                    }
                    getCameraControls() {
                        return new Promise((e, t) => {
                            this._navigator.stateService.state$
                                .pipe(bt())
                                .subscribe(
                                    (t) => {
                                        switch (t) {
                                            case j_.Custom:
                                                e(wT.Custom);
                                                break;
                                            case j_.Earth:
                                                e(wT.Earth);
                                                break;
                                            default:
                                                e(wT.Street);
                                        }
                                    },
                                    (e) => {
                                        t(e);
                                    }
                                );
                        });
                    }
                    getCanvas() {
                        return this._container.canvas;
                    }
                    getCanvasContainer() {
                        return this._container.canvasContainer;
                    }
                    getCenter() {
                        return new Promise((e, t) => {
                            this._navigator.stateService.getCenter().subscribe(
                                (t) => {
                                    e(t);
                                },
                                (e) => {
                                    t(e);
                                }
                            );
                        });
                    }
                    getComponent(e) {
                        return this._componentController.get(e);
                    }
                    getContainer() {
                        return this._container.container;
                    }
                    getFieldOfView() {
                        return new Promise((e, t) => {
                            this._container.renderService.renderCamera$
                                .pipe(bt())
                                .subscribe(
                                    (t) => {
                                        e(t.perspective.fov);
                                    },
                                    (e) => {
                                        t(e);
                                    }
                                );
                        });
                    }
                    getImage() {
                        return new Promise((e, t) => {
                            this._navigator.stateService.currentImage$
                                .pipe(bt())
                                .subscribe(
                                    (t) => {
                                        e(t);
                                    },
                                    (e) => {
                                        t(e);
                                    }
                                );
                        });
                    }
                    getPointOfView() {
                        return new Promise((e, t) => {
                            He(
                                this._container.renderService.renderCamera$,
                                this._container.renderService.bearing$
                            )
                                .pipe(bt())
                                .subscribe(
                                    ([t, i]) => {
                                        e({ bearing: i, tilt: t.getTilt() });
                                    },
                                    (e) => {
                                        t(e);
                                    }
                                );
                        });
                    }
                    getPosition() {
                        return new Promise((e, t) => {
                            He(
                                this._container.renderService.renderCamera$,
                                this._navigator.stateService.reference$
                            )
                                .pipe(bt())
                                .subscribe(
                                    ([t, i]) => {
                                        e(
                                            this._observer.projection.cameraToLngLat(
                                                t,
                                                i
                                            )
                                        );
                                    },
                                    (e) => {
                                        t(e);
                                    }
                                );
                        });
                    }
                    getReference() {
                        return new Promise((e, t) => {
                            this._navigator.stateService.reference$
                                .pipe(bt())
                                .subscribe(
                                    (t) => {
                                        e(t);
                                    },
                                    (e) => {
                                        t(e);
                                    }
                                );
                        });
                    }
                    getZoom() {
                        return new Promise((e, t) => {
                            this._navigator.stateService.getZoom().subscribe(
                                (t) => {
                                    e(t);
                                },
                                (e) => {
                                    t(e);
                                }
                            );
                        });
                    }
                    hasCustomCameraControls(e) {
                        return this._customCameraControls.has(e);
                    }
                    hasCustomRenderer(e) {
                        return this._customRenderer.has(e);
                    }
                    moveDir(e) {
                        const t = this.isNavigable
                            ? this._navigator.moveDir$(e)
                            : Ae(
                                  new Error(
                                      "Calling moveDir is not supported when viewer is not navigable."
                                  )
                              );
                        return new Promise((e, i) => {
                            t.subscribe(
                                (t) => {
                                    e(t);
                                },
                                (e) => {
                                    i(e);
                                }
                            );
                        });
                    }
                    moveTo(e) {
                        const t = this.isNavigable
                            ? this._navigator.moveTo$(e)
                            : Ae(
                                  new Error(
                                      "Calling moveTo is not supported when viewer is not navigable."
                                  )
                              );
                        return new Promise((e, i) => {
                            t.subscribe(
                                (t) => {
                                    e(t);
                                },
                                (e) => {
                                    i(e);
                                }
                            );
                        });
                    }
                    off(e, t) {
                        super.off(e, t);
                    }
                    on(e, t) {
                        super.on(e, t);
                    }
                    project(e) {
                        return new Promise((t, i) => {
                            this._observer.project$(e).subscribe(
                                (e) => {
                                    t(e);
                                },
                                (e) => {
                                    i(e);
                                }
                            );
                        });
                    }
                    projectFromBasic(e) {
                        return new Promise((t, i) => {
                            this._observer.projectBasic$(e).subscribe(
                                (e) => {
                                    t(e);
                                },
                                (e) => {
                                    i(e);
                                }
                            );
                        });
                    }
                    remove() {
                        this._customRenderer.dispose(this),
                            this._customCameraControls.dispose(this),
                            this._observer.dispose(),
                            this._componentController.remove(),
                            this._navigator.dispose(),
                            this._container.remove();
                        const e = "remove",
                            t = { target: this, type: e };
                        this.fire(e, t);
                    }
                    removeCustomRenderer(e) {
                        this._customRenderer.remove(e, this);
                    }
                    resize() {
                        this._container.renderService.resize$.next();
                    }
                    setCameraControls(e) {
                        const t = pS(e);
                        t === j_.Traversing
                            ? this._navigator.stateService.traverse()
                            : t === j_.Earth
                            ? this._navigator.stateService.earth()
                            : t === j_.Custom
                            ? this._navigator.stateService.custom()
                            : console.warn(
                                  `Unsupported camera control transition (${e})`
                              );
                    }
                    setCenter(e) {
                        this._navigator.stateService.setCenter(e);
                    }
                    setFieldOfView(e) {
                        this._container.renderService.renderCamera$
                            .pipe(bt())
                            .subscribe((t) => {
                                const i = t.fovToZoom(e);
                                this._navigator.stateService.setZoom(i);
                            });
                    }
                    setFilter(e) {
                        return new Promise((t, i) => {
                            this._navigator.setFilter$(e).subscribe(
                                () => {
                                    t(void 0);
                                },
                                (e) => {
                                    i(e);
                                }
                            );
                        });
                    }
                    setRenderMode(e) {
                        this._container.renderService.renderMode$.next(e);
                    }
                    setTransitionMode(e) {
                        this._navigator.stateService.setTransitionMode(e);
                    }
                    setAccessToken(e) {
                        const t = this.isNavigable
                            ? this._navigator.setAccessToken$(e)
                            : Ae(
                                  new Error(
                                      "Calling setAccessToken is not supported when viewer is not navigable."
                                  )
                              );
                        return new Promise((e, i) => {
                            t.subscribe(
                                () => {
                                    e(void 0);
                                },
                                (e) => {
                                    i(e);
                                }
                            );
                        });
                    }
                    setZoom(e) {
                        this._navigator.stateService.setZoom(e);
                    }
                    triggerRerender() {
                        this._container.glRenderer.triggerRerender();
                    }
                    unproject(e) {
                        return new Promise((t, i) => {
                            this._observer.unproject$(e).subscribe(
                                (e) => {
                                    t(e);
                                },
                                (e) => {
                                    i(e);
                                }
                            );
                        });
                    }
                    unprojectToBasic(e) {
                        return new Promise((t, i) => {
                            this._observer.unprojectBasic$(e).subscribe(
                                (e) => {
                                    t(e);
                                },
                                (e) => {
                                    i(e);
                                }
                            );
                        });
                    }
                }
                $p.register(ag),
                    Bp.register(ag),
                    og.registerCover(o_),
                    og.register(c_),
                    og.register(h_),
                    og.register(u_),
                    og.register(m_),
                    og.register(B_),
                    og.register(q_),
                    og.register(Q_),
                    og.register(hM),
                    og.register(dM),
                    og.register(gM),
                    og.register(MM),
                    og.register(PM),
                    og.register(Jy),
                    og.register(Ky),
                    og.register(ex),
                    og.register(tx);
                var yS = m(5635),
                    xS = m(5219),
                    bS = m.n(xS),
                    wS = m(6401),
                    TS = m.n(wS),
                    SS = m(5659),
                    NS = m.n(SS),
                    DS = m(663),
                    IS = m.n(DS),
                    CS = m(8302),
                    AS = m.n(CS),
                    ES = m(2591),
                    LS = m.n(ES),
                    zS = m(1740),
                    jS = m.n(zS),
                    OS = m(8128),
                    kS = m.n(OS),
                    RS = m(855),
                    PS = m.n(RS),
                    US = m(3051),
                    $S = m.n(US),
                    BS = m(3656),
                    FS = m.n(BS),
                    HS = m(9824),
                    GS = {};
                (GS.styleTagTransform = FS()),
                    (GS.setAttributes = PS()),
                    (GS.insert = kS().bind(null, "head")),
                    (GS.domAPI = jS()),
                    (GS.insertStyleElement = $S()),
                    LS()(HS.A, GS),
                    HS.A && HS.A.locals && HS.A.locals;
                var VS = m(151),
                    YS = {};
                (YS.styleTagTransform = FS()),
                    (YS.setAttributes = PS()),
                    (YS.insert = kS().bind(null, "head")),
                    (YS.domAPI = jS()),
                    (YS.insertStyleElement = $S()),
                    LS()(VS.A, YS),
                    VS.A && VS.A.locals && VS.A.locals;
                var qS = m(138);
                function WS(i) {
                    const { model: r } = i,
                        s = (0, t.useRef)();
                    return (
                        (0, qS.useWatchAndRerender)(r, "synchronizePosition"),
                        (0, t.useEffect)(() => {
                            const e = new vS({
                                imageId: "2935399116683438",
                                container: s.current,
                                accessToken: r.mapillaryKey,
                                component: { cover: !1 },
                            });
                            e.setTransitionMode(NT.Instantaneous),
                                (r.mapillary = e);
                            const t = new ResizeObserver(() => {
                                    e.resize();
                                }),
                                i = s.current;
                            t.observe(i);
                            const n = () => (r.currentMarkerPosition = void 0),
                                a = () => {
                                    r.mapillary?.isNavigable &&
                                        !r.updating &&
                                        r.currentMarkerPosition &&
                                        ((r.updating = !0),
                                        (r.currentMarkerPosition = void 0));
                                };
                            return (
                                document.body.addEventListener("mousedown", n),
                                document.body.addEventListener("mouseup", a),
                                () => {
                                    document.body.removeEventListener(
                                        "mousedown",
                                        n
                                    ),
                                        document.body.removeEventListener(
                                            "mouseup",
                                            a
                                        ),
                                        t.unobserve(i),
                                        (r.mapillary = void 0);
                                }
                            );
                        }, [r, r.id, r.mapillaryKey]),
                        (0, e.jsxs)(yS.LayoutElement, {
                            ...i,
                            stretch: !0,
                            children: [
                                (0, e.jsx)("div", {
                                    ref: s,
                                    className: "mapillary-map-container",
                                }),
                                (0, e.jsx)("div", {
                                    children: (0, e.jsxs)(TS(), {
                                        className: "third-party-map-controls",
                                        size: "small",
                                        children: [
                                            (0, e.jsx)(bS(), {
                                                className: n({
                                                    selected:
                                                        r.synchronizePosition,
                                                }),
                                                onClick: () =>
                                                    (r.synchronizePosition =
                                                        !r.synchronizePosition),
                                                title: r.synchronizePosition
                                                    ? "language-web-incubator-mapillary-disable-sync-title"
                                                    : "language-web-incubator-mapillary-enable-sync-title",
                                                children: r.synchronizePosition
                                                    ? (0, e.jsx)(NS(), {})
                                                    : (0, e.jsx)(IS(), {}),
                                            }),
                                            (0, e.jsx)(bS(), {
                                                onClick: () => {
                                                    r.recenter();
                                                },
                                                title: "language-web-incubator-mapillary-recenter-title",
                                                children: (0, e.jsx)(AS(), {}),
                                            }),
                                        ],
                                    }),
                                }),
                            ],
                        })
                    );
                }
                var QS = m(65),
                    ZS = m(6817),
                    XS = m(8055),
                    JS = m.n(XS),
                    KS = function (e, t, i, n) {
                        var r,
                            s = arguments.length,
                            a =
                                s < 3
                                    ? t
                                    : null === n
                                    ? (n = Object.getOwnPropertyDescriptor(
                                          t,
                                          i
                                      ))
                                    : n;
                        if (
                            "object" == typeof Reflect &&
                            "function" == typeof Reflect.decorate
                        )
                            a = Reflect.decorate(e, t, i, n);
                        else
                            for (var o = e.length - 1; o >= 0; o--)
                                (r = e[o]) &&
                                    (a =
                                        (s < 3
                                            ? r(a)
                                            : s > 3
                                            ? r(t, i, a)
                                            : r(t, i)) || a);
                        return s > 3 && a && Object.defineProperty(t, i, a), a;
                    };
                function eN(e) {
                    return 360 - e;
                }
                let tN = class extends QS.ComponentModelBase {
                    mapillaryKey;
                    searchRadius;
                    defaultScale;
                    startSynced;
                    synchronizePosition;
                    imageQueryUrl = "https://a.mapillary.com/v3/images";
                    currentMarkerPosition;
                    updating = !1;
                    _currentImagePosition;
                    _awaitViewHandle;
                    _viewerUpdateHandle;
                    _handleMarkerUpdate = !0;
                    _synced = !1;
                    _mapillary;
                    get mapillary() {
                        return this._mapillary;
                    }
                    set mapillary(e) {
                        e !== this._mapillary &&
                            (this._viewerUpdateHandle?.remove(),
                            this._mapillary &&
                                (this.mapillary.off(
                                    "image",
                                    this._onImageChange
                                ),
                                this.mapillary.off(
                                    "pov",
                                    this._onPerspectiveChange
                                ),
                                this.mapillary.activateCover(),
                                this._unsyncMaps()),
                            (this._mapillary = e),
                            e &&
                                (this.mapillary.on(
                                    "image",
                                    this._onImageChange
                                ),
                                (this._viewerUpdateHandle =
                                    this.messages.events.locationMarker.updated.subscribe(
                                        (e) => this._handleViewerUpdate(e)
                                    ))),
                            !this._synced && this.map.view && this._syncMaps());
                    }
                    _map;
                    get map() {
                        return this._map;
                    }
                    set map(e) {
                        e !== this._map &&
                            (this._map && this._unsyncMaps(),
                            (this._map = e),
                            (this._awaitViewHandle = this.watch(
                                "map.view",
                                (e) => {
                                    e &&
                                        (this._awaitViewHandle.remove(),
                                        this._syncMaps());
                                }
                            )));
                    }
                    async recenter() {
                        const {
                                latitude: e,
                                longitude: t,
                                heading: i,
                            } = await this._getMapillaryCamera(),
                            n = new (JS())({ latitude: e, longitude: t });
                        await this.messages.commands.map.zoomToViewpoint.execute(
                            {
                                maps: this.map,
                                viewpoint: {
                                    rotation: eN(i),
                                    targetGeometry: n,
                                    scale: this.defaultScale,
                                },
                            }
                        );
                    }
                    async _syncMaps() {
                        if (!this.map || !this.mapillary || this._synced)
                            return;
                        (this._synced = !0),
                            (this.synchronizePosition = this.startSynced ?? !0);
                        const {
                                latitude: e,
                                longitude: t,
                                heading: i,
                                tilt: n,
                                fov: r,
                            } = await this._getMapillaryCamera(),
                            s = new (JS())({ latitude: e, longitude: t });
                        await Promise.all([
                            this.messages.commands.locationMarker.create.execute(
                                {
                                    fov: r,
                                    geometry: s,
                                    heading: i,
                                    tilt: n,
                                    id: this.id,
                                    maps: this.map,
                                    userDraggable: !1,
                                }
                            ),
                            this.synchronizePosition
                                ? this.messages.commands.map.zoomToViewpoint.execute(
                                      {
                                          maps: this.map,
                                          viewpoint: {
                                              rotation: eN(i),
                                              targetGeometry: s,
                                              scale: this.defaultScale,
                                          },
                                      }
                                  )
                                : void 0,
                        ]);
                    }
                    async _unsyncMaps() {
                        (this._synced = !1),
                            await this.messages.commands.locationMarker.remove.execute(
                                { id: this.id, maps: this.map }
                            );
                    }
                    _handleViewerUpdate(e) {
                        if (this._handleMarkerUpdate) {
                            const t = e.geometry;
                            this.currentMarkerPosition = {
                                latitude: t.latitude,
                                longitude: t.longitude,
                            };
                        }
                        this._handleMarkerUpdate = !0;
                    }
                    _onImageChange = (e) => {
                        const { image: t } = e;
                        t.merged
                            ? ((this._currentImagePosition = t.lngLat),
                              this._onPerspectiveChange(),
                              this.mapillary.on(
                                  "pov",
                                  this._onPerspectiveChange
                              ))
                            : ((this._currentImagePosition = void 0),
                              this.mapillary.off(
                                  "pov",
                                  this._onPerspectiveChange
                              ));
                    };
                    _onPerspectiveChange = (0, ZS.throttle)(async () => {
                        if (!this.map || !this.mapillary || this.updating)
                            return;
                        this.updating = !0;
                        const {
                                latitude: e,
                                longitude: t,
                                heading: i,
                                tilt: n,
                                fov: r,
                            } = await this._getMapillaryCamera(),
                            s = new (JS())({ latitude: e, longitude: t });
                        (this._handleMarkerUpdate = !1),
                            await Promise.all([
                                this.messages.commands.locationMarker.update.execute(
                                    {
                                        geometry: s,
                                        heading: i,
                                        tilt: n,
                                        fov: r,
                                        id: this.id,
                                        maps: this.map,
                                    }
                                ),
                                this.synchronizePosition
                                    ? this.messages.commands.map.zoomToViewpoint.execute(
                                          {
                                              maps: this.map,
                                              viewpoint: {
                                                  rotation: eN(i),
                                                  targetGeometry: s,
                                                  scale: this.defaultScale,
                                              },
                                          }
                                      )
                                    : void 0,
                            ]).finally(() => (this.updating = !1));
                    }, 128);
                    async _getMapillaryCamera() {
                        if (!this.mapillary) return;
                        const [{ lat: e, lng: t }, { bearing: i, tilt: n }, r] =
                            await Promise.all([
                                this._currentImagePosition ??
                                    this.mapillary.getPosition(),
                                this.mapillary.getPointOfView(),
                                this.mapillary.getFieldOfView(),
                            ]);
                        return {
                            latitude: e,
                            longitude: t,
                            heading: i,
                            tilt: n + 90,
                            fov: r,
                        };
                    }
                    _activateCover() {
                        (this.updating = !1), this.mapillary.activateCover();
                    }
                    async _onDestroy() {
                        await super._onDestroy(),
                            this._viewerUpdateHandle?.remove(),
                            this._awaitViewHandle?.remove();
                    }
                    _getSerializableProperties() {
                        const e = super._getSerializableProperties();
                        return {
                            ...e,
                            mapillaryKey: {
                                serializeModes: ["initial"],
                                default: "",
                            },
                            searchRadius: {
                                serializeModes: ["initial"],
                                default: 500,
                            },
                            defaultScale: {
                                serializeModes: ["initial"],
                                default: 3e3,
                            },
                            startSynced: {
                                serializeModes: ["initial"],
                                default: !0,
                            },
                            title: {
                                ...this._toPropertyDef(e.title),
                                default:
                                    "language-web-incubator-mapillary-title",
                            },
                            icon: {
                                ...this._toPropertyDef(e.icon),
                                default: "map-3rd-party",
                            },
                        };
                    }
                };
                KS(
                    [(0, QS.importModel)("map-extension")],
                    tN.prototype,
                    "map",
                    null
                ),
                    (tN = KS([QS.serializable], tN));
                const iN = tN;
                var nN = m(3622);
                const rN = async (e) => {
                        const { model: t, settings: i } = e;
                        await (0, nN.applyComponentModelDesignerSettings)(e),
                            t.assignProperties(i);
                    },
                    sN = async (e) => {
                        const { model: t } = e,
                            {
                                mapillaryKey: i,
                                searchRadius: n,
                                defaultScale: r,
                                startSynced: s,
                            } = t;
                        return {
                            ...(await (0, nN.getComponentModelDesignerSettings)(
                                e
                            )),
                            mapillaryKey: i,
                            searchRadius: n,
                            defaultScale: r,
                            startSynced: s,
                        };
                    },
                    aN = async (e) => {
                        const t = await (0,
                        nN.getComponentModelDesignerSettingsSchema)(e);
                        return (
                            (t.settings[0].settings =
                                t.settings[0].settings.concat([
                                    {
                                        id: "mapillaryKey",
                                        type: "text",
                                        description:
                                            "language-designer-mapillary-key-description",
                                        displayName:
                                            "language-designer-mapillary-key-title",
                                    },
                                    {
                                        id: "searchRadius",
                                        type: "number",
                                        description:
                                            "language-designer-mapillary-search-radius-description",
                                        displayName:
                                            "language-designer-mapillary-search-radius-title",
                                    },
                                    {
                                        id: "defaultScale",
                                        type: "number",
                                        description:
                                            "language-designer-mapillary-default-scale-description",
                                        displayName:
                                            "language-designer-mapillary-default-scale-title",
                                    },
                                    {
                                        id: "startSynced",
                                        type: "checkbox",
                                        description:
                                            "language-designer-mapillary-start-synced-description",
                                        displayName:
                                            "language-designer-mapillary-start-synced-title",
                                    },
                                ])),
                            { ...t, settings: [...t.settings] }
                        );
                    },
                    oN = JSON.parse(
                        '{"language-designer-mapillary-key-description":"Add your API Key for Mapillary here to enable this component.","language-designer-mapillary-key-title":"Mapillary Key","language-designer-mapillary-search-radius-description":"Distance in meters to search from the location marker for a valid Mapillary image node.","language-designer-mapillary-search-radius-title":"Search Radius","language-designer-mapillary-default-scale-description":"Scale to zoom to after adding the location marker to the map component. Enter 0 to remain at the current scale.","language-designer-mapillary-default-scale-title":"Default Scale","language-designer-mapillary-start-synced-description":"Enable this to automatically link the position and viewpoint of Mapillary with the web component.","language-designer-mapillary-start-synced-title":"Start Synced","language-web-incubator-mapillary-title":"Mapillary","language-web-incubator-mapillary-enable-sync-title":"Enable positional sync","language-web-incubator-mapillary-disable-sync-title":"Disable positional sync","language-web-incubator-mapillary-recenter-title":"Recenter the map"}'
                    );
                function cN(e) {
                    e.registerComponent({
                        name: "mapillary",
                        namespace: "vertigis.web.incubator",
                        getComponentType: () => WS,
                        getDesignerSettings: (e) => sN(e),
                        applyDesignerSettings: (e) => rN(e),
                        getDesignerSettingsSchema: (e) => aN(e),
                        itemType: "mapillary",
                        title: "language-web-incubator-mapillary-title",
                        iconId: "map-3rd-party",
                    }),
                        e.registerModel({
                            getModel: (e) => new iN(e),
                            itemType: "mapillary",
                        }),
                        e.registerLanguageResources({
                            locale: "inv",
                            values: oN,
                        }),
                        e.registerLanguageResources({
                            locale: "en",
                            values: oN,
                        });
                }
            })(),
            f
        );
    })());
